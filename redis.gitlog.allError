[UAF] commit 6c03786b66d27a53629cac21d5b89b17bfad6b65
Author: Madelyn Olson <34459052+madolson@users.noreply.github.com>
Date:   Tue Sep 13 16:19:29 2022 -0500

    Prevent use after free for inbound cluster link (#11255)

diff --git a/src/cluster.c b/src/cluster.c
index 6d111500f..862c3c572 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -845,10 +845,15 @@ void setClusterNodeToInboundClusterLink(clusterNode *node, clusterLink *link) {
         /* A peer may disconnect and then reconnect with us, and it's not guaranteed that
          * we would always process the disconnection of the existing inbound link before
          * accepting a new existing inbound link. Therefore, it's possible to have more than
-         * one inbound link from the same node at the same time. */
+         * one inbound link from the same node at the same time. Our cleanup logic assumes
+         * a one to one relationship between nodes and inbound links, so we need to kill
+         * one of the links. The existing link is more likely the outdated one, but it's
+         * possible the the other node may need to open another link. */
         serverLog(LL_DEBUG, "Replacing inbound link fd %d from node %.40s with fd %d",
                 node->inbound_link->conn->fd, node->name, link->conn->fd);
+        freeClusterLink(node->inbound_link);
     }
+    serverAssert(!node->inbound_link);
     node->inbound_link = link;
     link->node = node;
 }

[ML] commit fc3956e8f4d35ea66967bb26f26175ad184f8978
Author: Binbin <binloveplay1314@qq.com>
Date:   Thu Aug 18 17:36:01 2022 +0800

    Fix memory leak in moduleFreeCommand (#11147)
    
    Currently, we call zfree(cmd->args), but the argument array
    needs to be freed recursively (there might be sub-args).
    Also fixed memory leaks on cmd->tips and cmd->history.
    
    Fixes #11145

diff --git a/src/module.c b/src/module.c
index 5db88703f..43394e2f2 100644
--- a/src/module.c
+++ b/src/module.c
@@ -11039,6 +11039,21 @@ void moduleFreeModuleStructure(struct RedisModule *module) {
     zfree(module);
 }
 
+void moduleFreeArgs(struct redisCommandArg *args, int num_args) {
+    for (int j = 0; j < num_args; j++) {
+        zfree((char *)args[j].name);
+        zfree((char *)args[j].token);
+        zfree((char *)args[j].summary);
+        zfree((char *)args[j].since);
+        zfree((char *)args[j].deprecated_since);
+
+        if (args[j].subargs) {
+            moduleFreeArgs(args[j].subargs, args[j].num_args);
+        }
+    }
+    zfree(args);
+}
+
 /* Free the command registered with the specified module.
  * On success C_OK is returned, otherwise C_ERR is returned.
  *
@@ -11064,10 +11079,12 @@ int moduleFreeCommand(struct RedisModule *module, struct redisCommand *cmd) {
         zfree(cmd->key_specs);
     for (int j = 0; cmd->tips && cmd->tips[j]; j++)
         zfree((char *)cmd->tips[j]);
+    zfree(cmd->tips);
     for (int j = 0; cmd->history && cmd->history[j].since; j++) {
         zfree((char *)cmd->history[j].since);
         zfree((char *)cmd->history[j].changes);
     }
+    zfree(cmd->history);
     zfree((char *)cmd->summary);
     zfree((char *)cmd->since);
     zfree((char *)cmd->deprecated_since);
@@ -11076,7 +11093,7 @@ int moduleFreeCommand(struct RedisModule *module, struct redisCommand *cmd) {
         hdr_close(cmd->latency_histogram);
         cmd->latency_histogram = NULL;
     }
-    zfree(cmd->args);
+    moduleFreeArgs(cmd->args, cmd->num_args);
     zfree(cp);
 
     if (cmd->subcommands_dict) {
diff --git a/tests/unit/moduleapi/cmdintrospection.tcl b/tests/unit/moduleapi/cmdintrospection.tcl
index 8ac49ed9f..4d67af1e1 100644
--- a/tests/unit/moduleapi/cmdintrospection.tcl
+++ b/tests/unit/moduleapi/cmdintrospection.tcl
@@ -40,4 +40,8 @@ start_server {tags {"modules"}} {
 
         assert_equal $redis_reply $module_reply
     }
+
+    test "Unload the module - cmdintrospection" {
+        assert_equal {OK} [r module unload cmdintrospection]
+    }
 }

[ML] commit 0a2f78837d82046ec7ffe77f8a2addcb591ff4f7
Author: Binbin <binloveplay1314@qq.com>
Date:   Mon Jun 13 23:23:53 2022 +0800

    redis-check-rdb add when_opcode check for module aux (#10859)
    
    In #9199, we add a `goto eoferr` in when_opcode check,
    this means that if the when_opcode check fails, we will
    abort the rdb loading, but this not reflected in the
    rdb-check tool. So someone can modify when_opcode to make
    rdb load fail, but rdb-check will report OK. Just a cleanup
    or a code consistency issue.
    ```
    serverLog: # Internal error in RDB reading offset 0, function at rdb.c:3055 -> bad when_opcode
    [offset 0] Checking RDB file dump.rdb
    [offset 109] \o/ RDB looks OK! \o/
    ```
    
    Plus a minor memory leak fix like #9860, note that it will
    exit immediately after the eoferr, so it is not strictly a
    leak, so it is also a small cleanup.

diff --git a/src/redis-check-rdb.c b/src/redis-check-rdb.c
index accdc35b0..959768991 100644
--- a/src/redis-check-rdb.c
+++ b/src/redis-check-rdb.c
@@ -283,7 +283,10 @@ int redis_check_rdb(char *rdbfilename, FILE *fp) {
             robj *auxkey, *auxval;
             rdbstate.doing = RDB_CHECK_DOING_READ_AUX;
             if ((auxkey = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
-            if ((auxval = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
+            if ((auxval = rdbLoadStringObject(&rdb)) == NULL) {
+                decrRefCount(auxkey);
+                goto eoferr;
+            }
 
             rdbCheckInfo("AUX FIELD %s = '%s'",
                 (char*)auxkey->ptr, (char*)auxval->ptr);
@@ -297,6 +300,10 @@ int redis_check_rdb(char *rdbfilename, FILE *fp) {
             if ((moduleid = rdbLoadLen(&rdb,NULL)) == RDB_LENERR) goto eoferr;
             if ((when_opcode = rdbLoadLen(&rdb,NULL)) == RDB_LENERR) goto eoferr;
             if ((when = rdbLoadLen(&rdb,NULL)) == RDB_LENERR) goto eoferr;
+            if (when_opcode != RDB_MODULE_OPCODE_UINT) {
+                rdbCheckError("bad when_opcode");
+                goto err;
+            }
 
             char name[10];
             moduleTypeNameByID(name,moduleid);

[ML] commit 4a7a4e42db8ff757cdf3f4a824f66426036034ef
Author: Yuuoniy <linmq006@gmail.com>
Date:   Sun May 22 17:15:26 2022 +0800

    Fix memory leak in streamGetEdgeID (#10753)
    
    si is initialized by streamIteratorStart(), we should call
    streamIteratorStop() on it when done.
    
    regression introduced in #9127 (redis 7.0)

diff --git a/src/t_stream.c b/src/t_stream.c
index e6e5da731..d3a3b9264 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -401,7 +401,7 @@ void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_i
         streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
         *edge_id = first ? max_id : min_id;
     }
-
+    streamIteratorStop(&si);
 }
 
 /* Adds a new item into the stream 's' having the specified number of

[ML] commit b8eb2a73408fa3b8845760857dd6fcccb62107fe
Author: sundb <sundbcn@gmail.com>
Date:   Thu Mar 31 20:26:10 2022 +0800

    Fix failing moduleconfigs tests and memory leak (#10501)
    
    Fix global `strval` not reset to NULL after being freed, causing a crash on alpine
    (most likely because the dynamic library loader doesn't init globals on reload)
    By the way, fix the memory leak of using `RedisModule_Free` to free `RedisModuleString`,
    and add a corresponding test.

diff --git a/tests/modules/moduleconfigs.c b/tests/modules/moduleconfigs.c
index ddf254ab3..a9e434a7b 100644
--- a/tests/modules/moduleconfigs.c
+++ b/tests/modules/moduleconfigs.c
@@ -48,7 +48,7 @@ int setStringConfigCommand(const char *name, RedisModuleString *new, void *privd
         *err = RedisModule_CreateString(NULL, "Cannot set string to 'rejectisfreed'", 36);
         return REDISMODULE_ERR;
     }
-    RedisModule_Free(strval);
+    if (strval) RedisModule_FreeString(NULL, strval);
     RedisModule_RetainString(NULL, new);
     strval = new;
     return REDISMODULE_OK;
@@ -134,6 +134,9 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
 
 int RedisModule_OnUnload(RedisModuleCtx *ctx) {
     REDISMODULE_NOT_USED(ctx);
-    if (strval) RedisModule_FreeString(ctx, strval);
+    if (strval) {
+        RedisModule_FreeString(ctx, strval);
+        strval = NULL;
+    }
     return REDISMODULE_OK;
 }
\ No newline at end of file
diff --git a/tests/unit/moduleapi/moduleconfigs.tcl b/tests/unit/moduleapi/moduleconfigs.tcl
index 0bb3a639c..01aa1e88e 100644
--- a/tests/unit/moduleapi/moduleconfigs.tcl
+++ b/tests/unit/moduleapi/moduleconfigs.tcl
@@ -22,6 +22,9 @@ start_server {tags {"modules"}} {
         assert_equal [r config get moduleconfigs.memory_numeric] "moduleconfigs.memory_numeric 1048576"
         r config set moduleconfigs.string wafflewednesdays
         assert_equal [r config get moduleconfigs.string] "moduleconfigs.string wafflewednesdays"
+        set not_embstr [string repeat A 50]
+        r config set moduleconfigs.string $not_embstr
+        assert_equal [r config get moduleconfigs.string] "moduleconfigs.string $not_embstr"
         r config set moduleconfigs.string \x73\x75\x70\x65\x72\x20\x00\x73\x65\x63\x72\x65\x74\x20\x70\x61\x73\x73\x77\x6f\x72\x64
         assert_equal [r config get moduleconfigs.string] "moduleconfigs.string {super \0secret password}"
         r config set moduleconfigs.enum two

[ML] commit dff153ff247478015d0cf93f0f46a222169ac09c
Author: Vitah Lin <linw1225@gmail.com>
Date:   Mon Feb 28 23:06:39 2022 +0800

    Fix memory leak in RM_StreamIteratorStop and moduleFreeKeyIterator (#10353)
    
    * Fix memory leak in RM_StreamIteratorStop
    * Fix memory leak in moduleFreeKeyIterator

diff --git a/src/module.c b/src/module.c
index 7130139a6..2946f6229 100644
--- a/src/module.c
+++ b/src/module.c
@@ -596,7 +596,10 @@ static void moduleFreeKeyIterator(RedisModuleKey *key) {
     serverAssert(key->iter != NULL);
     switch (key->value->type) {
     case OBJ_LIST: listTypeReleaseIterator(key->iter); break;
-    case OBJ_STREAM: zfree(key->iter); break;
+    case OBJ_STREAM:
+        streamIteratorStop(key->iter);
+        zfree(key->iter);
+        break;
     default: serverAssert(0); /* No key->iter for other types. */
     }
     key->iter = NULL;
@@ -5103,6 +5106,7 @@ int RM_StreamIteratorStop(RedisModuleKey *key) {
         errno = EBADF;
         return REDISMODULE_ERR;
     }
+    streamIteratorStop(key->iter);
     zfree(key->iter);
     key->iter = NULL;
     return REDISMODULE_OK;

[ML] commit beb94c901e814f63fe1170d72104c81d62fa663a
Author: Binbin <binloveplay1314@qq.com>
Date:   Wed Feb 9 13:33:24 2022 +0800

    Fix INFO SENTINEL memory leak (#10268)
    
    * Fix INFO SENTINEL memory leak
    
    Introduced in #6891
    
    * remove the copy-paste sentence

diff --git a/src/sentinel.c b/src/sentinel.c
index 7e9211bd0..2342c0c00 100644
--- a/src/sentinel.c
+++ b/src/sentinel.c
@@ -4133,8 +4133,7 @@ void sentinelInfoCommand(client *c) {
         sections_dict = cached_all_info_sectoins;
     }
 
-    sds info = sdsempty();
-    info = genRedisInfoString(sections_dict, 0, 0);
+    sds info = genRedisInfoString(sections_dict, 0, 0);
     if (sec_all || (dictFind(sections_dict, "sentinel") != NULL)) {
         dictIterator *di;
         dictEntry *de;
diff --git a/tests/sentinel/tests/13-info-command.tcl b/tests/sentinel/tests/13-info-command.tcl
index 4772a1da8..ef9dc0113 100644
--- a/tests/sentinel/tests/13-info-command.tcl
+++ b/tests/sentinel/tests/13-info-command.tcl
@@ -1,4 +1,3 @@
-# Check the basic monitoring and failover capabilities.
 source "../tests/includes/init-tests.tcl"
 
 test "info command with at most one argument" {

[ML] commit 6b5b3ca4148b058210f7c32096a6d1201a2121d9
Author: é­ä¼å <warriorguo@gmail.com>
Date:   Tue Feb 1 20:54:11 2022 +0800

    forbid module to unload when it holds ongoing timer (#10187)
    
    This is done to avoid a crash when the timer fires after the module was unloaded.
    Or memory leaks in case we wanted to just ignore the timer.
    It'll cause the MODULE UNLOAD command to return with an error
    
    Co-authored-by: sundb <sundbcn@gmail.com>

diff --git a/runtest-moduleapi b/runtest-moduleapi
index 8b4b108de..d13425f81 100755
--- a/runtest-moduleapi
+++ b/runtest-moduleapi
@@ -45,5 +45,6 @@ $TCLSH tests/test_helper.tcl \
 --single unit/moduleapi/subcommands \
 --single unit/moduleapi/reply \
 --single unit/moduleapi/eventloop \
+--single unit/moduleapi/timer \
 "${@}"
 
diff --git a/src/module.c b/src/module.c
index 8c44422c6..204f49c8b 100644
--- a/src/module.c
+++ b/src/module.c
@@ -7427,6 +7427,24 @@ int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remain
     return REDISMODULE_OK;
 }
 
+/* Query timers to see if any timer belongs to the module.
+ * Return 1 if any timer was found, otherwise 0 would be returned. */
+int moduleHoldsTimer(struct RedisModule *module) {
+    raxIterator iter;
+    int found = 0;
+    raxStart(&iter,Timers);
+    raxSeek(&iter,"^",NULL,0);
+    while (raxNext(&iter)) {
+        RedisModuleTimer *timer = iter.data;
+        if (timer->module == module) {
+            found = 1;
+            break;
+        }
+    }
+    raxStop(&iter);
+    return found;
+}
+
 /* --------------------------------------------------------------------------
  * ## Modules EventLoop API
  * --------------------------------------------------------------------------*/
@@ -10125,6 +10143,7 @@ int moduleLoad(const char *path, void **module_argv, int module_argc) {
  * * EBUSY: The module exports a new data type and can only be reloaded. 
  * * EPERM: The module exports APIs which are used by other module. 
  * * EAGAIN: The module has blocked clients. 
+ * * EINPROGRESS: The module holds timer not fired.
  * * ECANCELED: Unload module error.  */
 int moduleUnload(sds name) {
     struct RedisModule *module = dictFetchValue(modules,name);
@@ -10141,6 +10160,9 @@ int moduleUnload(sds name) {
     } else if (module->blocked_clients) {
         errno = EAGAIN;
         return C_ERR;
+    } else if (moduleHoldsTimer(module)) {
+        errno = EINPROGRESS;
+        return C_ERR;
     }
 
     /* Give module a chance to clean up. */
@@ -10345,6 +10367,10 @@ NULL
                 errmsg = "the module has blocked clients. "
                          "Please wait them unblocked and try again";
                 break;
+            case EINPROGRESS:
+                errmsg = "the module holds timer that is not fired. "
+                         "Please stop the timer or wait until it fires.";
+                break;
             default:
                 errmsg = "operation not possible.";
                 break;
diff --git a/tests/unit/moduleapi/timer.tcl b/tests/unit/moduleapi/timer.tcl
index c04f80b23..4e9dd0f09 100644
--- a/tests/unit/moduleapi/timer.tcl
+++ b/tests/unit/moduleapi/timer.tcl
@@ -26,6 +26,8 @@ start_server {tags {"modules"}} {
         assert_equal "timer-incr-key" [lindex $info 0]
         set remaining [lindex $info 1]
         assert {$remaining < 10000 && $remaining > 1}
+        # Stop the timer after get timer test
+        assert_equal 1 [r test.stoptimer $id]
     }
 
     test {RM_StopTimer: basic sanity} {
@@ -54,7 +56,43 @@ start_server {tags {"modules"}} {
         assert_equal {} [r test.gettimer $id]
     }
 
-    test "Unload the module - timer" {
+    test "Module can be unloaded when timer was finished" {
+        r set "timer-incr-key" 0
+        r test.createtimer 500 timer-incr-key
+
+        # Make sure the Timer has not been fired
+        assert_equal 0 [r get timer-incr-key]
+        # Module can not be unloaded since the timer was ongoing
+        catch {r module unload timer} err
+        assert_match {*the module holds timer that is not fired*} $err
+
+        # Wait to be sure timer has been finished
+        wait_for_condition 10 500 {
+            [r get timer-incr-key] == 1
+        } else {
+            fail "Timer not fired"
+        }
+
+        # Timer fired, can be unloaded now.
+        assert_equal {OK} [r module unload timer]
+    }
+
+    test "Module can be unloaded when timer was stopped" {
+        r module load $testmodule
+        r set "timer-incr-key" 0
+        set id [r test.createtimer 5000 timer-incr-key]
+
+        # Module can not be unloaded since the timer was ongoing
+        catch {r module unload timer} err
+        assert_match {*the module holds timer that is not fired*} $err
+
+        # Stop the timer
+        assert_equal 1 [r test.stoptimer $id]
+
+        # Make sure the Timer has not been fired
+        assert_equal 0 [r get timer-incr-key]
+
+        # Timer has stopped, can be unloaded now.
         assert_equal {OK} [r module unload timer]
     }
 }

[ML] commit b567d3694c647455bfe9908696af10dcccb339cd
Author: RuiliF <77563179+RuiliF@users.noreply.github.com>
Date:   Fri Nov 19 17:48:08 2021 -0500

    fix memory leak in example module hellocluster (#9813)
    
    Missing RedisModule_FreeCallReply

diff --git a/src/modules/hellocluster.c b/src/modules/hellocluster.c
index cb78187f9..ac04f9560 100644
--- a/src/modules/hellocluster.c
+++ b/src/modules/hellocluster.c
@@ -77,7 +77,8 @@ void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, cons
     RedisModule_Log(ctx,"notice","PING (type %d) RECEIVED from %.*s: '%.*s'",
         type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
     RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PONG,(unsigned char*)"Ohi!",4);
-    RedisModule_Call(ctx, "INCR", "c", "pings_received");
+    RedisModuleCallReply *reply = RedisModule_Call(ctx, "INCR", "c", "pings_received");
+    RedisModule_FreeCallReply(reply);
 }
 
 /* Callback for message MSGTYPE_PONG. */

[ML] commit cd0f710be957191a98620535430c629ba30c7453
Author: Jim Brunner <brunnerj@amazon.com>
Date:   Tue Nov 9 10:35:22 2021 -0800

    fix minor memory leak in rewriteConfigSds (#9762)

diff --git a/src/config.c b/src/config.c
index 5d0bf664a..6247c363a 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1066,7 +1066,7 @@ void rewriteConfigStringOption(struct rewriteConfigState *state, const char *opt
 }
 
 /* Rewrite a SDS string option. */
-void rewriteConfigSdsOption(struct rewriteConfigState *state, const char *option, sds value, const sds defvalue) {
+void rewriteConfigSdsOption(struct rewriteConfigState *state, const char *option, sds value, const char *defvalue) {
     int force = 1;
     sds line;
 
@@ -1078,7 +1078,7 @@ void rewriteConfigSdsOption(struct rewriteConfigState *state, const char *option
     }
 
     /* Set force to zero if the value is set to its default. */
-    if (defvalue && sdscmp(value, defvalue) == 0) force = 0;
+    if (defvalue && strcmp(value, defvalue) == 0) force = 0;
 
     line = sdsnew(option);
     line = sdscatlen(line, " ", 1);
@@ -1634,7 +1634,7 @@ static void sdsConfigGet(client *c, typeData data) {
 }
 
 static void sdsConfigRewrite(typeData data, const char *name, struct rewriteConfigState *state) {
-    rewriteConfigSdsOption(state, name, *(data.sds.config), data.sds.default_value ? sdsnew(data.sds.default_value) : NULL);
+    rewriteConfigSdsOption(state, name, *(data.sds.config), data.sds.default_value);
 }
 
 

[ML] commit 2ce29e032b6d474c4e819597e1fb690e29e735d6
Author: Wen Hui <wen.hui.ware@gmail.com>
Date:   Mon Nov 8 15:23:31 2021 -0500

    Sentinel tls memory leak (#9753)
    
    There was a memory leak when tls is used in Sentinels.
    The memory leak is noticed when some of the replicas are offline.

diff --git a/src/sentinel.c b/src/sentinel.c
index 56c70ffec..02cf931ab 100644
--- a/src/sentinel.c
+++ b/src/sentinel.c
@@ -2348,7 +2348,10 @@ static int instanceLinkNegotiateTLS(redisAsyncContext *context) {
     SSL *ssl = SSL_new(redis_tls_client_ctx ? redis_tls_client_ctx : redis_tls_ctx);
     if (!ssl) return C_ERR;
 
-    if (redisInitiateSSL(&context->c, ssl) == REDIS_ERR) return C_ERR;
+    if (redisInitiateSSL(&context->c, ssl) == REDIS_ERR) {
+        SSL_free(ssl);
+        return C_ERR;
+    }
 #endif
     return C_OK;
 }

[ML] commit 734cde7e3885bf4ba8120ca0cc07354851bb4db0
Author: Rafi Einstein <rafi@redislabs.com>
Date:   Sun Oct 31 15:59:48 2021 +0200

    Fix memory leak when there's a read error of module aux data from rdb. (#9705)

diff --git a/src/rdb.c b/src/rdb.c
index afdf57daf..ad7ede6c4 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -2766,15 +2766,16 @@ int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
                 io.ver = 2;
                 /* Call the rdb_load method of the module providing the 10 bit
                  * encoding version in the lower 10 bits of the module ID. */
-                if (mt->aux_load(&io,moduleid&1023, when) != REDISMODULE_OK || io.error) {
-                    moduleTypeNameByID(name,moduleid);
-                    serverLog(LL_WARNING,"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
-                    goto eoferr;
-                }
+                int rc = mt->aux_load(&io,moduleid&1023, when);
                 if (io.ctx) {
                     moduleFreeContext(io.ctx);
                     zfree(io.ctx);
                 }
+                if (rc != REDISMODULE_OK || io.error) {
+                    moduleTypeNameByID(name,moduleid);
+                    serverLog(LL_WARNING,"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
+                    goto eoferr;
+                }
                 uint64_t eof = rdbLoadLen(rdb,NULL);
                 if (eof != RDB_MODULE_OPCODE_EOF) {
                     serverLog(LL_WARNING,"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker", name);

[ML] commit 83478e6102bd86d077e64bb40b0903f8a06905b1
Author: yoav-steinberg <yoav@monfort.co.il>
Date:   Tue Oct 5 12:17:36 2021 +0300

    argv mem leak during multi command execution. (#9598)
    
    Changes in #9528 lead to memory leak if the command implementation
    used rewriteClientCommandArgument inside MULTI-EXEC.
    
    Adding an explicit test for that case since the test that uncovered it
    didn't specifically target this scenario

diff --git a/src/multi.c b/src/multi.c
index b02457bb9..4171131b7 100644
--- a/src/multi.c
+++ b/src/multi.c
@@ -159,7 +159,7 @@ void execCommandAbort(client *c, sds error) {
 void execCommand(client *c) {
     int j;
     robj **orig_argv;
-    int orig_argc;
+    int orig_argc, orig_argv_len;
     struct redisCommand *orig_cmd;
     int was_master = server.masterhost == NULL;
 
@@ -201,11 +201,12 @@ void execCommand(client *c) {
     server.in_exec = 1;
 
     orig_argv = c->argv;
+    orig_argv_len = c->argv_len;
     orig_argc = c->argc;
     orig_cmd = c->cmd;
     addReplyArrayLen(c,c->mstate.count);
     for (j = 0; j < c->mstate.count; j++) {
-        c->argc = c->mstate.commands[j].argc;
+        c->argv_len = c->argc = c->mstate.commands[j].argc;
         c->argv = c->mstate.commands[j].argv;
         c->cmd = c->mstate.commands[j].cmd;
 
@@ -252,6 +253,7 @@ void execCommand(client *c) {
         c->flags &= ~CLIENT_DENY_BLOCKING;
 
     c->argv = orig_argv;
+    c->argv_len = orig_argv_len;
     c->argc = orig_argc;
     c->cmd = orig_cmd;
     discardTransaction(c);
diff --git a/tests/unit/protocol.tcl b/tests/unit/protocol.tcl
index 4f185d9bd..ec08e2d36 100644
--- a/tests/unit/protocol.tcl
+++ b/tests/unit/protocol.tcl
@@ -203,6 +203,23 @@ start_server {tags {"protocol network"}} {
         r mset {*}$args
         assert_equal [r get "{k}2"] v2
     }
+    
+    test "test argument rewriting - issue 9598" {
+        # INCRBYFLOAT uses argument rewriting for correct float value propagation.
+        # We use it to make sure argument rewriting works properly. It's important 
+        # this test is run under valgrind to verify there are no memory leaks in 
+        # arg buffer handling.
+        r flushdb
+
+        # Test normal argument handling
+        r set k 0
+        assert_equal [r incrbyfloat k 1.0] 1
+        
+        # Test argument handing in multi-state buffers
+        r multi
+        r incrbyfloat k 1.0
+        assert_equal [r exec] 2
+    }
 
 }
 

[ML] commit dd3ac97ffec8af88230275b560ca1f43325a5a9c
Author: Binbin <binloveplay1314@qq.com>
Date:   Sun Oct 3 13:19:33 2021 +0800

    Cleanup typos, incorrect comments, and fixed small memory leak in redis-cli (#9153)
    
    1. Remove forward declarations from header files to functions that do not exist:
    hmsetCommand and rdbSaveTime.
    2. Minor phrasing fixes in #9519
    3. Add missing sdsfree(title) and fix typo in redis-benchmark.
    4. Modify some error comments in some zset commands.
    5. Fix copy-paste bug comment in syncWithMaster about `ip-address`.

diff --git a/redis.conf b/redis.conf
index 2839ec631..e6c7039f0 100644
--- a/redis.conf
+++ b/redis.conf
@@ -520,7 +520,7 @@ dir ./
 #
 # 2) If replica-serve-stale-data is set to 'no' the replica will reply with error
 #    "MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'"
-#    to all data access commands, excusing commands such as :
+#    to all data access commands, excluding commands such as :
 #    INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,
 #    UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,
 #    HOST and LATENCY.
diff --git a/src/rdb.h b/src/rdb.h
index 2cfbbc0e8..71332c8ba 100644
--- a/src/rdb.h
+++ b/src/rdb.h
@@ -137,7 +137,6 @@
 
 int rdbSaveType(rio *rdb, unsigned char type);
 int rdbLoadType(rio *rdb);
-int rdbSaveTime(rio *rdb, time_t t);
 time_t rdbLoadTime(rio *rdb);
 int rdbSaveLen(rio *rdb, uint64_t len);
 int rdbSaveMillisecondTime(rio *rdb, long long t);
diff --git a/src/redis-benchmark.c b/src/redis-benchmark.c
index 36da5e32e..86421e33f 100644
--- a/src/redis-benchmark.c
+++ b/src/redis-benchmark.c
@@ -68,7 +68,7 @@
 #define MAX_THREADS 500
 #define CLUSTER_SLOTS 16384
 #define CONFIG_LATENCY_HISTOGRAM_MIN_VALUE 10L          /* >= 10 usecs */
-#define CONFIG_LATENCY_HISTOGRAM_MAX_VALUE 3000000L          /* <= 30 secs(us precision) */
+#define CONFIG_LATENCY_HISTOGRAM_MAX_VALUE 3000000L          /* <= 3 secs(us precision) */
 #define CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE 3000000L   /* <= 3 secs(us precision) */
 #define SHOW_THROUGHPUT_INTERVAL 250  /* 250ms */
 
@@ -1859,6 +1859,7 @@ int main(int argc, char **argv) {
         } while(config.loop);
         sdsfreesplitres(sds_args, argc);
 
+        sdsfree(title);
         if (config.redis_config != NULL) freeRedisConfig(config.redis_config);
         return 0;
     }
diff --git a/src/replication.c b/src/replication.c
index 8c692df8d..dcb407491 100644
--- a/src/replication.c
+++ b/src/replication.c
@@ -2394,7 +2394,7 @@ void syncWithMaster(connection *conn) {
     if (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY) {
         err = receiveSynchronousResponse(conn);
         /* Ignore the error if any, not all the Redis versions support
-         * REPLCONF listening-port. */
+         * REPLCONF ip-address. */
         if (err[0] == '-') {
             serverLog(LL_NOTICE,"(Non critical) Master does not understand "
                                 "REPLCONF ip-address: %s", err);
diff --git a/src/server.h b/src/server.h
index 065bec445..d9f58133e 100644
--- a/src/server.h
+++ b/src/server.h
@@ -2819,7 +2819,6 @@ void zrevrankCommand(client *c);
 void hsetCommand(client *c);
 void hsetnxCommand(client *c);
 void hgetCommand(client *c);
-void hmsetCommand(client *c);
 void hmgetCommand(client *c);
 void hdelCommand(client *c);
 void hlenCommand(client *c);
diff --git a/src/t_zset.c b/src/t_zset.c
index 26a65baae..a6bfddf46 100644
--- a/src/t_zset.c
+++ b/src/t_zset.c
@@ -3097,7 +3097,7 @@ void zrangeCommand(client *c) {
     zrangeGenericCommand(&handler, 1, 0, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);
 }
 
-/* ZREVRANGE <key> <min> <max> [WITHSCORES] */
+/* ZREVRANGE <key> <start> <stop> [WITHSCORES] */
 void zrevrangeCommand(client *c) {
     zrange_result_handler handler;
     zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
@@ -3225,7 +3225,7 @@ void zrangebyscoreCommand(client *c) {
     zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_FORWARD);
 }
 
-/* ZREVRANGEBYSCORE <key> <min> <max> [WITHSCORES] [LIMIT offset count] */
+/* ZREVRANGEBYSCORE <key> <max> <min> [WITHSCORES] [LIMIT offset count] */
 void zrevrangebyscoreCommand(client *c) {
     zrange_result_handler handler;
     zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
@@ -3506,7 +3506,7 @@ void zrangebylexCommand(client *c) {
     zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_FORWARD);
 }
 
-/* ZREVRANGEBYLEX <key> <min> <max> [LIMIT offset count] */
+/* ZREVRANGEBYLEX <key> <max> <min> [LIMIT offset count] */
 void zrevrangebylexCommand(client *c) {
     zrange_result_handler handler;
     zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);

[ML] commit 1376d83363cf0e9c9f872762854518b16d8cedef
Author: sundb <sundbcn@gmail.com>
Date:   Tue Sep 14 20:14:09 2021 +0800

    Fix memory leak due to missing freeCallback in blockonbackground moduleapi test (#9499)
    
    Before #9497, before redis-server was shut down, we did not manually shut down all the clients,
    which would have prevented valgrind from detecting a memory leak in the client's argc.

diff --git a/tests/modules/blockonbackground.c b/tests/modules/blockonbackground.c
index 92f5876d2..ced77862d 100644
--- a/tests/modules/blockonbackground.c
+++ b/tests/modules/blockonbackground.c
@@ -31,6 +31,11 @@ void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
     RedisModule_Free(privdata);
 }
 
+/* Private data freeing callback for BLOCK.BLOCK command. */
+void HelloBlock_FreeStringData(RedisModuleCtx *ctx, void *privdata) {
+    RedisModule_FreeString(ctx, (RedisModuleString*)privdata);
+}
+
 /* The thread entry point that actually executes the blocking part
  * of the command BLOCK.DEBUG. */
 void *BlockDebug_ThreadMain(void *arg) {
@@ -225,7 +230,7 @@ int Block_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
      * callback and differentiate the different code flows above.
      */
     blocked_client = RedisModule_BlockClient(ctx, Block_RedisCommand,
-            timeout > 0 ? Block_RedisCommand : NULL, NULL, timeout);
+            timeout > 0 ? Block_RedisCommand : NULL, HelloBlock_FreeStringData, timeout);
     return REDISMODULE_OK;
 }
 

[ML] commit bc0c22fabca058f4b23c9a634a37f6753dd963bd
Author: chenyang8094 <chenyang8094@users.noreply.github.com>
Date:   Thu Sep 9 16:03:05 2021 +0800

    Fix callReplyParseCollection memleak when use AutoMemory (#9446)
    
    When parsing an array type reply, ctx will be lost when recursively parsing its
    elements, which will cause a memory leak in automemory mode.
    
    This is a result of the changes in #9202
    
    Add test for callReplyParseCollection fix

diff --git a/src/call_reply.c b/src/call_reply.c
index 5e7802463..7aa79d089 100644
--- a/src/call_reply.c
+++ b/src/call_reply.c
@@ -145,9 +145,9 @@ static void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t
     rep->val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));
     for (size_t i = 0; i < len * elements_per_entry; i += elements_per_entry) {
         for (size_t j = 0 ; j < elements_per_entry ; ++j) {
+            rep->val.array[i + j].private_data = rep->private_data;
             parseReply(parser, rep->val.array + i + j);
             rep->val.array[i + j].flags |= REPLY_FLAG_PARSED;
-            rep->val.array[i + j].private_data = rep->private_data;
             if (rep->val.array[i + j].flags & REPLY_FLAG_RESP3) {
                 /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */
                 rep->flags |= REPLY_FLAG_RESP3;
diff --git a/tests/modules/basics.c b/tests/modules/basics.c
index aa11fb967..a743b9edf 100644
--- a/tests/modules/basics.c
+++ b/tests/modules/basics.c
@@ -33,6 +33,7 @@
 #define REDISMODULE_EXPERIMENTAL_API
 #include "redismodule.h"
 #include <string.h>
+#include <stdlib.h>
 
 /* --------------------------------- Helpers -------------------------------- */
 
@@ -457,6 +458,38 @@ int TestUnlink(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     return RedisModule_ReplyWithSimpleString(ctx, "OK");
 }
 
+int TestNestedCallReplyArrayElement(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    RedisModule_AutoMemory(ctx);
+    REDISMODULE_NOT_USED(argv);
+    REDISMODULE_NOT_USED(argc);
+
+    RedisModuleString *expect_key = RedisModule_CreateString(ctx, "mykey", strlen("mykey"));
+    RedisModule_SelectDb(ctx, 1);
+    RedisModule_Call(ctx, "LPUSH", "sc", expect_key, "myvalue");
+
+    RedisModuleCallReply *scan_reply = RedisModule_Call(ctx, "SCAN", "l", 0);
+    RedisModule_Assert(scan_reply != NULL && RedisModule_CallReplyType(scan_reply) == REDISMODULE_REPLY_ARRAY);
+    RedisModule_Assert(RedisModule_CallReplyLength(scan_reply) == 2);
+
+    long long scan_cursor;
+    RedisModuleCallReply *cursor_reply = RedisModule_CallReplyArrayElement(scan_reply, 0);
+    RedisModule_Assert(RedisModule_CallReplyType(cursor_reply) == REDISMODULE_REPLY_STRING);
+    RedisModule_Assert(RedisModule_StringToLongLong(RedisModule_CreateStringFromCallReply(cursor_reply), &scan_cursor) == REDISMODULE_OK);
+    RedisModule_Assert(scan_cursor == 0);
+
+    RedisModuleCallReply *keys_reply = RedisModule_CallReplyArrayElement(scan_reply, 1);
+    RedisModule_Assert(RedisModule_CallReplyType(keys_reply) == REDISMODULE_REPLY_ARRAY);
+    RedisModule_Assert( RedisModule_CallReplyLength(keys_reply) == 1);
+ 
+    RedisModuleCallReply *key_reply = RedisModule_CallReplyArrayElement(keys_reply, 0);
+    RedisModule_Assert(RedisModule_CallReplyType(key_reply) == REDISMODULE_REPLY_STRING);
+    RedisModuleString *key = RedisModule_CreateStringFromCallReply(key_reply);
+    RedisModule_Assert(RedisModule_StringCompare(key, expect_key) == 0);
+
+    RedisModule_ReplyWithSimpleString(ctx, "OK");
+    return REDISMODULE_OK;
+}
+
 /* TEST.STRING.TRUNCATE -- Test truncating an existing string object. */
 int TestStringTruncate(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     RedisModule_AutoMemory(ctx);
@@ -795,6 +828,9 @@ int TestBasics(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     T("test.unlink","");
     if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
 
+    T("test.nestedcallreplyarray","");
+    if (!TestAssertStringReply(ctx,reply,"OK",2)) goto fail;
+
     T("test.string.append.am","");
     if (!TestAssertStringReply(ctx,reply,"foobar",6)) goto fail;
 
@@ -894,6 +930,10 @@ int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
         TestUnlink,"write deny-oom",1,1,1) == REDISMODULE_ERR)
         return REDISMODULE_ERR;
 
+    if (RedisModule_CreateCommand(ctx,"test.nestedcallreplyarray",
+        TestNestedCallReplyArrayElement,"write deny-oom",1,1,1) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
     if (RedisModule_CreateCommand(ctx,"test.basics",
         TestBasics,"readonly",1,1,1) == REDISMODULE_ERR)
         return REDISMODULE_ERR;

[DF] commit 492d8d09613cff88f15dcef98732392b8d509eb1
Author: sundb <sundbcn@gmail.com>
Date:   Fri Aug 20 15:37:45 2021 +0800

    Sanitize dump payload: fix double free after insert dup nodekey to stream rax and returns 0 (#9399)

diff --git a/src/rdb.c b/src/rdb.c
index be94da90c..e38c93407 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -2081,7 +2081,7 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error) {
             }
 
             /* Insert the key in the radix tree. */
-            int retval = raxInsert(s->rax,
+            int retval = raxTryInsert(s->rax,
                 (unsigned char*)nodekey,sizeof(streamID),lp,NULL);
             sdsfree(nodekey);
             if (!retval) {
@@ -2170,7 +2170,7 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error) {
                     streamFreeNACK(nack);
                     return NULL;
                 }
-                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL)) {
+                if (!raxTryInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL)) {
                     rdbReportCorruptRDB("Duplicated global PEL entry "
                                             "loading stream consumer group");
                     decrRefCount(o);
@@ -2234,11 +2234,12 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error) {
                      * loading the global PEL. Then set the same shared
                      * NACK structure also in the consumer-specific PEL. */
                     nack->consumer = consumer;
-                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL)) {
+                    if (!raxTryInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL)) {
                         rdbReportCorruptRDB("Duplicated consumer PEL entry "
                                                 " loading a stream consumer "
                                                 "group");
                         decrRefCount(o);
+                        streamFreeNACK(nack);
                         return NULL;
                     }
                 }
diff --git a/tests/integration/corrupt-dump.tcl b/tests/integration/corrupt-dump.tcl
index 2951de1de..fab15fc7b 100644
--- a/tests/integration/corrupt-dump.tcl
+++ b/tests/integration/corrupt-dump.tcl
@@ -716,5 +716,15 @@ test {corrupt payload: fuzzer findings - hash listpack first element too long en
     }
 }
 
+test {corrupt payload: fuzzer findings - stream double free listpack when insert dup node to rax returns 0} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r debug set-skip-checksum-validation 1
+        r config set sanitize-dump-payload yes
+        catch { r restore _stream 0 "\x0F\x03\x10\x00\x00\x01\x7B\x60\x5A\x23\x79\x00\x00\x00\x00\x00\x00\x00\x00\xC3\x40\x4F\x40\x5C\x18\x5C\x00\x00\x00\x24\x00\x05\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x00\x01\x20\x03\x00\x05\x20\x1C\x40\x09\x05\x01\x01\x82\x5F\x31\x03\x80\x0D\x00\x02\x20\x0D\x00\x02\xA0\x19\x00\x03\x20\x0B\x02\x82\x5F\x33\xA0\x19\x00\x04\x20\x0D\x00\x04\x20\x19\x00\xFF\x10\x00\x00\x01\x7B\x60\x5A\x23\x79\x00\x00\x00\x00\x00\x00\x00\x05\xC3\x40\x51\x40\x5E\x18\x5E\x00\x00\x00\x24\x00\x05\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x06\x01\x01\x82\x5F\x35\x03\x05\x20\x1E\x40\x0B\x03\x01\x01\x06\x01\x80\x0B\x00\x02\x20\x0B\x02\x82\x5F\x37\xA0\x19\x00\x03\x20\x0D\x00\x08\xA0\x19\x00\x04\x20\x0B\x02\x82\x5F\x39\x20\x19\x00\xFF\x10\x00\x00\x01\x7B\x60\x5A\x23\x79\x00\x00\x00\x00\x00\x00\x00\x00\xC3\x3B\x40\x49\x18\x49\x00\x00\x00\x15\x00\x02\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x40\x00\x00\x05\x20\x07\x40\x09\xC0\x22\x09\x01\x01\x86\x75\x6E\x69\x71\x75\x65\x07\xA0\x2C\x02\x08\x01\xFF\x0C\x81\x00\x00\x01\x7B\x60\x5A\x23\x7A\x01\x00\x0A\x00\x9C\x8F\x1E\xBF\x2E\x05\x59\x09" replace } err
+        assert_match "*Bad data format*" $err
+        r ping
+    }
+}
+
 } ;# tags
 

[NR] [ML] commit f03af47a34ec672a7d9b18150a5be3a83681c19b
Author: qetu3790 <qetu3790@163.com>
Date:   Fri Jul 16 11:40:25 2021 +0800

    Set TCP keepalive on inbound clusterbus connections (#9230)
    
    Set TCP keepalive on inbound clusterbus connections to prevent memory leak

diff --git a/src/cluster.c b/src/cluster.c
index 92601b001..85b3eecd8 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -736,6 +736,7 @@ void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
             return;
         }
         connEnableTcpNoDelay(conn);
+        connKeepAlive(conn,server.cluster_node_timeout * 2);
 
         /* Use non-blocking I/O for cluster messages. */
         serverLog(LL_VERBOSE,"Accepting cluster node connection from %s:%d", cip, cport);

[DF] commit eae0983d2d5f13e0897494f2604a0df691c1678d
Author: sundb <sundbcn@gmail.com>
Date:   Fri Jun 18 02:45:21 2021 +0800

    Fix leak and double free issues in datatype2 module test (#9102)
    
    * Add missing call for RedisModule_DictDel in datatype2 test
    * Fix memory leak in datatype2 test

diff --git a/tests/modules/datatype2.c b/tests/modules/datatype2.c
index aba66b124..0c4279ae5 100644
--- a/tests/modules/datatype2.c
+++ b/tests/modules/datatype2.c
@@ -220,6 +220,8 @@ void flushdbCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void
     int i;
     RedisModuleFlushInfo *fi = data;
 
+    RedisModule_AutoMemory(ctx);
+
     if (sub == REDISMODULE_SUBEVENT_FLUSHDB_START) {
         if (fi->dbnum != -1) {
            MemPoolFreeDb(ctx, fi->dbnum);
@@ -298,6 +300,7 @@ int MemFree_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc
     int nokey;
     struct MemBlock *mem = (struct MemBlock *)RedisModule_DictGet(mem_pool[RedisModule_GetSelectedDb(ctx)], argv[1], &nokey);
     if (!nokey && mem) {
+        RedisModule_DictDel(mem_pool[RedisModule_GetSelectedDb(ctx)], argv[1], NULL);
         MemBlockFree(mem);
         o->used = 0;
         o->size = 0;

commit bb671d90165590ecba80942e887b7a455d92384e
Author: Binbin <binloveplay1314@qq.com>
Date:   Sun Jun 6 17:13:00 2021 +0800

    Add missing zuiClearIterator in zrandmemberWithCountCommand. (#8979)
    
    Also the bug that currently does not cause memory leaks.
    Because op->type = OBJ_ZSET, in zuiClearIterator, we will do nothing.
    Just a cleanup that zuiInitIterator and zuiClearIterator should appear in pairs.

diff --git a/src/t_zset.c b/src/t_zset.c
index fb402816d..1f7040d1c 100644
--- a/src/t_zset.c
+++ b/src/t_zset.c
@@ -4070,6 +4070,7 @@ void zrandmemberWithCountCommand(client *c, long l, int withscores) {
             if (withscores)
                 addReplyDouble(c, zval.score);
         }
+        zuiClearIterator(&src);
         return;
     }
 
@@ -4137,6 +4138,7 @@ void zrandmemberWithCountCommand(client *c, long l, int withscores) {
             zarndmemberReplyWithZiplist(c, count, keys, vals);
             zfree(keys);
             zfree(vals);
+            zuiClearIterator(&src);
             return;
         }
 
@@ -4170,6 +4172,7 @@ void zrandmemberWithCountCommand(client *c, long l, int withscores) {
         /* Release memory */
         dictRelease(d);
     }
+    zuiClearIterator(&src);
 }
 
 /* ZRANDMEMBER [<count> WITHSCORES] */

[ML] commit 5100ef9f8246dec6590f35f6b9f0b88c2dea0cfb
Author: sundb <sundbcn@gmail.com>
Date:   Sun May 2 15:32:57 2021 +0800

    Fix memory leak in moduleDefragGlobals (#8853)

diff --git a/src/module.c b/src/module.c
index 995312a74..42ddfe154 100644
--- a/src/module.c
+++ b/src/module.c
@@ -9196,6 +9196,7 @@ long moduleDefragGlobals(void) {
         module->defrag_cb(&defrag_ctx);
         defragged += defrag_ctx.defragged;
     }
+    dictReleaseIterator(di);
 
     return defragged;
 }

[ML] commit c73b4ddfd96d00ed0d0fde17953ce63d78bc3777
Author: Madelyn Olson <34459052+madolson@users.noreply.github.com>
Date:   Mon Apr 19 22:16:27 2021 -0700

    Fix memory leak when doing lazyfreeing client tracking table (#8822)
    
    Interior rax pointers were not being freed

diff --git a/src/lazyfree.c b/src/lazyfree.c
index f18b2027f..a2cf2c3ed 100644
--- a/src/lazyfree.c
+++ b/src/lazyfree.c
@@ -39,12 +39,11 @@ void lazyfreeFreeSlotsMap(void *args[]) {
     atomicIncr(lazyfreed_objects,len);
 }
 
-/* Release the rax mapping Redis Cluster keys to slots in the
- * lazyfree thread. */
+/* Release the key tracking table. */
 void lazyFreeTrackingTable(void *args[]) {
     rax *rt = args[0];
     size_t len = rt->numele;
-    raxFree(rt);
+    freeTrackingRadixTree(rt);
     atomicDecr(lazyfree_objects,len);
     atomicIncr(lazyfreed_objects,len);
 }
diff --git a/src/server.h b/src/server.h
index d35eaa425..a2a722c6d 100644
--- a/src/server.h
+++ b/src/server.h
@@ -1911,6 +1911,7 @@ void disableTracking(client *c);
 void trackingRememberKeys(client *c);
 void trackingInvalidateKey(client *c, robj *keyobj);
 void trackingInvalidateKeysOnFlush(int async);
+void freeTrackingRadixTree(rax *rt);
 void freeTrackingRadixTreeAsync(rax *rt);
 void trackingLimitUsedSlots(void);
 uint64_t trackingGetTotalItems(void);
diff --git a/tests/unit/tracking.tcl b/tests/unit/tracking.tcl
index 40f1a2a66..4c75b6f48 100644
--- a/tests/unit/tracking.tcl
+++ b/tests/unit/tracking.tcl
@@ -395,6 +395,17 @@ start_server {tags {"tracking network"}} {
         assert {[lindex msg 2] eq {} }
     }
 
+    test {Test ASYNC flushall} {
+        clean_all
+        r CLIENT TRACKING on REDIRECT $redir_id
+        r GET key1
+        r GET key2
+        assert_equal [s 0 tracking_total_keys] 2
+        $rd_sg FLUSHALL ASYNC
+        assert_equal [s 0 tracking_total_keys] 0
+        assert_equal [lindex [$rd_redirection read] 2] {}
+    }
+
     # Keys are defined to be evicted 100 at a time by default.
     # If after eviction the number of keys still surpasses the limit
     # defined in tracking-table-max-keys, we increases eviction 

[ML] commit a4f03bd7eb44580b44f9499c53417df45e1edfb0
Author: guybe7 <guy.benoish@redislabs.com>
Date:   Thu Mar 11 12:50:13 2021 +0100

    Fix some memory leaks in propagagte.c (#8636)
    
    Introduced by 3d0b427c30610b45c00b2377ee28bb69974ccea2

diff --git a/tests/modules/propagate.c b/tests/modules/propagate.c
index e07f8efe7..7a63ed807 100644
--- a/tests/modules/propagate.c
+++ b/tests/modules/propagate.c
@@ -77,7 +77,8 @@ void timerNestedHandler(RedisModuleCtx *ctx, void *data) {
     /* The goal is the trigger a module command that calls RM_Replicate
      * in order to test MULTI/EXEC structre */
     RedisModule_Replicate(ctx,"INCRBY","cc","timer-nested-start","1");
-    RedisModule_Call(ctx,"propagate-test.nested", repl? "!" : "");
+    RedisModuleCallReply *reply = RedisModule_Call(ctx,"propagate-test.nested", repl? "!" : "");
+    RedisModule_FreeCallReply(reply);
     RedisModule_Replicate(ctx,"INCRBY","cc","timer-nested-end","1");
 }
 
@@ -178,7 +179,8 @@ int propagateTestNestedCommand(RedisModuleCtx *ctx, RedisModuleString **argv, in
     reply = RedisModule_Call(ctx, "INCR", "c!", "using-call");
     RedisModule_FreeCallReply(reply);
 
-    RedisModule_Call(ctx,"propagate-test.simple", "!");
+    reply = RedisModule_Call(ctx,"propagate-test.simple", "!");
+    RedisModule_FreeCallReply(reply);
 
     RedisModule_Replicate(ctx,"INCR","c","counter-3");
     RedisModule_Replicate(ctx,"INCR","c","counter-4");

[ML] commit cfcd0fa6f71af4e224c1d86be55b6b01f2288be2
Author: Wen Hui <wen.hui.ware@gmail.com>
Date:   Wed Jan 6 14:20:53 2021 -0500

    fix memory leak in processInlineBuffer error handling code (#8295)
    
    This code path is normally executed only when v6.0 and above replicates from v2.4

diff --git a/src/networking.c b/src/networking.c
index 29e5605d9..acb1b27cb 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -1734,6 +1734,7 @@ int processInlineBuffer(client *c) {
      * However the is an exception: masters may send us just a newline
      * to keep the connection active. */
     if (querylen != 0 && c->flags & CLIENT_MASTER) {
+        sdsfreesplitres(argv,argc);
         serverLog(LL_WARNING,"WARNING: Receiving inline protocol from master, master stream corruption? Closing the master connection and discarding the cached master.");
         setProtocolError("Master using the inline protocol. Desync?",c);
         return C_ERR;

[ML] commit 049cf8cdf4e9e0abecf137dc1e3362089439f414
Author: Oran Agra <oran@redislabs.com>
Date:   Sun Dec 27 21:40:12 2020 +0200

    Fix memory leaks in error replies due to recent change (#8249)
    
    Recently efaf09ee4 started using addReplyErrorSds in place of
    addReplySds the later takes ownership of the string but the former did
    not.
    This introduced memory leaks when a script returns an error to redis,
    and also in clusterRedirectClient (two new usages of
    addReplyErrorSds which was mostly unused till now.
    
    This commit chagnes two thanks.
    1. change addReplyErrorSds to take ownership of the error string.
    2. scripting.c doesn't actually need to use addReplyErrorSds, it's a
    perfect match for addReplyErrorFormat (replaces newlines with spaces)

diff --git a/src/networking.c b/src/networking.c
index 24a601630..34e8b8481 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -458,9 +458,11 @@ void addReplyError(client *c, const char *err) {
 }
 
 /* See addReplyErrorLength for expectations from the input string. */
+/* As a side effect the SDS string is freed. */
 void addReplyErrorSds(client *c, sds err) {
     addReplyErrorLength(c,err,sdslen(err));
     afterErrorReply(c,err,sdslen(err));
+    sdsfree(err);
 }
 
 /* See addReplyErrorLength for expectations from the formatted string.
diff --git a/src/scripting.c b/src/scripting.c
index 2ac8268ed..e75892046 100644
--- a/src/scripting.c
+++ b/src/scripting.c
@@ -366,10 +366,7 @@ void luaReplyToRedisReply(client *c, lua_State *lua) {
         lua_gettable(lua,-2);
         t = lua_type(lua,-1);
         if (t == LUA_TSTRING) {
-            sds err = sdsnew(lua_tostring(lua,-1));
-            sdsmapchars(err,"\r\n","  ",2);
-            addReplyErrorSds(c,sdscatprintf(sdsempty(),"-%s",err));
-            sdsfree(err);
+            addReplyErrorFormat(c,"-%s",lua_tostring(lua,-1));
             lua_pop(lua,2);
             return;
         }
diff --git a/src/server.c b/src/server.c
index 90f669bdb..257a39f71 100644
--- a/src/server.c
+++ b/src/server.c
@@ -3689,10 +3689,11 @@ void rejectCommandFormat(client *c, const char *fmt, ...) {
     sdsmapchars(s, "\r\n", "  ",  2);
     if (c->cmd && c->cmd->proc == execCommand) {
         execCommandAbort(c, s);
+        sdsfree(s);
     } else {
+        /* The following frees 's'. */
         addReplyErrorSds(c, s);
     }
-    sdsfree(s);
 }
 
 /* Returns 1 for commands that may have key names in their arguments, but have

commit ee59dc1b5cdcc631438aba3904d6d3b520354c80
Author: Yang Bodong <bodong.ybd@alibaba-inc.com>
Date:   Wed Dec 23 22:28:17 2020 +0800

    Tests: fix the problem that Darwin memory leak detection may fail (#8213)
    
    Apparently the "leaks" took reports a different error string about process
    that's not found in each version of MacOS.
    This cause the test suite to fail on some OS versions, since some tests terminate
    the process before looking for leaks.
    Instead of looking at the error string, we now look at the (documented) exit code.

diff --git a/tests/support/server.tcl b/tests/support/server.tcl
index 1cddb7068..77ba31d84 100644
--- a/tests/support/server.tcl
+++ b/tests/support/server.tcl
@@ -50,11 +50,17 @@ proc kill_server config {
                 tags {"leaks"} {
                     test "Check for memory leaks (pid $pid)" {
                         set output {0 leaks}
-                        catch {exec leaks $pid} output
-                        if {[string match {*process does not exist*} $output] ||
-                            [string match {*cannot examine*} $output]} {
-                            # In a few tests we kill the server process.
-                            set output "0 leaks"
+                        catch {exec leaks $pid} output option
+                        # In a few tests we kill the server process, so leaks will not find it.
+                        # It'll exits with exit code >1 on error, so we ignore these.
+                        if {[dict exists $option -errorcode]} {
+                            set details [dict get $option -errorcode]
+                            if {[lindex $details 0] eq "CHILDSTATUS"} {
+                                  set status [lindex $details 2]
+                                  if {$status > 1} {
+                                      set output "0 leaks"
+                                  }
+                            }
                         }
                         set output
                     } {*0 leaks*}

[ML] commit c31055db617a7fedb20c28c245ddad8ed2b11931
Author: Oran Agra <oran@redislabs.com>
Date:   Fri Aug 14 16:05:34 2020 +0300

    Sanitize dump payload: fuzz tester and fixes for segfaults and leaks it exposed
    
    The test creates keys with various encodings, DUMP them, corrupt the payload
    and RESTORES it.
    It utilizes the recently added use-exit-on-panic config to distinguish between
     asserts and segfaults.
    If the restore succeeds, it runs random commands on the key to attempt to
    trigger a crash.
    
    It runs in two modes, one with deep sanitation enabled and one without.
    In the first one we don't expect any assertions or segfaults, in the second one
    we expect assertions, but no segfaults.
    We also check for leaks and invalid reads using valgrind, and if we find them
    we print the commands that lead to that issue.
    
    Changes in the code (other than the test):
    - Replace a few NPD (null pointer deference) flows and division by zero with an
      assertion, so that it doesn't fail the test. (since we set the server to use
      `exit` rather than `abort` on assertion).
    - Fix quite a lot of flows in rdb.c that could have lead to memory leaks in
      RESTORE command (since it now responds with an error rather than panic)
    - Add a DEBUG flag for SET-SKIP-CHECKSUM-VALIDATION so that the test don't need
      to bother with faking a valid checksum
    - Remove a pile of code in serverLogObjectDebugInfo which is actually unsafe to
      run in the crash report (see comments in the code)
    - fix a missing boundary check in lzf_decompress
    
    test suite infra improvements:
    - be able to run valgrind checks before the process terminates
    - rotate log files when restarting servers

diff --git a/src/cluster.c b/src/cluster.c
index 6116614ea..ef73b1093 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -4981,6 +4981,9 @@ int verifyDumpPayload(unsigned char *p, size_t len) {
     rdbver = (footer[1] << 8) | footer[0];
     if (rdbver > RDB_VERSION) return C_ERR;
 
+    if (server.skip_checksum_validation)
+        return C_OK;
+
     /* Verify CRC64 */
     crc = crc64(0,p,len-8);
     memrev64ifbe(&crc);
diff --git a/src/db.c b/src/db.c
index 45865b3e8..12e1c2bbe 100644
--- a/src/db.c
+++ b/src/db.c
@@ -960,6 +960,7 @@ void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
          * value, or skip it if it was not filtered: we only match keys. */
         if (o && (o->type == OBJ_ZSET || o->type == OBJ_HASH)) {
             node = nextnode;
+            serverAssert(node); /* assertion for valgrind (avoid NPD) */
             nextnode = listNextNode(node);
             if (filter) {
                 kobj = listNodeValue(node);
diff --git a/src/debug.c b/src/debug.c
index d32a8ddce..7cc3c15a3 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -403,6 +403,7 @@ void debugCommand(client *c) {
 "SDSLEN <key> -- Show low level SDS string info representing key and value.",
 "SEGFAULT -- Crash the server with sigsegv.",
 "SET-ACTIVE-EXPIRE <0|1> -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.",
+"SET-SKIP-CHECKSUM-VALIDATION <0|1> -- Enables or disables checksum checks for rdb or RESTORE payload.",
 "AOF-FLUSH-SLEEP <microsec> -- Server will sleep before flushing the AOF, this is used for testing",
 "SLEEP <seconds> -- Stop the server for <seconds>. Decimals allowed.",
 "STRUCTSIZE -- Return the size of different Redis core C structures.",
@@ -722,6 +723,11 @@ NULL
     {
         server.active_expire_enabled = atoi(c->argv[2]->ptr);
         addReply(c,shared.ok);
+    } else if (!strcasecmp(c->argv[1]->ptr,"set-skip-checksum-validation") &&
+               c->argc == 3)
+    {
+        server.skip_checksum_validation = atoi(c->argv[2]->ptr);
+        addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"aof-flush-sleep") &&
                c->argc == 3)
     {
@@ -880,6 +886,14 @@ void serverLogObjectDebugInfo(const robj *o) {
     serverLog(LL_WARNING,"Object type: %d", o->type);
     serverLog(LL_WARNING,"Object encoding: %d", o->encoding);
     serverLog(LL_WARNING,"Object refcount: %d", o->refcount);
+#if UNSAFE_CRASH_REPORT
+    /* This code is now disabled. o->ptr may be unreliable to print. in some
+     * cases a ziplist could have already been freed by realloc, but not yet
+     * updated to o->ptr. in other cases the call to ziplistLen may need to
+     * iterate on all the items in the list (and possibly crash again).
+     * For some cases it may be ok to crash here again, but these could cause
+     * invalid memory access which will bother valgrind and also possibly cause
+     * random memory portion to be "leaked" into the logfile. */
     if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
         serverLog(LL_WARNING,"Object raw string len: %zu", sdslen(o->ptr));
         if (sdslen(o->ptr) < 4096) {
@@ -900,6 +914,7 @@ void serverLogObjectDebugInfo(const robj *o) {
     } else if (o->type == OBJ_STREAM) {
         serverLog(LL_WARNING,"Stream size: %d", (int) streamLength(o));
     }
+#endif
 }
 
 void _serverAssertPrintObject(const robj *o) {
diff --git a/src/intset.c b/src/intset.c
index 0079199cf..964a41187 100644
--- a/src/intset.c
+++ b/src/intset.c
@@ -34,6 +34,7 @@
 #include "intset.h"
 #include "zmalloc.h"
 #include "endianconv.h"
+#include "redisassert.h"
 
 /* Note that these encodings are ordered, so:
  * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */
@@ -258,7 +259,9 @@ uint8_t intsetFind(intset *is, int64_t value) {
 
 /* Return random member */
 int64_t intsetRandom(intset *is) {
-    return _intsetGet(is,rand()%intrev32ifbe(is->length));
+    uint32_t len = intrev32ifbe(is->length);
+    assert(len); /* avoid division by zero on corrupt intset payload. */
+    return _intsetGet(is,rand()%len);
 }
 
 /* Get the value at the given position. When this position is
diff --git a/src/listpack.c b/src/listpack.c
index 580954075..b403a1200 100644
--- a/src/listpack.c
+++ b/src/listpack.c
@@ -536,6 +536,7 @@ unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {
     int64_t val;
     uint64_t uval, negstart, negmax;
 
+    assert(p); /* assertion for valgrind (avoid NPD) */
     if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
         negstart = UINT64_MAX; /* 7 bit ints are always positive. */
         negmax = 0;
diff --git a/src/lzf_d.c b/src/lzf_d.c
index 5f55d471d..dbf1ae772 100644
--- a/src/lzf_d.c
+++ b/src/lzf_d.c
@@ -65,9 +65,10 @@ lzf_decompress (const void *const in_data,  unsigned int in_len,
   u8 const *const in_end  = ip + in_len;
   u8       *const out_end = op + out_len;
 
-  do
+  while (ip < in_end)
     {
-      unsigned int ctrl = *ip++;
+      unsigned int ctrl;
+      ctrl = *ip++;
 
       if (ctrl < (1 << 5)) /* literal run */
         {
@@ -182,7 +183,6 @@ lzf_decompress (const void *const in_data,  unsigned int in_len,
 #endif
         }
     }
-  while (ip < in_end);
 
   return op - (u8 *)out_data;
 }
diff --git a/src/networking.c b/src/networking.c
index 626b117a1..82b6428ac 100644
--- a/src/networking.c
+++ b/src/networking.c
@@ -674,6 +674,7 @@ void addReplyLongLong(client *c, long long ll) {
 }
 
 void addReplyAggregateLen(client *c, long length, int prefix) {
+    serverAssert(length >= 0);
     if (prefix == '*' && length < OBJ_SHARED_BULKHDR_LEN)
         addReply(c,shared.mbulkhdr[length]);
     else
diff --git a/src/quicklist.c b/src/quicklist.c
index 0916d1f1b..8d68aa9ae 100644
--- a/src/quicklist.c
+++ b/src/quicklist.c
@@ -34,6 +34,7 @@
 #include "ziplist.h"
 #include "util.h" /* for ll2string */
 #include "lzf.h"
+#include "redisassert.h"
 
 #if defined(REDIS_TEST) || defined(REDIS_TEST_VERBOSE)
 #include <stdio.h> /* for printf (debug printing), snprintf (genstr) */
@@ -1289,7 +1290,8 @@ int quicklistIndex(const quicklist *quicklist, const long long idx,
 
     quicklistDecompressNodeForUse(entry->node);
     entry->zi = ziplistIndex(entry->node->zl, entry->offset);
-    ziplistGet(entry->zi, &entry->value, &entry->sz, &entry->longval);
+    if (!ziplistGet(entry->zi, &entry->value, &entry->sz, &entry->longval))
+        assert(0); /* This can happen on corrupt ziplist with fake entry count. */
     /* The caller will use our result, so we don't re-compress here.
      * The caller can recompress or delete the node as needed. */
     return 1;
diff --git a/src/rdb.c b/src/rdb.c
index af527f94c..e88cabb5d 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -399,8 +399,9 @@ void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
 
     /* Load the compressed representation and uncompress it to target. */
     if (rioRead(rdb,c,clen) == 0) goto err;
-    if (lzf_decompress(c,clen,val,len) == 0) {
+    if (lzf_decompress(c,clen,val,len) != len) {
         rdbExitReportCorruptRDB("Invalid LZF compressed string");
+        goto err;
     }
     zfree(c);
 
@@ -504,6 +505,8 @@ void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
     unsigned long long len;
 
     len = rdbLoadLen(rdb,&isencoded);
+    if (len == RDB_LENERR) return NULL;
+
     if (isencoded) {
         switch(len) {
         case RDB_ENC_INT8:
@@ -518,7 +521,6 @@ void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
         }
     }
 
-    if (len == RDB_LENERR) return NULL;
     if (plain || sds) {
         void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
         if (lenptr) *lenptr = len;
@@ -604,7 +606,7 @@ int rdbLoadDoubleValue(rio *rdb, double *val) {
     default:
         if (rioRead(rdb,buf,len) == 0) return -1;
         buf[len] = '\0';
-        sscanf(buf, "%lg", val);
+        if (sscanf(buf, "%lg", val)!=1) return -1;
         return 0;
     }
 }
@@ -1572,7 +1574,12 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
             /* This will also be called when the set was just converted
              * to a regular hash table encoded set. */
             if (o->encoding == OBJ_ENCODING_HT) {
-                dictAdd((dict*)o->ptr,sdsele,NULL);
+                if (dictAdd((dict*)o->ptr,sdsele,NULL) != DICT_OK) {
+                    rdbExitReportCorruptRDB("Duplicate set members detected");
+                    decrRefCount(o);
+                    sdsfree(sdsele);
+                    return NULL;
+                }
             } else {
                 sdsfree(sdsele);
             }
@@ -1693,7 +1700,11 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
             /* Add pair to hash table */
             ret = dictAdd((dict*)o->ptr, field, value);
             if (ret == DICT_ERR) {
-                rdbExitReportCorruptRDB("Duplicate keys detected");
+                rdbExitReportCorruptRDB("Duplicate hash fields detected");
+                sdsfree(value);
+                sdsfree(field);
+                decrRefCount(o);
+                return NULL;
             }
         }
 
@@ -1843,6 +1854,9 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
             if (sdslen(nodekey) != sizeof(streamID)) {
                 rdbExitReportCorruptRDB("Stream node key entry is not the "
                                         "size of a stream ID");
+                sdsfree(nodekey);
+                decrRefCount(o);
+                return NULL;
             }
 
             /* Load the listpack. */
@@ -1870,14 +1884,22 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
                  * deletion we should remove the radix tree key if the
                  * resulting listpack is empty. */
                 rdbExitReportCorruptRDB("Empty listpack inside stream");
+                sdsfree(nodekey);
+                decrRefCount(o);
+                zfree(lp);
+                return NULL;
             }
 
             /* Insert the key in the radix tree. */
             int retval = raxInsert(s->rax,
                 (unsigned char*)nodekey,sizeof(streamID),lp,NULL);
             sdsfree(nodekey);
-            if (!retval)
+            if (!retval) {
                 rdbExitReportCorruptRDB("Listpack re-added with existing key");
+                decrRefCount(o);
+                zfree(lp);
+                return NULL;
+            }
         }
         /* Load total number of items inside the stream. */
         s->length = rdbLoadLen(rdb,NULL);
@@ -1922,9 +1944,13 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
             }
 
             streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);
-            if (cgroup == NULL)
+            if (cgroup == NULL) {
                 rdbExitReportCorruptRDB("Duplicated consumer group name %s",
                                          cgname);
+                decrRefCount(o);
+                sdsfree(cgname);
+                return NULL;
+            }
             sdsfree(cgname);
 
             /* Load the global PEL for this consumer group, however we'll
@@ -1954,9 +1980,13 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
                     streamFreeNACK(nack);
                     return NULL;
                 }
-                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))
+                if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL)) {
                     rdbExitReportCorruptRDB("Duplicated global PEL entry "
                                             "loading stream consumer group");
+                    decrRefCount(o);
+                    streamFreeNACK(nack);
+                    return NULL;
+                }
             }
 
             /* Now that we loaded our global PEL, we need to load the
@@ -2003,18 +2033,24 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
                         return NULL;
                     }
                     streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));
-                    if (nack == raxNotFound)
+                    if (nack == raxNotFound) {
                         rdbExitReportCorruptRDB("Consumer entry not found in "
                                                 "group global PEL");
+                        decrRefCount(o);
+                        return NULL;
+                    }
 
                     /* Set the NACK consumer, that was left to NULL when
                      * loading the global PEL. Then set the same shared
                      * NACK structure also in the consumer-specific PEL. */
                     nack->consumer = consumer;
-                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))
+                    if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL)) {
                         rdbExitReportCorruptRDB("Duplicated consumer PEL entry "
                                                 " loading a stream consumer "
                                                 "group");
+                        decrRefCount(o);
+                        return NULL;
+                    }
                 }
             }
         }
@@ -2034,8 +2070,8 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
 
         if (mt == NULL) {
             moduleTypeNameByID(name,moduleid);
-            serverLog(LL_WARNING,"The RDB file contains module data I can't load: no matching module '%s'", name);
-            exit(1);
+            rdbExitReportCorruptRDB("The RDB file contains module data I can't load: no matching module '%s'", name);
+            return NULL;
         }
         RedisModuleIO io;
         robj keyobj;
@@ -2054,20 +2090,26 @@ robj *rdbLoadObject(int rdbtype, rio *rdb, sds key) {
         if (io.ver == 2) {
             uint64_t eof = rdbLoadLen(rdb,NULL);
             if (eof == RDB_LENERR) {
-                o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */
-                decrRefCount(o);
+                if (ptr) {
+                    o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */
+                    decrRefCount(o);
+                }
                 return NULL;
             }
             if (eof != RDB_MODULE_OPCODE_EOF) {
-                serverLog(LL_WARNING,"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker", name);
-                exit(1);
+                rdbExitReportCorruptRDB("The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker", name);
+                if (ptr) {
+                    o = createModuleObject(mt,ptr); /* creating just in order to easily destroy */
+                    decrRefCount(o);
+                }
+                return NULL;
             }
         }
 
         if (ptr == NULL) {
             moduleTypeNameByID(name,moduleid);
-            serverLog(LL_WARNING,"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
-            exit(1);
+            rdbExitReportCorruptRDB("The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
+            return NULL;
         }
         o = createModuleObject(mt,ptr);
     } else {
@@ -2441,7 +2483,7 @@ int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
         uint64_t cksum, expected = rdb->cksum;
 
         if (rioRead(rdb,&cksum,8) == 0) goto eoferr;
-        if (server.rdb_checksum) {
+        if (server.rdb_checksum && !server.skip_checksum_validation) {
             memrev64ifbe(&cksum);
             if (cksum == 0) {
                 serverLog(LL_WARNING,"RDB file was saved with checksum disabled: no check performed.");
diff --git a/src/server.c b/src/server.c
index 1b6f71aef..0c3bbff03 100644
--- a/src/server.c
+++ b/src/server.c
@@ -2506,6 +2506,7 @@ void initServerConfig(void) {
     server.tlsfd_count = 0;
     server.sofd = -1;
     server.active_expire_enabled = 1;
+    server.skip_checksum_validation = 0;
     server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;
     server.saveparams = NULL;
     server.loading = 0;
diff --git a/src/server.h b/src/server.h
index 8a35d48df..47f054b3f 100644
--- a/src/server.h
+++ b/src/server.h
@@ -1245,6 +1245,7 @@ struct redisServer {
     int active_expire_effort;       /* From 1 (default) to 10, active effort. */
     int active_defrag_enabled;
     int sanitize_dump_payload;      /* Enables deep sanitization for ziplist and listpack in RDB and RESTORE. */
+    int skip_checksum_validation;   /* Disables checksum validateion for RDB and RESTORE payload. */
     int jemalloc_bg_thread;         /* Enable jemalloc background thread */
     size_t active_defrag_ignore_bytes; /* minimum amount of fragmentation waste to start active defrag */
     int active_defrag_threshold_lower; /* minimum percentage of fragmentation to start active defrag */
diff --git a/src/t_list.c b/src/t_list.c
index acabe7be2..42b4f92df 100644
--- a/src/t_list.c
+++ b/src/t_list.c
@@ -728,6 +728,7 @@ void lmoveGenericCommand(client *c, int wherefrom, int whereto) {
 
         if (checkType(c,dobj,OBJ_LIST)) return;
         value = listTypePop(sobj,wherefrom);
+        serverAssert(value); /* assertion for valgrind (avoid NPD) */
         /* We saved touched key, and protect it, since lmoveHandlePush
          * may change the client command argument vector (it does not
          * currently). */
diff --git a/src/t_stream.c b/src/t_stream.c
index 70cc8bfa1..320c5a2fe 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -787,6 +787,7 @@ int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
                 *numfields = lpGetInteger(si->lp_ele);
                 si->lp_ele = lpNext(si->lp,si->lp_ele);
             }
+            serverAssert(*numfields>=0);
 
             /* If current >= start, and the entry is not marked as
              * deleted, emit it. */
@@ -2879,6 +2880,7 @@ void xinfoReplyWithStreamInfo(client *c, stream *s) {
                     addReplyStreamID(c,&id);
 
                     /* Consumer name. */
+                    serverAssert(nack->consumer); /* assertion for valgrind (avoid NPD) */
                     addReplyBulkCBuffer(c,nack->consumer->name,
                                         sdslen(nack->consumer->name));
 
diff --git a/src/valgrind.sup b/src/valgrind.sup
index b05843d8c..5d6367e3f 100644
--- a/src/valgrind.sup
+++ b/src/valgrind.sup
@@ -15,3 +15,12 @@
    Memcheck:Value8
    fun:lzf_compress
 }
+
+{
+   <negative size allocatoin, see integration/corrupt-dump>
+   Memcheck:FishyValue
+   malloc(size)
+   fun:malloc
+   fun:ztrymalloc_usable
+   fun:ztrymalloc
+}
diff --git a/tests/instances.tcl b/tests/instances.tcl
index d3b1b50cd..156c92706 100644
--- a/tests/instances.tcl
+++ b/tests/instances.tcl
@@ -155,7 +155,7 @@ proc log_crashes {} {
 
     set logs [glob */err.txt]
     foreach log $logs {
-        set res [find_valgrind_errors $log]
+        set res [find_valgrind_errors $log true]
         if {$res != ""} {
             puts $res
             incr ::failed
diff --git a/tests/integration/corrupt-dump-fuzzer.tcl b/tests/integration/corrupt-dump-fuzzer.tcl
new file mode 100644
index 000000000..d41ed2941
--- /dev/null
+++ b/tests/integration/corrupt-dump-fuzzer.tcl
@@ -0,0 +1,193 @@
+# tests of corrupt ziplist payload with valid CRC
+
+tags {"dump" "corruption"} {
+
+proc generate_collections {suffix elements} {
+    set rd [redis_deferring_client]
+    for {set j 0} {$j < $elements} {incr j} {
+        # add both string values and integers
+        if {$j % 2 == 0} {set val $j} else {set val "_$j"}
+        $rd hset hash$suffix $j $val
+        $rd lpush list$suffix $val
+        $rd zadd zset$suffix $j $val
+        $rd sadd set$suffix $val
+        $rd xadd stream$suffix * item 1 value $val
+    }
+    for {set j 0} {$j < $elements * 5} {incr j} {
+        $rd read ; # Discard replies
+    }
+    $rd close
+}
+
+# generate keys with various types and encodings
+proc generate_types {} {
+    r config set list-max-ziplist-size 5
+    r config set hash-max-ziplist-entries 5
+    r config set zset-max-ziplist-entries 5
+    r config set stream-node-max-entries 5
+
+    # create small (ziplist / listpack encoded) objects with 3 items
+    generate_collections "" 3
+
+    # add some metadata to the stream
+    r xgroup create stream mygroup 0
+    set records [r xreadgroup GROUP mygroup Alice COUNT 2 STREAMS stream >]
+    r xack stream mygroup [lindex [lindex [lindex [lindex $records 0] 1] 0] 0]
+
+    # create other non-collection types
+    r incr int
+    r set string str
+
+    # create bigger objects with 10 items (more than a single ziplist / listpack)
+    generate_collections big 10
+
+    # make sure our big stream also has a listpack record that has different
+    # field names than the master recored
+    r xadd streambig * item 1 value 1
+    r xadd streambig * item 1 unique value
+}
+
+proc corrupt_payload {payload} {
+    set len [string length $payload]
+    set count 1 ;# usually corrupt only one byte
+    if {rand() > 0.9} { set count 2 }
+    while { $count > 0 } {
+        set idx [expr {int(rand() * $len)}]
+        set ch [binary format c [expr {int(rand()*255)}]]
+        set payload [string replace $payload $idx $idx $ch]
+        incr count -1
+    }
+    return $payload
+}
+
+# fuzzy tester for corrupt RESTORE payloads
+# valgrind will make sure there were no leaks in the rdb loader error handling code
+foreach sanitize_dump {no yes} {
+    if {$::accurate} {
+        set min_duration [expr {60 * 10}] ;# run at least 10 minutes
+        set min_cycles 1000 ;# run at least 1k cycles (max 16 minutes)
+    } else {
+        set min_duration 10 ; # run at least 10 seconds
+        set min_cycles 10 ; # run at least 10 cycles
+    }
+
+    test "Fuzzer corrupt restore payloads - sanitize_dump: $sanitize_dump" {
+        if {$min_duration * 2 > $::timeout} {
+            fail "insufficient timeout"
+        }
+        # start a server, fill with data and save an RDB file once (avoid re-save)
+        start_server [list overrides [list "save" "" use-exit-on-panic yes crash-memcheck-enabled no loglevel verbose] ] {
+            set stdout [srv 0 stdout]
+            r config set sanitize-dump-payload $sanitize_dump
+            r debug set-skip-checksum-validation 1
+            set start_time [clock seconds]
+            generate_types
+            r save
+            set cycle 0
+            set stat_terminated_in_restore 0
+            set stat_terminated_in_traffic 0
+            set stat_terminated_by_signal 0
+            set stat_successful_restore 0
+            set stat_rejected_restore 0
+            set stat_traffic_commands_sent 0
+            # repeatedly DUMP a random key, corrupt it and try RESTORE into a new key
+            while true {
+                set k [r randomkey]
+                set dump [r dump $k]
+                set dump [corrupt_payload $dump]
+                set printable_dump [string2printable $dump]
+                set restore_failed false
+                set report_and_restart false
+                set sent {}
+                # RESTORE can fail, but hopefully not terminate
+                if { [catch { r restore "_$k" 0 $dump REPLACE } err] } {
+                    set restore_failed true
+                    # skip if return failed with an error response.
+                    if {[string match "ERR*" $err]} {
+                        incr stat_rejected_restore
+                    } else {
+                        set report_and_restart true
+                        incr stat_terminated_in_restore
+                        write_log_line 0 "corrupt payload: $printable_dump"
+                        if {$sanitize_dump == 1} {
+                            puts "Server crashed in RESTORE with payload: $printable_dump"
+                        }
+                    }
+                } else {
+                    r ping ;# an attempt to check if the server didn't terminate (this will throw an error that will terminate the tests)
+                }
+
+                set print_commands false
+                if {!$restore_failed} {
+                    # if RESTORE didn't fail or terminate, run some random traffic on the new key
+                    incr stat_successful_restore
+                    if { [ catch {
+                        set sent [generate_fuzzy_traffic_on_key "_$k" 1] ;# traffic for 1 second
+                        incr stat_traffic_commands_sent [llength $sent]
+                        r del "_$k" ;# in case the server terminated, here's where we'll detect it.
+                    } err ] } {
+                        # if the server terminated update stats and restart it
+                        set report_and_restart true
+                        incr stat_terminated_in_traffic
+                        set by_signal [count_log_message 0 "crashed by signal"]
+                        incr stat_terminated_by_signal $by_signal
+
+                        if {$by_signal != 0 || $sanitize_dump == 1 } {
+                            puts "Server crashed (by signal: $by_signal), with payload: $printable_dump"
+                            set print_commands true
+                        }
+                    }
+                }
+
+                # check valgrind report for invalid reads after each RESTORE
+                # payload so that we have a report that is easier to reproduce
+                set valgrind_errors [find_valgrind_errors [srv 0 stderr] false]
+                if {$valgrind_errors != ""} {
+                    puts "valgrind found an issue for payload: $printable_dump"
+                    set report_and_restart true
+                    set print_commands true
+                }
+
+                if {$report_and_restart} {
+                    if {$print_commands} {
+                        puts "violating commands:"
+                        foreach cmd $sent {
+                            foreach arg $cmd {
+                                puts -nonewline "[string2printable $arg] "
+                            }
+                            puts ""
+                        }
+                    }
+
+                    # restart the server and re-apply debug configuration
+                    write_log_line 0 "corrupt payload: $printable_dump"
+                    restart_server 0 true true
+                    r config set sanitize-dump-payload $sanitize_dump
+                    r debug set-skip-checksum-validation 1
+                }
+
+                incr cycle
+                if { ([clock seconds]-$start_time) >= $min_duration && $cycle >= $min_cycles} {
+                    break
+                }
+            }
+            if {$::verbose} {
+                puts "Done $cycle cycles in [expr {[clock seconds]-$start_time}] seconds."
+                puts "RESTORE: successful: $stat_successful_restore, rejected: $stat_rejected_restore"
+                puts "Total commands sent in traffic: $stat_traffic_commands_sent, crashes during traffic: $stat_terminated_in_traffic ($stat_terminated_by_signal by signal)."
+            }
+        }
+        # if we run sanitization we never expect the server to crash at runtime
+        if { $sanitize_dump == 1} {
+            assert_equal $stat_terminated_in_restore 0
+            assert_equal $stat_terminated_in_traffic 0
+        }
+        # make sure all terminations where due to assertion and not a SIGSEGV
+        assert_equal $stat_terminated_by_signal 0
+    }
+}
+
+
+
+} ;# tags
+
diff --git a/tests/integration/corrupt-dump.tcl b/tests/integration/corrupt-dump.tcl
index 9864036d2..b8828fd94 100644
--- a/tests/integration/corrupt-dump.tcl
+++ b/tests/integration/corrupt-dump.tcl
@@ -1,4 +1,10 @@
 # tests of corrupt ziplist payload with valid CRC
+# * setting crash-memcheck-enabled to no to avoid issues with valgrind
+# * setting use-exit-on-panic to yes so that valgrind can search for leaks
+# * settng debug set-skip-checksum-validation to 1 on some tests for which we
+#   didn't bother to fake a valid checksum
+# * some tests set sanitize-dump-payload to no and some to yet, depending on
+#   what we want to test
 
 tags {"dump" "corruption"} {
 
@@ -18,27 +24,27 @@ test {corrupt payload: #7445 - with sanitize} {
 test {corrupt payload: #7445 - without sanitize - 1} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
         r config set sanitize-dump-payload no
-        r config set crash-memcheck-enabled no ;# avoid valgrind issues
         r restore key 0 $corrupt_payload_7445
         catch {r lindex key 2}
-        verify_log_message 0 "*ASSERTION FAILED*" 0
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
     }
 }
 
 test {corrupt payload: #7445 - without sanitize - 2} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
         r config set sanitize-dump-payload no
-        r config set crash-memcheck-enabled no ;# avoid valgrind issues
         r restore key 0 $corrupt_payload_7445
         catch {r lset key 2 "BEEF"}
-        verify_log_message 0 "*ASSERTION FAILED*" 0
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
     }
 }
 
 test {corrupt payload: hash with valid zip list header, invalid entry len} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         r restore key 0 "\x0D\x1B\x1B\x00\x00\x00\x16\x00\x00\x00\x04\x00\x00\x02\x61\x00\x04\x02\x62\x00\x04\x14\x63\x00\x04\x02\x64\x00\xFF\x09\x00\xD9\x10\x54\x92\x15\xF5\x5F\x52"
-        r config set crash-memcheck-enabled no ;# avoid valgrind issues
         r config set hash-max-ziplist-entries 1
         catch {r hset key b b}
         verify_log_message 0 "*zipEntrySafe*" 0
@@ -47,6 +53,7 @@ test {corrupt payload: hash with valid zip list header, invalid entry len} {
 
 test {corrupt payload: invalid zlbytes header} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         catch {
             r restore key 0 "\x0D\x1B\x25\x00\x00\x00\x16\x00\x00\x00\x04\x00\x00\x02\x61\x00\x04\x02\x62\x00\x04\x02\x63\x00\x04\x02\x64\x00\xFF\x09\x00\xB7\xF7\x6E\x9F\x43\x43\x14\xC6"
         } err
@@ -56,8 +63,8 @@ test {corrupt payload: invalid zlbytes header} {
 
 test {corrupt payload: valid zipped hash header, dup records} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         r restore key 0 "\x0D\x1B\x1B\x00\x00\x00\x16\x00\x00\x00\x04\x00\x00\x02\x61\x00\x04\x02\x62\x00\x04\x02\x61\x00\x04\x02\x64\x00\xFF\x09\x00\xA1\x98\x36\x78\xCC\x8E\x93\x2E"
-        r config set crash-memcheck-enabled no ;# avoid valgrind issues
         r config set hash-max-ziplist-entries 1
         # cause an assertion when converting to hash table
         catch {r hset key b b}
@@ -67,10 +74,11 @@ test {corrupt payload: valid zipped hash header, dup records} {
 
 test {corrupt payload: quicklist big ziplist prev len} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         r restore key 0 "\x0E\x01\x13\x13\x00\x00\x00\x0E\x00\x00\x00\x02\x00\x00\x02\x61\x00\x0E\x02\x62\x00\xFF\x09\x00\x49\x97\x30\xB2\x0D\xA1\xED\xAA"
-        r config set crash-memcheck-enabled no ;# avoid valgrind issues
         catch {r lindex key -2}
-        verify_log_message 0 "*ASSERTION FAILED*" 0
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
     }
 }
 
@@ -87,19 +95,24 @@ test {corrupt payload: quicklist small ziplist prev len} {
 
 test {corrupt payload: quicklist ziplist wrong count} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         r restore key 0 "\x0E\x01\x13\x13\x00\x00\x00\x0E\x00\x00\x00\x03\x00\x00\x02\x61\x00\x04\x02\x62\x00\xFF\x09\x00\x4D\xE2\x0A\x2F\x08\x25\xDF\x91"
-        r lpush key a
-        # check that the server didn't crash
-        r ping
+        # we'll be able to push, but iterating on the list will assert
+        r lpush key header
+        r rpush key footer
+        catch { [r lrange key -1 -1] }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
     }
 }
 
 test {corrupt payload: #3080 - quicklist} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         catch {
             r RESTORE key 0 "\x0E\x01\x80\x00\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x02\x00\x00\x80\x41\x41\x41\x41\x07\x00\x03\xC7\x1D\xEF\x54\x68\xCC\xF3"
-            r DUMP key
-        }
+            r DUMP key ;# DUMP was used in the original issue, but now even with shallow sanitization restore safely fails, so this is dead code
+        } err
         assert_match "*Bad data format*" $err
         verify_log_message 0 "*Ziplist integrity check failed*" 0
     }
@@ -107,9 +120,11 @@ test {corrupt payload: #3080 - quicklist} {
 
 test {corrupt payload: #3080 - ziplist} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        # shallow sanitization is enough for restore to safely reject the payload with wrong size
+        r config set sanitize-dump-payload no
         catch {
             r RESTORE key 0 "\x0A\x80\x00\x00\x00\x10\x41\x41\x41\x41\x41\x41\x41\x41\x02\x00\x00\x80\x41\x41\x41\x41\x07\x00\x39\x5B\x49\xE0\xC1\xC6\xDD\x76"
-        }
+        } err
         assert_match "*Bad data format*" $err
         verify_log_message 0 "*Ziplist integrity check failed*" 0
     }
@@ -118,7 +133,7 @@ test {corrupt payload: #3080 - ziplist} {
 test {corrupt payload: load corrupted rdb with no CRC - #3505} {
     set server_path [tmpdir "server.rdb-corruption-test"]
     exec cp tests/assets/corrupt_ziplist.rdb $server_path
-    set srv [start_server [list overrides [list "dir" $server_path "dbfilename" "corrupt_ziplist.rdb" loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no]]]
+    set srv [start_server [list overrides [list "dir" $server_path "dbfilename" "corrupt_ziplist.rdb" loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no sanitize-dump-payload no]]]
 
     # wait for termination
     wait_for_condition 100 50 {
@@ -135,6 +150,7 @@ test {corrupt payload: load corrupted rdb with no CRC - #3505} {
 
 test {corrupt payload: listpack invalid size header} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         catch {
             r restore key 0 "\x0F\x01\x10\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x40\x55\x5F\x00\x00\x00\x0F\x00\x01\x01\x00\x01\x02\x01\x88\x31\x00\x00\x00\x00\x00\x00\x00\x09\x88\x32\x00\x00\x00\x00\x00\x00\x00\x09\x00\x01\x00\x01\x00\x01\x00\x01\x02\x02\x88\x31\x00\x00\x00\x00\x00\x00\x00\x09\x88\x61\x00\x00\x00\x00\x00\x00\x00\x09\x88\x32\x00\x00\x00\x00\x00\x00\x00\x09\x88\x62\x00\x00\x00\x00\x00\x00\x00\x09\x08\x01\xFF\x0A\x01\x00\x00\x09\x00\x45\x91\x0A\x87\x2F\xA5\xF9\x2E"
         } err
@@ -145,21 +161,25 @@ test {corrupt payload: listpack invalid size header} {
 
 test {corrupt payload: listpack too long entry len} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         r restore key 0 "\x0F\x01\x10\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x40\x55\x55\x00\x00\x00\x0F\x00\x01\x01\x00\x01\x02\x01\x88\x31\x00\x00\x00\x00\x00\x00\x00\x09\x88\x32\x00\x00\x00\x00\x00\x00\x00\x09\x00\x01\x00\x01\x00\x01\x00\x01\x02\x02\x89\x31\x00\x00\x00\x00\x00\x00\x00\x09\x88\x61\x00\x00\x00\x00\x00\x00\x00\x09\x88\x32\x00\x00\x00\x00\x00\x00\x00\x09\x88\x62\x00\x00\x00\x00\x00\x00\x00\x09\x08\x01\xFF\x0A\x01\x00\x00\x09\x00\x40\x63\xC9\x37\x03\xA2\xE5\x68"
         catch {
             r xinfo stream key full
         } err
-        verify_log_message 0 "*ASSERTION FAILED*" 0
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
     }
 }
 
 test {corrupt payload: listpack very long entry len} {
     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
         r restore key 0 "\x0F\x01\x10\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x02\x40\x55\x55\x00\x00\x00\x0F\x00\x01\x01\x00\x01\x02\x01\x88\x31\x00\x00\x00\x00\x00\x00\x00\x09\x88\x32\x00\x00\x00\x00\x00\x00\x00\x09\x00\x01\x00\x01\x00\x01\x00\x01\x02\x02\x88\x31\x00\x00\x00\x00\x00\x00\x00\x09\x88\x61\x00\x00\x00\x00\x00\x00\x00\x09\x88\x32\x00\x00\x00\x00\x00\x00\x00\x09\x9C\x62\x00\x00\x00\x00\x00\x00\x00\x09\x08\x01\xFF\x0A\x01\x00\x00\x09\x00\x63\x6F\x42\x8E\x7C\xB5\xA2\x9D"
         catch {
             r xinfo stream key full
         } err
-        verify_log_message 0 "*ASSERTION FAILED*" 0
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
     }
 }
 
@@ -174,5 +194,247 @@ test {corrupt payload: listpack too long entry prev len} {
     }
 }
 
+test {corrupt payload: fuzzer findings - NPD in streamIteratorGetID} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch {
+            r RESTORE key 0 "\x0F\x01\x10\x00\x00\x01\x73\xBD\x68\x48\x71\x00\x00\x00\x00\x00\x00\x00\x00\x40\x42\x42\x00\x00\x00\x18\x00\x03\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x00\x01\x02\x01\x00\x01\x00\x01\x01\x01\x00\x01\x05\x01\x02\x01\x00\x01\x01\x01\x01\x01\x82\x5F\x31\x03\x05\x01\x02\x01\x00\x01\x02\x01\x01\x01\x02\x01\x48\x01\xFF\x03\x81\x00\x00\x01\x73\xBD\x68\x48\x71\x02\x01\x07\x6D\x79\x67\x72\x6F\x75\x70\x81\x00\x00\x01\x73\xBD\x68\x48\x71\x00\x01\x00\x00\x01\x73\xBD\x68\x48\x71\x00\x00\x00\x00\x00\x00\x00\x00\x72\x48\x68\xBD\x73\x01\x00\x00\x01\x01\x05\x41\x6C\x69\x63\x65\x72\x48\x68\xBD\x73\x01\x00\x00\x01\x00\x00\x01\x73\xBD\x68\x48\x71\x00\x00\x00\x00\x00\x00\x00\x00\x09\x00\x80\xCD\xB0\xD5\x1A\xCE\xFF\x10"
+            r XREVRANGE key 725 233
+        }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - listpack NPD on invalid stream} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch {
+            r RESTORE _stream 0 "\x0F\x01\x10\x00\x00\x01\x73\xDC\xB6\x6B\xF1\x00\x00\x00\x00\x00\x00\x00\x00\x40\x42\x42\x00\x00\x00\x18\x00\x03\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x00\x01\x02\x01\x00\x01\x00\x01\x01\x01\x00\x01\x05\x01\x02\x01\x1F\x01\x00\x01\x01\x01\x6D\x5F\x31\x03\x05\x01\x02\x01\x29\x01\x00\x01\x01\x01\x02\x01\x05\x01\xFF\x03\x81\x00\x00\x01\x73\xDC\xB6\x6C\x1A\x00\x01\x07\x6D\x79\x67\x72\x6F\x75\x70\x81\x00\x00\x01\x73\xDC\xB6\x6B\xF1\x00\x01\x00\x00\x01\x73\xDC\xB6\x6B\xF1\x00\x00\x00\x00\x00\x00\x00\x00\x4B\x6C\xB6\xDC\x73\x01\x00\x00\x01\x01\x05\x41\x6C\x69\x63\x65\x3D\x6C\xB6\xDC\x73\x01\x00\x00\x01\x00\x00\x01\x73\xDC\xB6\x6B\xF1\x00\x00\x00\x00\x00\x00\x00\x00\x09\x00\xC7\x7D\x1C\xD7\x04\xFF\xE6\x9D"
+            r XREAD STREAMS _stream 519389898758
+        }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - NPD in quicklistIndex} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch {
+            r RESTORE key 0 "\x0E\x01\x13\x13\x00\x00\x00\x10\x00\x00\x00\x03\x12\x00\xF3\x02\x02\x5F\x31\x04\xF1\xFF\x09\x00\xC9\x4B\x31\xFE\x61\xC0\x96\xFE"
+            r LSET key 290 290
+        }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - invalid read in ziplistFind} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch {
+            r RESTORE key 0 "\x0D\x19\x19\x00\x00\x00\x16\x00\x00\x00\x06\x00\x00\xF1\x02\xF1\x02\xF2\x02\x02\x5F\x31\x04\x99\x02\xF3\xFF\x09\x00\xC5\xB8\x10\xC0\x8A\xF9\x16\xDF"
+            r HEXISTS key -688319650333
+        }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+
+test {corrupt payload: fuzzer findings - invalid ziplist encoding} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload yes
+        r debug set-skip-checksum-validation 1
+        catch {
+            r RESTORE _listbig 0 "\x0E\x02\x1B\x1B\x00\x00\x00\x16\x00\x00\x00\x05\x00\x00\x02\x5F\x39\x04\xF9\x02\x86\x5F\x37\x04\xF7\x02\x02\x5F\x35\xFF\x19\x19\x00\x00\x00\x16\x00\x00\x00\x05\x00\x00\xF5\x02\x02\x5F\x33\x04\xF3\x02\x02\x5F\x31\x04\xF1\xFF\x09\x00\x0C\xFC\x99\x2C\x23\x45\x15\x60"
+        } err
+        assert_match "*Bad data format*" $err
+        verify_log_message 0 "*Ziplist integrity check failed*" 0
+    }
+}
+
+test {corrupt payload: fuzzer findings - hash crash} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload yes
+        r debug set-skip-checksum-validation 1
+        r RESTORE _hash 0 "\x0D\x19\x19\x00\x00\x00\x16\x00\x00\x00\x06\x00\x00\xF1\x02\xF1\x02\xF2\x02\x02\x5F\x31\x04\xF3\x02\xF3\xFF\x09\x00\x38\xB8\x10\xC0\x8A\xF9\x16\xDF"
+        r HSET _hash 394891450 1635910264
+        r HMGET _hash 887312884855
+    }
+}
+
+test {corrupt payload: fuzzer findings - uneven entry count in hash} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _hashbig 0 "\x0D\x3D\x3D\x00\x00\x00\x38\x00\x00\x00\x14\x00\x00\xF2\x02\x02\x5F\x31\x04\x1C\x02\xF7\x02\xF1\x02\xF1\x02\xF5\x02\xF5\x02\xF4\x02\x02\x5F\x33\x04\xF6\x02\x02\x5F\x35\x04\xF8\x02\x02\x5F\x37\x04\xF9\x02\xF9\x02\xF3\x02\xF3\x02\xFA\x02\x02\x5F\x39\xFF\x09\x00\x73\xB7\x68\xC8\x97\x24\x8E\x88"
+        catch { r HSCAN _hashbig -250 }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - invalid read in lzf_decompress} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch { r RESTORE _setbig 0 "\x02\x03\x02\x5F\x31\xC0\x02\xC3\x00\x09\x00\xE6\xDC\x76\x44\xFF\xEB\x3D\xFE" } err
+        assert_match "*Bad data format*" $err
+    }
+}
+
+test {corrupt payload: fuzzer findings - leak in rdbloading due to dup entry in set} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch { r RESTORE _setbig 0 "\x02\x0A\x02\x5F\x39\xC0\x06\x02\x5F\x31\xC0\x00\xC0\x04\x02\x5F\x35\xC0\x02\xC0\x08\x02\x5F\x31\x02\x5F\x33\x09\x00\x7A\x5A\xFB\x90\x3A\xE9\x3C\xBE" } err
+        assert_match "*Bad data format*" $err
+    }
+}
+
+test {corrupt payload: fuzzer findings - empty intset div by zero} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _setbig 0 "\x02\xC0\xC0\x06\x02\x5F\x39\xC0\x02\x02\x5F\x33\xC0\x00\x02\x5F\x31\xC0\x04\xC0\x08\x02\x5F\x37\x02\x5F\x35\x09\x00\xC5\xD4\x6D\xBA\xAD\x14\xB7\xE7"
+        catch {r SRANDMEMBER _setbig }
+    }
+}
+
+test {corrupt payload: fuzzer findings - valgrind ziplist - crash report prints freed memory} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _zsetbig 0 "\x0C\x3D\x3D\x00\x00\x00\x3A\x00\x00\x00\x14\x00\x00\xF1\x02\xF1\x02\x02\x5F\x31\x04\xF2\x02\xF3\x02\xF3\x02\x02\x5F\x33\x04\xF4\x02\xEE\x02\xF5\x02\x02\x5F\x35\x04\xF6\x02\xF7\x02\xF7\x02\x02\x5F\x37\x04\xF8\x02\xF9\x02\xF9\x02\x02\x5F\x39\x04\xFA\xFF\x09\x00\xAE\xF9\x77\x2A\x47\x24\x33\xF6"
+        catch { r ZREMRANGEBYSCORE _zsetbig -1050966020 724 }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - valgrind ziplist prevlen reaches outside the ziplist} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _listbig 0 "\x0E\x02\x1B\x1B\x00\x00\x00\x16\x00\x00\x00\x05\x00\x00\x02\x5F\x39\x04\xF9\x02\x02\x5F\x37\x04\xF7\x02\x02\x5F\x35\xFF\x19\x19\x00\x00\x00\x16\x00\x00\x00\x05\x00\x00\xF5\x02\x02\x5F\x33\x04\xF3\x95\x02\x5F\x31\x04\xF1\xFF\x09\x00\x0C\xFC\x99\x2C\x23\x45\x15\x60"
+        catch { r RPOP _listbig }
+        catch { r RPOP _listbig }
+        catch { r RPUSH _listbig 949682325 }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - valgrind - bad rdbLoadDoubleValue} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch { r RESTORE _list 0 "\x03\x01\x11\x11\x00\x00\x00\x0A\x00\x00\x00\x01\x00\x00\xD0\x07\x1A\xE9\x02\xFF\x09\x00\x1A\x06\x07\x32\x41\x28\x3A\x46" } err
+        assert_match "*Bad data format*" $err
+    }
+}
+
+test {corrupt payload: fuzzer findings - valgrind ziplist prev too big} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _list 0 "\x0E\x01\x13\x13\x00\x00\x00\x10\x00\x00\x00\x03\x00\x00\xF3\x02\x02\x5F\x31\xC1\xF1\xFF\x09\x00\xC9\x4B\x31\xFE\x61\xC0\x96\xFE"
+        catch { r RPUSHX _list -45 }
+        catch { r LREM _list -748 -840}
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - lzf decompression fails, avoid valgrind invalid read} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        catch {r RESTORE _stream 0 "\x0F\x02\x10\x00\x00\x01\x73\xDD\xAA\x2A\xB9\x00\x00\x00\x00\x00\x00\x00\x00\xC3\x40\x4B\x40\x5C\x18\x5C\x00\x00\x00\x24\x00\x05\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x00\x01\x20\x03\x00\x05\x20\x1C\x40\x07\x05\x01\x01\x82\x5F\x31\x03\x80\x0D\x40\x00\x00\x02\x60\x19\x40\x27\x40\x19\x00\x33\x60\x19\x40\x29\x02\x01\x01\x04\x20\x19\x00\xFF\x10\x00\x00\x01\x73\xDD\xAA\x2A\xBC\x00\x00\x00\x00\x00\x00\x00\x00\xC3\x40\x4D\x40\x5E\x18\x5E\x00\x00\x00\x24\x00\x05\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x06\x01\x01\x82\x5F\x35\x03\x05\x20\x1E\x17\x0B\x03\x01\x01\x06\x01\x40\x0B\x00\x01\x60\x0D\x02\x82\x5F\x37\x60\x19\x80\x00\x00\x08\x60\x19\x80\x27\x02\x82\x5F\x39\x20\x19\x00\xFF\x0A\x81\x00\x00\x01\x73\xDD\xAA\x2A\xBE\x00\x00\x09\x00\x21\x85\x77\x43\x71\x7B\x17\x88"} err
+        assert_match "*Bad data format*" $err
+    }
+}
+
+test {corrupt payload: fuzzer findings - stream bad lp_count} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload yes
+        r debug set-skip-checksum-validation 1
+        catch { r RESTORE _stream 0 "\x0F\x01\x10\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x00\x00\x00\x00\x00\x00\x00\x40\x42\x42\x00\x00\x00\x18\x00\x03\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x00\x01\x02\x01\x00\x01\x00\x01\x01\x01\x00\x01\x56\x01\x02\x01\x22\x01\x00\x01\x01\x01\x82\x5F\x31\x03\x05\x01\x02\x01\x2C\x01\x00\x01\x01\x01\x02\x01\x05\x01\xFF\x03\x81\x00\x00\x01\x73\xDE\xDF\x7D\xC7\x00\x01\x07\x6D\x79\x67\x72\x6F\x75\x70\x81\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x01\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x00\x00\x00\x00\x00\x00\x00\xF9\x7D\xDF\xDE\x73\x01\x00\x00\x01\x01\x05\x41\x6C\x69\x63\x65\xEB\x7D\xDF\xDE\x73\x01\x00\x00\x01\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x00\x00\x00\x00\x00\x00\x00\x09\x00\xB2\xA8\xA7\x5F\x1B\x61\x72\xD5"} err
+        assert_match "*Bad data format*" $err
+        r ping
+    }
+}
+
+test {corrupt payload: fuzzer findings - stream bad lp_count - unsanitized} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _stream 0 "\x0F\x01\x10\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x00\x00\x00\x00\x00\x00\x00\x40\x42\x42\x00\x00\x00\x18\x00\x03\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x00\x01\x02\x01\x00\x01\x00\x01\x01\x01\x00\x01\x56\x01\x02\x01\x22\x01\x00\x01\x01\x01\x82\x5F\x31\x03\x05\x01\x02\x01\x2C\x01\x00\x01\x01\x01\x02\x01\x05\x01\xFF\x03\x81\x00\x00\x01\x73\xDE\xDF\x7D\xC7\x00\x01\x07\x6D\x79\x67\x72\x6F\x75\x70\x81\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x01\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x00\x00\x00\x00\x00\x00\x00\xF9\x7D\xDF\xDE\x73\x01\x00\x00\x01\x01\x05\x41\x6C\x69\x63\x65\xEB\x7D\xDF\xDE\x73\x01\x00\x00\x01\x00\x00\x01\x73\xDE\xDF\x7D\x9B\x00\x00\x00\x00\x00\x00\x00\x00\x09\x00\xB2\xA8\xA7\x5F\x1B\x61\x72\xD5"
+        catch { r XREVRANGE _stream 638932639 738}
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - stream integrity check issue} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload yes
+        r debug set-skip-checksum-validation 1
+        catch { r RESTORE _stream 0 "\x0F\x02\x10\x00\x00\x01\x75\x2D\xA2\x90\x67\x00\x00\x00\x00\x00\x00\x00\x00\xC3\x40\x4F\x40\x5C\x18\x5C\x00\x00\x00\x24\x00\x05\x01\x00\x01\x4A\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x00\x01\x20\x03\x00\x05\x20\x1C\x40\x09\x05\x01\x01\x82\x5F\x31\x03\x80\x0D\x00\x02\x20\x0D\x00\x02\xA0\x19\x00\x03\x20\x0B\x02\x82\x5F\x33\xA0\x19\x00\x04\x20\x0D\x00\x04\x20\x19\x00\xFF\x10\x00\x00\x01\x75\x2D\xA2\x90\x67\x00\x00\x00\x00\x00\x00\x00\x05\xC3\x40\x56\x40\x60\x18\x60\x00\x00\x00\x24\x00\x05\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x40\x10\x00\x00\x20\x01\x06\x01\x01\x82\x5F\x35\x03\x05\x20\x1E\x40\x0B\x03\x01\x01\x06\x01\x80\x0B\x00\x02\x20\x0B\x02\x82\x5F\x37\x60\x19\x03\x01\x01\xDF\xFB\x20\x05\x00\x08\x60\x1A\x20\x0C\x00\xFC\x20\x05\x02\x82\x5F\x39\x20\x1B\x00\xFF\x0A\x81\x00\x00\x01\x75\x2D\xA2\x90\x68\x01\x00\x09\x00\x1D\x6F\xC0\x69\x8A\xDE\xF7\x92" } err
+        assert_match "*Bad data format*" $err
+    }
+}
+
+test {corrupt payload: fuzzer findings - infinite loop} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _stream 0 "\x0F\x01\x10\x00\x00\x01\x75\x3A\xA6\xD0\x93\x00\x00\x00\x00\x00\x00\x00\x00\x40\x42\x42\x00\x00\x00\x18\x00\x03\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x00\x01\x02\x01\x00\x01\x00\x01\x01\x01\x00\x01\x05\x01\x02\x01\x00\x01\x01\x01\x01\x01\x82\x5F\x31\x03\xFD\x01\x02\x01\x00\x01\x02\x01\x01\x01\x02\x01\x05\x01\xFF\x03\x81\x00\x00\x01\x75\x3A\xA6\xD0\x93\x02\x01\x07\x6D\x79\x67\x72\x6F\x75\x70\x81\x00\x00\x01\x75\x3A\xA6\xD0\x93\x00\x01\x00\x00\x01\x75\x3A\xA6\xD0\x93\x00\x00\x00\x00\x00\x00\x00\x00\x94\xD0\xA6\x3A\x75\x01\x00\x00\x01\x01\x05\x41\x6C\x69\x63\x65\x94\xD0\xA6\x3A\x75\x01\x00\x00\x01\x00\x00\x01\x75\x3A\xA6\xD0\x93\x00\x00\x00\x00\x00\x00\x00\x00\x09\x00\xC4\x09\xAD\x69\x7E\xEE\xA6\x2F"
+        catch { r XREVRANGE _stream 288270516 971031845 }
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - invalid tail offset after removal} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _zset 0 "\x0C\x19\x19\x00\x00\x00\x02\x00\x00\x00\x06\x00\x00\xF1\x02\xF1\x02\x02\x5F\x31\x04\xF2\x02\xF3\x02\xF3\xFF\x09\x00\x4D\x72\x7B\x97\xCD\x9A\x70\xC1"
+        catch {r ZPOPMIN _zset}
+        catch {r ZPOPMAX _zset}
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - negative reply length} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload no
+        r debug set-skip-checksum-validation 1
+        r RESTORE _stream 0 "\x0F\x01\x10\x00\x00\x01\x75\xCF\xA1\x16\xA7\x00\x00\x00\x00\x00\x00\x00\x00\x40\x42\x42\x00\x00\x00\x18\x00\x03\x01\x00\x01\x02\x01\x84\x69\x74\x65\x6D\x05\x85\x76\x61\x6C\x75\x65\x06\x00\x01\x02\x01\x00\x01\x00\x01\x01\x01\x00\x01\x05\x01\x02\x01\x00\x01\x01\x01\x01\x01\x14\x5F\x31\x03\x05\x01\x02\x01\x00\x01\x02\x01\x01\x01\x02\x01\x05\x01\xFF\x03\x81\x00\x00\x01\x75\xCF\xA1\x16\xA7\x02\x01\x07\x6D\x79\x67\x72\x6F\x75\x70\x81\x00\x00\x01\x75\xCF\xA1\x16\xA7\x01\x01\x00\x00\x01\x75\xCF\xA1\x16\xA7\x00\x00\x00\x00\x00\x00\x00\x01\xA7\x16\xA1\xCF\x75\x01\x00\x00\x01\x01\x05\x41\x6C\x69\x63\x65\xA7\x16\xA1\xCF\x75\x01\x00\x00\x01\x00\x00\x01\x75\xCF\xA1\x16\xA7\x00\x00\x00\x00\x00\x00\x00\x01\x09\x00\x1B\x42\x52\xB8\xDD\x5C\xE5\x4E"
+        catch {r XADD _stream * -956 -2601503852}
+        catch {r XINFO STREAM _stream FULL}
+        assert_equal [count_log_message 0 "crashed by signal"] 0
+        assert_equal [count_log_message 0 "ASSERTION FAILED"] 1
+    }
+}
+
+test {corrupt payload: fuzzer findings - valgrind negative malloc} {
+    start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {
+        r config set sanitize-dump-payload yes
+        r debug set-skip-checksum-validation 1
+        catch {r RESTORE _key 0 "\x0E\x01\x81\xD6\xD6\x00\x00\x00\x0A\x00\x00\x00\x01\x00\x00\x40\xC8\x6F\x2F\x36\xE2\xDF\xE3\x2E\x26\x64\x8B\x87\xD1\x7A\xBD\xFF\xEF\xEF\x63\x65\xF6\xF8\x8C\x4E\xEC\x96\x89\x56\x88\xF8\x3D\x96\x5A\x32\xBD\xD1\x36\xD8\x02\xE6\x66\x37\xCB\x34\x34\xC4\x52\xA7\x2A\xD5\x6F\x2F\x7E\xEE\xA2\x94\xD9\xEB\xA9\x09\x38\x3B\xE1\xA9\x60\xB6\x4E\x09\x44\x1F\x70\x24\xAA\x47\xA8\x6E\x30\xE1\x13\x49\x4E\xA1\x92\xC4\x6C\xF0\x35\x83\xD9\x4F\xD9\x9C\x0A\x0D\x7A\xE7\xB1\x61\xF5\xC1\x2D\xDC\xC3\x0E\x87\xA6\x80\x15\x18\xBA\x7F\x72\xDD\x14\x75\x46\x44\x0B\xCA\x9C\x8F\x1C\x3C\xD7\xDA\x06\x62\x18\x7E\x15\x17\x24\xAB\x45\x21\x27\xC2\xBC\xBB\x86\x6E\xD8\xBD\x8E\x50\xE0\xE0\x88\xA4\x9B\x9D\x15\x2A\x98\xFF\x5E\x78\x6C\x81\xFC\xA8\xC9\xC8\xE6\x61\xC8\xD1\x4A\x7F\x81\xD6\xA6\x1A\xAD\x4C\xC1\xA2\x1C\x90\x68\x15\x2A\x8A\x36\xC0\x58\xC3\xCC\xA6\x54\x19\x12\x0F\xEB\x46\xFF\x6E\xE3\xA7\x92\xF8\xFF\x09\x00\xD0\x71\xF7\x9F\xF7\x6A\xD6\x2E"} err
+        assert_match "*Bad data format*" $err
+        r ping
+    }
+}
+
 } ;# tags
 
diff --git a/tests/integration/psync2.tcl b/tests/integration/psync2.tcl
index 1b996ffd4..8f8db5a92 100644
--- a/tests/integration/psync2.tcl
+++ b/tests/integration/psync2.tcl
@@ -280,7 +280,7 @@ start_server {} {
         set sync_partial_err [status $R($master_id) sync_partial_err]
         catch {
             $R($slave_id) config rewrite
-            restart_server [expr {0-$slave_id}] true
+            restart_server [expr {0-$slave_id}] true false
             set R($slave_id) [srv [expr {0-$slave_id}] client]
         }
         # note: just waiting for connected_slaves==4 has a race condition since
@@ -329,7 +329,7 @@ start_server {} {
 
         catch {
             $R($slave_id) config rewrite
-            restart_server [expr {0-$slave_id}] true
+            restart_server [expr {0-$slave_id}] true false
             set R($slave_id) [srv [expr {0-$slave_id}] client]
         }
 
diff --git a/tests/integration/rdb.tcl b/tests/integration/rdb.tcl
index d29f9d88e..aadfe281f 100644
--- a/tests/integration/rdb.tcl
+++ b/tests/integration/rdb.tcl
@@ -164,7 +164,7 @@ test {client freed during loading} {
         # 100mb of rdb, 100k keys will load in more than 1 second
         r debug populate 100000 key 1000
 
-        restart_server 0 false
+        restart_server 0 false false
 
         # make sure it's still loading
         assert_equal [s loading] 1
diff --git a/tests/support/server.tcl b/tests/support/server.tcl
index ae93ad007..e5b167a35 100644
--- a/tests/support/server.tcl
+++ b/tests/support/server.tcl
@@ -13,7 +13,7 @@ proc start_server_error {config_file error} {
 }
 
 proc check_valgrind_errors stderr {
-    set res [find_valgrind_errors $stderr]
+    set res [find_valgrind_errors $stderr true]
     if {$res != ""} {
         send_data_packet $::test_server_fd err "Valgrind error: $res\n"
     }
@@ -437,7 +437,7 @@ proc start_server {options {code undefined}} {
 
         while 1 {
             # check that the server actually started and is ready for connections
-            if {[exec grep -i "Ready to accept" | wc -l < $stdout] > 0} {
+            if {[count_message_lines $stdout "Ready to accept"] > 0} {
                 break
             }
             after 10
@@ -511,13 +511,19 @@ proc start_server {options {code undefined}} {
     }
 }
 
-proc restart_server {level wait_ready} {
+proc restart_server {level wait_ready rotate_logs} {
     set srv [lindex $::servers end+$level]
     kill_server $srv
 
+    set pid [dict get $srv "pid"]
     set stdout [dict get $srv "stdout"]
     set stderr [dict get $srv "stderr"]
-    set config_file [dict get $srv "config_file"]
+    if {$rotate_logs} {
+        set ts [clock format [clock seconds] -format %y%m%d%H%M%S]
+        file rename $stdout $stdout.$ts.$pid
+        file rename $stderr $stderr.$ts.$pid
+    }
+    set prev_ready_count [count_message_lines $stdout "Ready to accept"]
 
     # if we're inside a test, write the test name to the server log file
     if {[info exists ::cur_test]} {
@@ -526,7 +532,7 @@ proc restart_server {level wait_ready} {
         close $fd
     }
 
-    set prev_ready_count [exec grep -i "Ready to accept" | wc -l < $stdout]
+    set config_file [dict get $srv "config_file"]
 
     set pid [spawn_server $config_file $stdout $stderr]
 
@@ -541,7 +547,7 @@ proc restart_server {level wait_ready} {
     if {$wait_ready} {
         while 1 {
             # check that the server actually started and is ready for connections
-            if {[exec grep -i "Ready to accept" | wc -l < $stdout] > $prev_ready_count + 1} {
+            if {[count_message_lines $stdout "Ready to accept"] > $prev_ready_count} {
                 break
             }
             after 10
diff --git a/tests/support/util.tcl b/tests/support/util.tcl
index aadec7cd1..040a7f7d9 100644
--- a/tests/support/util.tcl
+++ b/tests/support/util.tcl
@@ -454,22 +454,31 @@ proc colorstr {color str} {
     }
 }
 
-proc find_valgrind_errors {stderr} {
+proc find_valgrind_errors {stderr on_termination} {
     set fd [open $stderr]
     set buf [read $fd]
     close $fd
 
     # Look for stack trace (" at 0x") and other errors (Invalid, Mismatched, etc).
     # Look for "Warnings", but not the "set address range perms". These don't indicate any real concern.
-    # Look for the absense of a leak free summary (happens when redis isn't terminated properly).
+    # corrupt-dump unit, not sure why but it seems they don't indicate any real concern.
     if {[regexp -- { at 0x} $buf] ||
         [regexp -- {^(?=.*Warning)(?:(?!set address range perms).)*$} $buf] ||
         [regexp -- {Invalid} $buf] ||
         [regexp -- {Mismatched} $buf] ||
         [regexp -- {uninitialized} $buf] ||
         [regexp -- {has a fishy} $buf] ||
-        [regexp -- {overlap} $buf] ||
-        (![regexp -- {definitely lost: 0 bytes} $buf] &&
+        [regexp -- {overlap} $buf]} {
+        return $buf
+    }
+
+    # If the process didn't terminate yet, we can't look for the summary report
+    if {!$on_termination} {
+        return ""
+    }
+
+    # Look for the absense of a leak free summary (happens when redis isn't terminated properly).
+    if {(![regexp -- {definitely lost: 0 bytes} $buf] &&
          ![regexp -- {no leaks are possible} $buf])} {
         return $buf
     }
@@ -547,3 +556,116 @@ proc cmdrstat {cmd r} {
         set _ $value
     }
 }
+
+proc generate_fuzzy_traffic_on_key {key duration} {
+    # Commands per type, blocking commands removed
+    # TODO: extract these from help.h or elsewhere, and improve to include other types
+    set string_commands {APPEND BITCOUNT BITFIELD BITOP BITPOS DECR DECRBY GET GETBIT GETRANGE GETSET INCR INCRBY INCRBYFLOAT MGET MSET MSETNX PSETEX SET SETBIT SETEX SETNX SETRANGE STRALGO STRLEN}
+    set hash_commands {HDEL HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSCAN HSET HSETNX HSTRLEN HVALS}
+    set zset_commands {ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZLEXCOUNT ZPOPMAX ZPOPMIN ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANK ZREM ZREMRANGEBYLEX ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGE ZREVRANGEBYLEX ZREVRANGEBYSCORE ZREVRANK ZSCAN ZSCORE ZUNIONSTORE}
+    set list_commands {LINDEX LINSERT LLEN LPOP LPOS LPUSH LPUSHX LRANGE LREM LSET LTRIM RPOP RPOPLPUSH RPUSH RPUSHX}
+    set set_commands {SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE}
+    set stream_commands {XACK XADD XCLAIM XDEL XGROUP XINFO XLEN XPENDING XRANGE XREAD XREADGROUP XREVRANGE XTRIM}
+    set commands [dict create string $string_commands hash $hash_commands zset $zset_commands list $list_commands set $set_commands stream $stream_commands]
+
+    set type [r type $key]
+    set cmds [dict get $commands $type]
+    set start_time [clock seconds]
+    set sent {}
+    set succeeded 0
+    while {([clock seconds]-$start_time) < $duration} {
+        # find a random command for our key type
+        set cmd_idx [expr {int(rand()*[llength $cmds])}]
+        set cmd [lindex $cmds $cmd_idx]
+        # get the command details from redis
+        if { [ catch {
+            set cmd_info [lindex [r command info $cmd] 0]
+        } err ] } {
+            # if we failed, it means redis crashed after the previous command
+            return $sent
+        }
+        # try to build a valid command argument
+        set arity [lindex $cmd_info 1]
+        set arity [expr $arity < 0 ? - $arity: $arity]
+        set firstkey [lindex $cmd_info 3]
+        set i 1
+        if {$cmd == "XINFO"} {
+            lappend cmd "STREAM"
+            lappend cmd $key
+            lappend cmd "FULL"
+            incr i 3
+        }
+        if {$cmd == "XREAD"} {
+            lappend cmd "STREAMS"
+            lappend cmd $key
+            randpath {
+                lappend cmd \$
+            } {
+                lappend cmd [randomValue]
+            }
+            incr i 3
+        }
+        if {$cmd == "XADD"} {
+            lappend cmd $key
+            randpath {
+                lappend cmd "*"
+            } {
+                lappend cmd [randomValue]
+            }
+            lappend cmd [randomValue]
+            lappend cmd [randomValue]
+            incr i 4
+        }
+        for {} {$i < $arity} {incr i} {
+            if {$i == $firstkey} {
+                lappend cmd $key
+            } else {
+                lappend cmd [randomValue]
+            }
+        }
+        # execute the command, we expect commands to fail on syntax errors
+        lappend sent $cmd
+        if { ! [ catch {
+            r {*}$cmd
+        } err ] } {
+            incr succeeded
+        }
+    }
+
+    # print stats so that we know if we managed to generate commands that actually made senes
+    #if {$::verbose} {
+    #    set count [llength $sent]
+    #    puts "Fuzzy traffic sent: $count, succeeded: $succeeded"
+    #}
+
+    # return the list of commands we sent
+    return $sent
+}
+
+# write line to server log file
+proc write_log_line {srv_idx msg} {
+    set logfile [srv $srv_idx stdout]
+    set fd [open $logfile "a+"]
+    puts $fd "### $msg"
+    close $fd
+}
+
+proc string2printable s {
+    set res {}
+    set has_special_chars false
+    foreach i [split $s {}] {
+        scan $i %c int
+        # non printable characters, including space and excluding: " \ $ { }
+        if {$int < 32 || $int > 122 || $int == 34 || $int == 36 || $int == 92} {
+            set has_special_chars true
+        }
+        # TCL8.5 has issues mixing \x notation and normal chars in the same
+        # source code string, so we'll convert the entire string.
+        append res \\x[format %02X $int]
+    }
+    if {!$has_special_chars} {
+        return $s
+    }
+    set res "\"$res\""
+    return $res
+}
diff --git a/tests/test_helper.tcl b/tests/test_helper.tcl
index 998e82bd9..a1fae8d75 100644
--- a/tests/test_helper.tcl
+++ b/tests/test_helper.tcl
@@ -45,6 +45,7 @@ set ::all_tests {
     integration/aof
     integration/rdb
     integration/corrupt-dump
+    integration/corrupt-dump-fuzzer
     integration/convert-zipmap-hash-on-load
     integration/logging
     integration/psync2
diff --git a/tests/unit/introspection.tcl b/tests/unit/introspection.tcl
index 2d50b417b..86da17657 100644
--- a/tests/unit/introspection.tcl
+++ b/tests/unit/introspection.tcl
@@ -160,7 +160,7 @@ start_server {tags {"introspection"}} {
         # Rewrite entire configuration, restart and confirm the
         # server is able to parse it and start.
         assert_equal [r debug config-rewrite-force-all] "OK"
-        restart_server 0 0
+        restart_server 0 false false
         assert_equal [r ping] "PONG"
 
         # Verify no changes were introduced

[ML] commit 9812e88959a37ed4aa95bb4d3fb55c56dc49a768
Author: Oran Agra <oran@redislabs.com>
Date:   Mon Nov 16 16:37:15 2020 +0200

    Fix memory leaks in newly added ZDIFF (#8056)

diff --git a/src/t_zset.c b/src/t_zset.c
index 858085a05..5b848a1b9 100644
--- a/src/t_zset.c
+++ b/src/t_zset.c
@@ -2267,6 +2267,7 @@ static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *
             if (sdslen(tmp) > *maxelelen) *maxelelen = sdslen(tmp);
         }
     }
+    zuiClearIterator(&src[0]);
 }
 
 
@@ -2304,7 +2305,7 @@ static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *
                 dictAdd(dstzset->dict,tmp,&znode->score);
                 cardinality++;
             } else {
-                tmp = zuiNewSdsFromValue(&zval);
+                tmp = zuiSdsFromValue(&zval);
                 if (zsetRemoveFromSkiplist(dstzset, tmp)) {
                     cardinality--;
                 }
@@ -2314,6 +2315,7 @@ static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *
                 * of elements will have no effect. */
             if (cardinality == 0) break;
         }
+        zuiClearIterator(&src[j]);
 
         if (cardinality == 0) break;
     }

[ML] commit 434270374344bbdfa36545a93868b7920e4f47ce
Author: Wen Hui <wen.hui.ware@gmail.com>
Date:   Wed Oct 28 06:35:28 2020 -0400

    refactor aof rewrite code to avoid memory leaks in error handling (#7976)

diff --git a/src/aof.c b/src/aof.c
index 5c46c76f6..b9072da93 100644
--- a/src/aof.c
+++ b/src/aof.c
@@ -961,15 +961,25 @@ int rewriteListObject(rio *r, robj *key, robj *o) {
             if (count == 0) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
-                if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
-                if (rioWriteBulkString(r,"RPUSH",5) == 0) return 0;
-                if (rioWriteBulkObject(r,key) == 0) return 0;
+                if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
+                    !rioWriteBulkString(r,"RPUSH",5) ||
+                    !rioWriteBulkObject(r,key)) 
+                {
+                    quicklistReleaseIterator(li);
+                    return 0;
+                }
             }
 
             if (entry.value) {
-                if (rioWriteBulkString(r,(char*)entry.value,entry.sz) == 0) return 0;
+                if (!rioWriteBulkString(r,(char*)entry.value,entry.sz)) {
+                    quicklistReleaseIterator(li);
+                    return 0;
+                }
             } else {
-                if (rioWriteBulkLongLong(r,entry.longval) == 0) return 0;
+                if (!rioWriteBulkLongLong(r,entry.longval)) {
+                    quicklistReleaseIterator(li);
+                    return 0;
+                }
             }
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
@@ -995,11 +1005,14 @@ int rewriteSetObject(rio *r, robj *key, robj *o) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
 
-                if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
-                if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
-                if (rioWriteBulkObject(r,key) == 0) return 0;
+                if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
+                    !rioWriteBulkString(r,"SADD",4) ||
+                    !rioWriteBulkObject(r,key)) 
+                {
+                    return 0;
+                }
             }
-            if (rioWriteBulkLongLong(r,llval) == 0) return 0;
+            if (!rioWriteBulkLongLong(r,llval)) return 0;
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
@@ -1013,11 +1026,18 @@ int rewriteSetObject(rio *r, robj *key, robj *o) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
 
-                if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
-                if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
-                if (rioWriteBulkObject(r,key) == 0) return 0;
+                if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
+                    !rioWriteBulkString(r,"SADD",4) ||
+                    !rioWriteBulkObject(r,key)) 
+                {
+                    dictReleaseIterator(di);
+                    return 0;
+                }
+            }
+            if (!rioWriteBulkString(r,ele,sdslen(ele))) {
+                dictReleaseIterator(di);
+                return 0;          
             }
-            if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
@@ -1054,15 +1074,18 @@ int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
 
-                if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
-                if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
-                if (rioWriteBulkObject(r,key) == 0) return 0;
+                if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
+                    !rioWriteBulkString(r,"ZADD",4) ||
+                    !rioWriteBulkObject(r,key)) 
+                {
+                    return 0;
+                }
             }
-            if (rioWriteBulkDouble(r,score) == 0) return 0;
+            if (!rioWriteBulkDouble(r,score)) return 0;
             if (vstr != NULL) {
-                if (rioWriteBulkString(r,(char*)vstr,vlen) == 0) return 0;
+                if (!rioWriteBulkString(r,(char*)vstr,vlen)) return 0;
             } else {
-                if (rioWriteBulkLongLong(r,vll) == 0) return 0;
+                if (!rioWriteBulkLongLong(r,vll)) return 0;
             }
             zzlNext(zl,&eptr,&sptr);
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
@@ -1081,12 +1104,20 @@ int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
 
-                if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
-                if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
-                if (rioWriteBulkObject(r,key) == 0) return 0;
+                if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
+                    !rioWriteBulkString(r,"ZADD",4) ||
+                    !rioWriteBulkObject(r,key)) 
+                {
+                    dictReleaseIterator(di);
+                    return 0;
+                }
+            }
+            if (!rioWriteBulkDouble(r,*score) ||
+                !rioWriteBulkString(r,ele,sdslen(ele)))
+            {
+                dictReleaseIterator(di);
+                return 0;
             }
-            if (rioWriteBulkDouble(r,*score) == 0) return 0;
-            if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
@@ -1135,13 +1166,21 @@ int rewriteHashObject(rio *r, robj *key, robj *o) {
             int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                 AOF_REWRITE_ITEMS_PER_CMD : items;
 
-            if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
-            if (rioWriteBulkString(r,"HMSET",5) == 0) return 0;
-            if (rioWriteBulkObject(r,key) == 0) return 0;
+            if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
+                !rioWriteBulkString(r,"HMSET",5) ||
+                !rioWriteBulkObject(r,key)) 
+            {
+                hashTypeReleaseIterator(hi);
+                return 0;
+            }
         }
 
-        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) == 0) return 0;
-        if (rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE) == 0) return 0;
+        if (!rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) ||
+            !rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE))
+        {
+            hashTypeReleaseIterator(hi);
+            return 0;           
+        }
         if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
         items--;
     }

[ML] commit a295770e32b4bd71ff560c5ec7bc5c0ad12bf068
Author: caozb <1162650653@qq.com>
Date:   Sun Sep 27 20:40:07 2020 +0800

    ignore slaveof no one in redis.conf (#7842)
    
    when slaveof config is "no one", reset any pre-existing config and resume.
    
    also solve a memory leak if slaveof appears twice.
    and fail loading if port number is out of range or not an integer.
    
    Co-authored-by: caozhengbin <caozb@yidingyun.com>
    Co-authored-by: Oran Agra <oran@redislabs.com>

diff --git a/src/config.c b/src/config.c
index fbdef05b1..3d5a79eab 100644
--- a/src/config.c
+++ b/src/config.c
@@ -473,8 +473,17 @@ void loadServerConfigFromString(char *config) {
         } else if ((!strcasecmp(argv[0],"slaveof") ||
                     !strcasecmp(argv[0],"replicaof")) && argc == 3) {
             slaveof_linenum = linenum;
+            sdsfree(server.masterhost);
+            if (!strcasecmp(argv[1], "no") && !strcasecmp(argv[2], "one")) {
+                server.masterhost = NULL;
+                continue;
+            }
             server.masterhost = sdsnew(argv[1]);
-            server.masterport = atoi(argv[2]);
+            char *ptr;
+            server.masterport = strtol(argv[2], &ptr, 10);
+            if (server.masterport < 0 || server.masterport > 65535 || *ptr != '\0') {
+                err = "Invalid master port"; goto loaderr;
+            }
             server.repl_state = REPL_STATE_CONNECT;
         } else if (!strcasecmp(argv[0],"requirepass") && argc == 2) {
             if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {

commit 340963b2d7f5bd5fc999e3a8e6311c51420ba76c
Merge: 750acf3a4 0a1e73419
Author: Oran Agra <oran@redislabs.com>
Date:   Tue Sep 8 16:28:58 2020 +0300

    Tests: Some fixes for macOS (#7757)
    
    * Tests: Some fixes for macOS
    
    1) cur_test: when restart_server, "no such variable" error occurs
      ./runtest --single integration/rdb
      test {client freed during loading}
          SET ::cur_test
          restart_server
            kill_server
              test "Check for memory leaks (pid $pid)"
              SET ::cur_test
              UNSET ::cur_test
          UNSET ::cur_test // This global variable has been unset.
    
    2) `ps --ppid` not available on macOS platform, can be replaced with
    `pgrep -P pid`.
    
    * handle cur_test for nested tests
    
    if there are nested tests and nested servers, we need to restore the
    previous value of cur_test when a test exist.
    
    example:
    ```
    test{test 1} {
            start_server {
                    test{test 1.1 - master only} {
                    }
                    start_server {
                        test{test 1.2 - with replication} {
                }
                    }
            }
    }
    ```
    when `test 1.1 - master only exists`, we're still inside `test 1`
    
    Co-authored-by: Oran Agra <oran@redislabs.com>

[NR] [ML] commit f22fa9594d536cb53f83ed8e508c03d4278778b0
Author: bodong.ybd <bodong.ybd@alibaba-inc.com>
Date:   Tue Sep 8 10:45:03 2020 +0800

    Tests: Some fixes for macOS
    
    1) cur_test: when restart_server, "no such variable" error occurs
      ./runtest --single integration/rdb
      test {client freed during loading}
          SET ::cur_test
          restart_server
            kill_server
              test "Check for memory leaks (pid $pid)"
              SET ::cur_test
              UNSET ::cur_test
          UNSET ::cur_test // This global variable has been unset.
    
    2) `ps --ppid` not available on macOS platform, can be replaced with
    `pgrep -P pid`.

diff --git a/tests/support/test.tcl b/tests/support/test.tcl
index f5b4c8bef..54d323fa2 100644
--- a/tests/support/test.tcl
+++ b/tests/support/test.tcl
@@ -190,5 +190,4 @@ proc test {name code {okpattern undefined} {options undefined}} {
             send_data_packet $::test_server_fd err "Detected a memory leak in test '$name': $output"
         }
     }
-    unset ::cur_test
 }
diff --git a/tests/support/util.tcl b/tests/support/util.tcl
index ed4ff713a..b9a65358f 100644
--- a/tests/support/util.tcl
+++ b/tests/support/util.tcl
@@ -508,8 +508,13 @@ proc populate {num prefix size} {
 
 proc get_child_pid {idx} {
     set pid [srv $idx pid]
-    set fd [open "|ps --ppid $pid -o pid" "r"]
-    set child_pid [string trim [lindex [split [read $fd] \n] 1]]
+    if {[string match {*Darwin*} [exec uname -a]]} {
+        set fd [open "|pgrep -P $pid" "r"]
+        set child_pid [string trim [lindex [split [read $fd] \n] 0]]
+    } else {
+        set fd [open "|ps --ppid $pid -o pid" "r"]
+        set child_pid [string trim [lindex [split [read $fd] \n] 1]]
+    }
     close $fd
 
     return $child_pid

[ML] commit 3f67b0337833cbd2a2746dad7cd8411a31b75f70
Author: Wen Hui <wen.hui.ware@gmail.com>
Date:   Sat Aug 8 07:42:32 2020 -0400

    fix memory leak in ACLLoadFromFile error handling (#7623)

diff --git a/src/acl.c b/src/acl.c
index 3ce45f03b..e0432ba5c 100644
--- a/src/acl.c
+++ b/src/acl.c
@@ -1327,6 +1327,7 @@ sds ACLLoadFromFile(const char *filename) {
             errors = sdscatprintf(errors,
                      "'%s:%d: username '%s' contains invalid characters. ",
                      server.acl_filename, linenum, argv[1]);
+            sdsfreesplitres(argv,argc);
             continue;
         }
 

[ML] commit c69a9b2f61e0747fabb8120f03c9e2a29b43b472
Author: Wen Hui <wen.hui.ware@gmail.com>
Date:   Tue Jul 28 15:05:48 2020 -0400

    fix leak in error handling of debug populate command (#7062)
    
    valsize was not modified during the for loop below instead of getting from c->argv[4], therefore there is no need to put inside the for loop.. Moreover, putting the check outside loop will also avoid memory leaking, decrRefCount(key) should be called in the original code if we put the check in for loop

diff --git a/src/debug.c b/src/debug.c
index 60cc2a1fa..0bea69876 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -591,14 +591,13 @@ NULL
         if (getLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != C_OK)
             return;
         dictExpand(c->db->dict,keys);
+        long valsize = 0;
+        if ( c->argc == 5 && getLongFromObjectOrReply(c, c->argv[4], &valsize, NULL) != C_OK ) 
+            return;
         for (j = 0; j < keys; j++) {
-            long valsize = 0;
             snprintf(buf,sizeof(buf),"%s:%lu",
                 (c->argc == 3) ? "key" : (char*)c->argv[3]->ptr, j);
             key = createStringObject(buf,strlen(buf));
-            if (c->argc == 5)
-                if (getLongFromObjectOrReply(c, c->argv[4], &valsize, NULL) != C_OK)
-                    return;
             if (lookupKeyWrite(c->db,key) != NULL) {
                 decrRefCount(key);
                 continue;

commit 42fd522c630d56c577f2b62e238ce0b5dce42c3a
Merge: 5e46e0800 1bfa2d27a
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Mon Jun 22 11:06:50 2020 +0200

    Merge pull request #7421 from hwware/sentinel_leak_fix
    
    fix memory leak in sentinel connection sharing

[ML] commit 1bfa2d27a637119226ee3244d2d219c7e5a7ff33
Author: hwware <wen.hui.ware@gmail.com>
Date:   Sun Jun 21 23:04:28 2020 -0400

    fix memory leak in sentinel connection sharing

diff --git a/src/sentinel.c b/src/sentinel.c
index fb504ae4d..5be4193dc 100644
--- a/src/sentinel.c
+++ b/src/sentinel.c
@@ -1076,6 +1076,7 @@ int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
         releaseInstanceLink(ri->link,NULL);
         ri->link = match->link;
         match->link->refcount++;
+        dictReleaseIterator(di);
         return C_OK;
     }
     dictReleaseIterator(di);

[ML] commit 7008a0ba66fe13af0d584071eaa5fe3f34c56512
Author: hwware <wen.hui.ware@gmail.com>
Date:   Mon Jun 8 23:48:51 2020 -0400

    fix memory leak

diff --git a/src/t_string.c b/src/t_string.c
index d1a3e1b96..8e367ec80 100644
--- a/src/t_string.c
+++ b/src/t_string.c
@@ -516,13 +516,13 @@ void stralgoLCS(client *c) {
             withmatchlen = 1;
         } else if (!strcasecmp(opt,"MINMATCHLEN") && moreargs) {
             if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)
-                != C_OK) return;
+                != C_OK) goto clean_up_obj;
             if (minmatchlen < 0) minmatchlen = 0;
             j++;
         } else if (!strcasecmp(opt,"STRINGS") && moreargs > 1) {
             if (a != NULL) {
                 addReplyError(c,"Either use STRINGS or KEYS");
-                return;
+                goto clean_up_obj;
             }
             a = c->argv[j+1]->ptr;
             b = c->argv[j+2]->ptr;
@@ -530,17 +530,14 @@ void stralgoLCS(client *c) {
         } else if (!strcasecmp(opt,"KEYS") && moreargs > 1) {
             if (a != NULL) {
                 addReplyError(c,"Either use STRINGS or KEYS");
-                return;
+                goto clean_up_obj;
             }
             obja = lookupKeyRead(c->db,c->argv[j+1]);
             objb = lookupKeyRead(c->db,c->argv[j+2]);
-
             if ( !(obja->type == OBJ_STRING) || !(objb->type == OBJ_STRING) ) {
                 addReplyError(c,"Object associate with KEYS option should only be string type");
-                return;
-
+                goto clean_up_obj;
             }
-
             obja = obja ? getDecodedObject(obja) : createStringObject("",0);
             objb = objb ? getDecodedObject(objb) : createStringObject("",0);
             a = obja->ptr;
@@ -548,7 +545,7 @@ void stralgoLCS(client *c) {
             j += 2;
         } else {
             addReply(c,shared.syntaxerr);
-            return;
+            goto clean_up_obj;
         }
     }
 
@@ -556,12 +553,12 @@ void stralgoLCS(client *c) {
     if (a == NULL) {
         addReplyError(c,"Please specify two strings: "
                         "STRINGS or KEYS options are mandatory");
-        return;
+        goto clean_up_obj;
     } else if (getlen && getidx) {
         addReplyError(c,
             "If you want both the length and indexes, please "
             "just use IDX.");
-        return;
+        goto clean_up_obj;
     }
 
     /* Compute the LCS using the vanilla dynamic programming technique of
@@ -696,10 +693,12 @@ void stralgoLCS(client *c) {
     }
 
     /* Cleanup. */
-    if (obja) decrRefCount(obja);
-    if (objb) decrRefCount(objb);
     sdsfree(result);
     zfree(lcs);
+
+clean_up_obj:
+    if (obja) decrRefCount(obja);
+    if (objb) decrRefCount(objb);
     return;
 }
 

commit 5fa6f9ebe12c439b56c17ac49db1796516fe5319
Merge: e17f9311c 150ba0e1f
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Fri May 8 10:53:20 2020 +0200

    Merge pull request #7204 from ShooterIT/benchmark-fix
    
    Redis Benchmark: Fix coredump because of double free

commit 54cb8214d9bca268458752b3be92f038d4f52445
Merge: 373a3384a 93021da22
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue May 5 18:22:24 2020 +0200

    Merge pull request #7175 from bsergean/bsergean-patch-1
    
    redis-cli cluster reshard does not work with ACL (AUTH2 MIGRATE args un-implemented)

commit 7c5dc070163adf2455b035441af9d97658af3a90
Merge: b9e5be5f5 f16eaadd4
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Mon Mar 23 11:15:42 2020 +0100

    Merge pull request #7003 from guybe7/rm_context_flags_handle_null
    
    Allow RM_GetContextFlags to work with ctx==NULL

[ML] commit 86691ccff51b0065d430836e15c81464cc691765
Author: hwware <wen.hui.ware@gmail.com>
Date:   Wed Mar 18 09:33:52 2020 -0400

    fix potentical memory leak in redis-cli

diff --git a/src/redis-cli.c b/src/redis-cli.c
index 7ad80c0a1..c0cc69592 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -1989,6 +1989,8 @@ static void repl(void) {
                     if (config.eval) {
                         config.eval_ldb = 1;
                         config.output = OUTPUT_RAW;
+                        sdsfreesplitres(argv,argc);
+                        linenoiseFree(line);
                         return; /* Return to evalMode to restart the session. */
                     } else {
                         printf("Use 'restart' only in Lua debugging mode.");

commit ab8c383082a94c5b54cdced5036d0a6f11e54150
Merge: c552fad6d 7d4ebe114
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Thu Feb 20 17:42:24 2020 +0100

    Merge pull request #6901 from hwware/debughelp
    
    add missing subcommand description for DEBUG OOM in HELP

[ML] commit 5c73a6e2067f2bad1e622c372793a6d40ab1e2a0
Author: Guy Benoish <guy.benoish@redislabs.com>
Date:   Thu Feb 6 18:36:21 2020 +0530

    Fix memory leak in test_ld_conv

diff --git a/tests/modules/misc.c b/tests/modules/misc.c
index 41bec06ed..1048d5065 100644
--- a/tests/modules/misc.c
+++ b/tests/modules/misc.c
@@ -74,6 +74,7 @@ int test_ld_conv(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
         RedisModule_ReplyWithError(ctx, err);
         goto final;
     }
+
     /* Make sure we can't convert a string that has \0 in it */
     char buf[4] = "123";
     buf[1] = '\0';
@@ -81,8 +82,11 @@ int test_ld_conv(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
     long double ld3;
     if (RedisModule_StringToLongDouble(s3, &ld3) == REDISMODULE_OK) {
         RedisModule_ReplyWithError(ctx, "Invalid string successfully converted to long double");
+        RedisModule_FreeString(ctx, s3);
         goto final;
     }
+    RedisModule_FreeString(ctx, s3);
+
     RedisModule_ReplyWithLongDouble(ctx, ld2);
 final:
     RedisModule_FreeString(ctx, s1);

commit cfe39b7859bf076b7884ec5e9b47334dd05e74ff
Merge: 6ca1ad1e2 560e1e6c4
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue Feb 4 10:20:56 2020 +0100

    Merge pull request #6818 from leomurillo/zskiplistLevels
    
    Set ZSKIPLIST_MAXLEVEL to 32

[ML] commit eb2196f5ce68ee72dd64dffa75b9ecb3e930e0cd
Author: WuYunlong <xzsyeb@126.com>
Date:   Tue Feb 4 16:38:46 2020 +0800

    Fix lua related memory leak.

diff --git a/src/scripting.c b/src/scripting.c
index 9282b7fd9..a5c59b113 100644
--- a/src/scripting.c
+++ b/src/scripting.c
@@ -2473,6 +2473,7 @@ void ldbEval(lua_State *lua, sds *argv, int argc) {
             ldbLog(sdscatfmt(sdsempty(),"<error> %s",lua_tostring(lua,-1)));
             lua_pop(lua,1);
             sdsfree(code);
+            sdsfree(expr);
             return;
         }
     }

commit 01eaf53bb37506ddd922da89144b059ff85cd7fb
Author: WuYunlong <xzsyeb@126.com>
Date:   Tue Feb 4 16:34:11 2020 +0800

    Add tcl regression test in scripting.tcl to reproduce memory leak.

diff --git a/tests/unit/scripting.tcl b/tests/unit/scripting.tcl
index 2543a0377..fb36d0b80 100644
--- a/tests/unit/scripting.tcl
+++ b/tests/unit/scripting.tcl
@@ -741,3 +741,8 @@ start_server {tags {"scripting repl"}} {
     }
 }
 
+start_server {tags {"scripting"}} {
+    r script debug sync
+    r eval {return 'hello'} 0
+    r eval {return 'hello'} 0
+}

commit bf53f9280a7068ea80a47ccdc0fe9d50258e0612
Merge: 7ef2270ee d7d13721d
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Wed Jan 29 12:06:14 2020 +0100

    Merge pull request #6699 from guybe7/module_blocked_on_key_timeout_memleak
    
    Modules: Fix blocked-client-related memory leak

[ML] commit 3f6d00d387b85b0eaa459427c2891ca979dc8363
Author: hwware <wen.hui.ware@gmail.com>
Date:   Thu Jan 16 17:33:23 2020 -0500

    fix potentical memory leaks

diff --git a/src/debug.c b/src/debug.c
index a2d37337d..b441fa8f8 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -683,9 +683,12 @@ NULL
         sds stats = sdsempty();
         char buf[4096];
 
-        if (getLongFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK)
+        if (getLongFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK){
+            sdsfree(stats);
             return;
+        }
         if (dbid < 0 || dbid >= server.dbnum) {
+            sdsfree(stats);
             addReplyError(c,"Out of range database");
             return;
         }

commit 9506c860f6642bc14aa4079e991c1c298138044a
Merge: baa88a1c1 d6a13f444
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Mon Jan 13 13:23:49 2020 +0100

    Merge pull request #6739 from trevor211/fixMemoryLeak
    
    Fix potential memory leak of rioWriteBulkStreamID().

[ML] commit d6a13f444003e75e8ccbe97297bf32f0eb58cb23
Author: WuYunlong <xzsyeb@126.com>
Date:   Tue Jan 7 11:17:52 2020 +0800

    Free allocated sds in pfdebugCommand() to avoid memory leak.

diff --git a/src/hyperloglog.c b/src/hyperloglog.c
index a44d15646..facd99743 100644
--- a/src/hyperloglog.c
+++ b/src/hyperloglog.c
@@ -1535,6 +1535,7 @@ void pfdebugCommand(client *c) {
         sds decoded = sdsempty();
 
         if (hdr->encoding != HLL_SPARSE) {
+            sdsfree(decoded);
             addReplyError(c,"HLL encoding is not sparse");
             return;
         }

[ML] commit 9387f7333e0ccc200dda10032e517e2fb93cc368
Author: WuYunlong <xzsyeb@126.com>
Date:   Tue Jan 7 10:28:36 2020 +0800

    Fix potential memory leak of clusterLoadConfig().

diff --git a/src/cluster.c b/src/cluster.c
index f603361cd..f9d8ae151 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -157,7 +157,10 @@ int clusterLoadConfig(char *filename) {
         }
 
         /* Regular config lines have at least eight fields */
-        if (argc < 8) goto fmterr;
+        if (argc < 8) {
+            sdsfreesplitres(argv,argc);
+            goto fmterr;
+        }
 
         /* Create this node if it does not exist */
         n = clusterLookupNode(argv[0]);
@@ -166,7 +169,10 @@ int clusterLoadConfig(char *filename) {
             clusterAddNode(n);
         }
         /* Address and port */
-        if ((p = strrchr(argv[1],':')) == NULL) goto fmterr;
+        if ((p = strrchr(argv[1],':')) == NULL) {
+            sdsfreesplitres(argv,argc);
+            goto fmterr;
+        }
         *p = '\0';
         memcpy(n->ip,argv[1],strlen(argv[1])+1);
         char *port = p+1;
@@ -247,7 +253,10 @@ int clusterLoadConfig(char *filename) {
                 *p = '\0';
                 direction = p[1]; /* Either '>' or '<' */
                 slot = atoi(argv[j]+1);
-                if (slot < 0 || slot >= CLUSTER_SLOTS) goto fmterr;
+                if (slot < 0 || slot >= CLUSTER_SLOTS) {
+                    sdsfreesplitres(argv,argc);
+                    goto fmterr;
+                }
                 p += 3;
                 cn = clusterLookupNode(p);
                 if (!cn) {
@@ -267,8 +276,14 @@ int clusterLoadConfig(char *filename) {
             } else {
                 start = stop = atoi(argv[j]);
             }
-            if (start < 0 || start >= CLUSTER_SLOTS) goto fmterr;
-            if (stop < 0 || stop >= CLUSTER_SLOTS) goto fmterr;
+            if (start < 0 || start >= CLUSTER_SLOTS) {
+                sdsfreesplitres(argv,argc);
+                goto fmterr;
+            }
+            if (stop < 0 || stop >= CLUSTER_SLOTS) {
+                sdsfreesplitres(argv,argc);
+                goto fmterr;
+            }
             while(start <= stop) clusterAddSlot(n, start++);
         }
 

[ML] commit 2f8134a7ff9d3c435dad16a73bf96e3daa919a21
Author: WuYunlong <xzsyeb@126.com>
Date:   Mon Jan 6 19:56:50 2020 +0800

    Fix potential memory leak of rioWriteBulkStreamID().

diff --git a/src/aof.c b/src/aof.c
index 0ef59cfb6..102c39f3f 100644
--- a/src/aof.c
+++ b/src/aof.c
@@ -1139,7 +1139,10 @@ int rioWriteBulkStreamID(rio *r,streamID *id) {
     int retval;
 
     sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
-    if ((retval = rioWriteBulkString(r,replyid,sdslen(replyid))) == 0) return 0;
+    if ((retval = rioWriteBulkString(r,replyid,sdslen(replyid))) == 0) {
+        sdsfree(replyid);
+        return 0;
+    }
     sdsfree(replyid);
     return retval;
 }

[ML] commit d7d13721d38f391f31ed0d9b1081b59245b468ab
Author: Guy Benoish <guy.benoish@redislabs.com>
Date:   Tue Dec 24 17:14:23 2019 +0530

    Modules: Fix blocked-client-related memory leak
    
    If a blocked module client times-out (or disconnects, unblocked
    by CLIENT command, etc.) we need to call moduleUnblockClient
    in order to free memory allocated by the module sub-system
    and blocked-client private data
    
    Other changes:
    Made blockedonkeys.tcl tests a bit more aggressive in order
    to smoke-out potential memory leaks

diff --git a/src/module.c b/src/module.c
index 705ffec2c..cbab735f1 100644
--- a/src/module.c
+++ b/src/module.c
@@ -4271,6 +4271,15 @@ void unblockClientFromModule(client *c) {
         moduleFreeContext(&ctx);
     }
 
+    /* If we made it here and client is still blocked it means that the command
+     * timed-out, client was killed or disconnected and disconnect_callback was
+     * not implemented (or it was, but RM_UnblockClient was not called from
+     * within it, as it should).
+     * We must call moduleUnblockClient in order to free privdata and
+     * RedisModuleBlockedClient */
+    if (!bc->unblocked)
+        moduleUnblockClient(c);
+
     bc->client = NULL;
     /* Reset the client for a new query since, for blocking commands implemented
      * into modules, we do not it immediately after the command returns (and
diff --git a/tests/modules/blockonkeys.c b/tests/modules/blockonkeys.c
index 959918b1c..10dc65b1a 100644
--- a/tests/modules/blockonkeys.c
+++ b/tests/modules/blockonkeys.c
@@ -172,13 +172,13 @@ int bpopgt_reply_callback(RedisModuleCtx *ctx, RedisModuleString **argv, int arg
     REDISMODULE_NOT_USED(argv);
     REDISMODULE_NOT_USED(argc);
     RedisModuleString *keyname = RedisModule_GetBlockedClientReadyKey(ctx);
-    long long gt = (long long)RedisModule_GetBlockedClientPrivateData(ctx);
+    long long *pgt = RedisModule_GetBlockedClientPrivateData(ctx);
 
     fsl_t *fsl;
     if (!get_fsl(ctx, keyname, REDISMODULE_READ, 0, &fsl, 0))
         return REDISMODULE_ERR;
 
-    if (!fsl || fsl->list[fsl->length-1] <= gt)
+    if (!fsl || fsl->list[fsl->length-1] <= *pgt)
         return REDISMODULE_ERR;
 
     RedisModule_ReplyWithLongLong(ctx, fsl->list[--fsl->length]);
@@ -192,10 +192,8 @@ int bpopgt_timeout_callback(RedisModuleCtx *ctx, RedisModuleString **argv, int a
 }
 
 void bpopgt_free_privdata(RedisModuleCtx *ctx, void *privdata) {
-    /* Nothing to do because privdata is actually a 'long long',
-     * not a pointer to the heap */
     REDISMODULE_NOT_USED(ctx);
-    REDISMODULE_NOT_USED(privdata);
+    RedisModule_Free(privdata);
 }
 
 /* FSL.BPOPGT <key> <gt> <timeout> - Block clients until list has an element greater than <gt>.
@@ -217,9 +215,12 @@ int fsl_bpopgt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
         return REDISMODULE_OK;
 
     if (!fsl || fsl->list[fsl->length-1] <= gt) {
+        /* We use malloc so the tests in blockedonkeys.tcl can check for memory leaks */
+        long long *pgt = RedisModule_Alloc(sizeof(long long));
+        *pgt = gt;
         /* Key is empty or has <2 elements, we must block */
         RedisModule_BlockClientOnKeys(ctx, bpopgt_reply_callback, bpopgt_timeout_callback,
-                                      bpopgt_free_privdata, timeout, &argv[1], 1, (void*)gt);
+                                      bpopgt_free_privdata, timeout, &argv[1], 1, pgt);
     } else {
         RedisModule_ReplyWithLongLong(ctx, fsl->list[--fsl->length]);
     }
diff --git a/tests/unit/moduleapi/blockonkeys.tcl b/tests/unit/moduleapi/blockonkeys.tcl
index cb99ab1c9..b380227e0 100644
--- a/tests/unit/moduleapi/blockonkeys.tcl
+++ b/tests/unit/moduleapi/blockonkeys.tcl
@@ -45,18 +45,24 @@ start_server {tags {"modules"}} {
     test {Module client blocked on keys (with metadata): Timeout} {
         r del k
         set rd [redis_deferring_client]
+        $rd client id
+        set cid [$rd read]
         r fsl.push k 33
         $rd fsl.bpopgt k 35 1
         assert_equal {Request timedout} [$rd read]
+        r client kill id $cid ;# try to smoke-out client-related memory leak
     }
 
     test {Module client blocked on keys (with metadata): Blocked, case 1} {
         r del k
         set rd [redis_deferring_client]
+        $rd client id
+        set cid [$rd read]
         r fsl.push k 33
         $rd fsl.bpopgt k 33 0
         r fsl.push k 34
         assert_equal {34} [$rd read]
+        r client kill id $cid ;# try to smoke-out client-related memory leak
     }
 
     test {Module client blocked on keys (with metadata): Blocked, case 2} {
@@ -70,6 +76,35 @@ start_server {tags {"modules"}} {
         assert_equal {36} [$rd read]
     }
 
+    test {Module client blocked on keys (with metadata): Blocked, CLIENT KILL} {
+        r del k
+        set rd [redis_deferring_client]
+        $rd client id
+        set cid [$rd read]
+        $rd fsl.bpopgt k 35 0
+        r client kill id $cid ;# try to smoke-out client-related memory leak
+    }
+
+    test {Module client blocked on keys (with metadata): Blocked, CLIENT UNBLOCK TIMEOUT} {
+        r del k
+        set rd [redis_deferring_client]
+        $rd client id
+        set cid [$rd read]
+        $rd fsl.bpopgt k 35 0
+        r client unblock $cid timeout ;# try to smoke-out client-related memory leak
+        assert_equal {Request timedout} [$rd read]
+    }
+
+    test {Module client blocked on keys (with metadata): Blocked, CLIENT UNBLOCK ERROR} {
+        r del k
+        set rd [redis_deferring_client]
+        $rd client id
+        set cid [$rd read]
+        $rd fsl.bpopgt k 35 0
+        r client unblock $cid error ;# try to smoke-out client-related memory leak
+        assert_error "*unblocked*" {$rd read}
+    }
+
     test {Module client blocked on keys does not wake up on wrong type} {
         r del k
         set rd [redis_deferring_client]

[ML] commit dddfde85efb93b6365855c97a9b86e1951672a96
Author: antirez <antirez@gmail.com>
Date:   Wed Oct 23 18:21:57 2019 +0200

    Modules hooks: fix memory leak in example module.

diff --git a/src/modules/hellohook.c b/src/modules/hellohook.c
index 2e798f500..7ab78ed07 100644
--- a/src/modules/hellohook.c
+++ b/src/modules/hellohook.c
@@ -63,6 +63,7 @@ void flushdbCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void
             long long numkeys = RedisModule_CallReplyInteger(reply);
             printf("FLUSHDB event of database %d started (%lld keys in DB)\n",
                 fi->dbnum, numkeys);
+            RedisModule_FreeCallReply(reply);
         } else {
             printf("FLUSHALL event started\n");
         }

commit 8e3d910d4e8f8a4147ba5905a9684ce3a392d7ce
Merge: 363604a27 bea0384f5
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Thu Oct 10 14:56:43 2019 +0200

    Merge pull request #6429 from charsyam/feature/typo-slave
    
    [trivial] fix typos salves to slaves in replication.c

[ML] commit 8b5848a4f50f2fb0d9651ea91b74b22e83e6a452
Author: antirez <antirez@gmail.com>
Date:   Fri Sep 27 18:33:21 2019 +0200

    Fix memory leak in moduleLoadFromQueue().

diff --git a/src/module.c b/src/module.c
index 98d4db97f..351ffcc45 100644
--- a/src/module.c
+++ b/src/module.c
@@ -5334,6 +5334,8 @@ void moduleLoadFromQueue(void) {
 void moduleFreeModuleStructure(struct RedisModule *module) {
     listRelease(module->types);
     listRelease(module->filters);
+    listRelease(module->usedby);
+    listRelease(module->using);
     sdsfree(module->name);
     zfree(module);
 }

[ML] commit b394817754ade6151f40b64115f9fbe03a9ca09b
Author: antirez <antirez@gmail.com>
Date:   Fri Sep 27 18:32:52 2019 +0200

    Fix memory leak in RM_UnregisterCommandFilter().

diff --git a/src/module.c b/src/module.c
index 217478705..98d4db97f 100644
--- a/src/module.c
+++ b/src/module.c
@@ -5036,6 +5036,8 @@ int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *fi
     if (!ln) return REDISMODULE_ERR;    /* Shouldn't happen */
     listDelNode(ctx->module->filters,ln);
 
+    zfree(filter);
+
     return REDISMODULE_OK;
 }
 

[ML] commit 3b6aeea44cf8bdc64214a5f145da55453722a9a2
Author: Oran Agra <oran@redislabs.com>
Date:   Sun Jul 21 17:41:03 2019 +0300

    Implement module api for aux data in rdb
    
    Other changes:
    * fix memory leak in error handling of rdb loading of type OBJ_MODULE

diff --git a/runtest-moduleapi b/runtest-moduleapi
index 84cdb9bb8..8e1c0cb23 100755
--- a/runtest-moduleapi
+++ b/runtest-moduleapi
@@ -13,4 +13,4 @@ then
 fi
 
 make -C tests/modules && \
-$TCLSH tests/test_helper.tcl --single unit/moduleapi/commandfilter "${@}"
+$TCLSH tests/test_helper.tcl --single unit/moduleapi/commandfilter --single unit/moduleapi/testrdb "${@}"
diff --git a/src/module.c b/src/module.c
index f4f753c00..812a54e04 100644
--- a/src/module.c
+++ b/src/module.c
@@ -29,6 +29,7 @@
 
 #include "server.h"
 #include "cluster.h"
+#include "rdb.h"
 #include <dlfcn.h>
 
 #define REDISMODULE_CORE 1
@@ -3078,6 +3079,11 @@ moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver,
         moduleTypeMemUsageFunc mem_usage;
         moduleTypeDigestFunc digest;
         moduleTypeFreeFunc free;
+        struct {
+            moduleTypeAuxLoadFunc aux_load;
+            moduleTypeAuxSaveFunc aux_save;
+            int aux_save_triggers;
+        } v2;
     } *tms = (struct typemethods*) typemethods_ptr;
 
     moduleType *mt = zcalloc(sizeof(*mt));
@@ -3089,6 +3095,11 @@ moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver,
     mt->mem_usage = tms->mem_usage;
     mt->digest = tms->digest;
     mt->free = tms->free;
+    if (tms->version >= 2) {
+        mt->aux_load = tms->v2.aux_load;
+        mt->aux_save = tms->v2.aux_save;
+        mt->aux_save_triggers = tms->v2.aux_save_triggers;
+    }
     memcpy(mt->name,name,sizeof(mt->name));
     listAddNodeTail(ctx->module->types,mt);
     return mt;
@@ -3355,6 +3366,36 @@ loaderr:
     return 0; /* Never reached. */
 }
 
+/* Iterate over modules, and trigger rdb aux saving for the ones modules types
+ * who asked for it. */
+ssize_t rdbSaveModulesAux(rio *rdb, int when) {
+    size_t total_written = 0;
+    dictIterator *di = dictGetIterator(modules);
+    dictEntry *de;
+
+    while ((de = dictNext(di)) != NULL) {
+        struct RedisModule *module = dictGetVal(de);
+        listIter li;
+        listNode *ln;
+
+        listRewind(module->types,&li);
+        while((ln = listNext(&li))) {
+            moduleType *mt = ln->value;
+            if (!mt->aux_save || !(mt->aux_save_triggers & when))
+                continue;
+            ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
+            if (ret==-1) {
+                dictReleaseIterator(di);
+                return -1;
+            }
+            total_written += ret;
+        }
+    }
+
+    dictReleaseIterator(di);
+    return total_written;
+}
+
 /* --------------------------------------------------------------------------
  * Key digest API (DEBUG DIGEST interface for modules types)
  * -------------------------------------------------------------------------- */
diff --git a/src/rdb.c b/src/rdb.c
index 2118a00f4..4e00fad67 100644
--- a/src/rdb.c
+++ b/src/rdb.c
@@ -971,7 +971,6 @@ ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
         RedisModuleIO io;
         moduleValue *mv = o->ptr;
         moduleType *mt = mv->type;
-        moduleInitIOContext(io,mt,rdb,key);
 
         /* Write the "module" identifier as prefix, so that we'll be able
          * to call the right module during loading. */
@@ -980,10 +979,13 @@ ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
         io.bytes += retval;
 
         /* Then write the module-specific representation + EOF marker. */
+        moduleInitIOContext(io,mt,rdb,key);
         mt->rdb_save(&io,mv->value);
         retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
-        if (retval == -1) return -1;
-        io.bytes += retval;
+        if (retval == -1)
+            io.error = 1;
+        else
+            io.bytes += retval;
 
         if (io.ctx) {
             moduleFreeContext(io.ctx);
@@ -1101,6 +1103,40 @@ int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
     return 1;
 }
 
+ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
+    /* Save a module-specific aux value. */
+    RedisModuleIO io;
+    int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);
+
+    /* Write the "module" identifier as prefix, so that we'll be able
+     * to call the right module during loading. */
+    retval = rdbSaveLen(rdb,mt->id);
+    if (retval == -1) return -1;
+    io.bytes += retval;
+
+    /* write the 'when' so that we can provide it on loading */
+    retval = rdbSaveLen(rdb,when);
+    if (retval == -1) return -1;
+    io.bytes += retval;
+
+    /* Then write the module-specific representation + EOF marker. */
+    moduleInitIOContext(io,mt,rdb,NULL);
+    mt->aux_save(&io,when);
+    retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
+    if (retval == -1)
+        io.error = 1;
+    else
+        io.bytes += retval;
+
+    if (io.ctx) {
+        moduleFreeContext(io.ctx);
+        zfree(io.ctx);
+    }
+    if (io.error)
+        return -1;
+    return io.bytes;
+}
+
 /* Produces a dump of the database in RDB format sending it to the specified
  * Redis I/O channel. On success C_OK is returned, otherwise C_ERR
  * is returned and part of the output, or all the output, can be
@@ -1122,6 +1158,7 @@ int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
     snprintf(magic,sizeof(magic),"REDIS%04d",RDB_VERSION);
     if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
     if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;
+    if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;
 
     for (j = 0; j < server.dbnum; j++) {
         redisDb *db = server.db+j;
@@ -1183,6 +1220,8 @@ int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
         di = NULL; /* So that we don't release it again on error. */
     }
 
+    if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;
+
     /* EOF opcode */
     if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;
 
@@ -2089,15 +2128,11 @@ int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
             decrRefCount(auxval);
             continue; /* Read type again. */
         } else if (type == RDB_OPCODE_MODULE_AUX) {
-            /* This is just for compatibility with the future: we have plans
-             * to add the ability for modules to store anything in the RDB
-             * file, like data that is not related to the Redis key space.
-             * Such data will potentially be stored both before and after the
-             * RDB keys-values section. For this reason since RDB version 9,
-             * we have the ability to read a MODULE_AUX opcode followed by an
-             * identifier of the module, and a serialized value in "MODULE V2"
-             * format. */
+            /* Load module data that is not related to the Redis key space.
+             * Such data can be potentially be stored both before and after the
+             * RDB keys-values section. */
             uint64_t moduleid = rdbLoadLen(rdb,NULL);
+            int when = rdbLoadLen(rdb,NULL);
             if (rioGetReadError(rdb)) goto eoferr;
             moduleType *mt = moduleTypeLookupModuleByID(moduleid);
             char name[10];
@@ -2108,10 +2143,32 @@ int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
                 serverLog(LL_WARNING,"The RDB file contains AUX module data I can't load: no matching module '%s'", name);
                 exit(1);
             } else if (!rdbCheckMode && mt != NULL) {
-                /* This version of Redis actually does not know what to do
-                 * with modules AUX data... */
-                serverLog(LL_WARNING,"The RDB file contains AUX module data I can't load for the module '%s'. Probably you want to use a newer version of Redis which implements aux data callbacks", name);
-                exit(1);
+                if (!mt->aux_load) {
+                    /* Module doesn't support AUX. */
+                    serverLog(LL_WARNING,"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.", name);
+                    exit(1);
+                }
+
+                RedisModuleIO io;
+                moduleInitIOContext(io,mt,rdb,NULL);
+                io.ver = 2;
+                /* Call the rdb_load method of the module providing the 10 bit
+                 * encoding version in the lower 10 bits of the module ID. */
+                if (mt->aux_load(&io,moduleid&1023, when) || io.error) {
+                    moduleTypeNameByID(name,moduleid);
+                    serverLog(LL_WARNING,"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
+                    exit(1);
+                }
+                if (io.ctx) {
+                    moduleFreeContext(io.ctx);
+                    zfree(io.ctx);
+                }
+                uint64_t eof = rdbLoadLen(rdb,NULL);
+                if (eof != RDB_MODULE_OPCODE_EOF) {
+                    serverLog(LL_WARNING,"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker", name);
+                    exit(1);
+                }
+                continue;
             } else {
                 /* RDB check mode. */
                 robj *aux = rdbLoadCheckModuleValue(rdb,name);
diff --git a/src/rdb.h b/src/rdb.h
index 0acddf9ab..40a50f7ba 100644
--- a/src/rdb.h
+++ b/src/rdb.h
@@ -145,6 +145,7 @@ size_t rdbSavedObjectLen(robj *o);
 robj *rdbLoadObject(int type, rio *rdb, robj *key);
 void backgroundSaveDoneHandler(int exitcode, int bysignal);
 int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime);
+ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt);
 robj *rdbLoadStringObject(rio *rdb);
 ssize_t rdbSaveStringObject(rio *rdb, robj *obj);
 ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len);
diff --git a/src/redismodule.h b/src/redismodule.h
index b9c73957b..21227fe3a 100644
--- a/src/redismodule.h
+++ b/src/redismodule.h
@@ -129,6 +129,10 @@
 
 #define REDISMODULE_NOT_USED(V) ((void) V)
 
+/* Bit flags for aux_save_triggers and the aux_load and aux_save callbacks */
+#define REDISMODULE_AUX_BEFORE_RDB (1<<0)
+#define REDISMODULE_AUX_AFTER_RDB (1<<1)
+
 /* This type represents a timer handle, and is returned when a timer is
  * registered and used in order to invalidate a timer. It's just a 64 bit
  * number, because this is how each timer is represented inside the radix tree
@@ -166,6 +170,8 @@ typedef void (*RedisModuleDisconnectFunc)(RedisModuleCtx *ctx, RedisModuleBlocke
 typedef int (*RedisModuleNotificationFunc)(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);
 typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);
 typedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);
+typedef int (*RedisModuleTypeAuxLoadFunc)(RedisModuleIO *rdb, int encver, int when);
+typedef void (*RedisModuleTypeAuxSaveFunc)(RedisModuleIO *rdb, int when);
 typedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);
 typedef size_t (*RedisModuleTypeMemUsageFunc)(const void *value);
 typedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);
@@ -174,7 +180,7 @@ typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const cha
 typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);
 typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);
 
-#define REDISMODULE_TYPE_METHOD_VERSION 1
+#define REDISMODULE_TYPE_METHOD_VERSION 2
 typedef struct RedisModuleTypeMethods {
     uint64_t version;
     RedisModuleTypeLoadFunc rdb_load;
@@ -183,6 +189,9 @@ typedef struct RedisModuleTypeMethods {
     RedisModuleTypeMemUsageFunc mem_usage;
     RedisModuleTypeDigestFunc digest;
     RedisModuleTypeFreeFunc free;
+    RedisModuleTypeAuxLoadFunc aux_load;
+    RedisModuleTypeAuxSaveFunc aux_save;
+    int aux_save_triggers;
 } RedisModuleTypeMethods;
 
 #define REDISMODULE_GET_API(name) \
diff --git a/src/server.h b/src/server.h
index b200a6696..33522dd69 100644
--- a/src/server.h
+++ b/src/server.h
@@ -536,6 +536,10 @@ typedef long long mstime_t; /* millisecond time type. */
 #define REDISMODULE_TYPE_ENCVER(id) (id & REDISMODULE_TYPE_ENCVER_MASK)
 #define REDISMODULE_TYPE_SIGN(id) ((id & ~((uint64_t)REDISMODULE_TYPE_ENCVER_MASK)) >>REDISMODULE_TYPE_ENCVER_BITS)
 
+/* Bit flags for moduleTypeAuxSaveFunc */
+#define REDISMODULE_AUX_BEFORE_RDB (1<<0)
+#define REDISMODULE_AUX_AFTER_RDB (1<<1)
+
 struct RedisModule;
 struct RedisModuleIO;
 struct RedisModuleDigest;
@@ -548,6 +552,8 @@ struct redisObject;
  * is deleted. */
 typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);
 typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);
+typedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);
+typedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);
 typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);
 typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);
 typedef size_t (*moduleTypeMemUsageFunc)(const void *value);
@@ -564,6 +570,9 @@ typedef struct RedisModuleType {
     moduleTypeMemUsageFunc mem_usage;
     moduleTypeDigestFunc digest;
     moduleTypeFreeFunc free;
+    moduleTypeAuxLoadFunc aux_load;
+    moduleTypeAuxSaveFunc aux_save;
+    int aux_save_triggers;
     char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
 } moduleType;
 
@@ -1528,6 +1537,7 @@ void moduleAcquireGIL(void);
 void moduleReleaseGIL(void);
 void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid);
 void moduleCallCommandFilters(client *c);
+ssize_t rdbSaveModulesAux(rio *rdb, int when);
 
 /* Utils */
 long long ustime(void);
diff --git a/tests/modules/Makefile b/tests/modules/Makefile
index 014d20afa..6e4574747 100644
--- a/tests/modules/Makefile
+++ b/tests/modules/Makefile
@@ -13,12 +13,16 @@ endif
 
 .SUFFIXES: .c .so .xo .o
 
-all: commandfilter.so
+all: commandfilter.so testrdb.so
 
 .c.xo:
 	$(CC) -I../../src $(CFLAGS) $(SHOBJ_CFLAGS) -fPIC -c $< -o $@
 
 commandfilter.xo: ../../src/redismodule.h
+testrdb.xo: ../../src/redismodule.h
 
 commandfilter.so: commandfilter.xo
 	$(LD) -o $@ $< $(SHOBJ_LDFLAGS) $(LIBS) -lc
+
+testrdb.so: testrdb.xo
+	$(LD) -o $@ $< $(SHOBJ_LDFLAGS) $(LIBS) -lc
diff --git a/tests/modules/testrdb.c b/tests/modules/testrdb.c
new file mode 100644
index 000000000..415497a2f
--- /dev/null
+++ b/tests/modules/testrdb.c
@@ -0,0 +1,229 @@
+#include "redismodule.h"
+
+#include <string.h>
+#include <assert.h>
+
+/* Module configuration, save aux or not? */
+long long conf_aux_count = 0;
+
+/* Registered type */
+RedisModuleType *testrdb_type = NULL;
+
+/* Global values to store and persist to aux */
+RedisModuleString *before_str = NULL;
+RedisModuleString *after_str = NULL;
+
+void *testrdb_type_load(RedisModuleIO *rdb, int encver) {
+    int count = RedisModule_LoadSigned(rdb);
+    assert(count==1);
+    assert(encver==1);
+    RedisModuleString *str = RedisModule_LoadString(rdb);
+    return str;
+}
+
+void testrdb_type_save(RedisModuleIO *rdb, void *value) {
+    RedisModuleString *str = (RedisModuleString*)value;
+    RedisModule_SaveSigned(rdb, 1);
+    RedisModule_SaveString(rdb, str);
+}
+
+void testrdb_aux_save(RedisModuleIO *rdb, int when) {
+    if (conf_aux_count==1) assert(when == REDISMODULE_AUX_AFTER_RDB);
+    if (conf_aux_count==0) assert(0);
+    if (when == REDISMODULE_AUX_BEFORE_RDB) {
+        if (before_str) {
+            RedisModule_SaveSigned(rdb, 1);
+            RedisModule_SaveString(rdb, before_str);
+        } else {
+            RedisModule_SaveSigned(rdb, 0);
+        }
+    } else {
+        if (after_str) {
+            RedisModule_SaveSigned(rdb, 1);
+            RedisModule_SaveString(rdb, after_str);
+        } else {
+            RedisModule_SaveSigned(rdb, 0);
+        }
+    }
+}
+
+int testrdb_aux_load(RedisModuleIO *rdb, int encver, int when) {
+    assert(encver == 1);
+    if (conf_aux_count==1) assert(when == REDISMODULE_AUX_AFTER_RDB);
+    if (conf_aux_count==0) assert(0);
+    RedisModuleCtx *ctx = RedisModule_GetContextFromIO(rdb);
+    if (when == REDISMODULE_AUX_BEFORE_RDB) {
+        if (before_str)
+            RedisModule_FreeString(ctx, before_str);
+        before_str = NULL;
+        int count = RedisModule_LoadSigned(rdb);
+        if (count)
+            before_str = RedisModule_LoadString(rdb);
+    } else {
+        if (after_str)
+            RedisModule_FreeString(ctx, after_str);
+        after_str = NULL;
+        int count = RedisModule_LoadSigned(rdb);
+        if (count)
+            after_str = RedisModule_LoadString(rdb);
+    }
+    return REDISMODULE_OK;
+}
+
+void testrdb_type_free(void *value) {
+    RedisModule_FreeString(NULL, (RedisModuleString*)value);
+}
+
+int testrdb_set_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
+{
+    if (argc != 2) {
+        RedisModule_WrongArity(ctx);
+        return REDISMODULE_OK;
+    }
+
+    if (before_str)
+        RedisModule_FreeString(ctx, before_str);
+    before_str = argv[1];
+    RedisModule_RetainString(ctx, argv[1]);
+    RedisModule_ReplyWithLongLong(ctx, 1);
+    return REDISMODULE_OK;
+}
+
+int testrdb_get_before(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
+{
+    REDISMODULE_NOT_USED(argv);
+    if (argc != 1){
+        RedisModule_WrongArity(ctx);
+        return REDISMODULE_OK;
+    }
+    if (before_str)
+        RedisModule_ReplyWithString(ctx, before_str);
+    else
+        RedisModule_ReplyWithStringBuffer(ctx, "", 0);
+    return REDISMODULE_OK;
+}
+
+int testrdb_set_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
+{
+    if (argc != 2){
+        RedisModule_WrongArity(ctx);
+        return REDISMODULE_OK;
+    }
+
+    if (after_str)
+        RedisModule_FreeString(ctx, after_str);
+    after_str = argv[1];
+    RedisModule_RetainString(ctx, argv[1]);
+    RedisModule_ReplyWithLongLong(ctx, 1);
+    return REDISMODULE_OK;
+}
+
+int testrdb_get_after(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
+{
+    REDISMODULE_NOT_USED(argv);
+    if (argc != 1){
+        RedisModule_WrongArity(ctx);
+        return REDISMODULE_OK;
+    }
+    if (after_str)
+        RedisModule_ReplyWithString(ctx, after_str);
+    else
+        RedisModule_ReplyWithStringBuffer(ctx, "", 0);
+    return REDISMODULE_OK;
+}
+
+int testrdb_set_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
+{
+    if (argc != 3){
+        RedisModule_WrongArity(ctx);
+        return REDISMODULE_OK;
+    }
+
+    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_WRITE);
+    RedisModuleString *str = RedisModule_ModuleTypeGetValue(key);
+    if (str)
+        RedisModule_FreeString(ctx, str);
+    RedisModule_ModuleTypeSetValue(key, testrdb_type, argv[2]);
+    RedisModule_RetainString(ctx, argv[2]);
+    RedisModule_CloseKey(key);
+    RedisModule_ReplyWithLongLong(ctx, 1);
+    return REDISMODULE_OK;
+}
+
+int testrdb_get_key(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
+{
+    if (argc != 2){
+        RedisModule_WrongArity(ctx);
+        return REDISMODULE_OK;
+    }
+
+    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_WRITE);
+    RedisModuleString *str = RedisModule_ModuleTypeGetValue(key);
+    RedisModule_CloseKey(key);
+    RedisModule_ReplyWithString(ctx, str);
+    return REDISMODULE_OK;
+}
+
+int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
+    REDISMODULE_NOT_USED(argv);
+    REDISMODULE_NOT_USED(argc);
+
+    if (RedisModule_Init(ctx,"testrdb",1,REDISMODULE_APIVER_1) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    if (argc > 0)
+        RedisModule_StringToLongLong(argv[0], &conf_aux_count);
+
+    if (conf_aux_count==0) {
+        RedisModuleTypeMethods datatype_methods = {
+            .version = 1,
+            .rdb_load = testrdb_type_load,
+            .rdb_save = testrdb_type_save,
+            .aof_rewrite = NULL,
+            .digest = NULL,
+            .free = testrdb_type_free,
+        };
+
+        testrdb_type = RedisModule_CreateDataType(ctx, "test__rdb", 1, &datatype_methods);
+        if (testrdb_type == NULL)
+            return REDISMODULE_ERR;
+    } else {
+        RedisModuleTypeMethods datatype_methods = {
+            .version = REDISMODULE_TYPE_METHOD_VERSION,
+            .rdb_load = testrdb_type_load,
+            .rdb_save = testrdb_type_save,
+            .aof_rewrite = NULL,
+            .digest = NULL,
+            .free = testrdb_type_free,
+            .aux_load = testrdb_aux_load,
+            .aux_save = testrdb_aux_save,
+            .aux_save_triggers = (conf_aux_count == 1 ?
+                                  REDISMODULE_AUX_AFTER_RDB :
+                                  REDISMODULE_AUX_BEFORE_RDB | REDISMODULE_AUX_AFTER_RDB)
+        };
+
+        testrdb_type = RedisModule_CreateDataType(ctx, "test__rdb", 1, &datatype_methods);
+        if (testrdb_type == NULL)
+            return REDISMODULE_ERR;
+    }
+
+    if (RedisModule_CreateCommand(ctx,"testrdb.set.before", testrdb_set_before,"deny-oom",0,0,0) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    if (RedisModule_CreateCommand(ctx,"testrdb.get.before", testrdb_get_before,"",0,0,0) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    if (RedisModule_CreateCommand(ctx,"testrdb.set.after", testrdb_set_after,"deny-oom",0,0,0) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    if (RedisModule_CreateCommand(ctx,"testrdb.get.after", testrdb_get_after,"",0,0,0) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    if (RedisModule_CreateCommand(ctx,"testrdb.set.key", testrdb_set_key,"deny-oom",1,1,1) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    if (RedisModule_CreateCommand(ctx,"testrdb.get.key", testrdb_get_key,"",1,1,1) == REDISMODULE_ERR)
+        return REDISMODULE_ERR;
+
+    return REDISMODULE_OK;
+}
diff --git a/tests/unit/moduleapi/testrdb.tcl b/tests/unit/moduleapi/testrdb.tcl
new file mode 100644
index 000000000..22201a08e
--- /dev/null
+++ b/tests/unit/moduleapi/testrdb.tcl
@@ -0,0 +1,62 @@
+set testmodule [file normalize tests/modules/testrdb.so]
+
+proc restart_and_wait {} {
+    catch {
+        r debug restart
+    }
+
+    # wait for the server to come back up
+    set retry 50
+    while {$retry} {
+        if {[catch { r ping }]} {
+            after 100
+        } else {
+            break
+        }
+        incr retry -1
+    }
+}
+
+tags "modules" {
+    start_server [list overrides [list loadmodule "$testmodule"]] {
+        test {modules are able to persist types} {
+            r testrdb.set.key key1 value1
+            assert_equal "value1" [r testrdb.get.key key1]
+            r debug reload
+            assert_equal "value1" [r testrdb.get.key key1]
+        }
+
+        test {modules global are lost without aux} {
+            r testrdb.set.before global1
+            assert_equal "global1" [r testrdb.get.before]
+            restart_and_wait
+            assert_equal "" [r testrdb.get.before]
+        }
+    }
+
+    start_server [list overrides [list loadmodule "$testmodule 2"]] {
+        test {modules are able to persist globals before and after} {
+            r testrdb.set.before global1
+            r testrdb.set.after global2
+            assert_equal "global1" [r testrdb.get.before]
+            assert_equal "global2" [r testrdb.get.after]
+            restart_and_wait
+            assert_equal "global1" [r testrdb.get.before]
+            assert_equal "global2" [r testrdb.get.after]
+        }
+
+    }
+
+    start_server [list overrides [list loadmodule "$testmodule 1"]] {
+        test {modules are able to persist globals just after} {
+            r testrdb.set.after global2
+            assert_equal "global2" [r testrdb.get.after]
+            restart_and_wait
+            assert_equal "global2" [r testrdb.get.after]
+        }
+    }
+
+
+    # TODO: test short read handling
+
+}

commit f674e83215af5f15096bf53a27de6c4ccf21faae
Merge: a72ab70fe 48d591a01
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue May 7 10:25:13 2019 +0200

    Merge pull request #6082 from soloestoy/fix-config-rewrite-memleak
    
    fix memory leak when rewrite config file

[ML] commit 48d591a010bbe4cf0c09a4d84a55ee3f31e5664f
Author: zhaozhao.zz <zhaozhao.zz@alibaba-inc.com>
Date:   Tue May 7 15:59:16 2019 +0800

    fix memory leak when rewrite config file

diff --git a/src/config.c b/src/config.c
index 1686743a0..7f0e9af89 100644
--- a/src/config.c
+++ b/src/config.c
@@ -1711,12 +1711,11 @@ void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *
  * If the old file does not exist at all, an empty state is returned. */
 struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
     FILE *fp = fopen(path,"r");
-    struct rewriteConfigState *state = zmalloc(sizeof(*state));
-    char buf[CONFIG_MAX_LINE+1];
-    int linenum = -1;
-
     if (fp == NULL && errno != ENOENT) return NULL;
 
+    char buf[CONFIG_MAX_LINE+1];
+    int linenum = -1;
+    struct rewriteConfigState *state = zmalloc(sizeof(*state));
     state->option_to_line = dictCreate(&optionToLineDictType,NULL);
     state->rewritten = dictCreate(&optionSetDictType,NULL);
     state->numlines = 0;

[ML] commit c24e32041b91ac32626e8d8eee1c062942e25f27
Author: antirez <antirez@gmail.com>
Date:   Mon Apr 8 18:08:37 2019 +0200

    ACL: Fix memory leak in ACLResetSubcommandsForCommand().
    
    This commit fixes bug reported at #5998. Thanks to @tomcat1102.

diff --git a/src/acl.c b/src/acl.c
index d9f431f4f..0205e51ad 100644
--- a/src/acl.c
+++ b/src/acl.c
@@ -542,6 +542,8 @@ struct redisCommand *ACLLookupCommand(const char *name) {
  * and command ID. */
 void ACLResetSubcommandsForCommand(user *u, unsigned long id) {
     if (u->allowed_subcommands && u->allowed_subcommands[id]) {
+        for (int i = 0; u->allowed_subcommands[id][i]; i++)
+            sdsfree(u->allowed_subcommands[id][i]);
         zfree(u->allowed_subcommands[id]);
         u->allowed_subcommands[id] = NULL;
     }
diff --git a/tests/unit/acl.tcl b/tests/unit/acl.tcl
index 90f2c9bbf..058441433 100644
--- a/tests/unit/acl.tcl
+++ b/tests/unit/acl.tcl
@@ -109,7 +109,7 @@ start_server {tags {"acl"}} {
         assert_match {*+acl*} $cmdstr
     }
 
-    test {ACL regression: memory leaks adding / removing subcommands} {
+    test {ACL #5998 regression: memory leaks adding / removing subcommands} {
         r AUTH default ""
         r ACL setuser newuser reset -debug +debug|a +debug|b +debug|c
         r ACL setuser newuser -debug

[ML] commit 121adc604b4cee16fd5af15456bbb7665f37ce71
Author: Artix <artix2@gmail.com>
Date:   Wed Jun 6 20:14:58 2018 +0200

    Cluster Manager: fix memory leaks in clusterManagerGetDisconnectedLinks

diff --git a/src/redis-cli.c b/src/redis-cli.c
index 9e246dce7..71c8c6b30 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -3889,7 +3889,7 @@ static list *clusterManagerGetDisconnectedLinks(clusterManagerNode *node) {
                             (strstr(link_status, "disconnected")));
         int handshaking = (strstr(flags, "handshake") != NULL);
         if (disconnected || handshaking) {
-            clusterManagerLink *link = malloc(sizeof(*link)); 
+            clusterManagerLink *link = zmalloc(sizeof(*link)); 
             link->node_name = sdsnew(nodename);
             link->node_addr = sdsnew(addr);
             link->connected = 0;
@@ -3908,6 +3908,7 @@ cleanup:
 static dict *clusterManagerGetLinkStatus(void) {
     if (cluster_manager.nodes == NULL) return NULL;
     dictType dtype = clusterManagerDictType;
+    dtype.keyDestructor = dictSdsDestructor;
     dtype.valDestructor = dictListDestructor;
     dict *status = dictCreate(&dtype, NULL);
     listIter li;

[ML] commit b013d2c4dbea97544239deebe7a8f5a19f2b5604
Author: artix <artix2@gmail.com>
Date:   Wed Jun 6 18:45:31 2018 +0200

    Cluster Manager: fix memory leak in clusterManagerWaitForClusterJoin

diff --git a/src/redis-cli.c b/src/redis-cli.c
index 9ff4dfb9f..9e246dce7 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -3413,11 +3413,12 @@ static void clusterManagerWaitForClusterJoin(void) {
         sleep(1);
         if (++counter > check_after) {
             dict *status = clusterManagerGetLinkStatus();
+            dictIterator *iter = NULL;
             if (status != NULL && dictSize(status) > 0) {
                 printf("\n");
                 clusterManagerLogErr("Warning: %d node(s) may "
                                      "be unreachable\n", dictSize(status));
-                dictIterator *iter = dictGetIterator(status);
+                iter = dictGetIterator(status);
                 dictEntry *entry;
                 while ((entry = dictNext(iter)) != NULL) {
                     sds nodeaddr = (sds) dictGetKey(entry);
@@ -3447,11 +3448,11 @@ static void clusterManagerWaitForClusterJoin(void) {
                                          "from standard instance port.\n");
                     listEmpty(from);
                 }
-                dictReleaseIterator(iter);
-                dictRelease(status);
             }
+            if (iter != NULL) dictReleaseIterator(iter);
+            if (status != NULL) dictRelease(status);
             counter = 0;
-        } 
+        }
     }
     printf("\n");
 }

[ML] commit 9db2c84984739008c5cd911943ea97775fc32045
Author: antirez <antirez@gmail.com>
Date:   Wed Jan 30 11:50:30 2019 +0100

    ACL: free memory leak when freeing subcommands array.

diff --git a/src/acl.c b/src/acl.c
index 5f4185170..da7c0bd49 100644
--- a/src/acl.c
+++ b/src/acl.c
@@ -385,8 +385,13 @@ void ACLResetSubcommandsForCommand(user *u, unsigned long id) {
  * for the user. */
 void ACLResetSubcommands(user *u) {
     if (u->allowed_subcommands == NULL) return;
-    for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++)
-        if (u->allowed_subcommands[j]) zfree(u->allowed_subcommands[j]);
+    for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
+        if (u->allowed_subcommands[j]) {
+            for (int i = 0; u->allowed_subcommands[j][i]; i++)
+                sdsfree(u->allowed_subcommands[j][i]);
+            zfree(u->allowed_subcommands[j]);
+        }
+    }
     zfree(u->allowed_subcommands);
     u->allowed_subcommands = NULL;
 }

commit d5fe17dc11cc982f8d2e394cb54746f29ea0bc2d
Merge: b82d35688 1aa9fa37e
Author: antirez <antirez@gmail.com>
Date:   Fri Jan 25 13:00:30 2019 +0100

    Merge branch 'unstable' of github.com:/antirez/redis into unstable

commit 94460440b7ada26d27e81d0fa5fcef1b3f0f68c7
Merge: ed356c3a7 2925bdc63
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue Jan 22 17:29:37 2019 +0100

    Merge pull request #5743 from AngusP/forever-repeat-cli
    
    Redis CLI: Fix broken interval and repeat behaviour (incluing in cluster mode)

[DF] commit c90cf3d82f3288762441f2c287a21301c8be0ae7
Author: Zhicheng Wei <zhicheng@opensourceforge.net>
Date:   Sat Jan 19 11:38:36 2019 +0800

    fix clusterManagerGetAntiAffinityScore double free otypes

diff --git a/src/redis-cli.c b/src/redis-cli.c
index a74493ef0..b00a4861e 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -2471,9 +2471,10 @@ static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
             }
             // Master type 'm' is always set as the first character of the
             // types string.
+            otypes = sdsdup(otypes);
             if (!node->replicate) types = sdscatprintf(otypes, "m%s", otypes);
             else types = sdscat(otypes, "s");
-            if (types != otypes) dictReplace(related, key, types);
+            dictReplace(related, key, types);
         }
         /* Now it's trivial to check, for each related group having the
          * same host, what is their local score. */

commit f07205e48cab5577dbae10ac7540369ccbfcc9c5
Merge: 0d166674f cc2959018
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Wed Dec 19 17:24:38 2018 +0100

    Merge pull request #5709 from artix75/cluster_manager_fix_cmd
    
    Fixed memory leak in clusterManagerCompareKeysValues.

[ML] commit cc29590188a22eb73cfbbef39fce73c7467b1edf
Author: artix <artix2@gmail.com>
Date:   Tue Dec 18 18:39:21 2018 +0100

    Fixed memory leak in clusterManagerCompareKeysValues.

diff --git a/src/redis-cli.c b/src/redis-cli.c
index b0a12ebb9..705c7483f 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -2993,6 +2993,8 @@ static int clusterManagerCompareKeysValues(clusterManagerNode *n1,
 cleanup:
     if (r1) freeReplyObject(r1);
     if (r2) freeReplyObject(r2);
+    zfree(argv);
+    zfree(argv_len);
     return success;
 }
 

commit 81008bf99e131a2e56ccf467a6c60debb522759f
Merge: 129f2d274 d935cfcb8
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Wed Dec 12 13:39:53 2018 +0100

    Merge pull request #5691 from artix75/cluster_manager_fix_cmd
    
    Cluster Manager: avoid using reply error messages to check slot status.

commit 8acc07e6f097f20701813f9caa01e038e4226886
Merge: 30a455f14 64324901f
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue Nov 20 10:38:59 2018 +0100

    Merge pull request #5579 from yongman/fix-rediscli-pointer-access
    
    Fix pointer access and memory leak in redis-cli.

[ML] commit 64324901f22946a93226e0af56a6e59b2290be09
Author: yongman <yming0221@gmail.com>
Date:   Fri Nov 16 17:20:53 2018 +0800

    Fix pointer access and memory leak in redis-cli.

diff --git a/src/redis-cli.c b/src/redis-cli.c
index 1aa6751f7..4f68be200 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -2829,7 +2829,7 @@ static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
             if (err != NULL) {
                 *err = zmalloc((reply->len + 1) * sizeof(char));
                 strcpy(*err, reply->str);
-                CLUSTER_MANAGER_PRINT_REPLY_ERROR(source, err);
+                CLUSTER_MANAGER_PRINT_REPLY_ERROR(source, *err);
             }
             goto next;
         }
@@ -2947,7 +2947,7 @@ static int clusterManagerMoveSlot(clusterManagerNode *source,
                 if (err != NULL) {
                     *err = zmalloc((r->len + 1) * sizeof(char));
                     strcpy(*err, r->str);
-                    CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err);
+                    CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, *err);
                 }
             }
             freeReplyObject(r);
@@ -5196,10 +5196,13 @@ static int clusterManagerCommandSetTimeout(int argc, char **argv) {
                               n->port);
         ok_count++;
         continue;
-reply_err:
+reply_err:;
+        int need_free = 0;
         if (err == NULL) err = "";
+        else need_free = 1;
         clusterManagerLogErr("ERR setting node-timeot for %s:%d: %s\n", n->ip,
                              n->port, err);
+        if (need_free) zfree(err);
         err_count++;
     }
     clusterManagerLogInfo(">>> New node timeout set. %d OK, %d ERR.\n",

commit 093adb7ef9719ea70d7df1af6aec31a5a2af46c7
Merge: b0392e75e 35ca67006
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue Jul 31 17:11:16 2018 +0200

    Merge pull request #5191 from shenlongxing/fix-memory-leak
    
    Fix cluster-announce-ip memory leak

[ML] commit 35ca6700600f2b1991e71e6196ec03ba4bad997f
Author: shenlongxing <shenlongxing2012@gmail.com>
Date:   Tue Jul 31 16:01:44 2018 +0800

    Fix cluster-announce-ip memory leak

diff --git a/src/cluster.c b/src/cluster.c
index 8b76d9ad0..7a6a5f782 100644
--- a/src/cluster.c
+++ b/src/cluster.c
@@ -3325,10 +3325,11 @@ void clusterCron(void) {
         if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;
 
         if (changed) {
-            prev_ip = curr_ip;
-            if (prev_ip) prev_ip = zstrdup(prev_ip);
+            if (prev_ip) zfree(prev_ip);
 
+            prev_ip = curr_ip;
             if (curr_ip) {
+                prev_ip = zstrdup(prev_ip);
                 strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
                 myself->ip[NET_IP_STR_LEN-1] = '\0';
             } else {

commit 73cbc33a0ae4b01ef026dc6975492e1297808b5e
Merge: 0bdeb861f eb0e5fe4e
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Tue Jul 24 18:57:05 2018 +0200

    Merge pull request #5133 from soloestoy/fix-xdel-memory-leak
    
    Streams: fix xdel memory leak

[ML] commit eb0e5fe4e3b31c2b6cfebbe95324ce488211d372
Author: zhaozhao.zz <zhaozhao.zz@alibaba-inc.com>
Date:   Wed Jul 25 00:06:27 2018 +0800

    Streams: fix xdel memory leak

diff --git a/src/t_stream.c b/src/t_stream.c
index 7b1076b16..5a5263325 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -757,6 +757,7 @@ int streamDeleteItem(stream *s, streamID *id) {
         streamIteratorRemoveEntry(&si,&myid);
         deleted = 1;
     }
+    streamIteratorStop(&si);
     return deleted;
 }
 

commit b23a501135e573e285522d7f74982c3fb3fde2ab
Merge: 18b7f7113 c8ca71d40
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Thu May 24 16:16:12 2018 +0200

    Merge pull request #4099 from JunHe77/aarch64_stack_cflag
    
    Fixed stack trace generation on aarch64

[ML] commit 46e241ac8e5918c2d774752346bc9b6fd4b0adeb
Author: dejun.xdj <dejun.xdj@alibaba-inc.com>
Date:   Mon May 21 12:19:37 2018 +0800

    Fix redis-cli memory leak when sending set preference command.

diff --git a/src/redis-cli.c b/src/redis-cli.c
index d80973e75..1003e3768 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -1412,6 +1412,8 @@ static void repl(void) {
                     exit(0);
                 } else if (argv[0][0] == ':') {
                     cliSetPreferences(argv,argc,1);
+                    sdsfreesplitres(argv,argc);
+                    linenoiseFree(line);
                     continue;
                 } else if (strcasecmp(argv[0],"restart") == 0) {
                     if (config.eval) {

[ML] commit b3e0ca3412edbed27f07e2cd5f62b1506c013029
Author: artix <artix2@gmail.com>
Date:   Wed Jan 31 19:25:02 2018 +0100

    - Cluster Manager: fixed various memory leaks
    - Cluster Manager: fixed flags assignment in
      clusterManagerNodeLoadInfo

diff --git a/src/redis-cli.c b/src/redis-cli.c
index b20cd31d1..a596afca2 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -2310,12 +2310,6 @@ static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
         }         
         if (!flags) goto node_cmd_err;
         int myself = (strstr(flags, "myself") != NULL);
-        if (strstr(flags, "noaddr") != NULL)
-            node->flags |= CLUSTER_MANAGER_FLAG_NOADDR;
-        if (strstr(flags, "disconnected") != NULL)
-            node->flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
-        if (strstr(flags, "fail") != NULL)
-            node->flags |= CLUSTER_MANAGER_FLAG_FAIL;
         clusterManagerNode *currentNode = NULL;
         if (myself) {
             node->flags |= CLUSTER_MANAGER_FLAG_MYSELF;
@@ -2396,10 +2390,22 @@ static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
             if (node->friends == NULL) node->friends = listCreate();
             listAddNodeTail(node->friends, currentNode);
         }
-        if (name != NULL) currentNode->name = sdsnew(name);
+        if (name != NULL) {
+            if (currentNode->name) sdsfree(currentNode->name);
+            currentNode->name = sdsnew(name);
+        }
+        if (strstr(flags, "noaddr") != NULL)
+            currentNode->flags |= CLUSTER_MANAGER_FLAG_NOADDR;
+        if (strstr(flags, "disconnected") != NULL)
+            currentNode->flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
+        if (strstr(flags, "fail") != NULL)
+            currentNode->flags |= CLUSTER_MANAGER_FLAG_FAIL;
         if (strstr(flags, "slave") != NULL) {
             currentNode->flags |= CLUSTER_MANAGER_FLAG_SLAVE;
-            if (master_id != NULL) currentNode->replicate = sdsnew(master_id);
+            if (master_id != NULL) {
+                if (currentNode->replicate) sdsfree(currentNode->replicate);
+                currentNode->replicate = sdsnew(master_id);
+            }
         }
         if (config_epoch != NULL) 
             currentNode->current_epoch = atoll(config_epoch);
@@ -2442,27 +2448,39 @@ static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
         freeClusterManagerNode(node);
         return 0;
     }
+    listIter li;
+    listNode *ln;
+    if (cluster_manager.nodes != NULL) {
+        listRewind(cluster_manager.nodes, &li);
+        while ((ln = listNext(&li)) != NULL) 
+            freeClusterManagerNode((clusterManagerNode *) ln->value);
+        listRelease(cluster_manager.nodes);
+    }
     cluster_manager.nodes = listCreate();
     listAddNodeTail(cluster_manager.nodes, node);
     if (node->friends != NULL) {
-        listIter li;
-        listNode *ln;
         listRewind(node->friends, &li);
         while ((ln = listNext(&li)) != NULL) {
             clusterManagerNode *friend = ln->value;
-            if (!friend->ip || !friend->port) continue;
+            if (!friend->ip || !friend->port) goto invalid_friend;
             if (!friend->context)
                 friend->context = redisConnect(friend->ip, friend->port);
-            if (friend->context->err) continue;
+            if (friend->context->err) goto invalid_friend;
             e = NULL;
             if (clusterManagerNodeLoadInfo(friend, 0, &e)) {
                 if (friend->flags & (CLUSTER_MANAGER_FLAG_NOADDR | 
                                      CLUSTER_MANAGER_FLAG_DISCONNECT | 
-                                     CLUSTER_MANAGER_FLAG_FAIL)) continue;
+                                     CLUSTER_MANAGER_FLAG_FAIL))
+                    goto invalid_friend;
                 listAddNodeTail(cluster_manager.nodes, friend);
-                 
-            } else fprintf(stderr,"[ERR] Unable to load info for node %s:%d\n",
-                           friend->ip, friend->port);
+            } else {
+                fprintf(stderr,"[ERR] Unable to load info for node %s:%d\n",
+                        friend->ip, friend->port);
+                goto invalid_friend;
+            }
+            continue;
+invalid_friend:
+            freeClusterManagerNode(friend);
         }
         listRelease(node->friends);
         node->friends = NULL;
@@ -2601,6 +2619,7 @@ static void clusterManagerCheckCluster(int quiet) {
         CLUSTER_MANAGER_ERROR(err);
     } else printf("[OK] All nodes agree about slots configuration.\n");
     // Check open slots
+    printf(">>> Check for open slots...\n");
     listIter li;
     listRewind(cluster_manager.nodes, &li);
     int i;
@@ -2836,6 +2855,7 @@ assign_replicas:
             if (slave != NULL) {
                 assigned_replicas++;
                 available_count--;
+                if (slave->replicate) sdsfree(slave->replicate);
                 slave->replicate = sdsnew(master->name); 
                 slave->dirty = 1;
             } else break;
@@ -2873,7 +2893,7 @@ assign_replicas:
                     zfree(err);
                 }
                 goto cmd_err;
-            }
+            } else if (err != NULL) zfree(err);
         }
         printf(">>> Nodes configuration updated\n");
         printf(">>> Assign a different config epoch to each node\n");

commit 5d8c89163cdd4105633be1a5dd7a7784775e2143
Merge: 7acf0e0a1 c76f89020
Author: Salvatore Sanfilippo <antirez@gmail.com>
Date:   Thu Mar 22 09:20:17 2018 +0100

    Merge pull request #4757 from charsyam/feature/fix-invalid-listpack-type-in-makefile
    
    fix listpack.c to listpack.o in Makefile

[ML] commit 71c7477fd407cc3d0d08ab8dedc564f30776511d
Author: charsyam <charsyam@gmail.com>
Date:   Wed Mar 21 17:41:59 2018 +0900

    fix memory leak for streamPropagateXCLAIM

diff --git a/src/t_stream.c b/src/t_stream.c
index daf9509d3..4640f0b2c 100644
--- a/src/t_stream.c
+++ b/src/t_stream.c
@@ -712,6 +712,7 @@ void streamPropagateXCLAIM(client *c, robj *key, robj *group, robj *id, streamNA
     decrRefCount(argv[8]);
     decrRefCount(argv[9]);
     decrRefCount(argv[10]);
+    decrRefCount(argv[11]);
 }
 
 /* Send the specified range to the client 'c'. The range the client will

[ML] commit d38045805d45a1b990f38d7c2c2edabb9912f711
Author: artix <artix2@gmail.com>
Date:   Wed Jan 31 19:25:02 2018 +0100

    - Cluster Manager: fixed various memory leaks
    - Cluster Manager: fixed flags assignment in
      clusterManagerNodeLoadInfo

diff --git a/src/redis-cli.c b/src/redis-cli.c
index 456751f58..4c30067b3 100644
--- a/src/redis-cli.c
+++ b/src/redis-cli.c
@@ -2310,12 +2310,6 @@ static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
         }         
         if (!flags) goto node_cmd_err;
         int myself = (strstr(flags, "myself") != NULL);
-        if (strstr(flags, "noaddr") != NULL)
-            node->flags |= CLUSTER_MANAGER_FLAG_NOADDR;
-        if (strstr(flags, "disconnected") != NULL)
-            node->flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
-        if (strstr(flags, "fail") != NULL)
-            node->flags |= CLUSTER_MANAGER_FLAG_FAIL;
         clusterManagerNode *currentNode = NULL;
         if (myself) {
             node->flags |= CLUSTER_MANAGER_FLAG_MYSELF;
@@ -2396,10 +2390,22 @@ static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
             if (node->friends == NULL) node->friends = listCreate();
             listAddNodeTail(node->friends, currentNode);
         }
-        if (name != NULL) currentNode->name = sdsnew(name);
+        if (name != NULL) {
+            if (currentNode->name) sdsfree(currentNode->name);
+            currentNode->name = sdsnew(name);
+        }
+        if (strstr(flags, "noaddr") != NULL)
+            currentNode->flags |= CLUSTER_MANAGER_FLAG_NOADDR;
+        if (strstr(flags, "disconnected") != NULL)
+            currentNode->flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
+        if (strstr(flags, "fail") != NULL)
+            currentNode->flags |= CLUSTER_MANAGER_FLAG_FAIL;
         if (strstr(flags, "slave") != NULL) {
             currentNode->flags |= CLUSTER_MANAGER_FLAG_SLAVE;
-            if (master_id != NULL) currentNode->replicate = sdsnew(master_id);
+            if (master_id != NULL) {
+                if (currentNode->replicate) sdsfree(currentNode->replicate);
+                currentNode->replicate = sdsnew(master_id);
+            }
         }
         if (config_epoch != NULL) 
             currentNode->current_epoch = atoll(config_epoch);
@@ -2442,27 +2448,39 @@ static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
         freeClusterManagerNode(node);
         return 0;
     }
+    listIter li;
+    listNode *ln;
+    if (cluster_manager.nodes != NULL) {
+        listRewind(cluster_manager.nodes, &li);
+        while ((ln = listNext(&li)) != NULL) 
+            freeClusterManagerNode((clusterManagerNode *) ln->value);
+        listRelease(cluster_manager.nodes);
+    }
     cluster_manager.nodes = listCreate();
     listAddNodeTail(cluster_manager.nodes, node);
     if (node->friends != NULL) {
-        listIter li;
-        listNode *ln;
         listRewind(node->friends, &li);
         while ((ln = listNext(&li)) != NULL) {
             clusterManagerNode *friend = ln->value;
-            if (!friend->ip || !friend->port) continue;
+            if (!friend->ip || !friend->port) goto invalid_friend;
             if (!friend->context)
                 friend->context = redisConnect(friend->ip, friend->port);
-            if (friend->context->err) continue;
+            if (friend->context->err) goto invalid_friend;
             e = NULL;
             if (clusterManagerNodeLoadInfo(friend, 0, &e)) {
                 if (friend->flags & (CLUSTER_MANAGER_FLAG_NOADDR | 
                                      CLUSTER_MANAGER_FLAG_DISCONNECT | 
-                                     CLUSTER_MANAGER_FLAG_FAIL)) continue;
+                                     CLUSTER_MANAGER_FLAG_FAIL))
+                    goto invalid_friend;
                 listAddNodeTail(cluster_manager.nodes, friend);
-                 
-            } else fprintf(stderr,"[ERR] Unable to load info for node %s:%d\n",
-                           friend->ip, friend->port);
+            } else {
+                fprintf(stderr,"[ERR] Unable to load info for node %s:%d\n",
+                        friend->ip, friend->port);
+                goto invalid_friend;
+            }
+            continue;
+invalid_friend:
+            freeClusterManagerNode(friend);
         }
         listRelease(node->friends);
         node->friends = NULL;
@@ -2601,6 +2619,7 @@ static void clusterManagerCheckCluster(int quiet) {
         CLUSTER_MANAGER_ERROR(err);
     } else printf("[OK] All nodes agree about slots configuration.\n");
     // Check open slots
+    printf(">>> Check for open slots...\n");
     listIter li;
     listRewind(cluster_manager.nodes, &li);
     int i;
@@ -2836,6 +2855,7 @@ assign_replicas:
             if (slave != NULL) {
                 assigned_replicas++;
                 available_count--;
+                if (slave->replicate) sdsfree(slave->replicate);
                 slave->replicate = sdsnew(master->name); 
                 slave->dirty = 1;
             } else break;
@@ -2873,7 +2893,7 @@ assign_replicas:
                     zfree(err);
                 }
                 goto cmd_err;
-            }
+            } else if (err != NULL) zfree(err);
         }
         printf(">>> Nodes configuration updated\n");
         printf(">>> Assign a different config epoch to each node\n");

