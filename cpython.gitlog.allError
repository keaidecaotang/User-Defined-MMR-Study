[NR] [ML] commit 85c128e34daec7625b74746e127afa25888ccde1
Author: Zackery Spytz <zspytz@gmail.com>
Date:   Fri Nov 25 09:39:48 2022 -0800

    bpo-40882: Fix a memory leak in SharedMemory on Windows (GH-20684)
    
    In multiprocessing.shared_memory.SharedMemory(), the temporary view
    returned by MapViewOfFile() should be unmapped when it is no longer
    needed.

diff --git a/Lib/multiprocessing/shared_memory.py b/Lib/multiprocessing/shared_memory.py
index 881f2001dd..9a1e5aa17b 100644
--- a/Lib/multiprocessing/shared_memory.py
+++ b/Lib/multiprocessing/shared_memory.py
@@ -173,7 +173,10 @@ def __init__(self, name=None, create=False, size=0):
                     )
                 finally:
                     _winapi.CloseHandle(h_map)
-                size = _winapi.VirtualQuerySize(p_buf)
+                try:
+                    size = _winapi.VirtualQuerySize(p_buf)
+                finally:
+                    _winapi.UnmapViewOfFile(p_buf)
                 self._mmap = mmap.mmap(-1, size, tagname=name)
 
         self._size = size
diff --git a/Misc/NEWS.d/next/Windows/2020-06-06-15-10-37.bpo-40882.UvNbdj.rst b/Misc/NEWS.d/next/Windows/2020-06-06-15-10-37.bpo-40882.UvNbdj.rst
new file mode 100644
index 0000000000..2670aeef9a
--- /dev/null
+++ b/Misc/NEWS.d/next/Windows/2020-06-06-15-10-37.bpo-40882.UvNbdj.rst
@@ -0,0 +1,2 @@
+Fix a memory leak in :class:`multiprocessing.shared_memory.SharedMemory` on
+Windows.
diff --git a/Modules/_winapi.c b/Modules/_winapi.c
index 7a9bedb188..bb4514c36b 100644
--- a/Modules/_winapi.c
+++ b/Modules/_winapi.c
@@ -1393,6 +1393,30 @@ _winapi_MapViewOfFile_impl(PyObject *module, HANDLE file_map,
     return address;
 }
 
+/*[clinic input]
+_winapi.UnmapViewOfFile
+
+    address: LPCVOID
+    /
+[clinic start generated code]*/
+
+static PyObject *
+_winapi_UnmapViewOfFile_impl(PyObject *module, LPCVOID address)
+/*[clinic end generated code: output=4f7e18ac75d19744 input=8c4b6119ad9288a3]*/
+{
+    BOOL success;
+
+    Py_BEGIN_ALLOW_THREADS
+    success = UnmapViewOfFile(address);
+    Py_END_ALLOW_THREADS
+
+    if (!success) {
+        return PyErr_SetFromWindowsErr(0);
+    }
+
+    Py_RETURN_NONE;
+}
+
 /*[clinic input]
 _winapi.OpenFileMapping -> HANDLE
 
@@ -2062,6 +2086,7 @@ static PyMethodDef winapi_functions[] = {
     _WINAPI_READFILE_METHODDEF
     _WINAPI_SETNAMEDPIPEHANDLESTATE_METHODDEF
     _WINAPI_TERMINATEPROCESS_METHODDEF
+    _WINAPI_UNMAPVIEWOFFILE_METHODDEF
     _WINAPI_VIRTUALQUERYSIZE_METHODDEF
     _WINAPI_WAITNAMEDPIPE_METHODDEF
     _WINAPI_WAITFORMULTIPLEOBJECTS_METHODDEF
diff --git a/Modules/clinic/_winapi.c.h b/Modules/clinic/_winapi.c.h
index cc1a5881e0..13bf8b482c 100644
--- a/Modules/clinic/_winapi.c.h
+++ b/Modules/clinic/_winapi.c.h
@@ -742,6 +742,32 @@ exit:
     return return_value;
 }
 
+PyDoc_STRVAR(_winapi_UnmapViewOfFile__doc__,
+"UnmapViewOfFile($module, address, /)\n"
+"--\n"
+"\n");
+
+#define _WINAPI_UNMAPVIEWOFFILE_METHODDEF    \
+    {"UnmapViewOfFile", (PyCFunction)_winapi_UnmapViewOfFile, METH_O, _winapi_UnmapViewOfFile__doc__},
+
+static PyObject *
+_winapi_UnmapViewOfFile_impl(PyObject *module, LPCVOID address);
+
+static PyObject *
+_winapi_UnmapViewOfFile(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    LPCVOID address;
+
+    if (!PyArg_Parse(arg, "" F_POINTER ":UnmapViewOfFile", &address)) {
+        goto exit;
+    }
+    return_value = _winapi_UnmapViewOfFile_impl(module, address);
+
+exit:
+    return return_value;
+}
+
 PyDoc_STRVAR(_winapi_OpenFileMapping__doc__,
 "OpenFileMapping($module, desired_access, inherit_handle, name, /)\n"
 "--\n"
@@ -1345,4 +1371,4 @@ _winapi__mimetypes_read_windows_registry(PyObject *module, PyObject *const *args
 exit:
     return return_value;
 }
-/*[clinic end generated code: output=83c4a3f0e70e7775 input=a9049054013a1b77]*/
+/*[clinic end generated code: output=23ea9e176d86e026 input=a9049054013a1b77]*/

[NR] [ML] commit 995f6170c78570eca818f7e7dbd8a7661c171a81
Author: Dong Uk, Kang <nailbrainz@gmail.com>
Date:   Wed Nov 23 00:06:20 2022 +0900

    gh-88863: Clear ref cycles to resolve leak when asyncio.open_connection raises (#95739)
    
    Break reference cycles to resolve memory leak, by
    removing local exception and future instances from the frame

diff --git a/Lib/asyncio/base_events.py b/Lib/asyncio/base_events.py
index c8a2f9f256..91d32e3939 100644
--- a/Lib/asyncio/base_events.py
+++ b/Lib/asyncio/base_events.py
@@ -986,6 +986,8 @@ async def _connect_sock(self, exceptions, addr_info, local_addr_infos=None):
             if sock is not None:
                 sock.close()
             raise
+        finally:
+            exceptions = my_exceptions = None
 
     async def create_connection(
             self, protocol_factory, host=None, port=None,
@@ -1084,19 +1086,22 @@ async def create_connection(
 
             if sock is None:
                 exceptions = [exc for sub in exceptions for exc in sub]
-                if all_errors:
-                    raise ExceptionGroup("create_connection failed", exceptions)
-                if len(exceptions) == 1:
-                    raise exceptions[0]
-                else:
-                    # If they all have the same str(), raise one.
-                    model = str(exceptions[0])
-                    if all(str(exc) == model for exc in exceptions):
+                try:
+                    if all_errors:
+                        raise ExceptionGroup("create_connection failed", exceptions)
+                    if len(exceptions) == 1:
                         raise exceptions[0]
-                    # Raise a combined exception so the user can see all
-                    # the various error messages.
-                    raise OSError('Multiple exceptions: {}'.format(
-                        ', '.join(str(exc) for exc in exceptions)))
+                    else:
+                        # If they all have the same str(), raise one.
+                        model = str(exceptions[0])
+                        if all(str(exc) == model for exc in exceptions):
+                            raise exceptions[0]
+                        # Raise a combined exception so the user can see all
+                        # the various error messages.
+                        raise OSError('Multiple exceptions: {}'.format(
+                            ', '.join(str(exc) for exc in exceptions)))
+                finally:
+                    exceptions = None
 
         else:
             if sock is None:
@@ -1904,6 +1909,8 @@ def _run_once(self):
 
         event_list = self._selector.select(timeout)
         self._process_events(event_list)
+        # Needed to break cycles when an exception occurs.
+        event_list = None
 
         # Handle 'later' callbacks that are ready.
         end_time = self.time() + self._clock_resolution
diff --git a/Lib/asyncio/selector_events.py b/Lib/asyncio/selector_events.py
index bfa4590154..3d30006198 100644
--- a/Lib/asyncio/selector_events.py
+++ b/Lib/asyncio/selector_events.py
@@ -633,7 +633,11 @@ async def sock_connect(self, sock, address):
 
         fut = self.create_future()
         self._sock_connect(fut, sock, address)
-        return await fut
+        try:
+            return await fut
+        finally:
+            # Needed to break cycles when an exception occurs.
+            fut = None
 
     def _sock_connect(self, fut, sock, address):
         fd = sock.fileno()
@@ -655,6 +659,8 @@ def _sock_connect(self, fut, sock, address):
             fut.set_exception(exc)
         else:
             fut.set_result(None)
+        finally:
+            fut = None
 
     def _sock_write_done(self, fd, fut, handle=None):
         if handle is None or not handle.cancelled():
@@ -678,6 +684,8 @@ def _sock_connect_cb(self, fut, sock, address):
             fut.set_exception(exc)
         else:
             fut.set_result(None)
+        finally:
+            fut = None
 
     async def sock_accept(self, sock):
         """Accept a connection.
diff --git a/Lib/asyncio/windows_events.py b/Lib/asyncio/windows_events.py
index acc97daafe..4dad436fb4 100644
--- a/Lib/asyncio/windows_events.py
+++ b/Lib/asyncio/windows_events.py
@@ -439,7 +439,11 @@ def select(self, timeout=None):
             self._poll(timeout)
         tmp = self._results
         self._results = []
-        return tmp
+        try:
+            return tmp
+        finally:
+            # Needed to break cycles when an exception occurs.
+            tmp = None
 
     def _result(self, value):
         fut = self._loop.create_future()
@@ -793,6 +797,8 @@ def _poll(self, timeout=None):
                 else:
                     f.set_result(value)
                     self._results.append(f)
+                finally:
+                    f = None
 
         # Remove unregistered futures
         for ov in self._unregistered:
diff --git a/Misc/NEWS.d/next/Library/2022-08-06-12-18-07.gh-issue-88863.NnqsuJ.rst b/Misc/NEWS.d/next/Library/2022-08-06-12-18-07.gh-issue-88863.NnqsuJ.rst
new file mode 100644
index 0000000000..23f8cb01cf
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-08-06-12-18-07.gh-issue-88863.NnqsuJ.rst
@@ -0,0 +1,3 @@
+To avoid apparent memory leaks when :func:`asyncio.open_connection` raises,
+break reference cycles generated by local exception and future instances
+(which has exception instance as its member var). Patch by Dong Uk, Kang.

[ML] commit ab575050709e2b313ca9a9585f09b6f4b0560318
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Tue Nov 1 07:48:32 2022 +0530

    GH-98897: fix memory leak if `math.dist` raises exception (GH-98898)

diff --git a/Lib/test/test_math.py b/Lib/test/test_math.py
index cfaf3b3ea2..bf0d0a56e6 100644
--- a/Lib/test/test_math.py
+++ b/Lib/test/test_math.py
@@ -1006,6 +1006,11 @@ class T(tuple):
             self.assertEqual(math.dist(p, q), 5*scale)
             self.assertEqual(math.dist(q, p), 5*scale)
 
+    def test_math_dist_leak(self):
+        # gh-98897: Check for error handling does not leak memory
+        with self.assertRaises(ValueError):
+            math.dist([1, 2], [3, 4, 5])
+
     def testIsqrt(self):
         # Test a variety of inputs, large and small.
         test_values = (
diff --git a/Misc/NEWS.d/next/Library/2022-10-31-12-34-03.gh-issue-98897.rgNn4x.rst b/Misc/NEWS.d/next/Library/2022-10-31-12-34-03.gh-issue-98897.rgNn4x.rst
new file mode 100644
index 0000000000..f61af2543c
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-10-31-12-34-03.gh-issue-98897.rgNn4x.rst
@@ -0,0 +1 @@
+Fix memory leak in :func:`math.dist` when both points don't have the same dimension. Patch by Kumar Aditya.
diff --git a/Modules/mathmodule.c b/Modules/mathmodule.c
index 48625c8c18..46427876b8 100644
--- a/Modules/mathmodule.c
+++ b/Modules/mathmodule.c
@@ -2717,13 +2717,13 @@ math_dist_impl(PyObject *module, PyObject *p, PyObject *q)
     if (m != n) {
         PyErr_SetString(PyExc_ValueError,
                         "both points must have the same number of dimensions");
-        return NULL;
-
+        goto error_exit;
     }
     if (n > NUM_STACK_ELEMS) {
         diffs = (double *) PyObject_Malloc(n * sizeof(double));
         if (diffs == NULL) {
-            return PyErr_NoMemory();
+            PyErr_NoMemory();
+            goto error_exit;
         }
     }
     for (i=0 ; i<n ; i++) {

[ML] commit be4099e55d30a2991b46add59ee96c531904c144
Author: Carl Meyer <carl@oddbird.net>
Date:   Fri Oct 7 08:17:41 2022 -0700

    Fix memory leaks in test_capi (#98017)

diff --git a/Lib/test/test_capi.py b/Lib/test/test_capi.py
index cb90d55941..19367dfcc1 100644
--- a/Lib/test/test_capi.py
+++ b/Lib/test/test_capi.py
@@ -1495,6 +1495,9 @@ def unraisable_hook(unraisable):
         unraisable = unraisables[0]
         self.assertIs(unraisable.object, d)
         self.assertEqual(str(unraisable.exc_value), "boom!")
+        # avoid leaking reference cycles
+        del unraisable
+        del unraisables
 
     def test_two_watchers(self):
         d1 = {}
diff --git a/Modules/_testcapimodule.c b/Modules/_testcapimodule.c
index c57dba4a5b..28fb43dce4 100644
--- a/Modules/_testcapimodule.c
+++ b/Modules/_testcapimodule.c
@@ -5210,6 +5210,7 @@ dict_watch_callback(PyDict_WatchEvent event,
         Py_DECREF(msg);
         return -1;
     }
+    Py_DECREF(msg);
     return 0;
 }
 
@@ -5224,8 +5225,10 @@ dict_watch_callback_second(PyDict_WatchEvent event,
         return -1;
     }
     if (PyList_Append(g_dict_watch_events, msg) < 0) {
+        Py_DECREF(msg);
         return -1;
     }
+    Py_DECREF(msg);
     return 0;
 }
 

[NR][UAF] commit 67444902a0f10419a557d0a2d3b8675c31b075a9
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Tue Sep 6 23:32:41 2022 +0530

    GH-96572: fix use after free in trace refs build mode (#96618)

diff --git a/Misc/NEWS.d/next/Core and Builtins/2022-09-06-16-54-49.gh-issue-96572.8DRsaW.rst b/Misc/NEWS.d/next/Core and Builtins/2022-09-06-16-54-49.gh-issue-96572.8DRsaW.rst
new file mode 100644
index 0000000000..44cceb46c2
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2022-09-06-16-54-49.gh-issue-96572.8DRsaW.rst	
@@ -0,0 +1 @@
+Fix use after free in trace refs build mode. Patch by Kumar Aditya.
diff --git a/Python/ceval.c b/Python/ceval.c
index c2fa908535..971f6f177c 100644
--- a/Python/ceval.c
+++ b/Python/ceval.c
@@ -46,7 +46,7 @@
 #  error "ceval.c must be build with Py_BUILD_CORE define for best performance"
 #endif
 
-#ifndef Py_DEBUG
+#if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS)
 // GH-89279: The MSVC compiler does not inline these static inline functions
 // in PGO build in _PyEval_EvalFrameDefault(), because this function is over
 // the limit of PGO, and that limit cannot be configured.

[ML] commit 01ef1f95dab9c9930ce1a23634a3e5a8331bf3c7
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Tue Jun 28 12:31:43 2022 +0530

    GH-89988: Fix memory leak in pickle.Pickler dispatch_table lookup (GH-94298)

diff --git a/Lib/test/test_pickle.py b/Lib/test/test_pickle.py
index 057af21e71..44fdca7a6b 100644
--- a/Lib/test/test_pickle.py
+++ b/Lib/test/test_pickle.py
@@ -154,6 +154,29 @@ def persistent_id(obj):
                 return obj
         check(PersPickler)
 
+    @support.cpython_only
+    def test_custom_pickler_dispatch_table_memleak(self):
+        # See https://github.com/python/cpython/issues/89988
+
+        class Pickler(self.pickler):
+            def __init__(self, *args, **kwargs):
+                self.dispatch_table = table
+                super().__init__(*args, **kwargs)
+
+        class DispatchTable:
+            pass
+
+        table = DispatchTable()
+        pickler = Pickler(io.BytesIO())
+        self.assertIs(pickler.dispatch_table, table)
+        table_ref = weakref.ref(table)
+        self.assertIsNotNone(table_ref())
+        del pickler
+        del table
+        support.gc_collect()
+        self.assertIsNone(table_ref())
+
+
     @support.cpython_only
     def test_unpickler_reference_cycle(self):
         def check(Unpickler):
diff --git a/Misc/NEWS.d/next/Library/2022-06-26-10-59-15.gh-issue-89988.K8rnmt.rst b/Misc/NEWS.d/next/Library/2022-06-26-10-59-15.gh-issue-89988.K8rnmt.rst
new file mode 100644
index 0000000000..811a8d6031
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-06-26-10-59-15.gh-issue-89988.K8rnmt.rst
@@ -0,0 +1 @@
+Fix memory leak in :class:`pickle.Pickler` when looking up :attr:`dispatch_table`. Patch by Kumar Aditya.
diff --git a/Modules/_pickle.c b/Modules/_pickle.c
index 1c5de30b07..52704b0c59 100644
--- a/Modules/_pickle.c
+++ b/Modules/_pickle.c
@@ -4761,7 +4761,9 @@ _pickle_Pickler___init___impl(PicklerObject *self, PyObject *file,
     {
         return -1;
     }
-
+    if (self->dispatch_table != NULL) {
+        return 0;
+    }
     if (_PyObject_LookupAttr((PyObject *)self, &_Py_ID(dispatch_table),
                              &self->dispatch_table) < 0) {
         return -1;

[ML] commit 6b865349aae47b90f9ef0b98f3fe3720c2f05601
Author: Mark Dickinson <mdickinson@enthought.com>
Date:   Sat Jun 25 15:11:58 2022 +0100

    gh-94207: Fix struct module leak (GH-94239)
    
    Make _struct.Struct a GC type
    
    This fixes a memory leak in the _struct module, where as soon
    as a Struct object is stored in the cache, there's a cycle from
    the _struct module to the cache to Struct objects to the Struct
    type back to the module. If _struct.Struct is not gc-tracked, that
    cycle is never collected.
    
    This PR makes _struct.Struct GC-tracked, and adds a regression test.

diff --git a/Lib/test/test_struct.py b/Lib/test/test_struct.py
index 94873ff612..8f14ed3058 100644
--- a/Lib/test/test_struct.py
+++ b/Lib/test/test_struct.py
@@ -1,10 +1,12 @@
 from collections import abc
 import array
+import gc
 import math
 import operator
 import unittest
 import struct
 import sys
+import weakref
 
 from test import support
 from test.support import import_helper
@@ -672,6 +674,21 @@ def __del__(self):
         self.assertIn(b"Exception ignored in:", stderr)
         self.assertIn(b"C.__del__", stderr)
 
+    def test__struct_reference_cycle_cleaned_up(self):
+        # Regression test for python/cpython#94207.
+
+        # When we create a new struct module, trigger use of its cache,
+        # and then delete it ...
+        _struct_module = import_helper.import_fresh_module("_struct")
+        module_ref = weakref.ref(_struct_module)
+        _struct_module.calcsize("b")
+        del _struct_module
+
+        # Then the module should have been garbage collected.
+        gc.collect()
+        self.assertIsNone(
+            module_ref(), "_struct module was not garbage collected")
+
     def test_issue35714(self):
         # Embedded null characters should not be allowed in format strings.
         for s in '\0', '2\0i', b'\0':
diff --git a/Misc/NEWS.d/next/Library/2022-06-24-19-23-59.gh-issue-94207.VhS1eS.rst b/Misc/NEWS.d/next/Library/2022-06-24-19-23-59.gh-issue-94207.VhS1eS.rst
new file mode 100644
index 0000000000..3d38524ac0
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-06-24-19-23-59.gh-issue-94207.VhS1eS.rst
@@ -0,0 +1,2 @@
+Made :class:`_struct.Struct` GC-tracked in order to fix a reference leak in
+the :mod:`_struct` module.
diff --git a/Modules/_struct.c b/Modules/_struct.c
index 4daf9529d8..20307ad15b 100644
--- a/Modules/_struct.c
+++ b/Modules/_struct.c
@@ -1496,10 +1496,26 @@ Struct___init___impl(PyStructObject *self, PyObject *format)
     return ret;
 }
 
+static int
+s_clear(PyStructObject *s)
+{
+    Py_CLEAR(s->s_format);
+    return 0;
+}
+
+static int
+s_traverse(PyStructObject *s, visitproc visit, void *arg)
+{
+    Py_VISIT(Py_TYPE(s));
+    Py_VISIT(s->s_format);
+    return 0;
+}
+
 static void
 s_dealloc(PyStructObject *s)
 {
     PyTypeObject *tp = Py_TYPE(s);
+    PyObject_GC_UnTrack(s);
     if (s->weakreflist != NULL)
         PyObject_ClearWeakRefs((PyObject *)s);
     if (s->s_codes != NULL) {
@@ -2078,13 +2094,15 @@ static PyType_Slot PyStructType_slots[] = {
     {Py_tp_getattro, PyObject_GenericGetAttr},
     {Py_tp_setattro, PyObject_GenericSetAttr},
     {Py_tp_doc, (void*)s__doc__},
+    {Py_tp_traverse, s_traverse},
+    {Py_tp_clear, s_clear},
     {Py_tp_methods, s_methods},
     {Py_tp_members, s_members},
     {Py_tp_getset, s_getsetlist},
     {Py_tp_init, Struct___init__},
     {Py_tp_alloc, PyType_GenericAlloc},
     {Py_tp_new, s_new},
-    {Py_tp_free, PyObject_Del},
+    {Py_tp_free, PyObject_GC_Del},
     {0, 0},
 };
 
@@ -2092,7 +2110,7 @@ static PyType_Spec PyStructType_spec = {
     "_struct.Struct",
     sizeof(PyStructObject),
     0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_BASETYPE,
     PyStructType_slots
 };
 

[NR] [ML] commit 11190c4ad0d3722b8d263758ac802985131a5462
Author: Ken Jin <kenjin@python.org>
Date:   Fri Jun 17 23:14:53 2022 +0800

    gh-92888: Fix memoryview bad `__index__` use after free (GH-92946)
    
    Co-authored-by: chilaxan <35645806+chilaxan@users.noreply.github.com>
    Co-authored-by: Serhiy Storchaka <3659035+serhiy-storchaka@users.noreply.github.com>

diff --git a/Lib/test/test_memoryview.py b/Lib/test/test_memoryview.py
index d7e3f0c0ef..9d1e1f3063 100644
--- a/Lib/test/test_memoryview.py
+++ b/Lib/test/test_memoryview.py
@@ -545,6 +545,107 @@ def test_pickle(self):
             with self.assertRaises(TypeError):
                 pickle.dumps(m, proto)
 
+    def test_use_released_memory(self):
+        # gh-92888: Previously it was possible to use a memoryview even after
+        # backing buffer is freed in certain cases. This tests that those
+        # cases raise an exception.
+        size = 128
+        def release():
+            m.release()
+            nonlocal ba
+            ba = bytearray(size)
+        class MyIndex:
+            def __index__(self):
+                release()
+                return 4
+        class MyFloat:
+            def __float__(self):
+                release()
+                return 4.25
+        class MyBool:
+            def __bool__(self):
+                release()
+                return True
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        with self.assertRaises(ValueError):
+            m[MyIndex()]
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        self.assertEqual(list(m[:MyIndex()]), [255] * 4)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        self.assertEqual(list(m[MyIndex():8]), [255] * 4)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size)).cast('B', (64, 2))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[MyIndex(), 0]
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size)).cast('B', (2, 64))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[0, MyIndex()]
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[MyIndex()] = 42
+        self.assertEqual(ba[:8], b'\0'*8)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[:MyIndex()] = b'spam'
+        self.assertEqual(ba[:8], b'\0'*8)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[MyIndex():8] = b'spam'
+        self.assertEqual(ba[:8], b'\0'*8)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size)).cast('B', (64, 2))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[MyIndex(), 0] = 42
+        self.assertEqual(ba[8:16], b'\0'*8)
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size)).cast('B', (2, 64))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[0, MyIndex()] = 42
+        self.assertEqual(ba[:8], b'\0'*8)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size))
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[0] = MyIndex()
+        self.assertEqual(ba[:8], b'\0'*8)
+
+        for fmt in 'bhilqnBHILQN':
+            with self.subTest(fmt=fmt):
+                ba = None
+                m = memoryview(bytearray(b'\xff'*size)).cast(fmt)
+                with self.assertRaisesRegex(ValueError, "operation forbidden"):
+                    m[0] = MyIndex()
+                self.assertEqual(ba[:8], b'\0'*8)
+
+        for fmt in 'fd':
+            with self.subTest(fmt=fmt):
+                ba = None
+                m = memoryview(bytearray(b'\xff'*size)).cast(fmt)
+                with self.assertRaisesRegex(ValueError, "operation forbidden"):
+                    m[0] = MyFloat()
+                self.assertEqual(ba[:8], b'\0'*8)
+
+        ba = None
+        m = memoryview(bytearray(b'\xff'*size)).cast('?')
+        with self.assertRaisesRegex(ValueError, "operation forbidden"):
+            m[0] = MyBool()
+        self.assertEqual(ba[:8], b'\0'*8)
 
 if __name__ == "__main__":
     unittest.main()
diff --git a/Misc/NEWS.d/next/Security/2022-05-19-08-53-07.gh-issue-92888.TLtR9W.rst b/Misc/NEWS.d/next/Security/2022-05-19-08-53-07.gh-issue-92888.TLtR9W.rst
new file mode 100644
index 0000000000..4841b8a90a
--- /dev/null
+++ b/Misc/NEWS.d/next/Security/2022-05-19-08-53-07.gh-issue-92888.TLtR9W.rst
@@ -0,0 +1,2 @@
+Fix ``memoryview`` use after free when accessing the backing buffer in certain cases.
+
diff --git a/Objects/memoryobject.c b/Objects/memoryobject.c
index c833c0bef6..d29e35c2bc 100644
--- a/Objects/memoryobject.c
+++ b/Objects/memoryobject.c
@@ -193,6 +193,11 @@ PyTypeObject _PyManagedBuffer_Type = {
         return -1;                                                \
     }
 
+/* See gh-92888. These macros signal that we need to check the memoryview
+   again due to possible read after frees. */
+#define CHECK_RELEASED_AGAIN(mv) CHECK_RELEASED(mv)
+#define CHECK_RELEASED_INT_AGAIN(mv) CHECK_RELEASED_INT(mv)
+
 #define CHECK_LIST_OR_TUPLE(v) \
     if (!PyList_Check(v) && !PyTuple_Check(v)) { \
         PyErr_SetString(PyExc_TypeError,         \
@@ -381,8 +386,9 @@ copy_rec(const Py_ssize_t *shape, Py_ssize_t ndim, Py_ssize_t itemsize,
 
 /* Faster copying of one-dimensional arrays. */
 static int
-copy_single(const Py_buffer *dest, const Py_buffer *src)
+copy_single(PyMemoryViewObject *self, const Py_buffer *dest, const Py_buffer *src)
 {
+    CHECK_RELEASED_INT_AGAIN(self);
     char *mem = NULL;
 
     assert(dest->ndim == 1);
@@ -1677,7 +1683,7 @@ pylong_as_zu(PyObject *item)
    module syntax. This function is very sensitive to small changes. With this
    layout gcc automatically generates a fast jump table. */
 static inline PyObject *
-unpack_single(const char *ptr, const char *fmt)
+unpack_single(PyMemoryViewObject *self, const char *ptr, const char *fmt)
 {
     unsigned long long llu;
     unsigned long lu;
@@ -1689,6 +1695,8 @@ unpack_single(const char *ptr, const char *fmt)
     unsigned char uc;
     void *p;
 
+    CHECK_RELEASED_AGAIN(self);
+
     switch (fmt[0]) {
 
     /* signed integers and fast path for 'B' */
@@ -1767,7 +1775,7 @@ unpack_single(const char *ptr, const char *fmt)
 /* Pack a single item. 'fmt' can be any native format character in
    struct module syntax. */
 static int
-pack_single(char *ptr, PyObject *item, const char *fmt)
+pack_single(PyMemoryViewObject *self, char *ptr, PyObject *item, const char *fmt)
 {
     unsigned long long llu;
     unsigned long lu;
@@ -1784,6 +1792,7 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         ld = pylong_as_ld(item);
         if (ld == -1 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         switch (fmt[0]) {
         case 'b':
             if (ld < SCHAR_MIN || ld > SCHAR_MAX) goto err_range;
@@ -1804,6 +1813,7 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         lu = pylong_as_lu(item);
         if (lu == (unsigned long)-1 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         switch (fmt[0]) {
         case 'B':
             if (lu > UCHAR_MAX) goto err_range;
@@ -1824,12 +1834,14 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         lld = pylong_as_lld(item);
         if (lld == -1 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         PACK_SINGLE(ptr, lld, long long);
         break;
     case 'Q':
         llu = pylong_as_llu(item);
         if (llu == (unsigned long long)-1 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         PACK_SINGLE(ptr, llu, unsigned long long);
         break;
 
@@ -1838,12 +1850,14 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         zd = pylong_as_zd(item);
         if (zd == -1 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         PACK_SINGLE(ptr, zd, Py_ssize_t);
         break;
     case 'N':
         zu = pylong_as_zu(item);
         if (zu == (size_t)-1 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         PACK_SINGLE(ptr, zu, size_t);
         break;
 
@@ -1852,6 +1866,7 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         d = PyFloat_AsDouble(item);
         if (d == -1.0 && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         if (fmt[0] == 'f') {
             PACK_SINGLE(ptr, d, float);
         }
@@ -1865,6 +1880,7 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         ld = PyObject_IsTrue(item);
         if (ld < 0)
             return -1; /* preserve original error */
+        CHECK_RELEASED_INT_AGAIN(self);
         PACK_SINGLE(ptr, ld, _Bool);
          break;
 
@@ -1882,6 +1898,7 @@ pack_single(char *ptr, PyObject *item, const char *fmt)
         p = PyLong_AsVoidPtr(item);
         if (p == NULL && PyErr_Occurred())
             goto err_occurred;
+        CHECK_RELEASED_INT_AGAIN(self);
         PACK_SINGLE(ptr, p, void *);
         break;
 
@@ -2042,7 +2059,7 @@ adjust_fmt(const Py_buffer *view)
 
 /* Base case for multi-dimensional unpacking. Assumption: ndim == 1. */
 static PyObject *
-tolist_base(const char *ptr, const Py_ssize_t *shape,
+tolist_base(PyMemoryViewObject *self, const char *ptr, const Py_ssize_t *shape,
             const Py_ssize_t *strides, const Py_ssize_t *suboffsets,
             const char *fmt)
 {
@@ -2055,7 +2072,7 @@ tolist_base(const char *ptr, const Py_ssize_t *shape,
 
     for (i = 0; i < shape[0]; ptr+=strides[0], i++) {
         const char *xptr = ADJUST_PTR(ptr, suboffsets, 0);
-        item = unpack_single(xptr, fmt);
+        item = unpack_single(self, xptr, fmt);
         if (item == NULL) {
             Py_DECREF(lst);
             return NULL;
@@ -2069,7 +2086,7 @@ tolist_base(const char *ptr, const Py_ssize_t *shape,
 /* Unpack a multi-dimensional array into a nested list.
    Assumption: ndim >= 1. */
 static PyObject *
-tolist_rec(const char *ptr, Py_ssize_t ndim, const Py_ssize_t *shape,
+tolist_rec(PyMemoryViewObject *self, const char *ptr, Py_ssize_t ndim, const Py_ssize_t *shape,
            const Py_ssize_t *strides, const Py_ssize_t *suboffsets,
            const char *fmt)
 {
@@ -2081,7 +2098,7 @@ tolist_rec(const char *ptr, Py_ssize_t ndim, const Py_ssize_t *shape,
     assert(strides != NULL);
 
     if (ndim == 1)
-        return tolist_base(ptr, shape, strides, suboffsets, fmt);
+        return tolist_base(self, ptr, shape, strides, suboffsets, fmt);
 
     lst = PyList_New(shape[0]);
     if (lst == NULL)
@@ -2089,7 +2106,7 @@ tolist_rec(const char *ptr, Py_ssize_t ndim, const Py_ssize_t *shape,
 
     for (i = 0; i < shape[0]; ptr+=strides[0], i++) {
         const char *xptr = ADJUST_PTR(ptr, suboffsets, 0);
-        item = tolist_rec(xptr, ndim-1, shape+1,
+        item = tolist_rec(self, xptr, ndim-1, shape+1,
                           strides+1, suboffsets ? suboffsets+1 : NULL,
                           fmt);
         if (item == NULL) {
@@ -2123,15 +2140,15 @@ memoryview_tolist_impl(PyMemoryViewObject *self)
     if (fmt == NULL)
         return NULL;
     if (view->ndim == 0) {
-        return unpack_single(view->buf, fmt);
+        return unpack_single(self, view->buf, fmt);
     }
     else if (view->ndim == 1) {
-        return tolist_base(view->buf, view->shape,
+        return tolist_base(self, view->buf, view->shape,
                            view->strides, view->suboffsets,
                            fmt);
     }
     else {
-        return tolist_rec(view->buf, view->ndim, view->shape,
+        return tolist_rec(self, view->buf, view->ndim, view->shape,
                           view->strides, view->suboffsets,
                           fmt);
     }
@@ -2339,7 +2356,7 @@ memory_item(PyMemoryViewObject *self, Py_ssize_t index)
         char *ptr = ptr_from_index(view, index);
         if (ptr == NULL)
             return NULL;
-        return unpack_single(ptr, fmt);
+        return unpack_single(self, ptr, fmt);
     }
 
     PyErr_SetString(PyExc_NotImplementedError,
@@ -2370,7 +2387,7 @@ memory_item_multi(PyMemoryViewObject *self, PyObject *tup)
     ptr = ptr_from_tuple(view, tup);
     if (ptr == NULL)
         return NULL;
-    return unpack_single(ptr, fmt);
+    return unpack_single(self, ptr, fmt);
 }
 
 static inline int
@@ -2457,7 +2474,7 @@ memory_subscript(PyMemoryViewObject *self, PyObject *key)
             const char *fmt = adjust_fmt(view);
             if (fmt == NULL)
                 return NULL;
-            return unpack_single(view->buf, fmt);
+            return unpack_single(self, view->buf, fmt);
         }
         else if (key == Py_Ellipsis) {
             Py_INCREF(self);
@@ -2532,7 +2549,7 @@ memory_ass_sub(PyMemoryViewObject *self, PyObject *key, PyObject *value)
         if (key == Py_Ellipsis ||
             (PyTuple_Check(key) && PyTuple_GET_SIZE(key)==0)) {
             ptr = (char *)view->buf;
-            return pack_single(ptr, value, fmt);
+            return pack_single(self, ptr, value, fmt);
         }
         else {
             PyErr_SetString(PyExc_TypeError,
@@ -2554,7 +2571,7 @@ memory_ass_sub(PyMemoryViewObject *self, PyObject *key, PyObject *value)
         ptr = ptr_from_index(view, index);
         if (ptr == NULL)
             return -1;
-        return pack_single(ptr, value, fmt);
+        return pack_single(self, ptr, value, fmt);
     }
     /* one-dimensional: fast path */
     if (PySlice_Check(key) && view->ndim == 1) {
@@ -2577,7 +2594,7 @@ memory_ass_sub(PyMemoryViewObject *self, PyObject *key, PyObject *value)
             goto end_block;
         dest.len = dest.shape[0] * dest.itemsize;
 
-        ret = copy_single(&dest, &src);
+        ret = copy_single(self, &dest, &src);
 
     end_block:
         PyBuffer_Release(&src);
@@ -2593,7 +2610,7 @@ memory_ass_sub(PyMemoryViewObject *self, PyObject *key, PyObject *value)
         ptr = ptr_from_tuple(view, key);
         if (ptr == NULL)
             return -1;
-        return pack_single(ptr, value, fmt);
+        return pack_single(self, ptr, value, fmt);
     }
     if (PySlice_Check(key) || is_multislice(key)) {
         /* Call memory_subscript() to produce a sliced lvalue, then copy
@@ -3194,7 +3211,7 @@ memoryiter_next(memoryiterobject *it)
         if (ptr == NULL) {
             return NULL;
         }
-        return unpack_single(ptr, it->it_fmt);
+        return unpack_single(seq, ptr, it->it_fmt);
     }
 
     it->it_seq = NULL;

commit 4beee0c7b0c2cc78a893dde88fd8e34099dcf877
Author: Gregory P. Smith <greg@krypto.org>
Date:   Fri Jun 17 01:19:44 2022 -0700

    gh-91404: Revert "bpo-23689: re module, fix memory leak when a match is terminated by a signal or allocation failure (GH-32283) (#93882)
    
    Revert "bpo-23689: re module, fix memory leak when a match is terminated by a signal or memory allocation failure (GH-32283)"
    
    This reverts commit 6e3eee5c11b539e9aab39cff783acf57838c355a.
    
    Manual fixups to increase the MAGIC number and to handle conflicts with
    a couple of changes that landed after that.
    
    Thanks for reviews by Ma Lin and Serhiy Storchaka.

diff --git a/Lib/re/_compiler.py b/Lib/re/_compiler.py
index 4b5322338c..d8e0d2fdef 100644
--- a/Lib/re/_compiler.py
+++ b/Lib/re/_compiler.py
@@ -28,21 +28,14 @@
     POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),
 }
 
-class _CompileData:
-    __slots__ = ('code', 'repeat_count')
-    def __init__(self):
-        self.code = []
-        self.repeat_count = 0
-
 def _combine_flags(flags, add_flags, del_flags,
                    TYPE_FLAGS=_parser.TYPE_FLAGS):
     if add_flags & TYPE_FLAGS:
         flags &= ~TYPE_FLAGS
     return (flags | add_flags) & ~del_flags
 
-def _compile(data, pattern, flags):
+def _compile(code, pattern, flags):
     # internal: compile a (sub)pattern
-    code = data.code
     emit = code.append
     _len = len
     LITERAL_CODES = _LITERAL_CODES
@@ -115,7 +108,7 @@ def _compile(data, pattern, flags):
                 skip = _len(code); emit(0)
                 emit(av[0])
                 emit(av[1])
-                _compile(data, av[2], flags)
+                _compile(code, av[2], flags)
                 emit(SUCCESS)
                 code[skip] = _len(code) - skip
             else:
@@ -123,11 +116,7 @@ def _compile(data, pattern, flags):
                 skip = _len(code); emit(0)
                 emit(av[0])
                 emit(av[1])
-                # now op is in (MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT)
-                if op != POSSESSIVE_REPEAT:
-                    emit(data.repeat_count)
-                    data.repeat_count += 1
-                _compile(data, av[2], flags)
+                _compile(code, av[2], flags)
                 code[skip] = _len(code) - skip
                 emit(REPEATING_CODES[op][1])
         elif op is SUBPATTERN:
@@ -136,7 +125,7 @@ def _compile(data, pattern, flags):
                 emit(MARK)
                 emit((group-1)*2)
             # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))
-            _compile(data, p, _combine_flags(flags, add_flags, del_flags))
+            _compile(code, p, _combine_flags(flags, add_flags, del_flags))
             if group:
                 emit(MARK)
                 emit((group-1)*2+1)
@@ -148,7 +137,7 @@ def _compile(data, pattern, flags):
             # pop their stack if they reach it
             emit(ATOMIC_GROUP)
             skip = _len(code); emit(0)
-            _compile(data, av, flags)
+            _compile(code, av, flags)
             emit(SUCCESS)
             code[skip] = _len(code) - skip
         elif op in SUCCESS_CODES:
@@ -163,7 +152,7 @@ def _compile(data, pattern, flags):
                 if lo != hi:
                     raise error("look-behind requires fixed-width pattern")
                 emit(lo) # look behind
-            _compile(data, av[1], flags)
+            _compile(code, av[1], flags)
             emit(SUCCESS)
             code[skip] = _len(code) - skip
         elif op is AT:
@@ -182,7 +171,7 @@ def _compile(data, pattern, flags):
             for av in av[1]:
                 skip = _len(code); emit(0)
                 # _compile_info(code, av, flags)
-                _compile(data, av, flags)
+                _compile(code, av, flags)
                 emit(JUMP)
                 tailappend(_len(code)); emit(0)
                 code[skip] = _len(code) - skip
@@ -210,12 +199,12 @@ def _compile(data, pattern, flags):
             emit(op)
             emit(av[0]-1)
             skipyes = _len(code); emit(0)
-            _compile(data, av[1], flags)
+            _compile(code, av[1], flags)
             if av[2]:
                 emit(JUMP)
                 skipno = _len(code); emit(0)
                 code[skipyes] = _len(code) - skipyes + 1
-                _compile(data, av[2], flags)
+                _compile(code, av[2], flags)
                 code[skipno] = _len(code) - skipno
             else:
                 code[skipyes] = _len(code) - skipyes + 1
@@ -582,17 +571,17 @@ def isstring(obj):
 def _code(p, flags):
 
     flags = p.state.flags | flags
-    data = _CompileData()
+    code = []
 
     # compile info block
-    _compile_info(data.code, p, flags)
+    _compile_info(code, p, flags)
 
     # compile the pattern
-    _compile(data, p.data, flags)
+    _compile(code, p.data, flags)
 
-    data.code.append(SUCCESS)
+    code.append(SUCCESS)
 
-    return data
+    return code
 
 def _hex_code(code):
     return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)
@@ -693,7 +682,7 @@ def print_2(*args):
                     else:
                         print_(FAILURE)
                 i += 1
-            elif op in (REPEAT_ONE, MIN_REPEAT_ONE,
+            elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE,
                         POSSESSIVE_REPEAT, POSSESSIVE_REPEAT_ONE):
                 skip, min, max = code[i: i+3]
                 if max == MAXREPEAT:
@@ -701,13 +690,6 @@ def print_2(*args):
                 print_(op, skip, min, max, to=i+skip)
                 dis_(i+3, i+skip)
                 i += skip
-            elif op is REPEAT:
-                skip, min, max, repeat_index = code[i: i+4]
-                if max == MAXREPEAT:
-                    max = 'MAXREPEAT'
-                print_(op, skip, min, max, repeat_index, to=i+skip)
-                dis_(i+4, i+skip)
-                i += skip
             elif op is GROUPREF_EXISTS:
                 arg, skip = code[i: i+2]
                 print_(op, arg, skip, to=i+skip)
@@ -762,11 +744,11 @@ def compile(p, flags=0):
     else:
         pattern = None
 
-    data = _code(p, flags)
+    code = _code(p, flags)
 
     if flags & SRE_FLAG_DEBUG:
         print()
-        dis(data.code)
+        dis(code)
 
     # map in either direction
     groupindex = p.state.groupdict
@@ -775,6 +757,7 @@ def compile(p, flags=0):
         indexgroup[i] = k
 
     return _sre.compile(
-        pattern, flags | p.state.flags, data.code,
-        p.state.groups-1, groupindex, tuple(indexgroup),
-        data.repeat_count)
+        pattern, flags | p.state.flags, code,
+        p.state.groups-1,
+        groupindex, tuple(indexgroup)
+        )
diff --git a/Lib/re/_constants.py b/Lib/re/_constants.py
index 1cc85c631f..10ee14bfab 100644
--- a/Lib/re/_constants.py
+++ b/Lib/re/_constants.py
@@ -13,7 +13,7 @@
 
 # update when constants are added or removed
 
-MAGIC = 20220423
+MAGIC = 20220615
 
 from _sre import MAXREPEAT, MAXGROUPS
 
diff --git a/Lib/test/test_re.py b/Lib/test/test_re.py
index 3752d734db..9f734d47c5 100644
--- a/Lib/test/test_re.py
+++ b/Lib/test/test_re.py
@@ -1765,12 +1765,9 @@ def test_dealloc(self):
         long_overflow = 2**128
         self.assertRaises(TypeError, re.finditer, "a", {})
         with self.assertRaises(OverflowError):
-            _sre.compile("abc", 0, [long_overflow], 0, {}, (), 0)
+            _sre.compile("abc", 0, [long_overflow], 0, {}, ())
         with self.assertRaises(TypeError):
-            _sre.compile({}, 0, [], 0, [], [], 0)
-        with self.assertRaises(RuntimeError):
-            # invalid repeat_count -1
-            _sre.compile("abc", 0, [1], 0, {}, (), -1)
+            _sre.compile({}, 0, [], 0, [], [])
 
     def test_search_dot_unicode(self):
         self.assertTrue(re.search("123.*-", '123abc-'))
@@ -2509,27 +2506,6 @@ def test_possesive_repeat(self):
 14. SUCCESS
 ''')
 
-    def test_repeat_index(self):
-        self.assertEqual(get_debug_out(r'(?:ab)*?(?:cd)*'), '''\
-MIN_REPEAT 0 MAXREPEAT
-  LITERAL 97
-  LITERAL 98
-MAX_REPEAT 0 MAXREPEAT
-  LITERAL 99
-  LITERAL 100
-
- 0. INFO 4 0b0 0 MAXREPEAT (to 5)
- 5: REPEAT 8 0 MAXREPEAT 0 (to 14)
-10.   LITERAL 0x61 ('a')
-12.   LITERAL 0x62 ('b')
-14: MIN_UNTIL
-15. REPEAT 8 0 MAXREPEAT 1 (to 24)
-20.   LITERAL 0x63 ('c')
-22.   LITERAL 0x64 ('d')
-24: MAX_UNTIL
-25. SUCCESS
-''')
-
 
 class PatternReprTests(unittest.TestCase):
     def check(self, pattern, expected):
diff --git a/Misc/NEWS.d/next/Library/2022-06-15-21-35-11.gh-issue-91404.39TZzW.rst b/Misc/NEWS.d/next/Library/2022-06-15-21-35-11.gh-issue-91404.39TZzW.rst
new file mode 100644
index 0000000000..e20b15c7b7
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-06-15-21-35-11.gh-issue-91404.39TZzW.rst
@@ -0,0 +1,3 @@
+Revert the :mod:`re` memory leak when a match is terminated by a signal or
+memory allocation failure as the implemented fix caused a major performance
+regression.
diff --git a/Modules/_sre/clinic/sre.c.h b/Modules/_sre/clinic/sre.c.h
index e243c756e1..048a494f1b 100644
--- a/Modules/_sre/clinic/sre.c.h
+++ b/Modules/_sre/clinic/sre.c.h
@@ -764,7 +764,7 @@ PyDoc_STRVAR(_sre_SRE_Pattern___deepcopy____doc__,
 
 PyDoc_STRVAR(_sre_compile__doc__,
 "compile($module, /, pattern, flags, code, groups, groupindex,\n"
-"        indexgroup, repeat_count)\n"
+"        indexgroup)\n"
 "--\n"
 "\n");
 
@@ -774,24 +774,23 @@ PyDoc_STRVAR(_sre_compile__doc__,
 static PyObject *
 _sre_compile_impl(PyObject *module, PyObject *pattern, int flags,
                   PyObject *code, Py_ssize_t groups, PyObject *groupindex,
-                  PyObject *indexgroup, Py_ssize_t repeat_count);
+                  PyObject *indexgroup);
 
 static PyObject *
 _sre_compile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
 {
     PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"pattern", "flags", "code", "groups", "groupindex", "indexgroup", "repeat_count", NULL};
+    static const char * const _keywords[] = {"pattern", "flags", "code", "groups", "groupindex", "indexgroup", NULL};
     static _PyArg_Parser _parser = {NULL, _keywords, "compile", 0};
-    PyObject *argsbuf[7];
+    PyObject *argsbuf[6];
     PyObject *pattern;
     int flags;
     PyObject *code;
     Py_ssize_t groups;
     PyObject *groupindex;
     PyObject *indexgroup;
-    Py_ssize_t repeat_count;
 
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 7, 7, 0, argsbuf);
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 6, 6, 0, argsbuf);
     if (!args) {
         goto exit;
     }
@@ -827,19 +826,7 @@ _sre_compile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject
         goto exit;
     }
     indexgroup = args[5];
-    {
-        Py_ssize_t ival = -1;
-        PyObject *iobj = _PyNumber_Index(args[6]);
-        if (iobj != NULL) {
-            ival = PyLong_AsSsize_t(iobj);
-            Py_DECREF(iobj);
-        }
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        repeat_count = ival;
-    }
-    return_value = _sre_compile_impl(module, pattern, flags, code, groups, groupindex, indexgroup, repeat_count);
+    return_value = _sre_compile_impl(module, pattern, flags, code, groups, groupindex, indexgroup);
 
 exit:
     return return_value;
@@ -1129,4 +1116,4 @@ _sre_SRE_Scanner_search(ScannerObject *self, PyTypeObject *cls, PyObject *const
     }
     return _sre_SRE_Scanner_search_impl(self, cls);
 }
-/*[clinic end generated code: output=97e7ce058366760b input=a9049054013a1b77]*/
+/*[clinic end generated code: output=fd2f45c941620e6e input=a9049054013a1b77]*/
diff --git a/Modules/_sre/sre.c b/Modules/_sre/sre.c
index a1da180892..bcb30848d9 100644
--- a/Modules/_sre/sre.c
+++ b/Modules/_sre/sre.c
@@ -427,12 +427,6 @@ state_init(SRE_STATE* state, PatternObject* pattern, PyObject* string,
     state->lastmark = -1;
     state->lastindex = -1;
 
-    state->repeats_array = PyMem_New(SRE_REPEAT, pattern->repeat_count);
-    if (!state->repeats_array) {
-        PyErr_NoMemory();
-        goto err;
-    }
-
     state->buffer.buf = NULL;
     ptr = getstring(string, &length, &isbytes, &charsize, &state->buffer);
     if (!ptr)
@@ -482,9 +476,6 @@ state_init(SRE_STATE* state, PatternObject* pattern, PyObject* string,
        safely casted to `void*`, see bpo-39943 for details. */
     PyMem_Free((void*) state->mark);
     state->mark = NULL;
-    PyMem_Free(state->repeats_array);
-    state->repeats_array = NULL;
-
     if (state->buffer.buf)
         PyBuffer_Release(&state->buffer);
     return NULL;
@@ -500,8 +491,6 @@ state_fini(SRE_STATE* state)
     /* See above PyMem_Del for why we explicitly cast here. */
     PyMem_Free((void*) state->mark);
     state->mark = NULL;
-    PyMem_Free(state->repeats_array);
-    state->repeats_array = NULL;
 }
 
 /* calculate offset from start of string */
@@ -1408,15 +1397,14 @@ _sre.compile
     groups: Py_ssize_t
     groupindex: object(subclass_of='&PyDict_Type')
     indexgroup: object(subclass_of='&PyTuple_Type')
-    repeat_count: Py_ssize_t
 
 [clinic start generated code]*/
 
 static PyObject *
 _sre_compile_impl(PyObject *module, PyObject *pattern, int flags,
                   PyObject *code, Py_ssize_t groups, PyObject *groupindex,
-                  PyObject *indexgroup, Py_ssize_t repeat_count)
-/*[clinic end generated code: output=922af562d51b1657 input=77e39c322501ec2a]*/
+                  PyObject *indexgroup)
+/*[clinic end generated code: output=ef9c2b3693776404 input=0a68476dbbe5db30]*/
 {
     /* "compile" pattern descriptor to pattern object */
 
@@ -1474,8 +1462,8 @@ _sre_compile_impl(PyObject *module, PyObject *pattern, int flags,
     self->pattern = pattern;
 
     self->flags = flags;
+
     self->groups = groups;
-    self->repeat_count = repeat_count;
 
     if (PyDict_GET_SIZE(groupindex) > 0) {
         Py_INCREF(groupindex);
@@ -1647,7 +1635,7 @@ _validate_charset(SRE_CODE *code, SRE_CODE *end)
 }
 
 static int
-_validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
+_validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
 {
     /* Some variables are manipulated by the macros above */
     SRE_CODE op;
@@ -1668,8 +1656,8 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
                sre_match() code is robust even if they don't, and the worst
                you can get is nonsensical match results. */
             GET_ARG;
-            if (arg > 2 * (size_t)self->groups + 1) {
-                VTRACE(("arg=%d, groups=%d\n", (int)arg, (int)self->groups));
+            if (arg > 2 * (size_t)groups + 1) {
+                VTRACE(("arg=%d, groups=%d\n", (int)arg, (int)groups));
                 FAIL;
             }
             break;
@@ -1798,7 +1786,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
                     if (skip == 0)
                         break;
                     /* Stop 2 before the end; we check the JUMP below */
-                    if (!_validate_inner(code, code+skip-3, self))
+                    if (!_validate_inner(code, code+skip-3, groups))
                         FAIL;
                     code += skip-3;
                     /* Check that it ends with a JUMP, and that each JUMP
@@ -1827,7 +1815,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
                     FAIL;
                 if (max > SRE_MAXREPEAT)
                     FAIL;
-                if (!_validate_inner(code, code+skip-4, self))
+                if (!_validate_inner(code, code+skip-4, groups))
                     FAIL;
                 code += skip-4;
                 GET_OP;
@@ -1839,7 +1827,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
         case SRE_OP_REPEAT:
         case SRE_OP_POSSESSIVE_REPEAT:
             {
-                SRE_CODE op1 = op, min, max, repeat_index;
+                SRE_CODE op1 = op, min, max;
                 GET_SKIP;
                 GET_ARG; min = arg;
                 GET_ARG; max = arg;
@@ -1847,17 +1835,9 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
                     FAIL;
                 if (max > SRE_MAXREPEAT)
                     FAIL;
-                if (op1 == SRE_OP_REPEAT) {
-                    GET_ARG; repeat_index = arg;
-                    if (repeat_index >= (size_t)self->repeat_count)
-                        FAIL;
-                    skip -= 4;
-                } else {
-                    skip -= 3;
-                }
-                if (!_validate_inner(code, code+skip, self))
+                if (!_validate_inner(code, code+skip-3, groups))
                     FAIL;
-                code += skip;
+                code += skip-3;
                 GET_OP;
                 if (op1 == SRE_OP_POSSESSIVE_REPEAT) {
                     if (op != SRE_OP_SUCCESS)
@@ -1873,7 +1853,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
         case SRE_OP_ATOMIC_GROUP:
             {
                 GET_SKIP;
-                if (!_validate_inner(code, code+skip-2, self))
+                if (!_validate_inner(code, code+skip-2, groups))
                     FAIL;
                 code += skip-2;
                 GET_OP;
@@ -1887,7 +1867,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
         case SRE_OP_GROUPREF_UNI_IGNORE:
         case SRE_OP_GROUPREF_LOC_IGNORE:
             GET_ARG;
-            if (arg >= (size_t)self->groups)
+            if (arg >= (size_t)groups)
                 FAIL;
             break;
 
@@ -1896,7 +1876,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
                'group' is either an integer group number or a group name,
                'then' and 'else' are sub-regexes, and 'else' is optional. */
             GET_ARG;
-            if (arg >= (size_t)self->groups)
+            if (arg >= (size_t)groups)
                 FAIL;
             GET_SKIP_ADJ(1);
             code--; /* The skip is relative to the first arg! */
@@ -1929,17 +1909,17 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
                 code[skip-3] == SRE_OP_JUMP)
             {
                 VTRACE(("both then and else parts present\n"));
-                if (!_validate_inner(code+1, code+skip-3, self))
+                if (!_validate_inner(code+1, code+skip-3, groups))
                     FAIL;
                 code += skip-2; /* Position after JUMP, at <skipno> */
                 GET_SKIP;
-                if (!_validate_inner(code, code+skip-1, self))
+                if (!_validate_inner(code, code+skip-1, groups))
                     FAIL;
                 code += skip-1;
             }
             else {
                 VTRACE(("only a then part present\n"));
-                if (!_validate_inner(code+1, code+skip-1, self))
+                if (!_validate_inner(code+1, code+skip-1, groups))
                     FAIL;
                 code += skip-1;
             }
@@ -1953,7 +1933,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
             if (arg & 0x80000000)
                 FAIL; /* Width too large */
             /* Stop 1 before the end; we check the SUCCESS below */
-            if (!_validate_inner(code+1, code+skip-2, self))
+            if (!_validate_inner(code+1, code+skip-2, groups))
                 FAIL;
             code += skip-2;
             GET_OP;
@@ -1972,19 +1952,18 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
 }
 
 static int
-_validate_outer(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
+_validate_outer(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
 {
-    if (self->groups < 0 || (size_t)self->groups > SRE_MAXGROUPS ||
-        self->repeat_count < 0 ||
+    if (groups < 0 || (size_t)groups > SRE_MAXGROUPS ||
         code >= end || end[-1] != SRE_OP_SUCCESS)
         FAIL;
-    return _validate_inner(code, end-1, self);
+    return _validate_inner(code, end-1, groups);
 }
 
 static int
 _validate(PatternObject *self)
 {
-    if (!_validate_outer(self->code, self->code+self->codesize, self))
+    if (!_validate_outer(self->code, self->code+self->codesize, self->groups))
     {
         PyErr_SetString(PyExc_RuntimeError, "invalid SRE code");
         return 0;
diff --git a/Modules/_sre/sre.h b/Modules/_sre/sre.h
index aff064d343..52ae3e11b5 100644
--- a/Modules/_sre/sre.h
+++ b/Modules/_sre/sre.h
@@ -29,8 +29,6 @@ typedef struct {
     Py_ssize_t groups; /* must be first! */
     PyObject* groupindex; /* dict */
     PyObject* indexgroup; /* tuple */
-    /* the number of REPEATs */
-    Py_ssize_t repeat_count;
     /* compatibility */
     PyObject* pattern; /* pattern source (or None) */
     int flags; /* flags used when compiling pattern source */
@@ -85,8 +83,6 @@ typedef struct {
     size_t data_stack_base;
     /* current repeat context */
     SRE_REPEAT *repeat;
-    /* repeat contexts array */
-    SRE_REPEAT *repeats_array;
 } SRE_STATE;
 
 typedef struct {
diff --git a/Modules/_sre/sre_constants.h b/Modules/_sre/sre_constants.h
index 590d5be7cb..c633514736 100644
--- a/Modules/_sre/sre_constants.h
+++ b/Modules/_sre/sre_constants.h
@@ -11,7 +11,7 @@
  * See the sre.c file for information on usage and redistribution.
  */
 
-#define SRE_MAGIC 20220423
+#define SRE_MAGIC 20220615
 #define SRE_OP_FAILURE 0
 #define SRE_OP_SUCCESS 1
 #define SRE_OP_ANY 2
diff --git a/Modules/_sre/sre_lib.h b/Modules/_sre/sre_lib.h
index 1e5b50170a..fb4c18b63d 100644
--- a/Modules/_sre/sre_lib.h
+++ b/Modules/_sre/sre_lib.h
@@ -1079,12 +1079,17 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
             /* <REPEAT> <skip> <1=min> <2=max>
                <3=repeat_index> item <UNTIL> tail */
-            TRACE(("|%p|%p|REPEAT %d %d %d\n", pattern, ptr,
-                   pattern[1], pattern[2], pattern[3]));
-
-            /* install repeat context */
-            ctx->u.rep = &state->repeats_array[pattern[3]];
+            TRACE(("|%p|%p|REPEAT %d %d\n", pattern, ptr,
+                   pattern[1], pattern[2]));
 
+            /* install new repeat context */
+            /* TODO(https://github.com/python/cpython/issues/67877): Fix this
+             * potential memory leak. */
+            ctx->u.rep = (SRE_REPEAT*) PyObject_Malloc(sizeof(*ctx->u.rep));
+            if (!ctx->u.rep) {
+                PyErr_NoMemory();
+                RETURN_FAILURE;
+            }
             ctx->u.rep->count = -1;
             ctx->u.rep->pattern = pattern;
             ctx->u.rep->prev = state->repeat;
@@ -1094,6 +1099,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
             state->ptr = ptr;
             DO_JUMP(JUMP_REPEAT, jump_repeat, pattern+pattern[0]);
             state->repeat = ctx->u.rep->prev;
+            PyObject_Free(ctx->u.rep);
 
             if (ret) {
                 RETURN_ON_ERROR(ret);
@@ -1103,8 +1109,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
 
         TARGET(SRE_OP_MAX_UNTIL):
             /* maximizing repeat */
-            /* <REPEAT> <skip> <1=min> <2=max>
-               <3=repeat_index> item <MAX_UNTIL> tail */
+            /* <REPEAT> <skip> <1=min> <2=max> item <MAX_UNTIL> tail */
 
             /* FIXME: we probably need to deal with zero-width
                matches in here... */
@@ -1124,7 +1129,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                 /* not enough matches */
                 ctx->u.rep->count = ctx->count;
                 DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
-                        ctx->u.rep->pattern+4);
+                        ctx->u.rep->pattern+3);
                 if (ret) {
                     RETURN_ON_ERROR(ret);
                     RETURN_SUCCESS;
@@ -1146,7 +1151,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                 DATA_PUSH(&ctx->u.rep->last_ptr);
                 ctx->u.rep->last_ptr = state->ptr;
                 DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
-                        ctx->u.rep->pattern+4);
+                        ctx->u.rep->pattern+3);
                 DATA_POP(&ctx->u.rep->last_ptr);
                 if (ret) {
                     MARK_POP_DISCARD(ctx->lastmark);
@@ -1171,8 +1176,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
 
         TARGET(SRE_OP_MIN_UNTIL):
             /* minimizing repeat */
-            /* <REPEAT> <skip> <1=min> <2=max>
-               <3=repeat_index> item <MIN_UNTIL> tail */
+            /* <REPEAT> <skip> <1=min> <2=max> item <MIN_UNTIL> tail */
 
             ctx->u.rep = state->repeat;
             if (!ctx->u.rep)
@@ -1189,7 +1193,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                 /* not enough matches */
                 ctx->u.rep->count = ctx->count;
                 DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
-                        ctx->u.rep->pattern+4);
+                        ctx->u.rep->pattern+3);
                 if (ret) {
                     RETURN_ON_ERROR(ret);
                     RETURN_SUCCESS;
@@ -1232,7 +1236,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
             DATA_PUSH(&ctx->u.rep->last_ptr);
             ctx->u.rep->last_ptr = state->ptr;
             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
-                    ctx->u.rep->pattern+4);
+                    ctx->u.rep->pattern+3);
             DATA_POP(&ctx->u.rep->last_ptr);
             if (ret) {
                 RETURN_ON_ERROR(ret);

commit 8f728e5baa7a673b83607aaccbd496d77d334ded
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Sun Jun 12 20:12:18 2022 +0530

    gh-93728: fix memory leak in deepfrozen code objects (GH-93729)

diff --git a/Objects/codeobject.c b/Objects/codeobject.c
index dc6dec1b2a..2a2f132a6e 100644
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -2092,6 +2092,7 @@ _PyStaticCode_Dealloc(PyCodeObject *co)
     deopt_code(_PyCode_CODE(co), Py_SIZE(co));
     co->co_warmup = QUICKENING_INITIAL_WARMUP_VALUE;
     PyMem_Free(co->co_extra);
+    Py_CLEAR(co->_co_code);
     co->co_extra = NULL;
     if (co->co_weakreflist != NULL) {
         PyObject_ClearWeakRefs((PyObject *)co);

[ML] commit c5f5f978ca6b8b62effcbc4aa61932b76718da78
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Thu May 19 19:25:22 2022 +0530

    GH-92955: fix memory leak in code object lines and positions iterators (gh-92956)

diff --git a/Misc/NEWS.d/next/Core and Builtins/2022-05-19-13-25-50.gh-issue-92955.kmNV33.rst b/Misc/NEWS.d/next/Core and Builtins/2022-05-19-13-25-50.gh-issue-92955.kmNV33.rst
new file mode 100644
index 0000000000..09f03e520c
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2022-05-19-13-25-50.gh-issue-92955.kmNV33.rst	
@@ -0,0 +1 @@
+Fix memory leak in code object's lines and positions iterators as they were not finalized at exit. Patch by Kumar Aditya.
diff --git a/Objects/codeobject.c b/Objects/codeobject.c
index c2b29be1fe..68b0b1efb2 100644
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -1096,7 +1096,7 @@ lineiter_next(lineiterator *li)
     return result;
 }
 
-static PyTypeObject LineIterator = {
+PyTypeObject _PyLineIterator = {
     PyVarObject_HEAD_INIT(&PyType_Type, 0)
     "line_iterator",                    /* tp_name */
     sizeof(lineiterator),               /* tp_basicsize */
@@ -1142,7 +1142,7 @@ static PyTypeObject LineIterator = {
 static lineiterator *
 new_linesiterator(PyCodeObject *code)
 {
-    lineiterator *li = (lineiterator *)PyType_GenericAlloc(&LineIterator, 0);
+    lineiterator *li = (lineiterator *)PyType_GenericAlloc(&_PyLineIterator, 0);
     if (li == NULL) {
         return NULL;
     }
@@ -1196,7 +1196,7 @@ positionsiter_next(positionsiterator* pi)
         _source_offset_converter, &pi->pi_endcolumn);
 }
 
-static PyTypeObject PositionsIterator = {
+PyTypeObject _PyPositionsIterator = {
     PyVarObject_HEAD_INIT(&PyType_Type, 0)
     "positions_iterator",               /* tp_name */
     sizeof(positionsiterator),          /* tp_basicsize */
@@ -1242,7 +1242,7 @@ static PyTypeObject PositionsIterator = {
 static PyObject*
 code_positionsiterator(PyCodeObject* code, PyObject* Py_UNUSED(args))
 {
-    positionsiterator* pi = (positionsiterator*)PyType_GenericAlloc(&PositionsIterator, 0);
+    positionsiterator* pi = (positionsiterator*)PyType_GenericAlloc(&_PyPositionsIterator, 0);
     if (pi == NULL) {
         return NULL;
     }
diff --git a/Objects/object.c b/Objects/object.c
index c9bb60eaed..95045ed03d 100644
--- a/Objects/object.c
+++ b/Objects/object.c
@@ -1846,6 +1846,8 @@ extern PyTypeObject PyHKEY_Type;
 #endif
 extern PyTypeObject _Py_GenericAliasIterType;
 extern PyTypeObject _PyMemoryIter_Type;
+extern PyTypeObject _PyLineIterator;
+extern PyTypeObject _PyPositionsIterator;
 
 static PyTypeObject* static_types[] = {
     // The two most important base types: must be initialized first and
@@ -1944,12 +1946,14 @@ static PyTypeObject* static_types[] = {
     &_PyHamt_CollisionNode_Type,
     &_PyHamt_Type,
     &_PyInterpreterID_Type,
+    &_PyLineIterator,
     &_PyManagedBuffer_Type,
     &_PyMemoryIter_Type,
     &_PyMethodWrapper_Type,
     &_PyNamespace_Type,
     &_PyNone_Type,
     &_PyNotImplemented_Type,
+    &_PyPositionsIterator,
     &_PyUnicodeASCIIIter_Type,
     &_PyUnion_Type,
     &_PyWeakref_CallableProxyType,

[ML] commit d923fdf54bc97baece879179ba4971f632b9722b
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Sat May 14 19:54:20 2022 +0530

    GH-92804: Fix memory leak in memoryview iterator (gh-92805)

diff --git a/Misc/NEWS.d/next/Core and Builtins/2022-05-14-13-22-11.gh-issue-92804.rAqpI2.rst b/Misc/NEWS.d/next/Core and Builtins/2022-05-14-13-22-11.gh-issue-92804.rAqpI2.rst
new file mode 100644
index 0000000000..7a5fd3f656
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2022-05-14-13-22-11.gh-issue-92804.rAqpI2.rst	
@@ -0,0 +1 @@
+Fix memory leak in ``memoryview`` iterator as it was not finalized at exit. Patch by Kumar Aditya.
diff --git a/Objects/memoryobject.c b/Objects/memoryobject.c
index 45fe8985c2..8c26916882 100644
--- a/Objects/memoryobject.c
+++ b/Objects/memoryobject.c
@@ -3156,7 +3156,7 @@ static PyMethodDef memory_methods[] = {
 /*                          Memoryview Iterator                           */
 /**************************************************************************/
 
-static PyTypeObject PyMemoryIter_Type;
+PyTypeObject _PyMemoryIter_Type;
 
 typedef struct {
     PyObject_HEAD
@@ -3233,7 +3233,7 @@ memory_iter(PyObject *seq)
     }
 
     memoryiterobject *it;
-    it = PyObject_GC_New(memoryiterobject, &PyMemoryIter_Type);
+    it = PyObject_GC_New(memoryiterobject, &_PyMemoryIter_Type);
     if (it == NULL) {
         return NULL;
     }
@@ -3246,7 +3246,7 @@ memory_iter(PyObject *seq)
     return (PyObject *)it;
 }
 
-static PyTypeObject PyMemoryIter_Type = {
+PyTypeObject _PyMemoryIter_Type = {
     PyVarObject_HEAD_INIT(&PyType_Type, 0)
     .tp_name = "memory_iterator",
     .tp_basicsize = sizeof(memoryiterobject),
diff --git a/Objects/object.c b/Objects/object.c
index 8339ab392f..c9bb60eaed 100644
--- a/Objects/object.c
+++ b/Objects/object.c
@@ -1845,6 +1845,7 @@ _PyTypes_InitState(PyInterpreterState *interp)
 extern PyTypeObject PyHKEY_Type;
 #endif
 extern PyTypeObject _Py_GenericAliasIterType;
+extern PyTypeObject _PyMemoryIter_Type;
 
 static PyTypeObject* static_types[] = {
     // The two most important base types: must be initialized first and
@@ -1944,6 +1945,7 @@ static PyTypeObject* static_types[] = {
     &_PyHamt_Type,
     &_PyInterpreterID_Type,
     &_PyManagedBuffer_Type,
+    &_PyMemoryIter_Type,
     &_PyMethodWrapper_Type,
     &_PyNamespace_Type,
     &_PyNone_Type,

[DF] commit 9652900969df77b1ac245595419431df19296af9
Author: Tim Peters <tim.peters@gmail.com>
Date:   Thu May 5 23:14:09 2022 -0500

    Issues/88027: A potential double free in list_sort_impl (#92367)
    
    merge_freemem(): set keys to NULL do it's harmless to call this again.

diff --git a/Objects/listobject.c b/Objects/listobject.c
index 972f995821..b50623ed73 100644
--- a/Objects/listobject.c
+++ b/Objects/listobject.c
@@ -1573,8 +1573,10 @@ static void
 merge_freemem(MergeState *ms)
 {
     assert(ms != NULL);
-    if (ms->a.keys != ms->temparray)
+    if (ms->a.keys != ms->temparray) {
         PyMem_Free(ms->a.keys);
+        ms->a.keys = NULL;
+    }
 }
 
 /* Ensure enough temp memory for 'need' array slots is available.

[NR] [ML] commit 9c204b148fad9742ed19b3bce173073cdec79819
Author: themylogin <themylogin@gmail.com>
Date:   Mon May 2 22:24:39 2022 +0200

    bpo-46787: Fix `ProcessPoolExecutor exception` memory leak (GH-31408) (#31408)
    
    Do not store `ProcessPoolExecutor` work item exception traceback that prevents
    exception frame locals from being garbage collected.

diff --git a/Lib/concurrent/futures/process.py b/Lib/concurrent/futures/process.py
index 695f773330..0d49379c9b 100644
--- a/Lib/concurrent/futures/process.py
+++ b/Lib/concurrent/futures/process.py
@@ -125,6 +125,9 @@ class _ExceptionWithTraceback:
     def __init__(self, exc, tb):
         tb = ''.join(format_exception(type(exc), exc, tb))
         self.exc = exc
+        # Traceback object needs to be garbage-collected as its frames
+        # contain references to all the objects in the exception scope
+        self.exc.__traceback__ = None
         self.tb = '\n"""\n%s"""' % tb
     def __reduce__(self):
         return _rebuild_exc, (self.exc, self.tb)
diff --git a/Misc/NEWS.d/next/Library/2022-02-18-20-09-29.bpo-46787.juwWc0.rst b/Misc/NEWS.d/next/Library/2022-02-18-20-09-29.bpo-46787.juwWc0.rst
new file mode 100644
index 0000000000..cf167ff481
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-02-18-20-09-29.bpo-46787.juwWc0.rst
@@ -0,0 +1 @@
+Fix :class:`concurrent.futures.ProcessPoolExecutor` exception memory leak

[ML] commit 6e3eee5c11b539e9aab39cff783acf57838c355a
Author: Ma Lin <animalize@users.noreply.github.com>
Date:   Mon Apr 4 00:16:20 2022 +0800

    bpo-23689: re module, fix memory leak when a match is terminated by a signal or memory allocation failure (GH-32283)

diff --git a/Lib/re/_compiler.py b/Lib/re/_compiler.py
index 62da8e55d7..bedd4b8f40 100644
--- a/Lib/re/_compiler.py
+++ b/Lib/re/_compiler.py
@@ -67,14 +67,21 @@
 _ignorecase_fixes = {i: tuple(j for j in t if i != j)
                      for t in _equivalences for i in t}
 
+class _CompileData:
+    __slots__ = ('code', 'repeat_count')
+    def __init__(self):
+        self.code = []
+        self.repeat_count = 0
+
 def _combine_flags(flags, add_flags, del_flags,
                    TYPE_FLAGS=_parser.TYPE_FLAGS):
     if add_flags & TYPE_FLAGS:
         flags &= ~TYPE_FLAGS
     return (flags | add_flags) & ~del_flags
 
-def _compile(code, pattern, flags):
+def _compile(data, pattern, flags):
     # internal: compile a (sub)pattern
+    code = data.code
     emit = code.append
     _len = len
     LITERAL_CODES = _LITERAL_CODES
@@ -147,7 +154,7 @@ def _compile(code, pattern, flags):
                 skip = _len(code); emit(0)
                 emit(av[0])
                 emit(av[1])
-                _compile(code, av[2], flags)
+                _compile(data, av[2], flags)
                 emit(SUCCESS)
                 code[skip] = _len(code) - skip
             else:
@@ -155,7 +162,11 @@ def _compile(code, pattern, flags):
                 skip = _len(code); emit(0)
                 emit(av[0])
                 emit(av[1])
-                _compile(code, av[2], flags)
+                # now op is in (MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT)
+                if op != POSSESSIVE_REPEAT:
+                    emit(data.repeat_count)
+                    data.repeat_count += 1
+                _compile(data, av[2], flags)
                 code[skip] = _len(code) - skip
                 emit(REPEATING_CODES[op][1])
         elif op is SUBPATTERN:
@@ -164,7 +175,7 @@ def _compile(code, pattern, flags):
                 emit(MARK)
                 emit((group-1)*2)
             # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))
-            _compile(code, p, _combine_flags(flags, add_flags, del_flags))
+            _compile(data, p, _combine_flags(flags, add_flags, del_flags))
             if group:
                 emit(MARK)
                 emit((group-1)*2+1)
@@ -176,7 +187,7 @@ def _compile(code, pattern, flags):
             # pop their stack if they reach it
             emit(ATOMIC_GROUP)
             skip = _len(code); emit(0)
-            _compile(code, av, flags)
+            _compile(data, av, flags)
             emit(SUCCESS)
             code[skip] = _len(code) - skip
         elif op in SUCCESS_CODES:
@@ -191,13 +202,13 @@ def _compile(code, pattern, flags):
                 if lo != hi:
                     raise error("look-behind requires fixed-width pattern")
                 emit(lo) # look behind
-            _compile(code, av[1], flags)
+            _compile(data, av[1], flags)
             emit(SUCCESS)
             code[skip] = _len(code) - skip
         elif op is CALL:
             emit(op)
             skip = _len(code); emit(0)
-            _compile(code, av, flags)
+            _compile(data, av, flags)
             emit(SUCCESS)
             code[skip] = _len(code) - skip
         elif op is AT:
@@ -216,7 +227,7 @@ def _compile(code, pattern, flags):
             for av in av[1]:
                 skip = _len(code); emit(0)
                 # _compile_info(code, av, flags)
-                _compile(code, av, flags)
+                _compile(data, av, flags)
                 emit(JUMP)
                 tailappend(_len(code)); emit(0)
                 code[skip] = _len(code) - skip
@@ -244,12 +255,12 @@ def _compile(code, pattern, flags):
             emit(op)
             emit(av[0]-1)
             skipyes = _len(code); emit(0)
-            _compile(code, av[1], flags)
+            _compile(data, av[1], flags)
             if av[2]:
                 emit(JUMP)
                 skipno = _len(code); emit(0)
                 code[skipyes] = _len(code) - skipyes + 1
-                _compile(code, av[2], flags)
+                _compile(data, av[2], flags)
                 code[skipno] = _len(code) - skipno
             else:
                 code[skipyes] = _len(code) - skipyes + 1
@@ -608,17 +619,17 @@ def isstring(obj):
 def _code(p, flags):
 
     flags = p.state.flags | flags
-    code = []
+    data = _CompileData()
 
     # compile info block
-    _compile_info(code, p, flags)
+    _compile_info(data.code, p, flags)
 
     # compile the pattern
-    _compile(code, p.data, flags)
+    _compile(data, p.data, flags)
 
-    code.append(SUCCESS)
+    data.code.append(SUCCESS)
 
-    return code
+    return data
 
 def _hex_code(code):
     return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)
@@ -719,7 +730,7 @@ def print_2(*args):
                     else:
                         print_(FAILURE)
                 i += 1
-            elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE,
+            elif op in (REPEAT_ONE, MIN_REPEAT_ONE,
                         POSSESSIVE_REPEAT, POSSESSIVE_REPEAT_ONE):
                 skip, min, max = code[i: i+3]
                 if max == MAXREPEAT:
@@ -727,6 +738,13 @@ def print_2(*args):
                 print_(op, skip, min, max, to=i+skip)
                 dis_(i+3, i+skip)
                 i += skip
+            elif op is REPEAT:
+                skip, min, max, repeat_index = code[i: i+4]
+                if max == MAXREPEAT:
+                    max = 'MAXREPEAT'
+                print_(op, skip, min, max, repeat_index, to=i+skip)
+                dis_(i+4, i+skip)
+                i += skip
             elif op is GROUPREF_EXISTS:
                 arg, skip = code[i: i+2]
                 print_(op, arg, skip, to=i+skip)
@@ -781,11 +799,11 @@ def compile(p, flags=0):
     else:
         pattern = None
 
-    code = _code(p, flags)
+    data = _code(p, flags)
 
     if flags & SRE_FLAG_DEBUG:
         print()
-        dis(code)
+        dis(data.code)
 
     # map in either direction
     groupindex = p.state.groupdict
@@ -794,7 +812,6 @@ def compile(p, flags=0):
         indexgroup[i] = k
 
     return _sre.compile(
-        pattern, flags | p.state.flags, code,
-        p.state.groups-1,
-        groupindex, tuple(indexgroup)
-        )
+        pattern, flags | p.state.flags, data.code,
+        p.state.groups-1, groupindex, tuple(indexgroup),
+        data.repeat_count)
diff --git a/Lib/re/_constants.py b/Lib/re/_constants.py
index c735edfea1..5317fd53e9 100644
--- a/Lib/re/_constants.py
+++ b/Lib/re/_constants.py
@@ -13,7 +13,7 @@
 
 # update when constants are added or removed
 
-MAGIC = 20220318
+MAGIC = 20220402
 
 from _sre import MAXREPEAT, MAXGROUPS
 
diff --git a/Lib/test/test_re.py b/Lib/test/test_re.py
index f1e5af452d..553eb4cfe8 100644
--- a/Lib/test/test_re.py
+++ b/Lib/test/test_re.py
@@ -1643,9 +1643,12 @@ def test_dealloc(self):
         long_overflow = 2**128
         self.assertRaises(TypeError, re.finditer, "a", {})
         with self.assertRaises(OverflowError):
-            _sre.compile("abc", 0, [long_overflow], 0, {}, ())
+            _sre.compile("abc", 0, [long_overflow], 0, {}, (), 0)
         with self.assertRaises(TypeError):
-            _sre.compile({}, 0, [], 0, [], [])
+            _sre.compile({}, 0, [], 0, [], [], 0)
+        with self.assertRaises(RuntimeError):
+            # invalid repeat_count -1
+            _sre.compile("abc", 0, [1], 0, {}, (), -1)
 
     def test_search_dot_unicode(self):
         self.assertTrue(re.search("123.*-", '123abc-'))
@@ -2334,6 +2337,27 @@ def test_possesive_repeat(self):
 14. SUCCESS
 ''')
 
+    def test_repeat_index(self):
+        self.assertEqual(get_debug_out(r'(?:ab)*?(?:cd)*'), '''\
+MIN_REPEAT 0 MAXREPEAT
+  LITERAL 97
+  LITERAL 98
+MAX_REPEAT 0 MAXREPEAT
+  LITERAL 99
+  LITERAL 100
+
+ 0. INFO 4 0b0 0 MAXREPEAT (to 5)
+ 5: REPEAT 8 0 MAXREPEAT 0 (to 14)
+10.   LITERAL 0x61 ('a')
+12.   LITERAL 0x62 ('b')
+14: MIN_UNTIL
+15. REPEAT 8 0 MAXREPEAT 1 (to 24)
+20.   LITERAL 0x63 ('c')
+22.   LITERAL 0x64 ('d')
+24: MAX_UNTIL
+25. SUCCESS
+''')
+
 
 class PatternReprTests(unittest.TestCase):
     def check(self, pattern, expected):
diff --git a/Misc/NEWS.d/next/Library/2022-04-03-13-19-08.bpo-23689.TFSc3E.rst b/Misc/NEWS.d/next/Library/2022-04-03-13-19-08.bpo-23689.TFSc3E.rst
new file mode 100644
index 0000000000..1032087d9b
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2022-04-03-13-19-08.bpo-23689.TFSc3E.rst
@@ -0,0 +1,2 @@
+:mod:`re` module: fix memory leak when a match is terminated by a signal or
+memory allocation failure. Patch by Ma Lin.
diff --git a/Modules/_sre.c b/Modules/_sre.c
index 48193f8247..506363d6fb 100644
--- a/Modules/_sre.c
+++ b/Modules/_sre.c
@@ -427,6 +427,12 @@ state_init(SRE_STATE* state, PatternObject* pattern, PyObject* string,
     state->lastmark = -1;
     state->lastindex = -1;
 
+    state->repeats_array = PyMem_New(SRE_REPEAT, pattern->repeat_count);
+    if (!state->repeats_array) {
+        PyErr_NoMemory();
+        goto err;
+    }
+
     state->buffer.buf = NULL;
     ptr = getstring(string, &length, &isbytes, &charsize, &state->buffer);
     if (!ptr)
@@ -476,6 +482,9 @@ state_init(SRE_STATE* state, PatternObject* pattern, PyObject* string,
        safely casted to `void*`, see bpo-39943 for details. */
     PyMem_Free((void*) state->mark);
     state->mark = NULL;
+    PyMem_Free(state->repeats_array);
+    state->repeats_array = NULL;
+
     if (state->buffer.buf)
         PyBuffer_Release(&state->buffer);
     return NULL;
@@ -491,6 +500,8 @@ state_fini(SRE_STATE* state)
     /* See above PyMem_Del for why we explicitly cast here. */
     PyMem_Free((void*) state->mark);
     state->mark = NULL;
+    PyMem_Free(state->repeats_array);
+    state->repeats_array = NULL;
 }
 
 /* calculate offset from start of string */
@@ -1407,14 +1418,15 @@ _sre.compile
     groups: Py_ssize_t
     groupindex: object(subclass_of='&PyDict_Type')
     indexgroup: object(subclass_of='&PyTuple_Type')
+    repeat_count: Py_ssize_t
 
 [clinic start generated code]*/
 
 static PyObject *
 _sre_compile_impl(PyObject *module, PyObject *pattern, int flags,
                   PyObject *code, Py_ssize_t groups, PyObject *groupindex,
-                  PyObject *indexgroup)
-/*[clinic end generated code: output=ef9c2b3693776404 input=0a68476dbbe5db30]*/
+                  PyObject *indexgroup, Py_ssize_t repeat_count)
+/*[clinic end generated code: output=922af562d51b1657 input=77e39c322501ec2a]*/
 {
     /* "compile" pattern descriptor to pattern object */
 
@@ -1472,8 +1484,8 @@ _sre_compile_impl(PyObject *module, PyObject *pattern, int flags,
     self->pattern = pattern;
 
     self->flags = flags;
-
     self->groups = groups;
+    self->repeat_count = repeat_count;
 
     if (PyDict_GET_SIZE(groupindex) > 0) {
         Py_INCREF(groupindex);
@@ -1645,7 +1657,7 @@ _validate_charset(SRE_CODE *code, SRE_CODE *end)
 }
 
 static int
-_validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
+_validate_inner(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
 {
     /* Some variables are manipulated by the macros above */
     SRE_CODE op;
@@ -1666,8 +1678,8 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
                sre_match() code is robust even if they don't, and the worst
                you can get is nonsensical match results. */
             GET_ARG;
-            if (arg > 2 * (size_t)groups + 1) {
-                VTRACE(("arg=%d, groups=%d\n", (int)arg, (int)groups));
+            if (arg > 2 * (size_t)self->groups + 1) {
+                VTRACE(("arg=%d, groups=%d\n", (int)arg, (int)self->groups));
                 FAIL;
             }
             break;
@@ -1796,7 +1808,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
                     if (skip == 0)
                         break;
                     /* Stop 2 before the end; we check the JUMP below */
-                    if (!_validate_inner(code, code+skip-3, groups))
+                    if (!_validate_inner(code, code+skip-3, self))
                         FAIL;
                     code += skip-3;
                     /* Check that it ends with a JUMP, and that each JUMP
@@ -1825,7 +1837,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
                     FAIL;
                 if (max > SRE_MAXREPEAT)
                     FAIL;
-                if (!_validate_inner(code, code+skip-4, groups))
+                if (!_validate_inner(code, code+skip-4, self))
                     FAIL;
                 code += skip-4;
                 GET_OP;
@@ -1837,7 +1849,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
         case SRE_OP_REPEAT:
         case SRE_OP_POSSESSIVE_REPEAT:
             {
-                SRE_CODE op1 = op, min, max;
+                SRE_CODE op1 = op, min, max, repeat_index;
                 GET_SKIP;
                 GET_ARG; min = arg;
                 GET_ARG; max = arg;
@@ -1845,9 +1857,17 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
                     FAIL;
                 if (max > SRE_MAXREPEAT)
                     FAIL;
-                if (!_validate_inner(code, code+skip-3, groups))
+                if (op1 == SRE_OP_REPEAT) {
+                    GET_ARG; repeat_index = arg;
+                    if (repeat_index >= (size_t)self->repeat_count)
+                        FAIL;
+                    skip -= 4;
+                } else {
+                    skip -= 3;
+                }
+                if (!_validate_inner(code, code+skip, self))
                     FAIL;
-                code += skip-3;
+                code += skip;
                 GET_OP;
                 if (op1 == SRE_OP_POSSESSIVE_REPEAT) {
                     if (op != SRE_OP_SUCCESS)
@@ -1863,7 +1883,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
         case SRE_OP_ATOMIC_GROUP:
             {
                 GET_SKIP;
-                if (!_validate_inner(code, code+skip-2, groups))
+                if (!_validate_inner(code, code+skip-2, self))
                     FAIL;
                 code += skip-2;
                 GET_OP;
@@ -1877,7 +1897,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
         case SRE_OP_GROUPREF_UNI_IGNORE:
         case SRE_OP_GROUPREF_LOC_IGNORE:
             GET_ARG;
-            if (arg >= (size_t)groups)
+            if (arg >= (size_t)self->groups)
                 FAIL;
             break;
 
@@ -1886,7 +1906,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
                'group' is either an integer group number or a group name,
                'then' and 'else' are sub-regexes, and 'else' is optional. */
             GET_ARG;
-            if (arg >= (size_t)groups)
+            if (arg >= (size_t)self->groups)
                 FAIL;
             GET_SKIP_ADJ(1);
             code--; /* The skip is relative to the first arg! */
@@ -1919,17 +1939,17 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
                 code[skip-3] == SRE_OP_JUMP)
             {
                 VTRACE(("both then and else parts present\n"));
-                if (!_validate_inner(code+1, code+skip-3, groups))
+                if (!_validate_inner(code+1, code+skip-3, self))
                     FAIL;
                 code += skip-2; /* Position after JUMP, at <skipno> */
                 GET_SKIP;
-                if (!_validate_inner(code, code+skip-1, groups))
+                if (!_validate_inner(code, code+skip-1, self))
                     FAIL;
                 code += skip-1;
             }
             else {
                 VTRACE(("only a then part present\n"));
-                if (!_validate_inner(code+1, code+skip-1, groups))
+                if (!_validate_inner(code+1, code+skip-1, self))
                     FAIL;
                 code += skip-1;
             }
@@ -1943,7 +1963,7 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
             if (arg & 0x80000000)
                 FAIL; /* Width too large */
             /* Stop 1 before the end; we check the SUCCESS below */
-            if (!_validate_inner(code+1, code+skip-2, groups))
+            if (!_validate_inner(code+1, code+skip-2, self))
                 FAIL;
             code += skip-2;
             GET_OP;
@@ -1962,18 +1982,19 @@ _validate_inner(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
 }
 
 static int
-_validate_outer(SRE_CODE *code, SRE_CODE *end, Py_ssize_t groups)
+_validate_outer(SRE_CODE *code, SRE_CODE *end, PatternObject *self)
 {
-    if (groups < 0 || (size_t)groups > SRE_MAXGROUPS ||
+    if (self->groups < 0 || (size_t)self->groups > SRE_MAXGROUPS ||
+        self->repeat_count < 0 ||
         code >= end || end[-1] != SRE_OP_SUCCESS)
         FAIL;
-    return _validate_inner(code, end-1, groups);
+    return _validate_inner(code, end-1, self);
 }
 
 static int
 _validate(PatternObject *self)
 {
-    if (!_validate_outer(self->code, self->code+self->codesize, self->groups))
+    if (!_validate_outer(self->code, self->code+self->codesize, self))
     {
         PyErr_SetString(PyExc_RuntimeError, "invalid SRE code");
         return 0;
diff --git a/Modules/clinic/_sre.c.h b/Modules/clinic/_sre.c.h
index 72d772c289..34cbe21f14 100644
--- a/Modules/clinic/_sre.c.h
+++ b/Modules/clinic/_sre.c.h
@@ -544,7 +544,7 @@ PyDoc_STRVAR(_sre_SRE_Pattern___deepcopy____doc__,
 
 PyDoc_STRVAR(_sre_compile__doc__,
 "compile($module, /, pattern, flags, code, groups, groupindex,\n"
-"        indexgroup)\n"
+"        indexgroup, repeat_count)\n"
 "--\n"
 "\n");
 
@@ -554,23 +554,24 @@ PyDoc_STRVAR(_sre_compile__doc__,
 static PyObject *
 _sre_compile_impl(PyObject *module, PyObject *pattern, int flags,
                   PyObject *code, Py_ssize_t groups, PyObject *groupindex,
-                  PyObject *indexgroup);
+                  PyObject *indexgroup, Py_ssize_t repeat_count);
 
 static PyObject *
 _sre_compile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
 {
     PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"pattern", "flags", "code", "groups", "groupindex", "indexgroup", NULL};
+    static const char * const _keywords[] = {"pattern", "flags", "code", "groups", "groupindex", "indexgroup", "repeat_count", NULL};
     static _PyArg_Parser _parser = {NULL, _keywords, "compile", 0};
-    PyObject *argsbuf[6];
+    PyObject *argsbuf[7];
     PyObject *pattern;
     int flags;
     PyObject *code;
     Py_ssize_t groups;
     PyObject *groupindex;
     PyObject *indexgroup;
+    Py_ssize_t repeat_count;
 
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 6, 6, 0, argsbuf);
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 7, 7, 0, argsbuf);
     if (!args) {
         goto exit;
     }
@@ -606,7 +607,19 @@ _sre_compile(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject
         goto exit;
     }
     indexgroup = args[5];
-    return_value = _sre_compile_impl(module, pattern, flags, code, groups, groupindex, indexgroup);
+    {
+        Py_ssize_t ival = -1;
+        PyObject *iobj = _PyNumber_Index(args[6]);
+        if (iobj != NULL) {
+            ival = PyLong_AsSsize_t(iobj);
+            Py_DECREF(iobj);
+        }
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        repeat_count = ival;
+    }
+    return_value = _sre_compile_impl(module, pattern, flags, code, groups, groupindex, indexgroup, repeat_count);
 
 exit:
     return return_value;
@@ -910,4 +923,4 @@ _sre_SRE_Scanner_search(ScannerObject *self, PyTypeObject *cls, PyObject *const
 exit:
     return return_value;
 }
-/*[clinic end generated code: output=518f7bb775c1184f input=a9049054013a1b77]*/
+/*[clinic end generated code: output=9d7510a57a157a38 input=a9049054013a1b77]*/
diff --git a/Modules/sre.h b/Modules/sre.h
index 785adbd003..e2c5277aef 100644
--- a/Modules/sre.h
+++ b/Modules/sre.h
@@ -29,6 +29,8 @@ typedef struct {
     Py_ssize_t groups; /* must be first! */
     PyObject* groupindex; /* dict */
     PyObject* indexgroup; /* tuple */
+    /* the number of REPEATs */
+    Py_ssize_t repeat_count;
     /* compatibility */
     PyObject* pattern; /* pattern source (or None) */
     int flags; /* flags used when compiling pattern source */
@@ -83,6 +85,8 @@ typedef struct {
     size_t data_stack_base;
     /* current repeat context */
     SRE_REPEAT *repeat;
+    /* repeat contexts array */
+    SRE_REPEAT *repeats_array;
 } SRE_STATE;
 
 typedef struct {
diff --git a/Modules/sre_constants.h b/Modules/sre_constants.h
index 45395dcea8..8b249493bd 100644
--- a/Modules/sre_constants.h
+++ b/Modules/sre_constants.h
@@ -11,7 +11,7 @@
  * See the _sre.c file for information on usage and redistribution.
  */
 
-#define SRE_MAGIC 20220318
+#define SRE_MAGIC 20220402
 #define SRE_OP_FAILURE 0
 #define SRE_OP_SUCCESS 1
 #define SRE_OP_ANY 2
diff --git a/Modules/sre_lib.h b/Modules/sre_lib.h
index 8e4e714ead..1cc926d956 100644
--- a/Modules/sre_lib.h
+++ b/Modules/sre_lib.h
@@ -1032,16 +1032,14 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
         case SRE_OP_REPEAT:
             /* create repeat context.  all the hard work is done
                by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
-            /* <REPEAT> <skip> <1=min> <2=max> item <UNTIL> tail */
-            TRACE(("|%p|%p|REPEAT %d %d\n", ctx->pattern, ctx->ptr,
-                   ctx->pattern[1], ctx->pattern[2]));
+            /* <REPEAT> <skip> <1=min> <2=max>
+               <3=repeat_index> item <UNTIL> tail */
+            TRACE(("|%p|%p|REPEAT %d %d %d\n", ctx->pattern, ctx->ptr,
+                   ctx->pattern[1], ctx->pattern[2], ctx->pattern[3]));
+
+            /* install repeat context */
+            ctx->u.rep = &state->repeats_array[ctx->pattern[3]];
 
-            /* install new repeat context */
-            ctx->u.rep = (SRE_REPEAT*) PyObject_Malloc(sizeof(*ctx->u.rep));
-            if (!ctx->u.rep) {
-                PyErr_NoMemory();
-                RETURN_FAILURE;
-            }
             ctx->u.rep->count = -1;
             ctx->u.rep->pattern = ctx->pattern;
             ctx->u.rep->prev = state->repeat;
@@ -1051,7 +1049,6 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
             state->ptr = ctx->ptr;
             DO_JUMP(JUMP_REPEAT, jump_repeat, ctx->pattern+ctx->pattern[0]);
             state->repeat = ctx->u.rep->prev;
-            PyObject_Free(ctx->u.rep);
 
             if (ret) {
                 RETURN_ON_ERROR(ret);
@@ -1061,7 +1058,8 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
 
         case SRE_OP_MAX_UNTIL:
             /* maximizing repeat */
-            /* <REPEAT> <skip> <1=min> <2=max> item <MAX_UNTIL> tail */
+            /* <REPEAT> <skip> <1=min> <2=max>
+               <3=repeat_index> item <MAX_UNTIL> tail */
 
             /* FIXME: we probably need to deal with zero-width
                matches in here... */
@@ -1081,7 +1079,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                 /* not enough matches */
                 ctx->u.rep->count = ctx->count;
                 DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
-                        ctx->u.rep->pattern+3);
+                        ctx->u.rep->pattern+4);
                 if (ret) {
                     RETURN_ON_ERROR(ret);
                     RETURN_SUCCESS;
@@ -1103,7 +1101,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                 DATA_PUSH(&ctx->u.rep->last_ptr);
                 ctx->u.rep->last_ptr = state->ptr;
                 DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
-                        ctx->u.rep->pattern+3);
+                        ctx->u.rep->pattern+4);
                 DATA_POP(&ctx->u.rep->last_ptr);
                 if (ret) {
                     MARK_POP_DISCARD(ctx->lastmark);
@@ -1128,7 +1126,8 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
 
         case SRE_OP_MIN_UNTIL:
             /* minimizing repeat */
-            /* <REPEAT> <skip> <1=min> <2=max> item <MIN_UNTIL> tail */
+            /* <REPEAT> <skip> <1=min> <2=max>
+               <3=repeat_index> item <MIN_UNTIL> tail */
 
             ctx->u.rep = state->repeat;
             if (!ctx->u.rep)
@@ -1145,7 +1144,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
                 /* not enough matches */
                 ctx->u.rep->count = ctx->count;
                 DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
-                        ctx->u.rep->pattern+3);
+                        ctx->u.rep->pattern+4);
                 if (ret) {
                     RETURN_ON_ERROR(ret);
                     RETURN_SUCCESS;
@@ -1188,7 +1187,7 @@ SRE(match)(SRE_STATE* state, const SRE_CODE* pattern, int toplevel)
             DATA_PUSH(&ctx->u.rep->last_ptr);
             ctx->u.rep->last_ptr = state->ptr;
             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
-                    ctx->u.rep->pattern+3);
+                    ctx->u.rep->pattern+4);
             DATA_POP(&ctx->u.rep->last_ptr);
             if (ret) {
                 RETURN_ON_ERROR(ret);

[NR] [ML] commit 4dc746310bd37ad6b381f9176acd167d445f4385
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Thu Feb 24 22:24:06 2022 +0530

    bpo-46430: Fix memory leak in interned strings of deep-frozen modules (GH-31549)

diff --git a/Include/internal/pycore_pylifecycle.h b/Include/internal/pycore_pylifecycle.h
index 439bc5b470..deac6ee3d3 100644
--- a/Include/internal/pycore_pylifecycle.h
+++ b/Include/internal/pycore_pylifecycle.h
@@ -65,7 +65,7 @@ extern PyStatus _Py_HashRandomization_Init(const PyConfig *);
 extern PyStatus _PyImportZip_Init(PyThreadState *tstate);
 extern PyStatus _PyGC_Init(PyInterpreterState *interp);
 extern PyStatus _PyAtExit_Init(PyInterpreterState *interp);
-
+extern void _Py_Deepfreeze_Init(void);
 
 /* Various internal finalizers */
 
diff --git a/Misc/NEWS.d/next/Core and Builtins/2022-02-24-07-33-29.bpo-46430.c91TAg.rst b/Misc/NEWS.d/next/Core and Builtins/2022-02-24-07-33-29.bpo-46430.c91TAg.rst
new file mode 100644
index 0000000000..0ae128ba7b
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2022-02-24-07-33-29.bpo-46430.c91TAg.rst	
@@ -0,0 +1 @@
+Fix memory leak in interned strings of deep-frozen modules.
diff --git a/Programs/_bootstrap_python.c b/Programs/_bootstrap_python.c
index f4d0167b62..75d455ca17 100644
--- a/Programs/_bootstrap_python.c
+++ b/Programs/_bootstrap_python.c
@@ -14,9 +14,13 @@
 #include "Python/frozen_modules/importlib._bootstrap_external.h"
 /* End includes */
 
-/* Empty finalizer for deepfrozen modules*/
+/* Empty initializer for deepfrozen modules */
+void _Py_Deepfreeze_Init(void)
+{
+}
+/* Empty finalizer for deepfrozen modules */
 void
-_Py_Deepfreeze_Fini(void) 
+_Py_Deepfreeze_Fini(void)
 {
 }
 
diff --git a/Programs/_freeze_module.c b/Programs/_freeze_module.c
index 99a1d4dfc2..d5a236a0c6 100644
--- a/Programs/_freeze_module.c
+++ b/Programs/_freeze_module.c
@@ -22,6 +22,10 @@
 #include <unistd.h>
 #endif
 
+/* Empty initializer for deepfrozen modules */
+void _Py_Deepfreeze_Init(void)
+{
+}
 /* Empty finalizer for deepfrozen modules */
 void
 _Py_Deepfreeze_Fini(void)
diff --git a/Python/pylifecycle.c b/Python/pylifecycle.c
index b6310c9aeb..9dd769a0e8 100644
--- a/Python/pylifecycle.c
+++ b/Python/pylifecycle.c
@@ -754,7 +754,6 @@ pycore_init_types(PyInterpreterState *interp)
     if (_PyStatus_EXCEPTION(status)) {
         return status;
     }
-
     return _PyStatus_OK();
 }
 
@@ -827,7 +826,10 @@ pycore_interp_init(PyThreadState *tstate)
     if (_PyStatus_EXCEPTION(status)) {
         return status;
     }
-
+    // Intern strings in deep-frozen modules first so that others
+    // can use it instead of creating a heap allocated string.
+    _Py_Deepfreeze_Init();
+    
     status = pycore_init_types(interp);
     if (_PyStatus_EXCEPTION(status)) {
         goto done;
diff --git a/Tools/scripts/deepfreeze.py b/Tools/scripts/deepfreeze.py
index 0edf3af71d..b62be3713f 100644
--- a/Tools/scripts/deepfreeze.py
+++ b/Tools/scripts/deepfreeze.py
@@ -110,6 +110,7 @@ def __init__(self, file: TextIO) -> None:
         self.hits, self.misses = 0, 0
         self.patchups: list[str] = []
         self.deallocs: list[str] = []
+        self.interns: list[str] = []
         self.write('#include "Python.h"')
         self.write('#include "internal/pycore_gc.h"')
         self.write('#include "internal/pycore_code.h"')
@@ -279,7 +280,7 @@ def generate_code(self, name: str, code: types.CodeType) -> str:
             self.write(f".co_cellvars = {co_cellvars},")
             self.write(f".co_freevars = {co_freevars},")
         self.deallocs.append(f"_PyStaticCode_Dealloc(&{name});")
-        self.patchups.append(f"_PyStaticCode_InternStrings(&{name});")
+        self.interns.append(f"_PyStaticCode_InternStrings(&{name});")
         return f"& {name}.ob_base"
 
     def generate_tuple(self, name: str, t: Tuple[object, ...]) -> str:
@@ -446,6 +447,9 @@ def generate(args: list[str], output: TextIO) -> None:
     with printer.block(f"void\n_Py_Deepfreeze_Fini(void)"):
             for p in printer.deallocs:
                 printer.write(p)
+    with printer.block(f"void\n_Py_Deepfreeze_Init(void)"):
+            for p in printer.interns:
+                printer.write(p)
     if verbose:
         print(f"Cache hits: {printer.hits}, misses: {printer.misses}")
 

[ML] commit c7f810b34d91a5c2fbe0a8385562015d2dd961f2
Author: Kumar Aditya <59607654+kumaraditya303@users.noreply.github.com>
Date:   Thu Jan 27 18:33:47 2022 +0530

    bpo-46476: Fix memory leak in code objects generated by deepfreeze (GH-30853)
    
    Add _Py_Deepfreeze_Fini() and _PyStaticCode_Dealloc() functions.

diff --git a/Include/internal/pycore_code.h b/Include/internal/pycore_code.h
index dfc7530031..884a91f3fb 100644
--- a/Include/internal/pycore_code.h
+++ b/Include/internal/pycore_code.h
@@ -276,6 +276,8 @@ void _Py_Specialize_BinaryOp(PyObject *lhs, PyObject *rhs, _Py_CODEUNIT *instr,
                              SpecializedCacheEntry *cache);
 void _Py_Specialize_CompareOp(PyObject *lhs, PyObject *rhs, _Py_CODEUNIT *instr, SpecializedCacheEntry *cache);
 
+/* Deallocator function for static codeobjects used in deepfreeze.py */
+void _PyStaticCode_Dealloc(PyCodeObject *co, _Py_CODEUNIT *firstinstr);
 
 #ifdef Py_STATS
 
diff --git a/Include/internal/pycore_pylifecycle.h b/Include/internal/pycore_pylifecycle.h
index 35e560b42e..439bc5b470 100644
--- a/Include/internal/pycore_pylifecycle.h
+++ b/Include/internal/pycore_pylifecycle.h
@@ -83,6 +83,7 @@ extern void _PyWarnings_Fini(PyInterpreterState *interp);
 extern void _PyAST_Fini(PyInterpreterState *interp);
 extern void _PyAtExit_Fini(PyInterpreterState *interp);
 extern void _PyThread_FiniType(PyInterpreterState *interp);
+extern void _Py_Deepfreeze_Fini(void);
 
 extern PyStatus _PyGILState_Init(_PyRuntimeState *runtime);
 extern PyStatus _PyGILState_SetTstate(PyThreadState *tstate);
diff --git a/Misc/NEWS.d/next/Core and Builtins/2022-01-24-15-39-34.bpo-46476.cvP1Mr.rst b/Misc/NEWS.d/next/Core and Builtins/2022-01-24-15-39-34.bpo-46476.cvP1Mr.rst
new file mode 100644
index 0000000000..26079839a5
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2022-01-24-15-39-34.bpo-46476.cvP1Mr.rst	
@@ -0,0 +1 @@
+Fix memory leak in code objects generated by deepfreeze. Patch by Kumar Aditya.
\ No newline at end of file
diff --git a/Objects/codeobject.c b/Objects/codeobject.c
index a413b183be..f983d66db0 100644
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -1906,3 +1906,18 @@ _PyCode_ConstantKey(PyObject *op)
     }
     return key;
 }
+
+void 
+_PyStaticCode_Dealloc(PyCodeObject *co, _Py_CODEUNIT *firstinstr)
+{
+    PyMem_Free(co->co_quickened);
+    co->co_quickened = NULL;
+    PyMem_Free(co->co_extra);
+    co->co_extra = NULL;
+    co->co_firstinstr = firstinstr;
+    if (co->co_weakreflist != NULL) {
+        PyObject_ClearWeakRefs((PyObject *)co);
+        co->co_weakreflist = NULL;
+    }
+    co->co_warmup = QUICKENING_INITIAL_WARMUP_VALUE;
+}
diff --git a/Programs/_bootstrap_python.c b/Programs/_bootstrap_python.c
index f2103fd5aa..f4d0167b62 100644
--- a/Programs/_bootstrap_python.c
+++ b/Programs/_bootstrap_python.c
@@ -14,6 +14,12 @@
 #include "Python/frozen_modules/importlib._bootstrap_external.h"
 /* End includes */
 
+/* Empty finalizer for deepfrozen modules*/
+void
+_Py_Deepfreeze_Fini(void) 
+{
+}
+
 /* Note that a negative size indicates a package. */
 
 static const struct _frozen bootstrap_modules[] = {
@@ -103,3 +109,4 @@ main(int argc, char **argv)
     }
     Py_ExitStatusException(status);
 }
+
diff --git a/Programs/_freeze_module.c b/Programs/_freeze_module.c
index b2f1a24016..99a1d4dfc2 100644
--- a/Programs/_freeze_module.c
+++ b/Programs/_freeze_module.c
@@ -22,6 +22,12 @@
 #include <unistd.h>
 #endif
 
+/* Empty finalizer for deepfrozen modules */
+void
+_Py_Deepfreeze_Fini(void)
+{
+}
+
 /* To avoid a circular dependency on frozen.o, we create our own structure
    of frozen modules instead, left deliberately blank so as to avoid
    unintentional import of a stale version of _frozen_importlib. */
@@ -235,3 +241,4 @@ main(int argc, char *argv[])
     Py_Finalize();
     return 1;
 }
+
diff --git a/Python/pylifecycle.c b/Python/pylifecycle.c
index 9d10f94efa..106e11ea12 100644
--- a/Python/pylifecycle.c
+++ b/Python/pylifecycle.c
@@ -1723,6 +1723,7 @@ finalize_interp_clear(PyThreadState *tstate)
         _Py_HashRandomization_Fini();
         _PyArg_Fini();
         _Py_ClearFileSystemEncoding();
+        _Py_Deepfreeze_Fini();
     }
 
     finalize_interp_types(tstate->interp);
diff --git a/Tools/scripts/deepfreeze.py b/Tools/scripts/deepfreeze.py
index a1ef85ea89..78849390f1 100644
--- a/Tools/scripts/deepfreeze.py
+++ b/Tools/scripts/deepfreeze.py
@@ -109,6 +109,7 @@ def __init__(self, file: TextIO) -> None:
         self.cache: Dict[tuple[type, object, str], str] = {}
         self.hits, self.misses = 0, 0
         self.patchups: list[str] = []
+        self.deallocs: list[str] = []
         self.write('#include "Python.h"')
         self.write('#include "internal/pycore_gc.h"')
         self.write('#include "internal/pycore_code.h"')
@@ -277,6 +278,7 @@ def generate_code(self, name: str, code: types.CodeType) -> str:
             self.write(f".co_varnames = {co_varnames},")
             self.write(f".co_cellvars = {co_cellvars},")
             self.write(f".co_freevars = {co_freevars},")
+        self.deallocs.append(f"_PyStaticCode_Dealloc(&{name}, (_Py_CODEUNIT *) {removesuffix(co_code, '.ob_base.ob_base')}.ob_sval);")
         return f"& {name}.ob_base"
 
     def generate_tuple(self, name: str, t: Tuple[object, ...]) -> str:
@@ -440,6 +442,9 @@ def generate(args: list[str], output: TextIO) -> None:
             else:
                 code = compile(fd.read(), f"<frozen {modname}>", "exec")
             printer.generate_file(modname, code)
+    with printer.block(f"void\n_Py_Deepfreeze_Fini(void)"):
+            for p in printer.deallocs:
+                printer.write(p)
     if verbose:
         print(f"Cache hits: {printer.hits}, misses: {printer.misses}")
 

[ML] commit 607d8a838f29ad3c4c4e85b39f338dade5f9cafe
Author: Yury Selivanov <yury@edgedb.com>
Date:   Tue Jan 11 14:25:28 2022 -0800

    bpo-46347: Fix memory leak in PyEval_EvalCodeEx. (#30546)
    
    First introduced in 0332e569c12d3dc97171546c6dc10e42c27de34b

diff --git a/Misc/NEWS.d/next/Core and Builtins/2022-01-11-13-57-00.bpo-46347.Gd8M-S.rst b/Misc/NEWS.d/next/Core and Builtins/2022-01-11-13-57-00.bpo-46347.Gd8M-S.rst
new file mode 100644
index 0000000000..fc12d6ba14
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2022-01-11-13-57-00.bpo-46347.Gd8M-S.rst	
@@ -0,0 +1 @@
+Fix memory leak in PyEval_EvalCodeEx.
diff --git a/Python/ceval.c b/Python/ceval.c
index be26ffd822..85b4400de3 100644
--- a/Python/ceval.c
+++ b/Python/ceval.c
@@ -6128,16 +6128,9 @@ PyEval_EvalCodeEx(PyObject *_co, PyObject *globals, PyObject *locals,
         }
         allargs = newargs;
     }
-    PyObject **kwargs = PyMem_Malloc(sizeof(PyObject *)*kwcount);
-    if (kwargs == NULL) {
-        res = NULL;
-        Py_DECREF(kwnames);
-        goto fail;
-    }
     for (int i = 0; i < kwcount; i++) {
         Py_INCREF(kws[2*i]);
         PyTuple_SET_ITEM(kwnames, i, kws[2*i]);
-        kwargs[i] = kws[2*i+1];
     }
     PyFrameConstructor constr = {
         .fc_globals = globals,

[NR] [ML] commit 8f42106b5c362495f72c6ca2fa3884538e4023db
Author: Yurii Karabas <1998uriyyo@gmail.com>
Date:   Fri Jul 23 17:28:05 2021 +0300

    bpo-44353: Fix memory leak introduced by GH-27262 (GH-27305)

diff --git a/Lib/test/test_typing.py b/Lib/test/test_typing.py
index 6f1d4f6ce2..ebe6c8d37e 100644
--- a/Lib/test/test_typing.py
+++ b/Lib/test/test_typing.py
@@ -3692,10 +3692,15 @@ def test_c_functions(self):
 
 
 class NewTypeTests:
+    def cleanup(self):
+        for f in self.module._cleanups:
+            f()
+
     def setUp(self):
         sys.modules['typing'] = self.module
 
     def tearDown(self):
+        self.cleanup()
         sys.modules['typing'] = typing
 
     def test_basic(self):
@@ -3738,12 +3743,12 @@ def test_repr(self):
 
         self.assertEqual(repr(UserId), f'{__name__}.UserId')
 
-class NewTypePythonTests(BaseTestCase, NewTypeTests):
+class NewTypePythonTests(NewTypeTests, BaseTestCase):
     module = py_typing
 
 
 @skipUnless(c_typing, 'requires _typing')
-class NewTypeCTests(BaseTestCase, NewTypeTests):
+class NewTypeCTests(NewTypeTests, BaseTestCase):
     module = c_typing
 
 

[ML] commit f572cbf1faab33d9afbbe3e95738ed6fbe6e48e6
Author: Serhiy Storchaka <storchaka@gmail.com>
Date:   Wed Jul 14 08:19:18 2021 +0300

    bpo-44608: Fix memory leak in _tkinter._flatten() (GH-27107)
    
    if it is called with a sequence or set, but not list or tuple.

diff --git a/Lib/test/test_tcl.py b/Lib/test/test_tcl.py
index e7a60db777..6e5ef097c8 100644
--- a/Lib/test/test_tcl.py
+++ b/Lib/test/test_tcl.py
@@ -43,8 +43,14 @@ def get_tk_patchlevel():
 class TkinterTest(unittest.TestCase):
 
     def testFlattenLen(self):
-        # flatten(<object with no length>)
+        # Object without length.
         self.assertRaises(TypeError, _tkinter._flatten, True)
+        # Object with length, but not sequence.
+        self.assertRaises(TypeError, _tkinter._flatten, {})
+        # Sequence or set, but not tuple or list.
+        # (issue44608: there were leaks in the following cases)
+        self.assertRaises(TypeError, _tkinter._flatten, 'string')
+        self.assertRaises(TypeError, _tkinter._flatten, {'set'})
 
 
 class TclTest(unittest.TestCase):
diff --git a/Misc/NEWS.d/next/Library/2021-07-13-09-01-33.bpo-44608.R3IcM1.rst b/Misc/NEWS.d/next/Library/2021-07-13-09-01-33.bpo-44608.R3IcM1.rst
new file mode 100644
index 0000000000..e0cf948f3c
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2021-07-13-09-01-33.bpo-44608.R3IcM1.rst
@@ -0,0 +1,2 @@
+Fix memory leak in :func:`_tkinter._flatten` if it is called with a sequence
+or set, but not list or tuple.
diff --git a/Modules/_tkinter.c b/Modules/_tkinter.c
index 14101d9e39..329b291729 100644
--- a/Modules/_tkinter.c
+++ b/Modules/_tkinter.c
@@ -3197,8 +3197,10 @@ _tkinter__flatten(PyObject *module, PyObject *item)
 
     context.size = 0;
 
-    if (!_flatten1(&context, item,0))
+    if (!_flatten1(&context, item, 0)) {
+        Py_XDECREF(context.tuple);
         return NULL;
+    }
 
     if (_PyTuple_Resize(&context.tuple, context.size))
         return NULL;

[ML] commit dfeec347f21b86879ba8f27f567bb275b243f1bc
Author: Zackery Spytz <zspytz@gmail.com>
Date:   Tue Mar 30 00:22:34 2021 -0600

    bpo-43637: Fix a possible memory leak in winreg.SetValueEx() (GH-25038)

diff --git a/PC/winreg.c b/PC/winreg.c
index fb488d8eb0..004a89a535 100644
--- a/PC/winreg.c
+++ b/PC/winreg.c
@@ -1813,6 +1813,7 @@ winreg_SetValueEx_impl(PyObject *module, HKEY key,
     if (PySys_Audit("winreg.SetValue", "nunO",
                     (Py_ssize_t)key, value_name, (Py_ssize_t)type,
                     value) < 0) {
+        PyMem_Free(data);
         return NULL;
     }
     Py_BEGIN_ALLOW_THREADS

[ML] commit fd009e606a48e803e7187983bf9a5682e938fddb
Author: Mark Shannon <mark@hotpy.org>
Date:   Fri Nov 13 12:53:53 2020 +0000

    bpo-42246: Fix memory leak in compiler (GH-23256)
    
    * Fix potential memory leak in assembler init.
    
    * Fix reference leak when encountering error during compilation of function body.

diff --git a/Python/compile.c b/Python/compile.c
index 5a0292646b..c2fcf096fb 100644
--- a/Python/compile.c
+++ b/Python/compile.c
@@ -2276,7 +2276,7 @@ compiler_function(struct compiler *c, stmt_ty s, int is_async)
     c->u->u_posonlyargcount = asdl_seq_LEN(args->posonlyargs);
     c->u->u_kwonlyargcount = asdl_seq_LEN(args->kwonlyargs);
     for (i = docstring ? 1 : 0; i < asdl_seq_LEN(body); i++) {
-        VISIT(c, stmt, (stmt_ty)asdl_seq_GET(body, i));
+        VISIT_IN_SCOPE(c, stmt, (stmt_ty)asdl_seq_GET(body, i));
     }
     co = assemble(c, 1);
     qualname = c->u->u_qualname;
@@ -5533,18 +5533,24 @@ assemble_init(struct assembler *a, int nblocks, int firstlineno)
 {
     memset(a, 0, sizeof(struct assembler));
     a->a_prevlineno = a->a_lineno = firstlineno;
+    a->a_lnotab = NULL;
     a->a_bytecode = PyBytes_FromStringAndSize(NULL, DEFAULT_CODE_SIZE);
-    if (!a->a_bytecode)
-        return 0;
+    if (a->a_bytecode == NULL) {
+        goto error;
+    }
     a->a_lnotab = PyBytes_FromStringAndSize(NULL, DEFAULT_LNOTAB_SIZE);
-    if (!a->a_lnotab)
-        return 0;
+    if (a->a_lnotab == NULL) {
+        goto error;
+    }
     if ((size_t)nblocks > SIZE_MAX / sizeof(basicblock *)) {
         PyErr_NoMemory();
-        return 0;
+        goto error;
     }
-
     return 1;
+error:
+    Py_XDECREF(a->a_bytecode);
+    Py_XDECREF(a->a_lnotab);
+    return 0;
 }
 
 static void

[ML] commit cda99b4022daa08ac74b0420e9903cce883d91c6
Author: Andrew Svetlov <andrew.svetlov@gmail.com>
Date:   Wed Nov 11 17:48:53 2020 +0200

    Fix memory leak introduced by GH-22780 (GH-23237)

diff --git a/Modules/_asynciomodule.c b/Modules/_asynciomodule.c
index d1d0f6bc75..01e36c656d 100644
--- a/Modules/_asynciomodule.c
+++ b/Modules/_asynciomodule.c
@@ -1628,6 +1628,7 @@ FutureIter_am_send(futureiterobject *it,
     it->future = NULL;
     res = _asyncio_Future_result_impl(fut);
     if (res != NULL) {
+        Py_DECREF(fut);
         *result = res;
         return PYGEN_RETURN;
     }

[ML] commit c0590c0033e86f98cdf5f2ca6898656f98ab4053
Author: Alexey Izbyshev <izbyshev@ispras.ru>
Date:   Mon Oct 26 03:09:32 2020 +0300

    bpo-42146: Fix memory leak in subprocess.Popen() in case of uid/gid overflow (GH-22966)
    
    Fix memory leak in subprocess.Popen() in case of uid/gid overflow
    
    Also add a test that would catch this leak with `--huntrleaks`.
    
    Alas, the test for `extra_groups` also exposes an inconsistency
    in our error reporting: we use a custom ValueError for `extra_groups`,
    but propagate OverflowError for `user` and `group`.

diff --git a/Lib/test/test_subprocess.py b/Lib/test/test_subprocess.py
index 9fc4434649..e25474abed 100644
--- a/Lib/test/test_subprocess.py
+++ b/Lib/test/test_subprocess.py
@@ -1895,6 +1895,10 @@ def test_user(self):
         with self.assertRaises(ValueError):
             subprocess.check_call(ZERO_RETURN_CMD, user=-1)
 
+        with self.assertRaises(OverflowError):
+            subprocess.check_call(ZERO_RETURN_CMD,
+                                  cwd=os.curdir, env=os.environ, user=2**64)
+
         if pwd is None and name_uid is not None:
             with self.assertRaises(ValueError):
                 subprocess.check_call(ZERO_RETURN_CMD, user=name_uid)
@@ -1938,6 +1942,10 @@ def test_group(self):
         with self.assertRaises(ValueError):
             subprocess.check_call(ZERO_RETURN_CMD, group=-1)
 
+        with self.assertRaises(OverflowError):
+            subprocess.check_call(ZERO_RETURN_CMD,
+                                  cwd=os.curdir, env=os.environ, group=2**64)
+
         if grp is None:
             with self.assertRaises(ValueError):
                 subprocess.check_call(ZERO_RETURN_CMD, group=name_group)
@@ -1986,6 +1994,11 @@ def test_extra_groups(self):
         with self.assertRaises(ValueError):
             subprocess.check_call(ZERO_RETURN_CMD, extra_groups=[-1])
 
+        with self.assertRaises(ValueError):
+            subprocess.check_call(ZERO_RETURN_CMD,
+                                  cwd=os.curdir, env=os.environ,
+                                  extra_groups=[2**64])
+
         if grp is None:
             with self.assertRaises(ValueError):
                 subprocess.check_call(ZERO_RETURN_CMD,
diff --git a/Misc/NEWS.d/next/Library/2020-10-25-19-25-02.bpo-42146.6A8uvS.rst b/Misc/NEWS.d/next/Library/2020-10-25-19-25-02.bpo-42146.6A8uvS.rst
new file mode 100644
index 0000000000..041809803d
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2020-10-25-19-25-02.bpo-42146.6A8uvS.rst
@@ -0,0 +1,2 @@
+Fix memory leak in :func:`subprocess.Popen` in case an uid (gid) specified in
+`user` (`group`, `extra_groups`) overflows `uid_t` (`gid_t`).
diff --git a/Modules/_posixsubprocess.c b/Modules/_posixsubprocess.c
index 8baea314f4..5e5fbb2e79 100644
--- a/Modules/_posixsubprocess.c
+++ b/Modules/_posixsubprocess.c
@@ -772,7 +772,7 @@ subprocess_fork_exec(PyObject* self, PyObject *args)
     uid_t uid;
     gid_t gid, *groups = NULL;
     int child_umask;
-    PyObject *cwd_obj, *cwd_obj2;
+    PyObject *cwd_obj, *cwd_obj2 = NULL;
     const char *cwd;
     pid_t pid;
     int need_to_reenable_gc = 0;
@@ -894,7 +894,6 @@ subprocess_fork_exec(PyObject* self, PyObject *args)
         cwd = PyBytes_AsString(cwd_obj2);
     } else {
         cwd = NULL;
-        cwd_obj2 = NULL;
     }
 
     if (groups_list != Py_None) {
@@ -1080,6 +1079,7 @@ subprocess_fork_exec(PyObject* self, PyObject *args)
     return PyLong_FromPid(pid);
 
 cleanup:
+    Py_XDECREF(cwd_obj2);
     if (envp)
         _Py_FreeCharPArray(envp);
     if (argv)

[ML] commit 75c80b0bda89debf312f075716b8c467d411f90e
Author: Tony Solomonik <tony.solomonik@gmail.com>
Date:   Sun Aug 30 07:53:08 2020 +0300

    closes bpo-41533: Fix a potential memory leak when allocating a stack (GH-21847)
    
    Free the stack allocated in va_build_stack if do_mkstack fails
    and the stack is not a small_stack

diff --git a/Misc/NEWS.d/next/Core and Builtins/2020-08-12-20-29-57.bpo-41533.4pcVAc.rst b/Misc/NEWS.d/next/Core and Builtins/2020-08-12-20-29-57.bpo-41533.4pcVAc.rst
new file mode 100644
index 0000000000..e166f0c0b6
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2020-08-12-20-29-57.bpo-41533.4pcVAc.rst	
@@ -0,0 +1,2 @@
+Free the stack allocated in ``va_build_stack`` if ``do_mkstack`` fails and
+the stack is not a ``small_stack``.
diff --git a/Python/modsupport.c b/Python/modsupport.c
index 2637039d4a..2dabcf3834 100644
--- a/Python/modsupport.c
+++ b/Python/modsupport.c
@@ -622,6 +622,9 @@ va_build_stack(PyObject **small_stack, Py_ssize_t small_stack_len,
     va_end(lva);
 
     if (res < 0) {
+        if (stack != small_stack) {
+            PyMem_Free(stack);
+        }
         return NULL;
     }
 

[ML] commit 0d3350daa8123a3e16d4a534b6e873eb12c10d7c
Author: Christian Heimes <christian@python.org>
Date:   Fri Jun 12 18:18:43 2020 +0200

    bpo-40955: Fix memory leak in subprocess module (GH-20825)
    
    
    
    ```
    Direct leak of 8 byte(s) in 1 object(s) allocated from:
        #0 0x7f008bf19667 in __interceptor_malloc (/lib64/libasan.so.6+0xb0667)
        #1 0x7f007a0bee4a in subprocess_fork_exec /home/heimes/dev/python/cpython/Modules/_posixsubprocess.c:774
        #2 0xe0305b in cfunction_call Objects/methodobject.c:546
    ```
    
    Signed-off-by: Christian Heimes <christian@python.org>

diff --git a/Misc/NEWS.d/next/Library/2020-06-12-11-55-30.bpo-40955.huixCg.rst b/Misc/NEWS.d/next/Library/2020-06-12-11-55-30.bpo-40955.huixCg.rst
new file mode 100644
index 0000000000..9a9803044e
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2020-06-12-11-55-30.bpo-40955.huixCg.rst
@@ -0,0 +1 @@
+Fix a minor memory leak in :mod:`subprocess` module when extra_groups was specified.
diff --git a/Modules/_posixsubprocess.c b/Modules/_posixsubprocess.c
index add2962189..5d1691ace4 100644
--- a/Modules/_posixsubprocess.c
+++ b/Modules/_posixsubprocess.c
@@ -893,6 +893,7 @@ subprocess_fork_exec(PyObject* self, PyObject *args)
     if (_enable_gc(need_to_reenable_gc, gc_module)) {
         pid = -1;
     }
+    PyMem_RawFree(groups);
     Py_XDECREF(preexec_fn_args_tuple);
     Py_XDECREF(gc_module);
 

[ML] commit a54096e30523534e8eebb8dc1011b4536ed237a8
Author: Pablo Galindo <Pablogsal@gmail.com>
Date:   Sat Jun 6 00:52:15 2020 +0100

    bpo-40883: Fix memory leak in fstring_compile_expr in parse_string.c (GH-20667)

diff --git a/Misc/NEWS.d/next/Core and Builtins/2020-06-05-23-25-00.bpo-40883.M6sQ-Q.rst b/Misc/NEWS.d/next/Core and Builtins/2020-06-05-23-25-00.bpo-40883.M6sQ-Q.rst
new file mode 100644
index 0000000000..ebeb0cc60d
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2020-06-05-23-25-00.bpo-40883.M6sQ-Q.rst	
@@ -0,0 +1 @@
+Fix memory leak in when parsing f-strings in the new parser. Patch by Pablo Galindo
\ No newline at end of file
diff --git a/Parser/pegen/parse_string.c b/Parser/pegen/parse_string.c
index e24ecc58d3..efe82df476 100644
--- a/Parser/pegen/parse_string.c
+++ b/Parser/pegen/parse_string.c
@@ -604,6 +604,7 @@ fstring_compile_expr(Parser *p, const char *expr_start, const char *expr_end,
 
     struct tok_state* tok = PyTokenizer_FromString(str, 1);
     if (tok == NULL) {
+        PyMem_RawFree(str);
         return NULL;
     }
     Py_INCREF(p->tok->filename);
@@ -629,6 +630,7 @@ fstring_compile_expr(Parser *p, const char *expr_start, const char *expr_end,
     result = expr;
 
 exit:
+    PyMem_RawFree(str);
     _PyPegen_Parser_Free(p2);
     PyTokenizer_Free(tok);
     return result;

[ML] commit 2c8cd06afe8e0abb52367f85978f19b88e2df53e
Author: Lysandros Nikolaou <lisandrosnik@gmail.com>
Date:   Sun May 17 06:19:23 2020 +0300

    bpo-40334: Improvements to error-handling code in the PEG parser (GH-20003)
    
    The following improvements are implemented in this commit:
    - `p->error_indicator` is set, in case malloc or realloc fail.
    - Avoid memory leaks in the case that realloc fails.
    - Call `PyErr_NoMemory()` instead of `PyErr_Format()`, because it requires no memory.
    
    Co-authored-by: Pablo Galindo <Pablogsal@gmail.com>

diff --git a/Parser/pegen/parse.c b/Parser/pegen/parse.c
index f4c5692212..2a9dad7d1d 100644
--- a/Parser/pegen/parse.c
+++ b/Parser/pegen/parse.c
@@ -11139,7 +11139,8 @@ _loop0_1_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11153,11 +11154,13 @@ _loop0_1_rule(Parser *p)
             _res = newline_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11166,8 +11169,9 @@ _loop0_1_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_1");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11188,7 +11192,8 @@ _loop0_2_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11202,11 +11207,13 @@ _loop0_2_rule(Parser *p)
             _res = newline_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11215,8 +11222,9 @@ _loop0_2_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_2");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11237,7 +11245,8 @@ _loop0_4_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11259,11 +11268,13 @@ _loop0_4_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11272,8 +11283,9 @@ _loop0_4_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_4");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11322,7 +11334,8 @@ _loop0_6_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11344,11 +11357,13 @@ _loop0_6_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11357,8 +11372,9 @@ _loop0_6_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_6");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11407,7 +11423,8 @@ _loop0_8_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11429,11 +11446,13 @@ _loop0_8_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11442,8 +11461,9 @@ _loop0_8_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_8");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11492,7 +11512,8 @@ _loop0_10_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11514,11 +11535,13 @@ _loop0_10_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11527,8 +11550,9 @@ _loop0_10_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_10");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11577,7 +11601,8 @@ _loop1_11_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11591,11 +11616,13 @@ _loop1_11_rule(Parser *p)
             _res = statement_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11608,8 +11635,9 @@ _loop1_11_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_11");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -11630,7 +11658,8 @@ _loop0_13_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -11652,11 +11681,13 @@ _loop0_13_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -11665,8 +11696,9 @@ _loop0_13_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_13");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12016,7 +12048,8 @@ _loop1_22_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12030,11 +12063,13 @@ _loop1_22_rule(Parser *p)
             _res = _tmp_135_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12047,8 +12082,9 @@ _loop1_22_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_22");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12141,7 +12177,8 @@ _loop0_26_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12163,11 +12200,13 @@ _loop0_26_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12176,8 +12215,9 @@ _loop0_26_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_26");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12226,7 +12266,8 @@ _loop0_28_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12248,11 +12289,13 @@ _loop0_28_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12261,8 +12304,9 @@ _loop0_28_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_28");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12343,7 +12387,8 @@ _loop0_30_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12357,11 +12402,13 @@ _loop0_30_rule(Parser *p)
             _res = _tmp_136_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12370,8 +12417,9 @@ _loop0_30_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_30");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12392,7 +12440,8 @@ _loop1_31_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12406,11 +12455,13 @@ _loop1_31_rule(Parser *p)
             _res = _tmp_137_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12423,8 +12474,9 @@ _loop1_31_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_31");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12445,7 +12497,8 @@ _loop0_33_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12467,11 +12520,13 @@ _loop0_33_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12480,8 +12535,9 @@ _loop0_33_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_33");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12562,7 +12618,8 @@ _loop0_36_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12584,11 +12641,13 @@ _loop0_36_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12597,8 +12656,9 @@ _loop0_36_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_36");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12679,7 +12739,8 @@ _loop0_39_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12701,11 +12762,13 @@ _loop0_39_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12714,8 +12777,9 @@ _loop0_39_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_39");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12764,7 +12828,8 @@ _loop0_41_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12786,11 +12851,13 @@ _loop0_41_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12799,8 +12866,9 @@ _loop0_41_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_41");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12849,7 +12917,8 @@ _loop0_43_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12871,11 +12940,13 @@ _loop0_43_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12884,8 +12955,9 @@ _loop0_43_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_43");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -12934,7 +13006,8 @@ _loop0_45_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -12956,11 +13029,13 @@ _loop0_45_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -12969,8 +13044,9 @@ _loop0_45_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_45");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13051,7 +13127,8 @@ _loop1_47_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13065,11 +13142,13 @@ _loop1_47_rule(Parser *p)
             _res = except_block_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13082,8 +13161,9 @@ _loop1_47_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_47");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13260,7 +13340,8 @@ _loop0_53_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13274,11 +13355,13 @@ _loop0_53_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13287,8 +13370,9 @@ _loop0_53_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_53");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13309,7 +13393,8 @@ _loop0_54_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13323,11 +13408,13 @@ _loop0_54_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13336,8 +13423,9 @@ _loop0_54_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_54");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13358,7 +13446,8 @@ _loop0_55_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13372,11 +13461,13 @@ _loop0_55_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13385,8 +13476,9 @@ _loop0_55_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_55");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13407,7 +13499,8 @@ _loop1_56_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13421,11 +13514,13 @@ _loop1_56_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13438,8 +13533,9 @@ _loop1_56_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_56");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13460,7 +13556,8 @@ _loop0_57_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13474,11 +13571,13 @@ _loop0_57_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13487,8 +13586,9 @@ _loop0_57_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_57");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13509,7 +13609,8 @@ _loop1_58_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13523,11 +13624,13 @@ _loop1_58_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13540,8 +13643,9 @@ _loop1_58_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_58");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13562,7 +13666,8 @@ _loop1_59_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13576,11 +13681,13 @@ _loop1_59_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13593,8 +13700,9 @@ _loop1_59_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_59");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13615,7 +13723,8 @@ _loop1_60_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13629,11 +13738,13 @@ _loop1_60_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13646,8 +13757,9 @@ _loop1_60_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_60");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13668,7 +13780,8 @@ _loop0_61_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13682,11 +13795,13 @@ _loop0_61_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13695,8 +13810,9 @@ _loop0_61_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_61");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13717,7 +13833,8 @@ _loop1_62_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13731,11 +13848,13 @@ _loop1_62_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13748,8 +13867,9 @@ _loop1_62_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_62");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13770,7 +13890,8 @@ _loop0_63_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13784,11 +13905,13 @@ _loop0_63_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13797,8 +13920,9 @@ _loop0_63_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_63");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13819,7 +13943,8 @@ _loop1_64_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13833,11 +13958,13 @@ _loop1_64_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13850,8 +13977,9 @@ _loop1_64_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_64");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13872,7 +14000,8 @@ _loop0_65_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13886,11 +14015,13 @@ _loop0_65_rule(Parser *p)
             _res = param_maybe_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13899,8 +14030,9 @@ _loop0_65_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_65");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13921,7 +14053,8 @@ _loop1_66_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13935,11 +14068,13 @@ _loop1_66_rule(Parser *p)
             _res = param_maybe_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -13952,8 +14087,9 @@ _loop1_66_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_66");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -13974,7 +14110,8 @@ _loop1_67_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -13988,11 +14125,13 @@ _loop1_67_rule(Parser *p)
             _res = _tmp_138_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14005,8 +14144,9 @@ _loop1_67_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_67");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14062,7 +14202,8 @@ _loop0_70_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14084,11 +14225,13 @@ _loop0_70_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14097,8 +14240,9 @@ _loop0_70_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_70");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14147,7 +14291,8 @@ _loop1_71_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14161,11 +14306,13 @@ _loop1_71_rule(Parser *p)
             _res = _tmp_139_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14178,8 +14325,9 @@ _loop1_71_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_71");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14200,7 +14348,8 @@ _loop0_73_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14222,11 +14371,13 @@ _loop0_73_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14235,8 +14386,9 @@ _loop0_73_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_73");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14285,7 +14437,8 @@ _loop1_74_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14299,11 +14452,13 @@ _loop1_74_rule(Parser *p)
             _res = _tmp_140_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14316,8 +14471,9 @@ _loop1_74_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_74");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14338,7 +14494,8 @@ _loop0_75_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14352,11 +14509,13 @@ _loop0_75_rule(Parser *p)
             _res = lambda_param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14365,8 +14524,9 @@ _loop0_75_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_75");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14387,7 +14547,8 @@ _loop0_76_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14401,11 +14562,13 @@ _loop0_76_rule(Parser *p)
             _res = lambda_param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14414,8 +14577,9 @@ _loop0_76_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_76");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14436,7 +14600,8 @@ _loop0_77_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14450,11 +14615,13 @@ _loop0_77_rule(Parser *p)
             _res = lambda_param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14463,8 +14630,9 @@ _loop0_77_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_77");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14485,7 +14653,8 @@ _loop1_78_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14499,11 +14668,13 @@ _loop1_78_rule(Parser *p)
             _res = lambda_param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14516,8 +14687,9 @@ _loop1_78_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_78");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14538,7 +14710,8 @@ _loop0_79_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14552,11 +14725,13 @@ _loop0_79_rule(Parser *p)
             _res = lambda_param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14565,8 +14740,9 @@ _loop0_79_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_79");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14587,7 +14763,8 @@ _loop1_80_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14601,11 +14778,13 @@ _loop1_80_rule(Parser *p)
             _res = lambda_param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14618,8 +14797,9 @@ _loop1_80_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_80");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14640,7 +14820,8 @@ _loop1_81_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14654,11 +14835,13 @@ _loop1_81_rule(Parser *p)
             _res = lambda_param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14671,8 +14854,9 @@ _loop1_81_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_81");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14693,7 +14877,8 @@ _loop1_82_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14707,11 +14892,13 @@ _loop1_82_rule(Parser *p)
             _res = lambda_param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14724,8 +14911,9 @@ _loop1_82_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_82");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14746,7 +14934,8 @@ _loop0_83_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14760,11 +14949,13 @@ _loop0_83_rule(Parser *p)
             _res = lambda_param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14773,8 +14964,9 @@ _loop0_83_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_83");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14795,7 +14987,8 @@ _loop1_84_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14809,11 +15002,13 @@ _loop1_84_rule(Parser *p)
             _res = lambda_param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14826,8 +15021,9 @@ _loop1_84_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_84");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14848,7 +15044,8 @@ _loop0_85_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14862,11 +15059,13 @@ _loop0_85_rule(Parser *p)
             _res = lambda_param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14875,8 +15074,9 @@ _loop0_85_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_85");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14897,7 +15097,8 @@ _loop1_86_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14911,11 +15112,13 @@ _loop1_86_rule(Parser *p)
             _res = lambda_param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14928,8 +15131,9 @@ _loop1_86_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_86");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14950,7 +15154,8 @@ _loop0_87_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -14964,11 +15169,13 @@ _loop0_87_rule(Parser *p)
             _res = lambda_param_maybe_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -14977,8 +15184,9 @@ _loop0_87_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_87");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -14999,7 +15207,8 @@ _loop1_88_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15013,11 +15222,13 @@ _loop1_88_rule(Parser *p)
             _res = lambda_param_maybe_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15030,8 +15241,9 @@ _loop1_88_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_88");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15052,7 +15264,8 @@ _loop1_89_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15066,11 +15279,13 @@ _loop1_89_rule(Parser *p)
             _res = _tmp_141_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15083,8 +15298,9 @@ _loop1_89_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_89");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15105,7 +15321,8 @@ _loop1_90_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15119,11 +15336,13 @@ _loop1_90_rule(Parser *p)
             _res = _tmp_142_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15136,8 +15355,9 @@ _loop1_90_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_90");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15158,7 +15378,8 @@ _loop1_91_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15172,11 +15393,13 @@ _loop1_91_rule(Parser *p)
             _res = compare_op_bitwise_or_pair_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15189,8 +15412,9 @@ _loop1_91_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_91");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15240,7 +15464,8 @@ _loop0_94_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15262,11 +15487,13 @@ _loop0_94_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15275,8 +15502,9 @@ _loop0_94_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_94");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15498,7 +15726,8 @@ _loop1_99_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15512,11 +15741,13 @@ _loop1_99_rule(Parser *p)
             _res = string_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15529,8 +15760,9 @@ _loop1_99_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_99");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15622,7 +15854,8 @@ _loop0_103_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15644,11 +15877,13 @@ _loop0_103_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15657,8 +15892,9 @@ _loop0_103_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_103");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15707,7 +15943,8 @@ _loop1_104_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15721,11 +15958,13 @@ _loop1_104_rule(Parser *p)
             _res = for_if_clause_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15738,8 +15977,9 @@ _loop1_104_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_104");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15760,7 +16000,8 @@ _loop0_105_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15774,11 +16015,13 @@ _loop0_105_rule(Parser *p)
             _res = _tmp_143_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15787,8 +16030,9 @@ _loop0_105_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_105");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15809,7 +16053,8 @@ _loop0_106_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15823,11 +16068,13 @@ _loop0_106_rule(Parser *p)
             _res = _tmp_144_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15836,8 +16083,9 @@ _loop0_106_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_106");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -15922,7 +16170,8 @@ _loop0_110_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -15944,11 +16193,13 @@ _loop0_110_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -15957,8 +16208,9 @@ _loop0_110_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_110");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16007,7 +16259,8 @@ _loop0_112_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16029,11 +16282,13 @@ _loop0_112_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16042,8 +16297,9 @@ _loop0_112_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_112");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16092,7 +16348,8 @@ _loop0_114_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16114,11 +16371,13 @@ _loop0_114_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16127,8 +16386,9 @@ _loop0_114_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_114");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16177,7 +16437,8 @@ _loop0_116_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16199,11 +16460,13 @@ _loop0_116_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16212,8 +16475,9 @@ _loop0_116_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_116");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16262,7 +16526,8 @@ _loop0_117_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16276,11 +16541,13 @@ _loop0_117_rule(Parser *p)
             _res = _tmp_145_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16289,8 +16556,9 @@ _loop0_117_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_117");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16311,7 +16579,8 @@ _loop0_119_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16333,11 +16602,13 @@ _loop0_119_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16346,8 +16617,9 @@ _loop0_119_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_119");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16423,7 +16695,8 @@ _loop0_122_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16445,11 +16718,13 @@ _loop0_122_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16458,8 +16733,9 @@ _loop0_122_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_122");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16508,7 +16784,8 @@ _loop0_124_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16530,11 +16807,13 @@ _loop0_124_rule(Parser *p)
             }
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16543,8 +16822,9 @@ _loop0_124_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_124");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16632,7 +16912,8 @@ _loop0_126_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16646,11 +16927,13 @@ _loop0_126_rule(Parser *p)
             _res = star_named_expressions_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16659,8 +16942,9 @@ _loop0_126_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_126");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -16828,7 +17112,8 @@ _loop0_131_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -16842,11 +17127,13 @@ _loop0_131_rule(Parser *p)
             _res = param_no_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -16855,8 +17142,9 @@ _loop0_131_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop0_131");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
@@ -17354,7 +17642,8 @@ _loop1_146_rule(Parser *p)
     int _start_mark = p->mark;
     void **_children = PyMem_Malloc(sizeof(void *));
     if (!_children) {
-        PyErr_Format(PyExc_MemoryError, "Parser out of memory");
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     ssize_t _children_capacity = 1;
@@ -17368,11 +17657,13 @@ _loop1_146_rule(Parser *p)
             _res = param_with_default_var;
             if (_n == _children_capacity) {
                 _children_capacity *= 2;
-                _children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
-                if (!_children) {
-                    PyErr_Format(PyExc_MemoryError, "realloc None");
+                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
+                if (!_new_children) {
+                    p->error_indicator = 1;
+                    PyErr_NoMemory();
                     return NULL;
                 }
+                _children = _new_children;
             }
             _children[_n++] = _res;
             _mark = p->mark;
@@ -17385,8 +17676,9 @@ _loop1_146_rule(Parser *p)
     }
     asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);
     if (!_seq) {
-        PyErr_Format(PyExc_MemoryError, "asdl_seq_new _loop1_146");
         PyMem_Free(_children);
+        p->error_indicator = 1;
+        PyErr_NoMemory();
         return NULL;
     }
     for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);
diff --git a/Tools/peg_generator/pegen/c_generator.py b/Tools/peg_generator/pegen/c_generator.py
index 6c9aa3f2ba..8f9972bb41 100644
--- a/Tools/peg_generator/pegen/c_generator.py
+++ b/Tools/peg_generator/pegen/c_generator.py
@@ -320,24 +320,21 @@ def call_with_errorcheck_goto(self, call_text: str, goto_target: str) -> None:
     def out_of_memory_return(
         self,
         expr: str,
-        returnval: str,
-        message: str = "Parser out of memory",
         cleanup_code: Optional[str] = None,
     ) -> None:
         self.print(f"if ({expr}) {{")
         with self.indent():
-            self.print(f'PyErr_Format(PyExc_MemoryError, "{message}");')
             if cleanup_code is not None:
                 self.print(cleanup_code)
-            self.print(f"return {returnval};")
+            self.print("p->error_indicator = 1;")
+            self.print("PyErr_NoMemory();");
+            self.print("return NULL;")
         self.print(f"}}")
 
-    def out_of_memory_goto(
-        self, expr: str, goto_target: str, message: str = "Parser out of memory"
-    ) -> None:
+    def out_of_memory_goto(self, expr: str, goto_target: str) -> None:
         self.print(f"if ({expr}) {{")
         with self.indent():
-            self.print(f'PyErr_Format(PyExc_MemoryError, "{message}");')
+            self.print("PyErr_NoMemory();")
             self.print(f"goto {goto_target};")
         self.print(f"}}")
 
@@ -487,7 +484,7 @@ def _handle_default_rule_body(self, node: Rule, rhs: Rhs, result_type: str) -> N
                 rhs,
                 is_loop=False,
                 is_gather=node.is_gather(),
-                rulename=node.name if memoize else None,
+                rulename=node.name,
             )
             if self.debug:
                 self.print('fprintf(stderr, "Fail at %d: {node.name}\\n", p->mark);')
@@ -515,7 +512,7 @@ def _handle_loop_rule_body(self, node: Rule, rhs: Rhs) -> None:
             self.print("int _mark = p->mark;")
             self.print("int _start_mark = p->mark;")
             self.print("void **_children = PyMem_Malloc(sizeof(void *));")
-            self.out_of_memory_return(f"!_children", "NULL")
+            self.out_of_memory_return(f"!_children")
             self.print("ssize_t _children_capacity = 1;")
             self.print("ssize_t _n = 0;")
             if any(alt.action and "EXTRA" in alt.action for alt in rhs.alts):
@@ -524,7 +521,7 @@ def _handle_loop_rule_body(self, node: Rule, rhs: Rhs) -> None:
                 rhs,
                 is_loop=True,
                 is_gather=node.is_gather(),
-                rulename=node.name if memoize else None,
+                rulename=node.name,
             )
             if is_repeat1:
                 self.print("if (_n == 0 || p->error_indicator) {")
@@ -533,12 +530,7 @@ def _handle_loop_rule_body(self, node: Rule, rhs: Rhs) -> None:
                     self.print("return NULL;")
                 self.print("}")
             self.print("asdl_seq *_seq = _Py_asdl_seq_new(_n, p->arena);")
-            self.out_of_memory_return(
-                "!_seq",
-                "NULL",
-                message=f"asdl_seq_new {node.name}",
-                cleanup_code="PyMem_Free(_children);",
-            )
+            self.out_of_memory_return(f"!_seq", cleanup_code="PyMem_Free(_children);")
             self.print("for (int i = 0; i < _n; i++) asdl_seq_SET(_seq, i, _children[i]);")
             self.print("PyMem_Free(_children);")
             if node.name:
@@ -682,10 +674,9 @@ def handle_alt_loop(self, node: Alt, is_gather: bool, rulename: Optional[str]) -
             self.print("if (_n == _children_capacity) {")
             with self.indent():
                 self.print("_children_capacity *= 2;")
-                self.print(
-                    "_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));"
-                )
-                self.out_of_memory_return(f"!_children", "NULL", message=f"realloc {rulename}")
+                self.print("void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));")
+                self.out_of_memory_return(f"!_new_children")
+                self.print("_children = _new_children;")
             self.print("}")
             self.print("_children[_n++] = _res;")
             self.print("_mark = p->mark;")

[ML] commit d2c349b190bcba21a4a38e6520a48ad97a9f1529
Author: Chris Jerdonek <chris.jerdonek@gmail.com>
Date:   Fri May 8 03:54:38 2020 -0700

    bpo-40559: Add Py_DECREF to _asynciomodule.c:task_step_impl() (GH-19990)
    
    This fixes a possible memory leak in the C implementation of
    asyncio.Task.

diff --git a/Misc/NEWS.d/next/Library/2020-05-05-08-12-51.bpo-40559.112wwa.rst b/Misc/NEWS.d/next/Library/2020-05-05-08-12-51.bpo-40559.112wwa.rst
new file mode 100644
index 0000000000..15846351f2
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2020-05-05-08-12-51.bpo-40559.112wwa.rst
@@ -0,0 +1 @@
+Fix possible memory leak in the C implementation of :class:`asyncio.Task`.
\ No newline at end of file
diff --git a/Modules/_asynciomodule.c b/Modules/_asynciomodule.c
index a03a63119b..cc211a8895 100644
--- a/Modules/_asynciomodule.c
+++ b/Modules/_asynciomodule.c
@@ -2638,6 +2638,10 @@ task_step_impl(TaskObj *task, PyObject *exc)
     coro = task->task_coro;
     if (coro == NULL) {
         PyErr_SetString(PyExc_RuntimeError, "uninitialized Task object");
+        if (clear_exc) {
+            /* We created 'exc' during this call */
+            Py_DECREF(exc);
+        }
         return NULL;
     }
 

commit 785f5e6d674306052bf865677d885c30561985ae
Author: Dong-hee Na <donghee.na92@gmail.com>
Date:   Tue May 5 02:30:42 2020 +0900

    bpo-40489: Add test case for dict contain use after free (GH-19906)

diff --git a/Lib/test/test_dict.py b/Lib/test/test_dict.py
index d5a3d9e894..6b8596fff6 100644
--- a/Lib/test/test_dict.py
+++ b/Lib/test/test_dict.py
@@ -1324,6 +1324,19 @@ def __eq__(self, other):
         d = {0: set()}
         (0, X()) in d.items()
 
+    def test_dict_contain_use_after_free(self):
+        # bpo-40489
+        class S(str):
+            def __eq__(self, other):
+                d.clear()
+                return NotImplemented
+
+            def __hash__(self):
+                return hash('test')
+
+        d = {S(): 'value'}
+        self.assertFalse('test' in d)
+
     def test_init_use_after_free(self):
         class X:
             def __hash__(self):

[NR] [ML] commit 24ffe705c30e36c82940d75fd1454256634d0b3c
Author: Lysandros Nikolaou <lisandrosnik@gmail.com>
Date:   Fri Apr 24 16:51:09 2020 +0300

    bpo-40334: Rewrite test_c_parser to avoid memory leaks (GH-19694)
    
    Previously every test was building an extension module and
    loading it into sys.modules. The tearDown function was thus
    not able to clean up correctly, resulting in memory leaks.
    
    With this commit, every test function now builds the extension
    module and runs the actual test code in a new process
    (using assert_python_ok), so that sys.modules stays intact
    and no memory gets leaked.

diff --git a/Lib/test/test_peg_generator/test_c_parser.py b/Lib/test/test_peg_generator/test_c_parser.py
index ceda6d43d1..8eb66d5279 100644
--- a/Lib/test/test_peg_generator/test_c_parser.py
+++ b/Lib/test/test_peg_generator/test_c_parser.py
@@ -1,19 +1,14 @@
-import ast
-import contextlib
-import traceback
-import tempfile
-import shutil
+import textwrap
 import unittest
-import sys
+from distutils.tests.support import TempdirManager
+from pathlib import Path
 
 from test import test_tools
-from test.test_peg_generator.ast_dump import ast_dump
 from test import support
-from pathlib import PurePath, Path
-from typing import Sequence
+from test.support.script_helper import assert_python_ok
 
-test_tools.skip_if_missing('peg_generator')
-with test_tools.imports_under_tool('peg_generator'):
+test_tools.skip_if_missing("peg_generator")
+with test_tools.imports_under_tool("peg_generator"):
     from pegen.grammar_parser import GeneratedParser as GrammarParser
     from pegen.testutil import (
         parse_string,
@@ -22,44 +17,72 @@
     )
 
 
-class TestCParser(unittest.TestCase):
-    def setUp(self):
-        cmd = support.missing_compiler_executable()
-        if cmd is not None:
-            self.skipTest('The %r command is not found' % cmd)
-        self.tmp_path = tempfile.mkdtemp()
+TEST_TEMPLATE = """
+tmp_dir = {extension_path!r}
 
-    def tearDown(self):
-        with contextlib.suppress(PermissionError):
-            shutil.rmtree(self.tmp_path)
+import ast
+import traceback
+import sys
+import unittest
+from test.test_peg_generator.ast_dump import ast_dump
+
+sys.path.insert(0, tmp_dir)
+import parse
+
+class Tests(unittest.TestCase):
 
     def check_input_strings_for_grammar(
         self,
-        source: str,
-        tmp_path: PurePath,
-        valid_cases: Sequence[str] = (),
-        invalid_cases: Sequence[str] = (),
-    ) -> None:
-        grammar = parse_string(source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(tmp_path))
-
+        valid_cases = (),
+        invalid_cases = (),
+    ):
         if valid_cases:
             for case in valid_cases:
-                extension.parse_string(case, mode=0)
+                parse.parse_string(case, mode=0)
 
         if invalid_cases:
             for case in invalid_cases:
                 with self.assertRaises(SyntaxError):
-                    extension.parse_string(case, mode=0)
-
-    def verify_ast_generation(self, source: str, stmt: str, tmp_path: PurePath) -> None:
-        grammar = parse_string(source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(tmp_path))
+                    parse.parse_string(case, mode=0)
 
+    def verify_ast_generation(self, stmt):
         expected_ast = ast.parse(stmt)
-        actual_ast = extension.parse_string(stmt, mode=1)
+        actual_ast = parse.parse_string(stmt, mode=1)
         self.assertEqual(ast_dump(expected_ast), ast_dump(actual_ast))
 
+    def test_parse(self):
+        {test_source}
+
+unittest.main()
+"""
+
+
+class TestCParser(TempdirManager, unittest.TestCase):
+    def setUp(self):
+        cmd = support.missing_compiler_executable()
+        if cmd is not None:
+            self.skipTest("The %r command is not found" % cmd)
+        super(TestCParser, self).setUp()
+        self.tmp_path = self.mkdtemp()
+        change_cwd = support.change_cwd(self.tmp_path)
+        change_cwd.__enter__()
+        self.addCleanup(change_cwd.__exit__, None, None, None)
+
+    def tearDown(self):
+        super(TestCParser, self).tearDown()
+
+    def build_extension(self, grammar_source):
+        grammar = parse_string(grammar_source, GrammarParser)
+        generate_parser_c_extension(grammar, Path(self.tmp_path))
+
+    def run_test(self, grammar_source, test_source):
+        self.build_extension(grammar_source)
+        test_source = textwrap.indent(textwrap.dedent(test_source), 8 * " ")
+        assert_python_ok(
+            "-c",
+            TEST_TEMPLATE.format(extension_path=self.tmp_path, test_source=test_source),
+        )
+
     def test_c_parser(self) -> None:
         grammar_source = """
         start[mod_ty]: a=stmt* $ { Module(a, NULL, p->arena) }
@@ -81,9 +104,7 @@ def test_c_parser(self) -> None:
                     | s=STRING { s }
                     )
         """
-        grammar = parse_string(grammar_source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(self.tmp_path))
-
+        test_source = """
         expressions = [
             "4+5",
             "4-5",
@@ -97,30 +118,38 @@ def test_c_parser(self) -> None:
         ]
 
         for expr in expressions:
-            the_ast = extension.parse_string(expr, mode=1)
+            the_ast = parse.parse_string(expr, mode=1)
             expected_ast = ast.parse(expr)
             self.assertEqual(ast_dump(the_ast), ast_dump(expected_ast))
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_lookahead(self) -> None:
-        grammar = """
+        grammar_source = """
         start: NAME &NAME expr NEWLINE? ENDMARKER
         expr: NAME | NUMBER
         """
+        test_source = """
         valid_cases = ["foo bar"]
         invalid_cases = ["foo 34"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases, invalid_cases)
+        self.check_input_strings_for_grammar(valid_cases, invalid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_negative_lookahead(self) -> None:
-        grammar = """
+        grammar_source = """
         start: NAME !NAME expr NEWLINE? ENDMARKER
         expr: NAME | NUMBER
         """
+        test_source = """
         valid_cases = ["foo 34"]
         invalid_cases = ["foo bar"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases, invalid_cases)
+        self.check_input_strings_for_grammar(valid_cases, invalid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_cut(self) -> None:
-        grammar = """
+        grammar_source = """
         start: X ~ Y Z | X Q S
         X: 'x'
         Y: 'y'
@@ -128,57 +157,75 @@ def test_cut(self) -> None:
         Q: 'q'
         S: 's'
         """
+        test_source = """
         valid_cases = ["x y z"]
         invalid_cases = ["x q s"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases, invalid_cases)
+        self.check_input_strings_for_grammar(valid_cases, invalid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_gather(self) -> None:
-        grammar = """
+        grammar_source = """
         start: ';'.pass_stmt+ NEWLINE
         pass_stmt: 'pass'
         """
+        test_source = """
         valid_cases = ["pass", "pass; pass"]
         invalid_cases = ["pass;", "pass; pass;"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases, invalid_cases)
+        self.check_input_strings_for_grammar(valid_cases, invalid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_left_recursion(self) -> None:
-        grammar = """
+        grammar_source = """
         start: expr NEWLINE
         expr: ('-' term | expr '+' term | term)
         term: NUMBER
         """
+        test_source = """
         valid_cases = ["-34", "34", "34 + 12", "1 + 1 + 2 + 3"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases)
+        self.check_input_strings_for_grammar(valid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_advanced_left_recursive(self) -> None:
-        grammar = """
+        grammar_source = """
         start: NUMBER | sign start
         sign: ['-']
         """
+        test_source = """
         valid_cases = ["23", "-34"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases)
+        self.check_input_strings_for_grammar(valid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_mutually_left_recursive(self) -> None:
-        grammar = """
+        grammar_source = """
         start: foo 'E'
         foo: bar 'A' | 'B'
         bar: foo 'C' | 'D'
         """
+        test_source = """
         valid_cases = ["B E", "D A C A E"]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases)
+        self.check_input_strings_for_grammar(valid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_nasty_mutually_left_recursive(self) -> None:
-        grammar = """
+        grammar_source = """
         start: target '='
         target: maybe '+' | NAME
         maybe: maybe '-' | target
         """
+        test_source = """
         valid_cases = ["x ="]
         invalid_cases = ["x - + ="]
-        self.check_input_strings_for_grammar(grammar, self.tmp_path, valid_cases, invalid_cases)
+        self.check_input_strings_for_grammar(valid_cases, invalid_cases)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_return_stmt_noexpr_action(self) -> None:
-        grammar = """
+        grammar_source = """
         start[mod_ty]: a=[statements] ENDMARKER { Module(a, NULL, p->arena) }
         statements[asdl_seq*]: a=statement+ { a }
         statement[stmt_ty]: simple_stmt
@@ -186,19 +233,25 @@ def test_return_stmt_noexpr_action(self) -> None:
         small_stmt[stmt_ty]: return_stmt
         return_stmt[stmt_ty]: a='return' NEWLINE { _Py_Return(NULL, EXTRA) }
         """
+        test_source = """
         stmt = "return"
-        self.verify_ast_generation(grammar, stmt, self.tmp_path)
+        self.verify_ast_generation(stmt)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_gather_action_ast(self) -> None:
-        grammar = """
+        grammar_source = """
         start[mod_ty]: a=';'.pass_stmt+ NEWLINE ENDMARKER { Module(a, NULL, p->arena) }
         pass_stmt[stmt_ty]: a='pass' { _Py_Pass(EXTRA)}
         """
+        test_source = """
         stmt = "pass; pass"
-        self.verify_ast_generation(grammar, stmt, self.tmp_path)
+        self.verify_ast_generation(stmt)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_pass_stmt_action(self) -> None:
-        grammar = """
+        grammar_source = """
         start[mod_ty]: a=[statements] ENDMARKER { Module(a, NULL, p->arena) }
         statements[asdl_seq*]: a=statement+ { a }
         statement[stmt_ty]: simple_stmt
@@ -206,11 +259,14 @@ def test_pass_stmt_action(self) -> None:
         small_stmt[stmt_ty]: pass_stmt
         pass_stmt[stmt_ty]: a='pass' NEWLINE { _Py_Pass(EXTRA) }
         """
+        test_source = """
         stmt = "pass"
-        self.verify_ast_generation(grammar, stmt, self.tmp_path)
+        self.verify_ast_generation(stmt)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_if_stmt_action(self) -> None:
-        grammar = """
+        grammar_source = """
         start[mod_ty]: a=[statements] ENDMARKER { Module(a, NULL, p->arena) }
         statements[asdl_seq*]: a=statement+ { _PyPegen_seq_flatten(p, a) }
         statement[asdl_seq*]:  a=compound_stmt { _PyPegen_singleton_seq(p, a) } | simple_stmt
@@ -230,11 +286,14 @@ def test_if_stmt_action(self) -> None:
 
         full_expression: NAME
         """
+        test_source = """
         stmt = "pass"
-        self.verify_ast_generation(grammar, stmt, self.tmp_path)
+        self.verify_ast_generation(stmt)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_same_name_different_types(self) -> None:
-        source = """
+        grammar_source = """
         start[mod_ty]: a=import_from+ NEWLINE ENDMARKER { Module(a, NULL, p->arena)}
         import_from[stmt_ty]: ( a='from' !'import' c=simple_name 'import' d=import_as_names_from {
                                 _Py_ImportFrom(c->v.Name.id, d, 0, EXTRA) }
@@ -245,13 +304,13 @@ def test_same_name_different_types(self) -> None:
         import_as_names_from[asdl_seq*]: a=','.import_as_name_from+ { a }
         import_as_name_from[alias_ty]: a=NAME 'as' b=NAME { _Py_alias(((expr_ty) a)->v.Name.id, ((expr_ty) b)->v.Name.id, p->arena) }
         """
-        grammar = parse_string(source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(self.tmp_path))
-
+        test_source = """
         for stmt in ("from a import b as c", "from . import a as b"):
             expected_ast = ast.parse(stmt)
-            actual_ast = extension.parse_string(stmt, mode=1)
+            actual_ast = parse.parse_string(stmt, mode=1)
             self.assertEqual(ast_dump(expected_ast), ast_dump(actual_ast))
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_with_stmt_with_paren(self) -> None:
         grammar_source = """
@@ -269,14 +328,15 @@ def test_with_stmt_with_paren(self) -> None:
         block[stmt_ty]: a=pass_stmt NEWLINE { a } | NEWLINE INDENT a=pass_stmt DEDENT { a }
         pass_stmt[stmt_ty]: a='pass' { _Py_Pass(EXTRA) }
         """
-        stmt = "with (\n    a as b,\n    c as d\n): pass"
-        grammar = parse_string(grammar_source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(self.tmp_path))
-        the_ast = extension.parse_string(stmt, mode=1)
+        test_source = """
+        stmt = "with (\\n    a as b,\\n    c as d\\n): pass"
+        the_ast = parse.parse_string(stmt, mode=1)
         self.assertTrue(ast_dump(the_ast).startswith(
             "Module(body=[With(items=[withitem(context_expr=Name(id='a', ctx=Load()), optional_vars=Name(id='b', ctx=Store())), "
             "withitem(context_expr=Name(id='c', ctx=Load()), optional_vars=Name(id='d', ctx=Store()))]"
         ))
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_ternary_operator(self) -> None:
         grammar_source = """
@@ -290,23 +350,27 @@ def test_ternary_operator(self) -> None:
                 { _Py_comprehension(_Py_Name(((expr_ty) a)->v.Name.id, Store, EXTRA), b, c, (y == NULL) ? 0 : 1, p->arena) })+ { a }
         )
         """
+        test_source = """
         stmt = "[i for i in a if b]"
-        self.verify_ast_generation(grammar_source, stmt, self.tmp_path)
+        self.verify_ast_generation(stmt)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_syntax_error_for_string(self) -> None:
         grammar_source = """
         start: expr+ NEWLINE? ENDMARKER
         expr: NAME
         """
-        grammar = parse_string(grammar_source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(self.tmp_path))
+        test_source = """
         for text in ("a b 42 b a", "  42  "):
             try:
-                extension.parse_string(text, mode=0)
+                parse.parse_string(text, mode=0)
             except SyntaxError as e:
                 tb = traceback.format_exc()
             self.assertTrue('File "<string>", line 1' in tb)
             self.assertTrue(f"SyntaxError: invalid syntax" in tb)
+        """
+        self.run_test(grammar_source, test_source)
 
     def test_headers_and_trailer(self) -> None:
         grammar_source = """
@@ -323,14 +387,14 @@ def test_headers_and_trailer(self) -> None:
         self.assertTrue("SOME SUBHEADER" in parser_source)
         self.assertTrue("SOME TRAILER" in parser_source)
 
-
     def test_error_in_rules(self) -> None:
         grammar_source = """
         start: expr+ NEWLINE? ENDMARKER
         expr: NAME {PyTuple_New(-1)}
         """
-        grammar = parse_string(grammar_source, GrammarParser)
-        extension = generate_parser_c_extension(grammar, Path(self.tmp_path))
         # PyTuple_New raises SystemError if an invalid argument was passed.
+        test_source = """
         with self.assertRaises(SystemError):
-            extension.parse_string("a", mode=0)
+            parse.parse_string("a", mode=0)
+        """
+        self.run_test(grammar_source, test_source)
diff --git a/Tools/peg_generator/pegen/build.py b/Tools/peg_generator/pegen/build.py
index 0ecb370510..0f5d73ee5f 100644
--- a/Tools/peg_generator/pegen/build.py
+++ b/Tools/peg_generator/pegen/build.py
@@ -83,6 +83,7 @@ def compile_c_extension(
     cmd.inplace = True
     if build_dir:
         cmd.build_temp = build_dir
+        cmd.build_lib = build_dir
     cmd.ensure_finalized()
     cmd.run()
 
diff --git a/Tools/peg_generator/pegen/testutil.py b/Tools/peg_generator/pegen/testutil.py
index 3616effe6b..5a91862be1 100644
--- a/Tools/peg_generator/pegen/testutil.py
+++ b/Tools/peg_generator/pegen/testutil.py
@@ -92,9 +92,7 @@ def generate_parser_c_extension(
     with open(source, "w") as file:
         genr = CParserGenerator(grammar, file, debug=debug)
         genr.generate("parse.c")
-    extension_path = compile_c_extension(str(source), build_dir=str(path / "build"))
-    extension = import_file("parse", extension_path)
-    return extension
+    compile_c_extension(str(source), build_dir=str(path))
 
 
 def print_memstats() -> bool:

[ML] commit 7ba6f18de2582755ae31888ba6a4237d96dddc48
Author: Alex Henrie <alexhenrie24@gmail.com>
Date:   Mon Jan 13 03:35:47 2020 -0700

    bpo-39307: Fix memory leak on error path in parsetok (GH-17953)

diff --git a/Parser/parsetok.c b/Parser/parsetok.c
index a5d78974b8..2bb733d0dc 100644
--- a/Parser/parsetok.c
+++ b/Parser/parsetok.c
@@ -246,6 +246,7 @@ parsetok(struct tok_state *tok, grammar *g, int start, perrdetail *err_ret,
 
     if ((ps = PyParser_New(g, start)) == NULL) {
         err_ret->error = E_NOMEM;
+        growable_comment_array_deallocate(&type_ignores);
         PyTokenizer_Free(tok);
         return NULL;
     }

[NR] [ML] commit 321def805abc5b7c92c7e90ca90cb2434fdab855
Author: Ben Harper <btharper1221@gmail.com>
Date:   Mon Oct 7 12:19:58 2019 -0400

    bpo-36356: Fix memory leak in _asynciomodule.c (GH-16598)

diff --git a/Modules/_asynciomodule.c b/Modules/_asynciomodule.c
index b67afd4176..89b2fdea0f 100644
--- a/Modules/_asynciomodule.c
+++ b/Modules/_asynciomodule.c
@@ -33,6 +33,7 @@ static PyObject *asyncio_task_repr_info_func;
 static PyObject *asyncio_InvalidStateError;
 static PyObject *asyncio_CancelledError;
 static PyObject *context_kwname;
+static int module_initialized;
 
 static PyObject *cached_running_holder;
 static volatile uint64_t cached_running_holder_tsid;
@@ -3247,6 +3248,12 @@ module_init(void)
     if (asyncio_mod == NULL) {
         goto fail;
     }
+    if (module_initialized != 0) {
+        return 0;
+    } 
+    else {
+        module_initialized = 1;
+    }
 
     current_tasks = PyDict_New();
     if (current_tasks == NULL) {

[ML] commit 1ce152a42eaa917d7763bce93f1e1ca72530d7ca
Author: Victor Stinner <vstinner@redhat.com>
Date:   Tue Sep 24 17:44:15 2019 +0200

    bpo-38234: Py_SetPath() uses the program full path (GH-16357)
    
    Py_SetPath() now sets sys.executable to the program full path
    (Py_GetProgramFullPath()), rather than to the program name
    (Py_GetProgramName()).
    
    Fix also memory leaks in pathconfig_set_from_config().

diff --git a/Doc/c-api/init.rst b/Doc/c-api/init.rst
index 0f8ff3b0dd..0b7a84d031 100644
--- a/Doc/c-api/init.rst
+++ b/Doc/c-api/init.rst
@@ -472,8 +472,8 @@ Process-wide parameters
    dependent delimiter character, which is ``':'`` on Unix and Mac OS X, ``';'``
    on Windows.
 
-   This also causes :data:`sys.executable` to be set only to the raw program
-   name (see :c:func:`Py_SetProgramName`) and for :data:`sys.prefix` and
+   This also causes :data:`sys.executable` to be set to the program
+   full path (see :c:func:`Py_GetProgramFullPath`) and for :data:`sys.prefix` and
    :data:`sys.exec_prefix` to be empty.  It is up to the caller to modify these
    if required after calling :c:func:`Py_Initialize`.
 
@@ -483,6 +483,10 @@ Process-wide parameters
    The path argument is copied internally, so the caller may free it after the
    call completes.
 
+   .. versionchanged:: 3.8
+      The program full path is now used for :data:`sys.executable`, instead
+      of the program name.
+
 
 .. c:function:: const char* Py_GetVersion()
 
diff --git a/Doc/whatsnew/3.8.rst b/Doc/whatsnew/3.8.rst
index c2455f487b..0995cb3b91 100755
--- a/Doc/whatsnew/3.8.rst
+++ b/Doc/whatsnew/3.8.rst
@@ -1347,6 +1347,11 @@ Build and C API Changes
   parameter for indicating the number of positional-only arguments.
   (Contributed by Pablo Galindo in :issue:`37221`.)
 
+* :c:func:`Py_SetPath` now sets :data:`sys.executable` to the program full
+  path (:c:func:`Py_GetProgramFullPath`) rather than to the program name
+  (:c:func:`Py_GetProgramName`).
+  (Contributed by Victor Stinner in :issue:`38234`.)
+
 
 Deprecated
 ==========
diff --git a/Misc/NEWS.d/next/C API/2019-09-24-17-09-48.bpo-38234.d0bhEA.rst b/Misc/NEWS.d/next/C API/2019-09-24-17-09-48.bpo-38234.d0bhEA.rst
new file mode 100644
index 0000000000..ba4cc312e6
--- /dev/null
+++ b/Misc/NEWS.d/next/C API/2019-09-24-17-09-48.bpo-38234.d0bhEA.rst	
@@ -0,0 +1,3 @@
+:c:func:`Py_SetPath` now sets :data:`sys.executable` to the program full
+path (:c:func:`Py_GetProgramFullPath`) rather than to the program name
+(:c:func:`Py_GetProgramName`).
diff --git a/Python/pathconfig.c b/Python/pathconfig.c
index 7677a15579..8f76fa50c9 100644
--- a/Python/pathconfig.c
+++ b/Python/pathconfig.c
@@ -23,6 +23,7 @@ wchar_t *_Py_dll_path = NULL;
 static int
 copy_wstr(wchar_t **dst, const wchar_t *src)
 {
+    assert(*dst == NULL);
     if (src != NULL) {
         *dst = _PyMem_RawWcsdup(src);
         if (*dst == NULL) {
@@ -172,6 +173,7 @@ pathconfig_set_from_config(_PyPathConfig *pathconfig, const PyConfig *config)
     _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
 
     if (config->module_search_paths_set) {
+        PyMem_RawFree(pathconfig->module_search_path);
         pathconfig->module_search_path = _PyWideStringList_Join(&config->module_search_paths, DELIM);
         if (pathconfig->module_search_path == NULL) {
             goto no_memory;
@@ -180,6 +182,8 @@ pathconfig_set_from_config(_PyPathConfig *pathconfig, const PyConfig *config)
 
 #define COPY_CONFIG(PATH_ATTR, CONFIG_ATTR) \
         if (config->CONFIG_ATTR) { \
+            PyMem_RawFree(pathconfig->PATH_ATTR); \
+            pathconfig->PATH_ATTR = NULL; \
             if (copy_wstr(&pathconfig->PATH_ATTR, config->CONFIG_ATTR) < 0) { \
                 goto no_memory; \
             } \
@@ -455,16 +459,15 @@ Py_SetPath(const wchar_t *path)
     PyMemAllocatorEx old_alloc;
     _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
 
-    /* Getting the program name calls pathconfig_global_init() */
-    wchar_t *program_name = _PyMem_RawWcsdup(Py_GetProgramName());
+    /* Getting the program full path calls pathconfig_global_init() */
+    wchar_t *program_full_path = _PyMem_RawWcsdup(Py_GetProgramFullPath());
 
     PyMem_RawFree(_Py_path_config.program_full_path);
     PyMem_RawFree(_Py_path_config.prefix);
     PyMem_RawFree(_Py_path_config.exec_prefix);
     PyMem_RawFree(_Py_path_config.module_search_path);
 
-    /* Copy program_name to program_full_path  */
-    _Py_path_config.program_full_path = program_name;
+    _Py_path_config.program_full_path = program_full_path;
     _Py_path_config.prefix = _PyMem_RawWcsdup(L"");
     _Py_path_config.exec_prefix = _PyMem_RawWcsdup(L"");
     _Py_path_config.module_search_path = _PyMem_RawWcsdup(path);

[ML] commit 8debfa50407107ff2329d01081cdc12d359f1d12
Author: Serhiy Storchaka <storchaka@gmail.com>
Date:   Mon Sep 16 20:15:18 2019 +0300

    bpo-38175: Fix a memory leak in comparison of sqlite3.Row objects. (GH-16155)

diff --git a/Lib/sqlite3/test/factory.py b/Lib/sqlite3/test/factory.py
index ced8445536..f103211ed9 100644
--- a/Lib/sqlite3/test/factory.py
+++ b/Lib/sqlite3/test/factory.py
@@ -169,19 +169,33 @@ def CheckSqliteRowHashCmp(self):
         row_1 = self.con.execute("select 1 as a, 2 as b").fetchone()
         row_2 = self.con.execute("select 1 as a, 2 as b").fetchone()
         row_3 = self.con.execute("select 1 as a, 3 as b").fetchone()
+        row_4 = self.con.execute("select 1 as b, 2 as a").fetchone()
+        row_5 = self.con.execute("select 2 as b, 1 as a").fetchone()
 
-        self.assertEqual(row_1, row_1)
-        self.assertEqual(row_1, row_2)
-        self.assertTrue(row_2 != row_3)
+        self.assertTrue(row_1 == row_1)
+        self.assertTrue(row_1 == row_2)
+        self.assertFalse(row_1 == row_3)
+        self.assertFalse(row_1 == row_4)
+        self.assertFalse(row_1 == row_5)
+        self.assertFalse(row_1 == object())
 
         self.assertFalse(row_1 != row_1)
         self.assertFalse(row_1 != row_2)
-        self.assertFalse(row_2 == row_3)
+        self.assertTrue(row_1 != row_3)
+        self.assertTrue(row_1 != row_4)
+        self.assertTrue(row_1 != row_5)
+        self.assertTrue(row_1 != object())
+
+        with self.assertRaises(TypeError):
+            row_1 > row_2
+        with self.assertRaises(TypeError):
+            row_1 < row_2
+        with self.assertRaises(TypeError):
+            row_1 >= row_2
+        with self.assertRaises(TypeError):
+            row_1 <= row_2
 
-        self.assertEqual(row_1, row_2)
         self.assertEqual(hash(row_1), hash(row_2))
-        self.assertNotEqual(row_1, row_3)
-        self.assertNotEqual(hash(row_1), hash(row_3))
 
     def CheckSqliteRowAsSequence(self):
         """ Checks if the row object can act like a sequence """
diff --git a/Misc/NEWS.d/next/Library/2019-09-15-10-30-33.bpo-38175.61XlUv.rst b/Misc/NEWS.d/next/Library/2019-09-15-10-30-33.bpo-38175.61XlUv.rst
new file mode 100644
index 0000000000..6d9f280bbd
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2019-09-15-10-30-33.bpo-38175.61XlUv.rst
@@ -0,0 +1 @@
+Fix a memory leak in comparison of :class:`sqlite3.Row` objects.
diff --git a/Modules/_sqlite/row.c b/Modules/_sqlite/row.c
index 5c2f400824..758518a8ff 100644
--- a/Modules/_sqlite/row.c
+++ b/Modules/_sqlite/row.c
@@ -192,14 +192,16 @@ static PyObject* pysqlite_row_richcompare(pysqlite_Row *self, PyObject *_other,
     if (opid != Py_EQ && opid != Py_NE)
         Py_RETURN_NOTIMPLEMENTED;
 
-    if (PyType_IsSubtype(Py_TYPE(_other), &pysqlite_RowType)) {
+    if (PyObject_TypeCheck(_other, &pysqlite_RowType)) {
         pysqlite_Row *other = (pysqlite_Row *)_other;
-        PyObject *res = PyObject_RichCompare(self->description, other->description, opid);
-        if ((opid == Py_EQ && res == Py_True)
-            || (opid == Py_NE && res == Py_False)) {
-            Py_DECREF(res);
+        int eq = PyObject_RichCompareBool(self->description, other->description, Py_EQ);
+        if (eq < 0) {
+            return NULL;
+        }
+        if (eq) {
             return PyObject_RichCompare(self->data, other->data, opid);
         }
+        return PyBool_FromLong(opid != Py_EQ);
     }
     Py_RETURN_NOTIMPLEMENTED;
 }

[ML] commit 8d88e8c662a80c186c7a0e67f1c1f3d4010276f8
Author: Dino Viehland <dinoviehland@fb.com>
Date:   Thu Sep 12 15:38:13 2019 +0100

    bpo-38138: Fix memory leak introduced by interned strings (GH-16053)
    
    
    
    Interned string needs to be decref'd
    
    
    
    https://bugs.python.org/issue38138
    
    
    
    Automerge-Triggered-By: @matrixise

diff --git a/Python/ast.c b/Python/ast.c
index 46815c271b..e6f71671c1 100644
--- a/Python/ast.c
+++ b/Python/ast.c
@@ -630,6 +630,7 @@ new_identifier(const char *n, struct compiling *c)
         PyObject *args[2] = {form, id};
         id2 = _PyObject_FastCall(c->c_normalize, args, 2);
         Py_DECREF(id);
+        Py_DECREF(form);
         if (!id2)
             return NULL;
         if (!PyUnicode_Check(id2)) {

[NR] [UAF] commit a9b6033179b64b985394ad351501089a6a94fc9d
Author: Ben Harper <btharper1221@gmail.com>
Date:   Tue Sep 10 11:20:15 2019 -0400

    bpo-36253: Remove use after free reference in ctypes test suite (GH-12257)

diff --git a/Lib/ctypes/test/test_stringptr.py b/Lib/ctypes/test/test_stringptr.py
index 95cd1614c6..c20951f4ce 100644
--- a/Lib/ctypes/test/test_stringptr.py
+++ b/Lib/ctypes/test/test_stringptr.py
@@ -70,8 +70,8 @@ def test_functions(self):
         x = r[0], r[1], r[2], r[3], r[4]
         self.assertEqual(x, (b"c", b"d", b"e", b"f", b"\000"))
         del buf
-        # x1 will NOT be the same as x, usually:
-        x1 = r[0], r[1], r[2], r[3], r[4]
+        # Because r is a pointer to memory that is freed after deleting buf,
+        # the pointer is hanging and using it would reference freed memory.
 
 if __name__ == '__main__':
     unittest.main()

[ML] commit ed70129e15ea028469145111044a4349960a4e6f
Author: neonene <53406459+neonene@users.noreply.github.com>
Date:   Mon Sep 9 21:33:43 2019 +0900

    bpo-37702: Fix SSL's certificate-store leak on Windows (GH-15632)
    
    ssl_collect_certificates function in _ssl.c has a memory leak.
    Calling CertOpenStore() and CertAddStoreToCollection(), a store's refcnt gets incremented by 2.
    But CertCloseStore() is called only once and the refcnt leaves 1.

diff --git a/Misc/NEWS.d/next/Windows/2019-07-29-16-49-31.bpo-37702.Lj2f5e.rst b/Misc/NEWS.d/next/Windows/2019-07-29-16-49-31.bpo-37702.Lj2f5e.rst
new file mode 100644
index 0000000000..67d53d4c46
--- /dev/null
+++ b/Misc/NEWS.d/next/Windows/2019-07-29-16-49-31.bpo-37702.Lj2f5e.rst
@@ -0,0 +1,2 @@
+Fix memory leak on Windows in creating an SSLContext object or
+running urllib.request.urlopen('https://...').
\ No newline at end of file
diff --git a/Modules/_ssl.c b/Modules/_ssl.c
index 3d63612168..d94efa98e9 100644
--- a/Modules/_ssl.c
+++ b/Modules/_ssl.c
@@ -5581,6 +5581,7 @@ ssl_collect_certificates(const char *store_name)
             if (result) {
                 ++storesAdded;
             }
+            CertCloseStore(hSystemStore, 0);  /* flag must be 0 */
         }
     }
     if (storesAdded == 0) {

commit eddef861b49f1635222a9e1771231c34a807debf
Author: Inada Naoki <songofacandy@gmail.com>
Date:   Tue Jun 4 07:38:10 2019 +0900

    bpo-37146: disable opcache when Py_DEBUG is defined (GH-13787)
    
    --with-pydebug is commonly used to find memory leaks.
    But opcache makes it harder.
    So disable opcache when Py_DEBUG is defined.

diff --git a/Python/ceval.c b/Python/ceval.c
index 0a4af915d6..2590ce6575 100644
--- a/Python/ceval.c
+++ b/Python/ceval.c
@@ -103,7 +103,14 @@ static long dxp[256];
 #endif
 
 /* per opcode cache */
+#ifdef Py_DEBUG
+// --with-pydebug is used to find memory leak.  opcache makes it harder.
+// So we disable opcache when Py_DEBUG is defined.
+// See bpo-37146
+#define OPCACHE_MIN_RUNS 0  /* disable opcache */
+#else
 #define OPCACHE_MIN_RUNS 1024  /* create opcache when code executed this time */
+#endif
 #define OPCACHE_STATS 0  /* Enable stats */
 
 #if OPCACHE_STATS

[ML] commit f83d1dbd3bfbde940117c85f5c70de00e47b7e6e
Author: Eric V. Smith <ericvsmith@users.noreply.github.com>
Date:   Wed May 29 03:55:44 2019 -0400

    bpo-37070: Cleanup fstring debug handling (GH-13607)
    
    * Clean up some comments, fix potential memory leaks, clarify literal and expr_text.

diff --git a/Lib/test/test_future.py b/Lib/test/test_future.py
index 303c5f7fbe..fd468b57b4 100644
--- a/Lib/test/test_future.py
+++ b/Lib/test/test_future.py
@@ -284,6 +284,7 @@ def test_annotations(self):
         eq("(x:=10)")
         eq("f'{(x:=10):=10}'")
 
+    def test_fstring_debug_annotations(self):
         # f-strings with '=' don't round trip very well, so set the expected
         # result explicitely.
         self.assertAnnotationEqual("f'{x=!r}'", expected="f'x={x!r}'")
diff --git a/Python/ast.c b/Python/ast.c
index 12a45f9bbb..183b08d6ba 100644
--- a/Python/ast.c
+++ b/Python/ast.c
@@ -5010,8 +5010,8 @@ fstring_parse(const char **str, const char *end, int raw, int recurse_lvl,
 
    *expression is set to the expression.  For an '=' "debug" expression,
    *expr_text is set to the debug text (the original text of the expression,
-   *including the '=' and any whitespace around it, as a string object).  If
-   *not a debug expression, *expr_text set to NULL. */
+   including the '=' and any whitespace around it, as a string object).  If
+   not a debug expression, *expr_text set to NULL. */
 static int
 fstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,
                   PyObject **expr_text, expr_ty *expression,
@@ -5039,6 +5039,8 @@ fstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,
     Py_ssize_t nested_depth = 0;
     char parenstack[MAXLEVEL];
 
+    *expr_text = NULL;
+
     /* Can only nest one level deep. */
     if (recurse_lvl >= 2) {
         ast_error(c, n, "f-string: expressions nested too deeply");
@@ -5214,8 +5216,6 @@ fstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,
         if (!*expr_text) {
             goto error;
         }
-    } else {
-        *expr_text = NULL;
     }
 
     /* Check for a conversion char, if present. */
@@ -5281,6 +5281,7 @@ fstring_find_expr(const char **str, const char *end, int raw, int recurse_lvl,
     /* Falls through to error. */
 
 error:
+    Py_XDECREF(*expr_text);
     return -1;
 
 }
@@ -5603,7 +5604,8 @@ FstringParser_ConcatFstring(FstringParser *state, const char **str,
 
     /* Parse the f-string. */
     while (1) {
-        PyObject *literal[2] = {NULL, NULL};
+        PyObject *literal = NULL;
+        PyObject *expr_text = NULL;
         expr_ty expression = NULL;
 
         /* If there's a zero length literal in front of the
@@ -5611,34 +5613,23 @@ FstringParser_ConcatFstring(FstringParser *state, const char **str,
            the f-string, expression will be NULL (unless result == 1,
            see below). */
         int result = fstring_find_literal_and_expr(str, end, raw, recurse_lvl,
-                                                   &literal[0], &literal[1],
+                                                   &literal, &expr_text,
                                                    &expression, c, n);
         if (result < 0)
             return -1;
 
-        /* Add the literals, if any. */
-        for (int i = 0; i < 2; i++) {
-            if (!literal[i]) {
-                /* Do nothing. Just leave last_str alone (and possibly
-                   NULL). */
-            } else if (!state->last_str) {
-                /*  Note that the literal can be zero length, if the
-                    input string is "\\\n" or "\\\r", among others. */
-                state->last_str = literal[i];
-                literal[i] = NULL;
-            } else {
-                /* We have a literal, concatenate it. */
-                assert(PyUnicode_GET_LENGTH(literal[i]) != 0);
-                if (FstringParser_ConcatAndDel(state, literal[i]) < 0)
-                    return -1;
-                literal[i] = NULL;
-            }
+        /* Add the literal, if any. */
+        if (literal && FstringParser_ConcatAndDel(state, literal) < 0) {
+            Py_XDECREF(expr_text);
+            return -1;
+        }
+        /* Add the expr_text, if any. */
+        if (expr_text && FstringParser_ConcatAndDel(state, expr_text) < 0) {
+            return -1;
         }
 
-        /* We've dealt with the literals now. They can't be leaked on further
-           errors. */
-        assert(literal[0] == NULL);
-        assert(literal[1] == NULL);
+        /* We've dealt with the literal and expr_text, their ownership has
+           been transferred to the state object.  Don't look at them again. */
 
         /* See if we should just loop around to get the next literal
            and expression, while ignoring the expression this

[ML] commit 463b82a3efe8a6a9f3924a5b37482e961dffe3b8
Author: Victor Stinner <vstinner@redhat.com>
Date:   Wed May 1 01:36:13 2019 +0200

    bpo-36763: Fix Py_SetStandardStreamEncoding() (GH-13028)
    
    Fix memory leak in Py_SetStandardStreamEncoding(): release memory
    if the function is called twice.

diff --git a/Misc/NEWS.d/next/C API/2019-05-01-00-42-08.bpo-36763.vghb86.rst b/Misc/NEWS.d/next/C API/2019-05-01-00-42-08.bpo-36763.vghb86.rst
new file mode 100644
index 0000000000..1c34920827
--- /dev/null
+++ b/Misc/NEWS.d/next/C API/2019-05-01-00-42-08.bpo-36763.vghb86.rst	
@@ -0,0 +1,2 @@
+Fix memory leak in :c:func:`Py_SetStandardStreamEncoding`: release memory if
+the function is called twice.
diff --git a/Python/coreconfig.c b/Python/coreconfig.c
index d05beef2aa..471d5126f8 100644
--- a/Python/coreconfig.c
+++ b/Python/coreconfig.c
@@ -375,6 +375,7 @@ Py_SetStandardStreamEncoding(const char *encoding, const char *errors)
      * Py_Initialize hasn't been called yet.
      */
     if (encoding) {
+        PyMem_RawFree(_Py_StandardStreamEncoding);
         _Py_StandardStreamEncoding = _PyMem_RawStrdup(encoding);
         if (!_Py_StandardStreamEncoding) {
             res = -2;
@@ -382,11 +383,11 @@ Py_SetStandardStreamEncoding(const char *encoding, const char *errors)
         }
     }
     if (errors) {
+        PyMem_RawFree(_Py_StandardStreamErrors);
         _Py_StandardStreamErrors = _PyMem_RawStrdup(errors);
         if (!_Py_StandardStreamErrors) {
-            if (_Py_StandardStreamEncoding) {
-                PyMem_RawFree(_Py_StandardStreamEncoding);
-            }
+            PyMem_RawFree(_Py_StandardStreamEncoding);
+            _Py_StandardStreamEncoding = NULL;
             res = -3;
             goto done;
         }

[ML] commit f5f336a819a3d881bb217bf8f9b5cacba03a4e45
Author: Victor Stinner <vstinner@redhat.com>
Date:   Tue Mar 19 14:53:58 2019 +0100

    bpo-36356: pymain_free() calls _PyRuntime_Finalize() (GH-12435)
    
    Ensure that _PyRuntime_Finalize() is always call. This change fix a
    few memory leaks when running "python3 -V".

diff --git a/Include/internal/pycore_pystate.h b/Include/internal/pycore_pystate.h
index 703a85b96b..7c9d11aec3 100644
--- a/Include/internal/pycore_pystate.h
+++ b/Include/internal/pycore_pystate.h
@@ -184,6 +184,8 @@ PyAPI_FUNC(void) _PyRuntimeState_ReInitThreads(void);
    Return NULL on success, or return an error message on failure. */
 PyAPI_FUNC(_PyInitError) _PyRuntime_Initialize(void);
 
+PyAPI_FUNC(void) _PyRuntime_Finalize(void);
+
 #define _Py_CURRENTLY_FINALIZING(tstate) \
     (_PyRuntime.finalizing == tstate)
 
diff --git a/Modules/main.c b/Modules/main.c
index 8f7a1bfa83..99396b73c6 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -839,6 +839,7 @@ pymain_free(void)
     _PyPathConfig_ClearGlobal();
     _Py_ClearStandardStreamEncoding();
     _Py_ClearArgcArgv();
+    _PyRuntime_Finalize();
 }
 
 

[ML] commit e130a07eb20c4b655d182d5d10d778c7584efe55
Author: btharper <btharper1221@gmail.com>
Date:   Tue Mar 19 06:50:25 2019 -0400

    bpo-36356: Fix memory leak in _PyPreConfig_Read() (GH-12425)
    
    _PyPreConfig_Read() now free 'old_old' at exit.

diff --git a/Misc/NEWS.d/next/Build/2019-03-18-23-49-15.bpo-36356.WNrwYI.rst b/Misc/NEWS.d/next/Build/2019-03-18-23-49-15.bpo-36356.WNrwYI.rst
new file mode 100644
index 0000000000..d30f5d586b
--- /dev/null
+++ b/Misc/NEWS.d/next/Build/2019-03-18-23-49-15.bpo-36356.WNrwYI.rst
@@ -0,0 +1 @@
+Fix leaks that led to build failure when configured with address sanitizer.
diff --git a/Python/preconfig.c b/Python/preconfig.c
index 1efc7ee5c5..b03436181c 100644
--- a/Python/preconfig.c
+++ b/Python/preconfig.c
@@ -514,6 +514,7 @@ _PyPreConfig_Read(_PyPreConfig *config)
     err = preconfig_read(config, NULL);
 
     setlocale(LC_CTYPE, old_loc);
+    PyMem_RawFree(old_loc);
 
     return err;
 }

[ML] commit c183444f7e2640b054956474d71aae6e8d31a543
Author: Victor Stinner <vstinner@redhat.com>
Date:   Mon Mar 18 22:24:28 2019 +0100

    bpo-36301: Fix Py_Main() memory leaks (GH-12420)
    
    bpo-36301, bpo-36333:
    
    * Fix memory allocator used by _PyPathConfig_ClearGlobal():
      force the default allocator.
    * _PyPreConfig_ReadFromArgv(): free init_ctype_locale memory.
    * pymain_main(): call pymain_free() on init error
    
    Co-Authored-By: Stphane Wirtel <stephane@wirtel.be>

diff --git a/Modules/main.c b/Modules/main.c
index 5c7f7e4567..50fecc9103 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -888,13 +888,13 @@ pymain_main(_PyArgv *args)
     PyInterpreterState *interp;
     err = pymain_init(args, &interp);
     if (_Py_INIT_FAILED(err)) {
-        _Py_ExitInitError(err);
+        goto exit_init_error;
     }
 
     int exitcode = 0;
     err = pymain_run_python(interp, &exitcode);
     if (_Py_INIT_FAILED(err)) {
-        _Py_ExitInitError(err);
+        goto exit_init_error;
     }
 
     if (Py_FinalizeEx() < 0) {
@@ -910,6 +910,10 @@ pymain_main(_PyArgv *args)
     }
 
     return exitcode;
+
+exit_init_error:
+    pymain_free();
+    _Py_ExitInitError(err);
 }
 
 
diff --git a/Python/pathconfig.c b/Python/pathconfig.c
index fb2d19e279..0ee87c4252 100644
--- a/Python/pathconfig.c
+++ b/Python/pathconfig.c
@@ -149,7 +149,12 @@ _PyPathConfig_SetGlobal(const _PyPathConfig *config)
 void
 _PyPathConfig_ClearGlobal(void)
 {
+    PyMemAllocatorEx old_alloc;
+    _PyMem_SetDefaultAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
+
     _PyPathConfig_Clear(&_Py_path_config);
+
+    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &old_alloc);
 }
 
 
diff --git a/Python/preconfig.c b/Python/preconfig.c
index a86ece57cf..1efc7ee5c5 100644
--- a/Python/preconfig.c
+++ b/Python/preconfig.c
@@ -758,6 +758,7 @@ _PyPreConfig_ReadFromArgv(_PyPreConfig *config, const _PyArgv *args)
 done:
     if (init_ctype_locale != NULL) {
         setlocale(LC_CTYPE, init_ctype_locale);
+        PyMem_RawFree(init_ctype_locale);
     }
     _PyPreConfig_Clear(&save_config);
     Py_UTF8Mode = init_utf8_mode ;

[NR] [ML] commit f683f464259715d620777d7ed568e701337a703a
Author: Fantix King <fantix.king@gmail.com>
Date:   Sun Mar 17 17:51:10 2019 -0500

    bpo-34745: Fix asyncio sslproto memory issues (GH-12386)
    
    * Fix handshake timeout leak in asyncio/sslproto
    
    Refs MagicStack/uvloop#222
    
    * Break circular ref _SSLPipe <-> SSLProtocol
    
    * bpo-34745: Fix asyncio ssl memory leak
    
    * Break circular ref SSLProtocol <-> UserProtocol
    
    * Add NEWS entry

diff --git a/Lib/asyncio/sslproto.py b/Lib/asyncio/sslproto.py
index 42785609dc..97a6fc66a9 100644
--- a/Lib/asyncio/sslproto.py
+++ b/Lib/asyncio/sslproto.py
@@ -498,7 +498,11 @@ def connection_lost(self, exc):
                 self._app_transport._closed = True
         self._transport = None
         self._app_transport = None
+        if getattr(self, '_handshake_timeout_handle', None):
+            self._handshake_timeout_handle.cancel()
         self._wakeup_waiter(exc)
+        self._app_protocol = None
+        self._sslpipe = None
 
     def pause_writing(self):
         """Called when the low-level transport's buffer goes over
diff --git a/Lib/test/test_asyncio/test_sslproto.py b/Lib/test/test_asyncio/test_sslproto.py
index 19b7a4366b..7bc2ccf0bd 100644
--- a/Lib/test/test_asyncio/test_sslproto.py
+++ b/Lib/test/test_asyncio/test_sslproto.py
@@ -4,6 +4,7 @@
 import socket
 import sys
 import unittest
+import weakref
 from unittest import mock
 try:
     import ssl
@@ -274,6 +275,72 @@ async def client(addr):
             self.loop.run_until_complete(
                 asyncio.wait_for(client(srv.addr), timeout=10))
 
+        # No garbage is left if SSL is closed uncleanly
+        client_context = weakref.ref(client_context)
+        self.assertIsNone(client_context())
+
+    def test_create_connection_memory_leak(self):
+        HELLO_MSG = b'1' * self.PAYLOAD_SIZE
+
+        server_context = test_utils.simple_server_sslcontext()
+        client_context = test_utils.simple_client_sslcontext()
+
+        def serve(sock):
+            sock.settimeout(self.TIMEOUT)
+
+            sock.start_tls(server_context, server_side=True)
+
+            sock.sendall(b'O')
+            data = sock.recv_all(len(HELLO_MSG))
+            self.assertEqual(len(data), len(HELLO_MSG))
+
+            sock.shutdown(socket.SHUT_RDWR)
+            sock.close()
+
+        class ClientProto(asyncio.Protocol):
+            def __init__(self, on_data, on_eof):
+                self.on_data = on_data
+                self.on_eof = on_eof
+                self.con_made_cnt = 0
+
+            def connection_made(proto, tr):
+                # XXX: We assume user stores the transport in protocol
+                proto.tr = tr
+                proto.con_made_cnt += 1
+                # Ensure connection_made gets called only once.
+                self.assertEqual(proto.con_made_cnt, 1)
+
+            def data_received(self, data):
+                self.on_data.set_result(data)
+
+            def eof_received(self):
+                self.on_eof.set_result(True)
+
+        async def client(addr):
+            await asyncio.sleep(0.5)
+
+            on_data = self.loop.create_future()
+            on_eof = self.loop.create_future()
+
+            tr, proto = await self.loop.create_connection(
+                lambda: ClientProto(on_data, on_eof), *addr,
+                ssl=client_context)
+
+            self.assertEqual(await on_data, b'O')
+            tr.write(HELLO_MSG)
+            await on_eof
+
+            tr.close()
+
+        with self.tcp_server(serve, timeout=self.TIMEOUT) as srv:
+            self.loop.run_until_complete(
+                asyncio.wait_for(client(srv.addr), timeout=10))
+
+        # No garbage is left for SSL client from loop.create_connection, even
+        # if user stores the SSLTransport in corresponding protocol instance
+        client_context = weakref.ref(client_context)
+        self.assertIsNone(client_context())
+
     def test_start_tls_client_buf_proto_1(self):
         HELLO_MSG = b'1' * self.PAYLOAD_SIZE
 
@@ -562,6 +629,11 @@ async def client(addr):
         # exception or log an error, even if the handshake failed
         self.assertEqual(messages, [])
 
+        # The 10s handshake timeout should be cancelled to free related
+        # objects without really waiting for 10s
+        client_sslctx = weakref.ref(client_sslctx)
+        self.assertIsNone(client_sslctx())
+
     def test_create_connection_ssl_slow_handshake(self):
         client_sslctx = test_utils.simple_client_sslcontext()
 
diff --git a/Misc/NEWS.d/next/Library/2019-03-17-16-43-29.bpo-34745.nOfm7_.rst b/Misc/NEWS.d/next/Library/2019-03-17-16-43-29.bpo-34745.nOfm7_.rst
new file mode 100644
index 0000000000..d88f36a6d2
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2019-03-17-16-43-29.bpo-34745.nOfm7_.rst
@@ -0,0 +1 @@
+Fix :mod:`asyncio` ssl memory issues caused by circular references

[ML] commit 9776b0636ae39668d3ce1c006d4be01dad01bf9f
Author: Victor Stinner <vstinner@redhat.com>
Date:   Wed Mar 13 17:55:01 2019 +0100

    bpo-36262: Fix _Py_dg_strtod() memory leak (goto undfl) (GH-12276)
    
    Fix an unlikely memory leak on conversion from string to float in the
    function _Py_dg_strtod() used by float(str), complex(str),
    pickle.load(), marshal.load(), etc.
    
    Fix an unlikely memory leak in _Py_dg_strtod() on "undfl:" label:
    rewrite memory management in this function to always release all
    memory before exiting the function. Initialize variables to NULL, and
    set them to NULL after calling Bfree() at the "cont:" label.
    
    Note: Bfree(NULL) is well defined: it does nothing.

diff --git a/Misc/NEWS.d/next/Core and Builtins/2019-03-11-15-37-33.bpo-36262.v3N6Fz.rst b/Misc/NEWS.d/next/Core and Builtins/2019-03-11-15-37-33.bpo-36262.v3N6Fz.rst
new file mode 100644
index 0000000000..b5ccc95fd7
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2019-03-11-15-37-33.bpo-36262.v3N6Fz.rst	
@@ -0,0 +1,3 @@
+Fix an unlikely memory leak on conversion from string to float in the function
+``_Py_dg_strtod()`` used by ``float(str)``, ``complex(str)``,
+:func:`pickle.load`, :func:`marshal.load`, etc.
diff --git a/Python/dtoa.c b/Python/dtoa.c
index 01ca9b0b22..b7bb7acfb6 100644
--- a/Python/dtoa.c
+++ b/Python/dtoa.c
@@ -1441,8 +1441,9 @@ _Py_dg_strtod(const char *s00, char **se)
     ULong y, z, abs_exp;
     Long L;
     BCinfo bc;
-    Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
+    Bigint *bb = NULL, *bd = NULL, *bd0 = NULL, *bs = NULL, *delta = NULL;
     size_t ndigits, fraclen;
+    double result;
 
     dval(&rv) = 0.;
 
@@ -1634,7 +1635,6 @@ _Py_dg_strtod(const char *s00, char **se)
     if (k > 9) {
         dval(&rv) = tens[k - 9] * dval(&rv) + z;
     }
-    bd0 = 0;
     if (nd <= DBL_DIG
         && Flt_Rounds == 1
         ) {
@@ -1804,14 +1804,11 @@ _Py_dg_strtod(const char *s00, char **se)
 
         bd = Balloc(bd0->k);
         if (bd == NULL) {
-            Bfree(bd0);
             goto failed_malloc;
         }
         Bcopy(bd, bd0);
         bb = sd2b(&rv, bc.scale, &bbe);   /* srv = bb * 2^bbe */
         if (bb == NULL) {
-            Bfree(bd);
-            Bfree(bd0);
             goto failed_malloc;
         }
         /* Record whether lsb of bb is odd, in case we need this
@@ -1821,9 +1818,6 @@ _Py_dg_strtod(const char *s00, char **se)
         /* tdv = bd * 10**e;  srv = bb * 2**bbe */
         bs = i2b(1);
         if (bs == NULL) {
-            Bfree(bb);
-            Bfree(bd);
-            Bfree(bd0);
             goto failed_malloc;
         }
 
@@ -1874,54 +1868,36 @@ _Py_dg_strtod(const char *s00, char **se)
         if (bb5 > 0) {
             bs = pow5mult(bs, bb5);
             if (bs == NULL) {
-                Bfree(bb);
-                Bfree(bd);
-                Bfree(bd0);
                 goto failed_malloc;
             }
-            bb1 = mult(bs, bb);
+            Bigint *bb1 = mult(bs, bb);
             Bfree(bb);
             bb = bb1;
             if (bb == NULL) {
-                Bfree(bs);
-                Bfree(bd);
-                Bfree(bd0);
                 goto failed_malloc;
             }
         }
         if (bb2 > 0) {
             bb = lshift(bb, bb2);
             if (bb == NULL) {
-                Bfree(bs);
-                Bfree(bd);
-                Bfree(bd0);
                 goto failed_malloc;
             }
         }
         if (bd5 > 0) {
             bd = pow5mult(bd, bd5);
             if (bd == NULL) {
-                Bfree(bb);
-                Bfree(bs);
-                Bfree(bd0);
                 goto failed_malloc;
             }
         }
         if (bd2 > 0) {
             bd = lshift(bd, bd2);
             if (bd == NULL) {
-                Bfree(bb);
-                Bfree(bs);
-                Bfree(bd0);
                 goto failed_malloc;
             }
         }
         if (bs2 > 0) {
             bs = lshift(bs, bs2);
             if (bs == NULL) {
-                Bfree(bb);
-                Bfree(bd);
-                Bfree(bd0);
                 goto failed_malloc;
             }
         }
@@ -1932,10 +1908,6 @@ _Py_dg_strtod(const char *s00, char **se)
 
         delta = diff(bb, bd);
         if (delta == NULL) {
-            Bfree(bb);
-            Bfree(bs);
-            Bfree(bd);
-            Bfree(bd0);
             goto failed_malloc;
         }
         dsign = delta->sign;
@@ -1989,10 +1961,6 @@ _Py_dg_strtod(const char *s00, char **se)
             }
             delta = lshift(delta,Log2P);
             if (delta == NULL) {
-                Bfree(bb);
-                Bfree(bs);
-                Bfree(bd);
-                Bfree(bd0);
                 goto failed_malloc;
             }
             if (cmp(delta, bs) > 0)
@@ -2094,11 +2062,6 @@ _Py_dg_strtod(const char *s00, char **se)
             if ((word0(&rv) & Exp_mask) >=
                 Exp_msk1*(DBL_MAX_EXP+Bias-P)) {
                 if (word0(&rv0) == Big0 && word1(&rv0) == Big1) {
-                    Bfree(bb);
-                    Bfree(bd);
-                    Bfree(bs);
-                    Bfree(bd0);
-                    Bfree(delta);
                     goto ovfl;
                 }
                 word0(&rv) = Big0;
@@ -2140,16 +2103,11 @@ _Py_dg_strtod(const char *s00, char **se)
                 }
         }
       cont:
-        Bfree(bb);
-        Bfree(bd);
-        Bfree(bs);
-        Bfree(delta);
+        Bfree(bb); bb = NULL;
+        Bfree(bd); bd = NULL;
+        Bfree(bs); bs = NULL;
+        Bfree(delta); delta = NULL;
     }
-    Bfree(bb);
-    Bfree(bd);
-    Bfree(bs);
-    Bfree(bd0);
-    Bfree(delta);
     if (bc.nd > nd) {
         error = bigcomp(&rv, s0, &bc);
         if (error)
@@ -2163,24 +2121,37 @@ _Py_dg_strtod(const char *s00, char **se)
     }
 
   ret:
-    return sign ? -dval(&rv) : dval(&rv);
+    result = sign ? -dval(&rv) : dval(&rv);
+    goto done;
 
   parse_error:
-    return 0.0;
+    result = 0.0;
+    goto done;
 
   failed_malloc:
     errno = ENOMEM;
-    return -1.0;
+    result = -1.0;
+    goto done;
 
   undfl:
-    return sign ? -0.0 : 0.0;
+    result = sign ? -0.0 : 0.0;
+    goto done;
 
   ovfl:
     errno = ERANGE;
     /* Can't trust HUGE_VAL */
     word0(&rv) = Exp_mask;
     word1(&rv) = 0;
-    return sign ? -dval(&rv) : dval(&rv);
+    result = sign ? -dval(&rv) : dval(&rv);
+    goto done;
+
+  done:
+    Bfree(bb);
+    Bfree(bd);
+    Bfree(bs);
+    Bfree(bd0);
+    Bfree(delta);
+    return result;
 
 }
 

[ML] commit 36433221f06d649dbd7e13f5fec948be8ffb90af
Author: Alexey Izbyshev <izbyshev@ispras.ru>
Date:   Sat Feb 16 01:28:58 2019 +0300

    bpo-35984: _xxsubinterpreters: Fix memory leak in _channel_send() (GH-11845)
    
    
    
    https://bugs.python.org/issue35984

diff --git a/Modules/_xxsubinterpretersmodule.c b/Modules/_xxsubinterpretersmodule.c
index 235df7076f..79c9def726 100644
--- a/Modules/_xxsubinterpretersmodule.c
+++ b/Modules/_xxsubinterpretersmodule.c
@@ -1339,6 +1339,7 @@ _channel_send(_channels *channels, int64_t id, PyObject *obj)
         return -1;
     }
     if (_PyObject_GetCrossInterpreterData(obj, data) != 0) {
+        PyMem_Free(data);
         PyThread_release_lock(mutex);
         return -1;
     }

[DF] commit bb3c05d7efca8d23bf39bc2640297ba2598899f3
Author: Zackery Spytz <zspytz@gmail.com>
Date:   Thu Feb 14 00:43:17 2019 -0700

    closes bpo-35991: Fix a potential double free in Modules/_randommodule.c. (GH-11849)

diff --git a/Misc/NEWS.d/next/Core and Builtins/2019-02-14-00-00-30.bpo-35991.xlbfSk.rst b/Misc/NEWS.d/next/Core and Builtins/2019-02-14-00-00-30.bpo-35991.xlbfSk.rst
new file mode 100644
index 0000000000..4bd55208da
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2019-02-14-00-00-30.bpo-35991.xlbfSk.rst	
@@ -0,0 +1 @@
+Fix a potential double free in Modules/_randommodule.c.
diff --git a/Modules/_randommodule.c b/Modules/_randommodule.c
index dae9d42fcb..6a48689204 100644
--- a/Modules/_randommodule.c
+++ b/Modules/_randommodule.c
@@ -292,7 +292,6 @@ random_seed(RandomObject *self, PyObject *args)
                               PY_LITTLE_ENDIAN,
                               0); /* unsigned */
     if (res == -1) {
-        PyMem_Free(key);
         goto Done;
     }
 

[ML] commit b9d2e97601847a1845bf96e2895a6214f02b92a6
Author: Pablo Galindo <Pablogsal@gmail.com>
Date:   Wed Feb 13 00:45:53 2019 +0000

    Fix potential memory leak in parsetok.c (GH-11832)

diff --git a/Parser/parsetok.c b/Parser/parsetok.c
index 1fa4a1286b..6a96f6bc5a 100644
--- a/Parser/parsetok.c
+++ b/Parser/parsetok.c
@@ -370,7 +370,6 @@ parsetok(struct tok_state *tok, grammar *g, int start, perrdetail *err_ret,
                                 type_ignores.items[i], 0);
             }
         }
-        growable_int_array_deallocate(&type_ignores);
 
 #ifndef PGEN
         /* Check that the source for a single input statement really
@@ -405,6 +404,8 @@ parsetok(struct tok_state *tok, grammar *g, int start, perrdetail *err_ret,
     else
         n = NULL;
 
+    growable_int_array_deallocate(&type_ignores);
+
 #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
     *flags = ps->p_flags;
 #endif

[ML] commit 35ca1820e19f81f69073f294503cdcd708fe490f
Author: Lucas Cimon <lucas.cimon@gmail.com>
Date:   Tue Jan 22 17:15:01 2019 +0100

    bpo-35720: Fixing a memory leak in pymain_parse_cmdline_impl() (GH-11528)
    
    When the loop in the pymain_read_conf function in this same file
    calls pymain_init_cmdline_argv() a 2nd time, the pymain->command
    buffer of wchar_t is overriden and the previously allocated memory
    is never freed.

diff --git a/Misc/NEWS.d/next/Core and Builtins/2019-01-12-23-33-04.bpo-35720.LELKQx.rst b/Misc/NEWS.d/next/Core and Builtins/2019-01-12-23-33-04.bpo-35720.LELKQx.rst
new file mode 100644
index 0000000000..9c57ebcb62
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2019-01-12-23-33-04.bpo-35720.LELKQx.rst	
@@ -0,0 +1 @@
+Fixed a minor memory leak in pymain_parse_cmdline_impl function in Modules/main.c
\ No newline at end of file
diff --git a/Modules/main.c b/Modules/main.c
index 8e66ddded4..da79a6397b 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -1376,6 +1376,7 @@ pymain_read_conf(_PyMain *pymain, _PyCoreConfig *config,
             goto done;
         }
         pymain_clear_cmdline(pymain, cmdline);
+        pymain_clear_pymain(pymain);
         memset(cmdline, 0, sizeof(*cmdline));
         config->utf8_mode = new_utf8_mode;
         config->coerce_c_locale = new_coerce_c_locale;

[ML] commit 5485085b324a45307c1ff4ec7d85b5998d7d5e0d
Author: Victor Stinner <vstinner@redhat.com>
Date:   Fri Jan 11 14:35:14 2019 +0100

    bpo-32710: Fix _overlapped.Overlapped memory leaks (GH-11489)
    
    Fix memory leaks in asyncio ProactorEventLoop on overlapped operation
    failures.
    
    Changes:
    
    * Implement the tp_traverse slot in the _overlapped.Overlapped type
      to help to break reference cycles and identify referrers in the
      garbage collector.
    * Always clear overlapped on failure: not only set type to
      TYPE_NOT_STARTED, but release also resources.

diff --git a/Misc/NEWS.d/next/Library/2019-01-10-15-55-10.bpo-32710.KwECPu.rst b/Misc/NEWS.d/next/Library/2019-01-10-15-55-10.bpo-32710.KwECPu.rst
new file mode 100644
index 0000000000..9f7a95a0aa
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2019-01-10-15-55-10.bpo-32710.KwECPu.rst
@@ -0,0 +1,2 @@
+Fix memory leaks in asyncio ProactorEventLoop on overlapped operation
+failure.
diff --git a/Modules/overlapped.c b/Modules/overlapped.c
index bbaa4fb300..ef4390b825 100644
--- a/Modules/overlapped.c
+++ b/Modules/overlapped.c
@@ -561,6 +561,28 @@ Overlapped_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
     return (PyObject *)self;
 }
 
+
+/* Note (bpo-32710): OverlappedType.tp_clear is not defined to not release
+   buffers while overlapped are still running, to prevent a crash. */
+static int
+Overlapped_clear(OverlappedObject *self)
+{
+    switch (self->type) {
+    case TYPE_READ:
+    case TYPE_ACCEPT:
+        Py_CLEAR(self->allocated_buffer);
+        break;
+    case TYPE_WRITE:
+    case TYPE_READINTO:
+        if (self->user_buffer.obj) {
+            PyBuffer_Release(&self->user_buffer);
+        }
+        break;
+    }
+    self->type = TYPE_NOT_STARTED;
+    return 0;
+}
+
 static void
 Overlapped_dealloc(OverlappedObject *self)
 {
@@ -594,20 +616,11 @@ Overlapped_dealloc(OverlappedObject *self)
         }
     }
 
-    if (self->overlapped.hEvent != NULL)
+    if (self->overlapped.hEvent != NULL) {
         CloseHandle(self->overlapped.hEvent);
-
-    switch (self->type) {
-    case TYPE_READ:
-    case TYPE_ACCEPT:
-        Py_CLEAR(self->allocated_buffer);
-        break;
-    case TYPE_WRITE:
-    case TYPE_READINTO:
-        if (self->user_buffer.obj)
-            PyBuffer_Release(&self->user_buffer);
-        break;
     }
+
+    Overlapped_clear(self);
     PyObject_Del(self);
     SetLastError(olderr);
 }
@@ -723,8 +736,7 @@ do_ReadFile(OverlappedObject *self, HANDLE handle,
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            PyBuffer_Release(&self->user_buffer);
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -827,7 +839,7 @@ do_WSARecv(OverlappedObject *self, HANDLE handle,
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -955,7 +967,7 @@ Overlapped_WriteFile(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1012,8 +1024,7 @@ Overlapped_WSASend(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            PyBuffer_Release(&self->user_buffer);
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1063,7 +1074,7 @@ Overlapped_AcceptEx(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1155,7 +1166,7 @@ Overlapped_ConnectEx(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1194,7 +1205,7 @@ Overlapped_DisconnectEx(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1249,7 +1260,7 @@ Overlapped_TransmitFile(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1290,7 +1301,7 @@ Overlapped_ConnectNamedPipe(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_FALSE;
         default:
-            self->type = TYPE_NOT_STARTED;
+            Overlapped_clear(self);
             return SetFromWindowsErr(err);
     }
 }
@@ -1340,6 +1351,25 @@ Overlapped_getpending(OverlappedObject *self)
                            self->type != TYPE_NOT_STARTED);
 }
 
+static int
+Overlapped_traverse(OverlappedObject *self, visitproc visit, void *arg)
+{
+    switch (self->type) {
+    case TYPE_READ:
+    case TYPE_ACCEPT:
+        Py_VISIT(self->allocated_buffer);
+        break;
+    case TYPE_WRITE:
+    case TYPE_READINTO:
+        if (self->user_buffer.obj) {
+            Py_VISIT(&self->user_buffer.obj);
+        }
+        break;
+    }
+    return 0;
+}
+
+
 static PyMethodDef Overlapped_methods[] = {
     {"getresult", (PyCFunction) Overlapped_getresult,
      METH_VARARGS, Overlapped_getresult_doc},
@@ -1410,7 +1440,7 @@ PyTypeObject OverlappedType = {
     /* tp_as_buffer      */ 0,
     /* tp_flags          */ Py_TPFLAGS_DEFAULT,
     /* tp_doc            */ "OVERLAPPED structure wrapper",
-    /* tp_traverse       */ 0,
+    /* tp_traverse       */ (traverseproc)Overlapped_traverse,
     /* tp_clear          */ 0,
     /* tp_richcompare    */ 0,
     /* tp_weaklistoffset */ 0,

[ML] commit a234e148394c2c7419372ab65b773d53a57f3625
Author: Victor Stinner <vstinner@redhat.com>
Date:   Tue Jan 8 14:23:09 2019 +0100

    bpo-32710: Fix leak in Overlapped_WSASend() (GH-11469)
    
    Fix a memory leak in asyncio in the ProactorEventLoop when ReadFile()
    or WSASend() overlapped operation fail immediately: release the
    internal buffer.

diff --git a/Misc/NEWS.d/next/Library/2019-01-08-14-00-52.bpo-32710.Sn5Ujj.rst b/Misc/NEWS.d/next/Library/2019-01-08-14-00-52.bpo-32710.Sn5Ujj.rst
new file mode 100644
index 0000000000..5c3961c33d
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2019-01-08-14-00-52.bpo-32710.Sn5Ujj.rst
@@ -0,0 +1,3 @@
+Fix a memory leak in asyncio in the ProactorEventLoop when ``ReadFile()`` or
+``WSASend()`` overlapped operation fail immediately: release the internal
+buffer.
diff --git a/Modules/overlapped.c b/Modules/overlapped.c
index 69875a7f37..bbaa4fb300 100644
--- a/Modules/overlapped.c
+++ b/Modules/overlapped.c
@@ -723,6 +723,7 @@ do_ReadFile(OverlappedObject *self, HANDLE handle,
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
+            PyBuffer_Release(&self->user_buffer);
             self->type = TYPE_NOT_STARTED;
             return SetFromWindowsErr(err);
     }
@@ -1011,6 +1012,7 @@ Overlapped_WSASend(OverlappedObject *self, PyObject *args)
         case ERROR_IO_PENDING:
             Py_RETURN_NONE;
         default:
+            PyBuffer_Release(&self->user_buffer);
             self->type = TYPE_NOT_STARTED;
             return SetFromWindowsErr(err);
     }

[ML] commit bde9d6bbb46ca59bcee5d5060adaa33c3ffee3a6
Author: Victor Stinner <vstinner@redhat.com>
Date:   Wed Nov 28 10:26:20 2018 +0100

    bpo-34523, bpo-35322: Fix unicode_encode_locale() (GH-10759)
    
    Fix memory leak in PyUnicode_EncodeLocale() and
    PyUnicode_EncodeFSDefault() on error handling.
    
    Changes:
    
    * Fix unicode_encode_locale() error handling
    * Fix test_codecs.LocaleCodecTest

diff --git a/Lib/test/test_codecs.py b/Lib/test/test_codecs.py
index 00b5d317c4..8c92556e84 100644
--- a/Lib/test/test_codecs.py
+++ b/Lib/test/test_codecs.py
@@ -3290,9 +3290,9 @@ def check_encode_strings(self, errors):
                     expected = text.encode(self.ENCODING, errors)
                 except UnicodeEncodeError:
                     with self.assertRaises(RuntimeError) as cm:
-                        self.encode(self.SURROGATES)
+                        self.encode(text, errors)
                     errmsg = str(cm.exception)
-                    self.assertTrue(errmsg.startswith("encode error: pos=0, reason="), errmsg)
+                    self.assertRegex(errmsg, r"encode error: pos=[0-9]+, reason=")
                 else:
                     encoded = self.encode(text, errors)
                     self.assertEqual(encoded, expected)
@@ -3315,6 +3315,11 @@ def test_encode_surrogatepass(self):
 
         self.check_encode_strings("surrogatepass")
 
+    def test_encode_unsupported_error_handler(self):
+        with self.assertRaises(ValueError) as cm:
+            self.encode('', 'backslashreplace')
+        self.assertEqual(str(cm.exception), 'unsupported error handler')
+
     def decode(self, encoded, errors="strict"):
         return _testcapi.DecodeLocaleEx(encoded, 0, errors)
 
@@ -3370,6 +3375,11 @@ def test_decode_surrogatepass(self):
 
         self.check_decode_strings("surrogatepass")
 
+    def test_decode_unsupported_error_handler(self):
+        with self.assertRaises(ValueError) as cm:
+            self.decode(b'', 'backslashreplace')
+        self.assertEqual(str(cm.exception), 'unsupported error handler')
+
 
 if __name__ == "__main__":
     unittest.main()
diff --git a/Misc/NEWS.d/next/C API/2018-11-28-03-20-36.bpo-35322.Qcqsag.rst b/Misc/NEWS.d/next/C API/2018-11-28-03-20-36.bpo-35322.Qcqsag.rst
new file mode 100644
index 0000000000..f5b4796307
--- /dev/null
+++ b/Misc/NEWS.d/next/C API/2018-11-28-03-20-36.bpo-35322.Qcqsag.rst	
@@ -0,0 +1,2 @@
+Fix memory leak in :c:func:`PyUnicode_EncodeLocale` and
+:c:func:`PyUnicode_EncodeFSDefault` on error handling.
diff --git a/Objects/unicodeobject.c b/Objects/unicodeobject.c
index 2b1db918a1..bc98c44c74 100644
--- a/Objects/unicodeobject.c
+++ b/Objects/unicodeobject.c
@@ -3449,10 +3449,9 @@ unicode_encode_locale(PyObject *unicode, const char *errors,
         return NULL;
     }
 
-    Py_ssize_t wlen2 = wcslen(wstr);
-    if (wlen2 != wlen) {
-        PyMem_Free(wstr);
+    if ((size_t)wlen != wcslen(wstr)) {
         PyErr_SetString(PyExc_ValueError, "embedded null character");
+        PyMem_Free(wstr);
         return NULL;
     }
 
@@ -3461,6 +3460,8 @@ unicode_encode_locale(PyObject *unicode, const char *errors,
     const char *reason;
     int res = _Py_EncodeLocaleEx(wstr, &str, &error_pos, &reason,
                                  current_locale, error_handler);
+    PyMem_Free(wstr);
+
     if (res != 0) {
         if (res == -2) {
             PyObject *exc;
@@ -3473,18 +3474,15 @@ unicode_encode_locale(PyObject *unicode, const char *errors,
                 PyCodec_StrictErrors(exc);
                 Py_DECREF(exc);
             }
-            return NULL;
         }
         else if (res == -3) {
             PyErr_SetString(PyExc_ValueError, "unsupported error handler");
         }
         else {
             PyErr_NoMemory();
-            PyMem_Free(wstr);
-            return NULL;
         }
+        return NULL;
     }
-    PyMem_Free(wstr);
 
     PyObject *bytes = PyBytes_FromString(str);
     PyMem_RawFree(str);

[DF] commit 9f3ed3e213b30059087d059a7d1d3b2527fa8654
Author: Zackery Spytz <zspytz@gmail.com>
Date:   Tue Oct 23 13:28:06 2018 -0600

    Fix error handling bugs in _elementtree.c. (GH-10060)
    
    References could leak, NULL could be dereferenced, and the Expat parser could
    be double freed when some errors raised.

diff --git a/Modules/_elementtree.c b/Modules/_elementtree.c
index f88315d771..2f1c4c02e8 100644
--- a/Modules/_elementtree.c
+++ b/Modules/_elementtree.c
@@ -336,6 +336,9 @@ static PyObject*
 get_attrib_from_keywords(PyObject *kwds)
 {
     PyObject *attrib_str = PyUnicode_FromString("attrib");
+    if (attrib_str == NULL) {
+        return NULL;
+    }
     PyObject *attrib = PyDict_GetItem(kwds, attrib_str);
 
     if (attrib) {
@@ -356,10 +359,10 @@ get_attrib_from_keywords(PyObject *kwds)
 
     Py_DECREF(attrib_str);
 
-    /* attrib can be NULL if PyDict_New failed */
-    if (attrib)
-        if (PyDict_Update(attrib, kwds) < 0)
-            return NULL;
+    if (attrib != NULL && PyDict_Update(attrib, kwds) < 0) {
+        Py_DECREF(attrib);
+        return NULL;
+    }
     return attrib;
 }
 
@@ -592,10 +595,9 @@ subelement(PyObject *self, PyObject *args, PyObject *kwds)
         attrib = PyDict_Copy(attrib);
         if (!attrib)
             return NULL;
-        if (kwds) {
-            if (PyDict_Update(attrib, kwds) < 0) {
-                return NULL;
-            }
+        if (kwds != NULL && PyDict_Update(attrib, kwds) < 0) {
+            Py_DECREF(attrib);
+            return NULL;
         }
     } else if (kwds) {
         /* have keyword args */
@@ -1871,7 +1873,6 @@ element_ass_subscr(PyObject* self_, PyObject* item, PyObject* value)
              * scheduled for removal.
             */
             if (!(recycle = PyList_New(slicelen))) {
-                PyErr_NoMemory();
                 return -1;
             }
 
@@ -1911,7 +1912,7 @@ element_ass_subscr(PyObject* self_, PyObject* item, PyObject* value)
             self->extra->length -= slicelen;
 
             /* Discard the recycle list with all the deleted sub-elements */
-            Py_XDECREF(recycle);
+            Py_DECREF(recycle);
             return 0;
         }
 
@@ -3338,7 +3339,6 @@ _elementtree_XMLParser___init___impl(XMLParserObject *self, PyObject *target,
         if (!target) {
             Py_CLEAR(self->entity);
             Py_CLEAR(self->names);
-            EXPAT(ParserFree)(self->parser);
             return -1;
         }
     }

[ML] commit 91e6c8717b7dcbcc46b189509de5f2d335819f37
Author: Zackery Spytz <zspytz@gmail.com>
Date:   Fri Sep 21 00:09:48 2018 -0600

    bpo-34735: Fix a memory leak in Modules/timemodule.c (GH-9418)
    
    There was a missing PyMem_Free(format) in time_strftime().

diff --git a/Misc/NEWS.d/next/Core and Builtins/2018-09-19-06-57-34.bpo-34735.-3mrSJ.rst b/Misc/NEWS.d/next/Core and Builtins/2018-09-19-06-57-34.bpo-34735.-3mrSJ.rst
new file mode 100644
index 0000000000..8de08ec386
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2018-09-19-06-57-34.bpo-34735.-3mrSJ.rst	
@@ -0,0 +1 @@
+Fix a memory leak in Modules/timemodule.c.  Patch by Zackery Spytz.
diff --git a/Modules/timemodule.c b/Modules/timemodule.c
index d162d93c9c..f41d6fab95 100644
--- a/Modules/timemodule.c
+++ b/Modules/timemodule.c
@@ -801,6 +801,7 @@ time_strftime(PyObject *self, PyObject *args)
         if (outbuf[1] == L'y' && buf.tm_year < 0) {
             PyErr_SetString(PyExc_ValueError,
                             "format %y requires year >= 1900 on AIX");
+            PyMem_Free(format);
             return NULL;
         }
     }

[ML] commit 67b9cc8e6072a919d2ed7e7ecc8124c8acfb3733
Author: Sergey Fedoseev <fedoseev.sergey@gmail.com>
Date:   Thu Aug 16 09:27:50 2018 +0500

    bpo-34395: Fix memory leaks caused by incautious usage of PyMem_Resize(). (GH-8756)

diff --git a/Modules/_csv.c b/Modules/_csv.c
index f58538c427..4cc1f7c88d 100644
--- a/Modules/_csv.c
+++ b/Modules/_csv.c
@@ -555,25 +555,17 @@ parse_save_field(ReaderObj *self)
 static int
 parse_grow_buff(ReaderObj *self)
 {
-    if (self->field_size == 0) {
-        self->field_size = 4096;
-        if (self->field != NULL)
-            PyMem_Free(self->field);
-        self->field = PyMem_New(Py_UCS4, self->field_size);
-    }
-    else {
-        Py_UCS4 *field = self->field;
-        if (self->field_size > PY_SSIZE_T_MAX / 2) {
-            PyErr_NoMemory();
-            return 0;
-        }
-        self->field_size *= 2;
-        self->field = PyMem_Resize(field, Py_UCS4, self->field_size);
-    }
-    if (self->field == NULL) {
+    assert((size_t)self->field_size <= PY_SSIZE_T_MAX / sizeof(Py_UCS4));
+
+    Py_ssize_t field_size_new = self->field_size ? 2 * self->field_size : 4096;
+    Py_UCS4 *field_new = self->field;
+    PyMem_Resize(field_new, Py_UCS4, field_size_new);
+    if (field_new == NULL) {
         PyErr_NoMemory();
         return 0;
     }
+    self->field = field_new;
+    self->field_size = field_size_new;
     return 1;
 }
 
@@ -1089,31 +1081,18 @@ join_append_data(WriterObj *self, unsigned int field_kind, void *field_data,
 static int
 join_check_rec_size(WriterObj *self, Py_ssize_t rec_len)
 {
-
-    if (rec_len < 0 || rec_len > PY_SSIZE_T_MAX - MEM_INCR) {
-        PyErr_NoMemory();
-        return 0;
-    }
+    assert(rec_len >= 0);
 
     if (rec_len > self->rec_size) {
-        if (self->rec_size == 0) {
-            self->rec_size = (rec_len / MEM_INCR + 1) * MEM_INCR;
-            if (self->rec != NULL)
-                PyMem_Free(self->rec);
-            self->rec = PyMem_New(Py_UCS4, self->rec_size);
-        }
-        else {
-            Py_UCS4* old_rec = self->rec;
-
-            self->rec_size = (rec_len / MEM_INCR + 1) * MEM_INCR;
-            self->rec = PyMem_Resize(old_rec, Py_UCS4, self->rec_size);
-            if (self->rec == NULL)
-                PyMem_Free(old_rec);
-        }
-        if (self->rec == NULL) {
+        size_t rec_size_new = (size_t)(rec_len / MEM_INCR + 1) * MEM_INCR;
+        Py_UCS4 *rec_new = self->rec;
+        PyMem_Resize(rec_new, Py_UCS4, rec_size_new);
+        if (rec_new == NULL) {
             PyErr_NoMemory();
             return 0;
         }
+        self->rec = rec_new;
+        self->rec_size = (Py_ssize_t)rec_size_new;
     }
     return 1;
 }
diff --git a/Modules/_pickle.c b/Modules/_pickle.c
index 294f33419c..ea778c7635 100644
--- a/Modules/_pickle.c
+++ b/Modules/_pickle.c
@@ -1382,11 +1382,13 @@ _Unpickler_ResizeMemoList(UnpicklerObject *self, Py_ssize_t new_size)
 
     assert(new_size > self->memo_size);
 
-    PyMem_RESIZE(self->memo, PyObject *, new_size);
-    if (self->memo == NULL) {
+    PyObject **memo_new = self->memo;
+    PyMem_RESIZE(memo_new, PyObject *, new_size);
+    if (memo_new == NULL) {
         PyErr_NoMemory();
         return -1;
     }
+    self->memo = memo_new;
     for (i = self->memo_size; i < new_size; i++)
         self->memo[i] = NULL;
     self->memo_size = new_size;
@@ -6295,11 +6297,10 @@ load_mark(UnpicklerObject *self)
             return -1;
         }
 
-        if (self->marks == NULL)
-            self->marks = PyMem_NEW(Py_ssize_t, alloc);
-        else
-            PyMem_RESIZE(self->marks, Py_ssize_t, alloc);
+        Py_ssize_t *marks_old = self->marks;
+        PyMem_RESIZE(self->marks, Py_ssize_t, alloc);
         if (self->marks == NULL) {
+            PyMem_FREE(marks_old);
             self->marks_size = 0;
             PyErr_NoMemory();
             return -1;

commit fc96437db4fa95dff99d43d4500beaf12bad5bff
Author: Victor Stinner <vstinner@redhat.com>
Date:   Wed Aug 1 16:16:46 2018 +0200

    bpo-33499: Fix pymain_init_pycache_prefix() (GH-8596)
    
    Fix a memory leak in pymain_init_pycache_prefix()
    when PYTHONPYCACHEPREFIX and -X pycache_prefix are used.

diff --git a/Modules/main.c b/Modules/main.c
index 664a70ad5e..34069e1b2d 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -1768,16 +1768,6 @@ pymain_init_tracemalloc(_PyCoreConfig *config)
 static _PyInitError
 pymain_init_pycache_prefix(_PyCoreConfig *config)
 {
-    wchar_t *env;
-
-    int res = config_get_env_var_dup(config, &env,
-                                     L"PYTHONPYCACHEPREFIX", "PYTHONPYCACHEPREFIX");
-    if (res < 0) {
-        return DECODE_LOCALE_ERR("PYTHONPYCACHEPREFIX", res);
-    } else if (env) {
-        config->pycache_prefix = env;
-    }
-
     const wchar_t *xoption = config_get_xoption(config, L"pycache_prefix");
     if (xoption) {
         const wchar_t *sep = wcschr(xoption, L'=');
@@ -1790,6 +1780,16 @@ pymain_init_pycache_prefix(_PyCoreConfig *config)
             // -X pycache_prefix= can cancel the env var
             config->pycache_prefix = NULL;
         }
+        return _Py_INIT_OK();
+    }
+
+    wchar_t *env;
+    int res = config_get_env_var_dup(config, &env,
+                                     L"PYTHONPYCACHEPREFIX", "PYTHONPYCACHEPREFIX");
+    if (res < 0) {
+        return DECODE_LOCALE_ERR("PYTHONPYCACHEPREFIX", res);
+    } else if (env) {
+        config->pycache_prefix = env;
     }
 
     return _Py_INIT_OK();

[ML] commit 993030aac576710a46b3dd0b4864f819d4a94145
Author: Serhiy Storchaka <storchaka@gmail.com>
Date:   Thu Jul 12 00:17:53 2018 +0300

    bpo-34080: Fix a memory leak in the compiler. (GH-8222)

diff --git a/Misc/NEWS.d/next/Core and Builtins/2018-07-10-11-24-16.bpo-34080.8t7PtO.rst b/Misc/NEWS.d/next/Core and Builtins/2018-07-10-11-24-16.bpo-34080.8t7PtO.rst
new file mode 100644
index 0000000000..cfc53cca48
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2018-07-10-11-24-16.bpo-34080.8t7PtO.rst	
@@ -0,0 +1,2 @@
+Fixed a memory leak in the compiler when it raised some uncommon errors
+during tokenizing.
diff --git a/Python/pythonrun.c b/Python/pythonrun.c
index bcd1ca931d..10605db0b6 100644
--- a/Python/pythonrun.c
+++ b/Python/pythonrun.c
@@ -1339,7 +1339,7 @@ err_input(perrdetail *err)
     errtype = PyExc_SyntaxError;
     switch (err->error) {
     case E_ERROR:
-        return;
+        goto cleanup;
     case E_SYNTAX:
         errtype = PyExc_IndentationError;
         if (err->expected == INDENT)

[ML] commit 3c452404ae178b742967589a0bb4a5ec768d76e0
Author: INADA Naoki <methane@users.noreply.github.com>
Date:   Wed Jul 4 11:15:50 2018 +0900

    bpo-33418: Add tp_clear for function object (GH-8058)
    
    Without tp_clear, GC can't break cyclic reference.
    It will cause memory leak when cyclic reference is
    created intentionally.

diff --git a/Misc/NEWS.d/next/Core and Builtins/2018-07-03-19-00-10.bpo-33418.cfGm3n.rst b/Misc/NEWS.d/next/Core and Builtins/2018-07-03-19-00-10.bpo-33418.cfGm3n.rst
new file mode 100644
index 0000000000..8f136c6a35
--- /dev/null
+++ b/Misc/NEWS.d/next/Core and Builtins/2018-07-03-19-00-10.bpo-33418.cfGm3n.rst	
@@ -0,0 +1,2 @@
+Fix potential memory leak in function object when it creates reference
+cycle.
diff --git a/Objects/funcobject.c b/Objects/funcobject.c
index 241685d5b7..c2f79c05db 100644
--- a/Objects/funcobject.c
+++ b/Objects/funcobject.c
@@ -523,23 +523,31 @@ func_new_impl(PyTypeObject *type, PyCodeObject *code, PyObject *globals,
     return (PyObject *)newfunc;
 }
 
+static int
+func_clear(PyFunctionObject *op)
+{
+    Py_CLEAR(op->func_code);
+    Py_CLEAR(op->func_globals);
+    Py_CLEAR(op->func_module);
+    Py_CLEAR(op->func_name);
+    Py_CLEAR(op->func_defaults);
+    Py_CLEAR(op->func_kwdefaults);
+    Py_CLEAR(op->func_doc);
+    Py_CLEAR(op->func_dict);
+    Py_CLEAR(op->func_closure);
+    Py_CLEAR(op->func_annotations);
+    Py_CLEAR(op->func_qualname);
+    return 0;
+}
+
 static void
 func_dealloc(PyFunctionObject *op)
 {
     _PyObject_GC_UNTRACK(op);
-    if (op->func_weakreflist != NULL)
+    if (op->func_weakreflist != NULL) {
         PyObject_ClearWeakRefs((PyObject *) op);
-    Py_DECREF(op->func_code);
-    Py_DECREF(op->func_globals);
-    Py_XDECREF(op->func_module);
-    Py_DECREF(op->func_name);
-    Py_XDECREF(op->func_defaults);
-    Py_XDECREF(op->func_kwdefaults);
-    Py_XDECREF(op->func_doc);
-    Py_XDECREF(op->func_dict);
-    Py_XDECREF(op->func_closure);
-    Py_XDECREF(op->func_annotations);
-    Py_XDECREF(op->func_qualname);
+    }
+    (void)func_clear(op);
     PyObject_GC_Del(op);
 }
 
@@ -612,7 +620,7 @@ PyTypeObject PyFunction_Type = {
     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,    /* tp_flags */
     func_new__doc__,                            /* tp_doc */
     (traverseproc)func_traverse,                /* tp_traverse */
-    0,                                          /* tp_clear */
+    (inquiry)func_clear,                        /* tp_clear */
     0,                                          /* tp_richcompare */
     offsetof(PyFunctionObject, func_weakreflist), /* tp_weaklistoffset */
     0,                                          /* tp_iter */

commit 23401fb960bb94e6ea62d2999527968d53d3fc65
Author: Victor Stinner <vstinner@redhat.com>
Date:   Tue Jul 3 13:20:35 2018 +0200

    bpo-33735: Fix test_multiprocessing random failure (GH-8059)
    
    When hunting memory leaks using -R 3:3, test_imap_unordered() of
    test_multiprocessing leaks randomly a few memory blocks. It is a
    false alarm: when testing using -R 3:20 for example, no leak is
    detected.
    
    Modify test_imap_unordered() to be closer to test_imap():
    
    * Only test 10 numbers instead of 1000: it's a pool of 4 processes, so
      10 is enough to test at least one number per process
    * Use chunksize=100 instead of chunksize=53 to mimick test_imap()

diff --git a/Lib/test/_test_multiprocessing.py b/Lib/test/_test_multiprocessing.py
index 2be40c1fbe..4c5da2fccd 100644
--- a/Lib/test/_test_multiprocessing.py
+++ b/Lib/test/_test_multiprocessing.py
@@ -2351,10 +2351,10 @@ def test_imap_handle_iterable_exception(self):
         self.assertRaises(SayWhenError, it.__next__)
 
     def test_imap_unordered(self):
-        it = self.pool.imap_unordered(sqr, list(range(1000)))
-        self.assertEqual(sorted(it), list(map(sqr, list(range(1000)))))
+        it = self.pool.imap_unordered(sqr, list(range(10)))
+        self.assertEqual(sorted(it), list(map(sqr, list(range(10)))))
 
-        it = self.pool.imap_unordered(sqr, list(range(1000)), chunksize=53)
+        it = self.pool.imap_unordered(sqr, list(range(1000)), chunksize=100)
         self.assertEqual(sorted(it), list(map(sqr, list(range(1000)))))
 
     def test_imap_unordered_handle_iterable_exception(self):

[ML] commit 3e197c7a6740d564ad52fb7901c07d5ff49460f5
Author: Alexey Izbyshev <izbyshev@users.noreply.github.com>
Date:   Thu Mar 1 12:13:56 2018 +0300

    bpo-32903: Fix a memory leak in os.chdir() on Windows (GH-5801)

diff --git a/Misc/NEWS.d/next/Windows/2018-02-28-11-03-24.bpo-32903.1SXY4t.rst b/Misc/NEWS.d/next/Windows/2018-02-28-11-03-24.bpo-32903.1SXY4t.rst
new file mode 100644
index 0000000000..a20a414790
--- /dev/null
+++ b/Misc/NEWS.d/next/Windows/2018-02-28-11-03-24.bpo-32903.1SXY4t.rst
@@ -0,0 +1,2 @@
+Fix a memory leak in os.chdir() on Windows if the current directory is set
+to a UNC path.
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index 4b59229883..6bba8ee26e 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -1529,15 +1529,15 @@ win32_wchdir(LPCWSTR path)
             return FALSE;
         }
     }
-    if (wcsncmp(new_path, L"\\\\", 2) == 0 ||
-        wcsncmp(new_path, L"//", 2) == 0)
-        /* UNC path, nothing to do. */
-        return TRUE;
-    env[1] = new_path[0];
-    result = SetEnvironmentVariableW(env, new_path);
+    int is_unc_like_path = (wcsncmp(new_path, L"\\\\", 2) == 0 ||
+                            wcsncmp(new_path, L"//", 2) == 0);
+    if (!is_unc_like_path) {
+        env[1] = new_path[0];
+        result = SetEnvironmentVariableW(env, new_path);
+    }
     if (new_path != path_buf)
         PyMem_RawFree(new_path);
-    return result;
+    return result ? TRUE : FALSE;
 }
 #endif
 

[ML] commit 4e9da0d163731caa79811c723c703ee416c31826
Author: Eric Snow <ericsnowcurrently@gmail.com>
Date:   Fri Feb 2 21:49:49 2018 -0700

    bpo-32604: Fix memory leaks in the new _xxsubinterpreters module. (#5507)

diff --git a/Lib/test/test__xxsubinterpreters.py b/Lib/test/test__xxsubinterpreters.py
index 2b170443a3..8d72ca2002 100644
--- a/Lib/test/test__xxsubinterpreters.py
+++ b/Lib/test/test__xxsubinterpreters.py
@@ -362,13 +362,15 @@ def test_bad_id(self):
     def test_from_current(self):
         main, = interpreters.list_all()
         id = interpreters.create()
-        script = dedent("""
+        script = dedent(f"""
             import _xxsubinterpreters as _interpreters
-            _interpreters.destroy({})
-            """).format(id)
+            try:
+                _interpreters.destroy({id})
+            except RuntimeError:
+                pass
+            """)
 
-        with self.assertRaises(RuntimeError):
-            interpreters.run_string(id, script)
+        interpreters.run_string(id, script)
         self.assertEqual(set(interpreters.list_all()), {main, id})
 
     def test_from_sibling(self):
@@ -761,12 +763,12 @@ def __int__(self):
         self.assertEqual(int(cid), 10)
 
     def test_bad_id(self):
-        ids = [-1, 2**64, "spam"]
-        for cid in ids:
+        for cid in [-1, 'spam']:
             with self.subTest(cid):
                 with self.assertRaises(ValueError):
                     interpreters._channel_id(cid)
-
+        with self.assertRaises(OverflowError):
+            interpreters._channel_id(2**64)
         with self.assertRaises(TypeError):
             interpreters._channel_id(object())
 
diff --git a/Modules/_xxsubinterpretersmodule.c b/Modules/_xxsubinterpretersmodule.c
index d2b5f26fae..7829b4cd95 100644
--- a/Modules/_xxsubinterpretersmodule.c
+++ b/Modules/_xxsubinterpretersmodule.c
@@ -7,6 +7,22 @@
 #include "internal/pystate.h"
 
 
+static char *
+_copy_raw_string(PyObject *strobj)
+{
+    const char *str = PyUnicode_AsUTF8(strobj);
+    if (str == NULL) {
+        return NULL;
+    }
+    char *copied = PyMem_Malloc(strlen(str)+1);
+    if (str == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    strcpy(copied, str);
+    return copied;
+}
+
 static PyInterpreterState *
 _get_current(void)
 {
@@ -31,10 +47,13 @@ _coerce_id(PyObject *id)
         }
         return -1;
     }
-    long long cid = PyLong_AsLongLong(id);
+    int64_t cid = PyLong_AsLongLong(id);
+    Py_DECREF(id);
     if (cid == -1 && PyErr_Occurred() != NULL) {
-        PyErr_SetString(PyExc_ValueError,
-                        "'id' must be a non-negative int");
+        if (!PyErr_ExceptionMatches(PyExc_OverflowError)) {
+            PyErr_SetString(PyExc_ValueError,
+                            "'id' must be a non-negative int");
+        }
         return -1;
     }
     if (cid < 0) {
@@ -42,92 +61,131 @@ _coerce_id(PyObject *id)
                         "'id' must be a non-negative int");
         return -1;
     }
-    if (cid > INT64_MAX) {
-        PyErr_SetString(PyExc_ValueError,
-                        "'id' too large (must be 64-bit int)");
-        return -1;
-    }
     return cid;
 }
 
+
 /* data-sharing-specific code ***********************************************/
 
-typedef struct _shareditem {
-    Py_UNICODE *name;
-    Py_ssize_t namelen;
+struct _sharednsitem {
+    char *name;
     _PyCrossInterpreterData data;
-} _shareditem;
+};
+
+static int
+_sharednsitem_init(struct _sharednsitem *item, PyObject *key, PyObject *value)
+{
+    item->name = _copy_raw_string(key);
+    if (item->name == NULL) {
+        return -1;
+    }
+    if (_PyObject_GetCrossInterpreterData(value, &item->data) != 0) {
+        return -1;
+    }
+    return 0;
+}
+
+static void
+_sharednsitem_clear(struct _sharednsitem *item)
+{
+    if (item->name != NULL) {
+        PyMem_Free(item->name);
+    }
+    _PyCrossInterpreterData_Release(&item->data);
+}
+
+static int
+_sharednsitem_apply(struct _sharednsitem *item, PyObject *ns)
+{
+    PyObject *name = PyUnicode_FromString(item->name);
+    if (name == NULL) {
+        return -1;
+    }
+    PyObject *value = _PyCrossInterpreterData_NewObject(&item->data);
+    if (value == NULL) {
+        Py_DECREF(name);
+        return -1;
+    }
+    int res = PyDict_SetItem(ns, name, value);
+    Py_DECREF(name);
+    Py_DECREF(value);
+    return res;
+}
+
+typedef struct _sharedns {
+    Py_ssize_t len;
+    struct _sharednsitem* items;
+} _sharedns;
+
+static _sharedns *
+_sharedns_new(Py_ssize_t len)
+{
+    _sharedns *shared = PyMem_NEW(_sharedns, 1);
+    if (shared == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    shared->len = len;
+    shared->items = PyMem_NEW(struct _sharednsitem, len);
+    if (shared->items == NULL) {
+        PyErr_NoMemory();
+        PyMem_Free(shared);
+        return NULL;
+    }
+    return shared;
+}
 
-void
-_sharedns_clear(_shareditem *shared)
+static void
+_sharedns_free(_sharedns *shared)
 {
-    for (_shareditem *item=shared; item->name != NULL; item += 1) {
-        _PyCrossInterpreterData_Release(&item->data);
+    for (Py_ssize_t i=0; i < shared->len; i++) {
+        _sharednsitem_clear(&shared->items[i]);
     }
+    PyMem_Free(shared->items);
+    PyMem_Free(shared);
 }
 
-static _shareditem *
-_get_shared_ns(PyObject *shareable, Py_ssize_t *lenp)
+static _sharedns *
+_get_shared_ns(PyObject *shareable)
 {
     if (shareable == NULL || shareable == Py_None) {
-        *lenp = 0;
         return NULL;
     }
     Py_ssize_t len = PyDict_Size(shareable);
-    *lenp = len;
     if (len == 0) {
         return NULL;
     }
 
-    _shareditem *shared = PyMem_NEW(_shareditem, len+1);
+    _sharedns *shared = _sharedns_new(len);
     if (shared == NULL) {
         return NULL;
     }
-    for (Py_ssize_t i=0; i < len; i++) {
-        *(shared + i) = (_shareditem){0};
-    }
     Py_ssize_t pos = 0;
     for (Py_ssize_t i=0; i < len; i++) {
         PyObject *key, *value;
         if (PyDict_Next(shareable, &pos, &key, &value) == 0) {
             break;
         }
-        _shareditem *item = shared + i;
-
-        if (_PyObject_GetCrossInterpreterData(value, &item->data) != 0) {
+        if (_sharednsitem_init(&shared->items[i], key, value) != 0) {
             break;
         }
-        item->name = PyUnicode_AsUnicodeAndSize(key, &item->namelen);
-        if (item->name == NULL) {
-            _PyCrossInterpreterData_Release(&item->data);
-            break;
-        }
-        (item + 1)->name = NULL;  // Mark the next one as the last.
     }
     if (PyErr_Occurred()) {
-        _sharedns_clear(shared);
-        PyMem_Free(shared);
+        _sharedns_free(shared);
         return NULL;
     }
     return shared;
 }
 
 static int
-_shareditem_apply(_shareditem *item, PyObject *ns)
+_sharedns_apply(_sharedns *shared, PyObject *ns)
 {
-    PyObject *name = PyUnicode_FromUnicode(item->name, item->namelen);
-    if (name == NULL) {
-        return 1;
-    }
-    PyObject *value = _PyCrossInterpreterData_NewObject(&item->data);
-    if (value == NULL) {
-        Py_DECREF(name);
-        return 1;
+    for (Py_ssize_t i=0; i < shared->len; i++) {
+        if (_sharednsitem_apply(&shared->items[i], ns) != 0) {
+            return -1;
+        }
     }
-    int res = PyDict_SetItem(ns, name, value);
-    Py_DECREF(name);
-    Py_DECREF(value);
-    return res;
+    return 0;
 }
 
 // Ultimately we'd like to preserve enough information about the
@@ -136,65 +194,117 @@ _shareditem_apply(_shareditem *item, PyObject *ns)
 // of the exception in the calling interpreter.
 
 typedef struct _sharedexception {
+    char *name;
     char *msg;
 } _sharedexception;
 
 static _sharedexception *
-_get_shared_exception(void)
+_sharedexception_new(void)
 {
     _sharedexception *err = PyMem_NEW(_sharedexception, 1);
     if (err == NULL) {
+        PyErr_NoMemory();
         return NULL;
     }
-    PyObject *exc;
-    PyObject *value;
-    PyObject *tb;
-    PyErr_Fetch(&exc, &value, &tb);
-    PyObject *msg;
-    if (value == NULL) {
-        msg = PyUnicode_FromFormat("%S", exc);
-    }
-    else {
-        msg = PyUnicode_FromFormat("%S: %S", exc, value);
-    }
-    if (msg == NULL) {
-        err->msg = "unable to format exception";
-        return err;
+    err->name = NULL;
+    err->msg = NULL;
+    return err;
+}
+
+static void
+_sharedexception_clear(_sharedexception *exc)
+{
+    if (exc->name != NULL) {
+        PyMem_Free(exc->name);
     }
-    err->msg = (char *)PyUnicode_AsUTF8(msg);
-    if (err->msg == NULL) {
-        err->msg = "unable to encode exception";
+    if (exc->msg != NULL) {
+        PyMem_Free(exc->msg);
     }
-    return err;
 }
 
-static PyObject * RunFailedError;
+static void
+_sharedexception_free(_sharedexception *exc)
+{
+    _sharedexception_clear(exc);
+    PyMem_Free(exc);
+}
 
-static int
-interp_exceptions_init(PyObject *ns)
+static _sharedexception *
+_sharedexception_bind(PyObject *exctype, PyObject *exc, PyObject *tb)
 {
-    // XXX Move the exceptions into per-module memory?
+    assert(exctype != NULL);
+    char *failure = NULL;
 
-    // An uncaught exception came out of interp_run_string().
-    RunFailedError = PyErr_NewException("_xxsubinterpreters.RunFailedError",
-                                        PyExc_RuntimeError, NULL);
-    if (RunFailedError == NULL) {
-        return -1;
+    _sharedexception *err = _sharedexception_new();
+    if (err == NULL) {
+        goto finally;
     }
-    if (PyDict_SetItemString(ns, "RunFailedError", RunFailedError) != 0) {
-        return -1;
+
+    PyObject *name = PyUnicode_FromFormat("%S", exctype);
+    if (name == NULL) {
+        failure = "unable to format exception type name";
+        goto finally;
+    }
+    err->name = _copy_raw_string(name);
+    Py_DECREF(name);
+    if (err->name == NULL) {
+        if (PyErr_ExceptionMatches(PyExc_MemoryError)) {
+            failure = "out of memory copying exception type name";
+        }
+        failure = "unable to encode and copy exception type name";
+        goto finally;
     }
 
-    return 0;
+    if (exc != NULL) {
+        PyObject *msg = PyUnicode_FromFormat("%S", exc);
+        if (msg == NULL) {
+            failure = "unable to format exception message";
+            goto finally;
+        }
+        err->msg = _copy_raw_string(msg);
+        Py_DECREF(msg);
+        if (err->msg == NULL) {
+            if (PyErr_ExceptionMatches(PyExc_MemoryError)) {
+                failure = "out of memory copying exception message";
+            }
+            failure = "unable to encode and copy exception message";
+            goto finally;
+        }
+    }
+
+finally:
+    if (failure != NULL) {
+        PyErr_Clear();
+        if (err->name != NULL) {
+            PyMem_Free(err->name);
+            err->name = NULL;
+        }
+        err->msg = failure;
+    }
+    return err;
 }
 
 static void
-_apply_shared_exception(_sharedexception *exc)
+_sharedexception_apply(_sharedexception *exc, PyObject *wrapperclass)
 {
-    PyErr_SetString(RunFailedError, exc->msg);
+    if (exc->name != NULL) {
+        if (exc->msg != NULL) {
+            PyErr_Format(wrapperclass, "%s: %s",  exc->name, exc->msg);
+        }
+        else {
+            PyErr_SetString(wrapperclass, exc->name);
+        }
+    }
+    else if (exc->msg != NULL) {
+        PyErr_SetString(wrapperclass, exc->msg);
+    }
+    else {
+        PyErr_SetNone(wrapperclass);
+    }
 }
 
-/* channel-specific code */
+
+/* channel-specific code ****************************************************/
 
 static PyObject *ChannelError;
 static PyObject *ChannelNotFoundError;
@@ -249,6 +359,139 @@ channel_exceptions_init(PyObject *ns)
     return 0;
 }
 
+/* the channel queue */
+
+struct _channelitem;
+
+typedef struct _channelitem {
+    _PyCrossInterpreterData *data;
+    struct _channelitem *next;
+} _channelitem;
+
+static _channelitem *
+_channelitem_new(void)
+{
+    _channelitem *item = PyMem_NEW(_channelitem, 1);
+    if (item == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    item->data = NULL;
+    item->next = NULL;
+    return item;
+}
+
+static void
+_channelitem_clear(_channelitem *item)
+{
+    if (item->data != NULL) {
+        _PyCrossInterpreterData_Release(item->data);
+        PyMem_Free(item->data);
+        item->data = NULL;
+    }
+    item->next = NULL;
+}
+
+static void
+_channelitem_free(_channelitem *item)
+{
+    _channelitem_clear(item);
+    PyMem_Free(item);
+}
+
+static void
+_channelitem_free_all(_channelitem *item)
+{
+    while (item != NULL) {
+        _channelitem *last = item;
+        item = item->next;
+        _channelitem_free(last);
+    }
+}
+
+static _PyCrossInterpreterData *
+_channelitem_popped(_channelitem *item)
+{
+    _PyCrossInterpreterData *data = item->data;
+    item->data = NULL;
+    _channelitem_free(item);
+    return data;
+}
+
+typedef struct _channelqueue {
+    int64_t count;
+    _channelitem *first;
+    _channelitem *last;
+} _channelqueue;
+
+static _channelqueue *
+_channelqueue_new(void)
+{
+    _channelqueue *queue = PyMem_NEW(_channelqueue, 1);
+    if (queue == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    queue->count = 0;
+    queue->first = NULL;
+    queue->last = NULL;
+    return queue;
+}
+
+static void
+_channelqueue_clear(_channelqueue *queue)
+{
+    _channelitem_free_all(queue->first);
+    queue->count = 0;
+    queue->first = NULL;
+    queue->last = NULL;
+}
+
+static void
+_channelqueue_free(_channelqueue *queue)
+{
+    _channelqueue_clear(queue);
+    PyMem_Free(queue);
+}
+
+static int
+_channelqueue_put(_channelqueue *queue, _PyCrossInterpreterData *data)
+{
+    _channelitem *item = _channelitem_new();
+    if (item == NULL) {
+        return -1;
+    }
+    item->data = data;
+
+    queue->count += 1;
+    if (queue->first == NULL) {
+        queue->first = item;
+    }
+    else {
+        queue->last->next = item;
+    }
+    queue->last = item;
+    return 0;
+}
+
+static _PyCrossInterpreterData *
+_channelqueue_get(_channelqueue *queue)
+{
+    _channelitem *item = queue->first;
+    if (item == NULL) {
+        return NULL;
+    }
+    queue->first = item->next;
+    if (queue->last == item) {
+        queue->last = NULL;
+    }
+    queue->count -= 1;
+
+    return _channelitem_popped(item);
+}
+
+/* channel-interpreter associations */
+
 struct _channelend;
 
 typedef struct _channelend {
@@ -262,23 +505,28 @@ _channelend_new(int64_t interp)
 {
     _channelend *end = PyMem_NEW(_channelend, 1);
     if (end == NULL) {
+        PyErr_NoMemory();
         return NULL;
     }
-
     end->next = NULL;
     end->interp = interp;
-
     end->open = 1;
-
     return end;
 }
 
 static void
-_channelend_free_all(_channelend *end) {
+_channelend_free(_channelend *end)
+{
+    PyMem_Free(end);
+}
+
+static void
+_channelend_free_all(_channelend *end)
+{
     while (end != NULL) {
         _channelend *last = end;
         end = end->next;
-        PyMem_Free(last);
+        _channelend_free(last);
     }
 }
 
@@ -300,24 +548,7 @@ _channelend_find(_channelend *first, int64_t interp, _channelend **pprev)
     return end;
 }
 
-struct _channelitem;
-
-typedef struct _channelitem {
-    _PyCrossInterpreterData *data;
-    struct _channelitem *next;
-} _channelitem;
-
-struct _channel;
-
-typedef struct _channel {
-    PyThread_type_lock mutex;
-
-    int open;
-
-    int64_t count;
-    _channelitem *first;
-    _channelitem *last;
-
+typedef struct _channelassociations {
     // Note that the list entries are never removed for interpreter
     // for which the channel is closed.  This should be a problem in
     // practice.  Also, a channel isn't automatically closed when an
@@ -326,39 +557,43 @@ typedef struct _channel {
     int64_t numrecvopen;
     _channelend *send;
     _channelend *recv;
-} _PyChannelState;
+} _channelends;
 
-static _PyChannelState *
-_channel_new(void)
+static _channelends *
+_channelends_new(void)
 {
-    _PyChannelState *chan = PyMem_NEW(_PyChannelState, 1);
-    if (chan == NULL) {
+    _channelends *ends = PyMem_NEW(_channelends, 1);
+    if (ends== NULL) {
         return NULL;
     }
-    chan->mutex = PyThread_allocate_lock();
-    if (chan->mutex == NULL) {
-        PyMem_Free(chan);
-        PyErr_SetString(ChannelError,
-                        "can't initialize mutex for new channel");
-        return NULL;
-    }
-
-    chan->open = 1;
+    ends->numsendopen = 0;
+    ends->numrecvopen = 0;
+    ends->send = NULL;
+    ends->recv = NULL;
+    return ends;
+}
 
-    chan->count = 0;
-    chan->first = NULL;
-    chan->last = NULL;
+static void
+_channelends_clear(_channelends *ends)
+{
+    _channelend_free_all(ends->send);
+    ends->send = NULL;
+    ends->numsendopen = 0;
 
-    chan->numsendopen = 0;
-    chan->numrecvopen = 0;
-    chan->send = NULL;
-    chan->recv = NULL;
+    _channelend_free_all(ends->recv);
+    ends->recv = NULL;
+    ends->numrecvopen = 0;
+}
 
-    return chan;
+static void
+_channelends_free(_channelends *ends)
+{
+    _channelends_clear(ends);
+    PyMem_Free(ends);
 }
 
 static _channelend *
-_channel_add_end(_PyChannelState *chan, _channelend *prev, int64_t interp,
+_channelends_add(_channelends *ends, _channelend *prev, int64_t interp,
                  int send)
 {
     _channelend *end = _channelend_new(interp);
@@ -368,137 +603,163 @@ _channel_add_end(_PyChannelState *chan, _channelend *prev, int64_t interp,
 
     if (prev == NULL) {
         if (send) {
-            chan->send = end;
+            ends->send = end;
         }
         else {
-            chan->recv = end;
+            ends->recv = end;
         }
     }
     else {
         prev->next = end;
     }
     if (send) {
-        chan->numsendopen += 1;
+        ends->numsendopen += 1;
     }
     else {
-        chan->numrecvopen += 1;
+        ends->numrecvopen += 1;
     }
     return end;
 }
 
-static _channelend *
-_channel_associate_end(_PyChannelState *chan, int64_t interp, int send)
+static int
+_channelends_associate(_channelends *ends, int64_t interp, int send)
 {
-    if (!chan->open) {
-        PyErr_SetString(ChannelClosedError, "channel closed");
-        return NULL;
-    }
-
     _channelend *prev;
-    _channelend *end = _channelend_find(send ? chan->send : chan->recv,
+    _channelend *end = _channelend_find(send ? ends->send : ends->recv,
                                         interp, &prev);
     if (end != NULL) {
         if (!end->open) {
             PyErr_SetString(ChannelClosedError, "channel already closed");
-            return NULL;
+            return -1;
         }
         // already associated
-        return end;
+        return 0;
+    }
+    if (_channelends_add(ends, prev, interp, send) == NULL) {
+        return -1;
     }
-    return _channel_add_end(chan, prev, interp, send);
+    return 0;
+}
+
+static int
+_channelends_is_open(_channelends *ends)
+{
+    if (ends->numsendopen != 0 || ends->numrecvopen != 0) {
+        return 1;
+    }
+    if (ends->send == NULL && ends->recv == NULL) {
+        return 1;
+    }
+    return 0;
 }
 
 static void
-_channel_close_channelend(_PyChannelState *chan, _channelend *end, int send)
+_channelends_close_end(_channelends *ends, _channelend *end, int send)
 {
     end->open = 0;
     if (send) {
-        chan->numsendopen -= 1;
+        ends->numsendopen -= 1;
     }
     else {
-        chan->numrecvopen -= 1;
+        ends->numrecvopen -= 1;
     }
 }
 
 static int
-_channel_close_interpreter(_PyChannelState *chan, int64_t interp, int which)
+_channelends_close_interpreter(_channelends *ends, int64_t interp, int which)
 {
-    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
-
-    int res = -1;
-    if (!chan->open) {
-        PyErr_SetString(ChannelClosedError, "channel already closed");
-        goto done;
-    }
-
     _channelend *prev;
     _channelend *end;
     if (which >= 0) {  // send/both
-        end = _channelend_find(chan->send, interp, &prev);
+        end = _channelend_find(ends->send, interp, &prev);
         if (end == NULL) {
             // never associated so add it
-            end = _channel_add_end(chan, prev, interp, 1);
+            end = _channelends_add(ends, prev, interp, 1);
             if (end == NULL) {
-                goto done;
+                return -1;
             }
         }
-        _channel_close_channelend(chan, end, 1);
+        _channelends_close_end(ends, end, 1);
     }
     if (which <= 0) {  // recv/both
-        end = _channelend_find(chan->recv, interp, &prev);
+        end = _channelend_find(ends->recv, interp, &prev);
         if (end == NULL) {
             // never associated so add it
-            end = _channel_add_end(chan, prev, interp, 0);
+            end = _channelends_add(ends, prev, interp, 0);
             if (end == NULL) {
-                goto done;
+                return -1;
             }
         }
-        _channel_close_channelend(chan, end, 0);
-    }
-
-    if (chan->numsendopen == 0 && chan->numrecvopen == 0) {
-        if (chan->send != NULL || chan->recv != NULL) {
-            chan->open = 0;
-        }
+        _channelends_close_end(ends, end, 0);
     }
-
-    res = 0;
-done:
-    PyThread_release_lock(chan->mutex);
-    return res;
+    return 0;
 }
 
-static int
-_channel_close_all(_PyChannelState *chan)
+static void
+_channelends_close_all(_channelends *ends)
 {
-    int res = -1;
-    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
+    // Ensure all the "send"-associated interpreters are closed.
+    _channelend *end;
+    for (end = ends->send; end != NULL; end = end->next) {
+        _channelends_close_end(ends, end, 1);
+    }
 
-    if (!chan->open) {
-        PyErr_SetString(ChannelClosedError, "channel already closed");
-        goto done;
+    // Ensure all the "recv"-associated interpreters are closed.
+    for (end = ends->recv; end != NULL; end = end->next) {
+        _channelends_close_end(ends, end, 0);
     }
+}
 
-    chan->open = 0;
+/* channels */
 
-    // We *could* also just leave these in place, since we've marked
-    // the channel as closed already.
+struct _channel;
 
-    // Ensure all the "send"-associated interpreters are closed.
-    _channelend *end;
-    for (end = chan->send; end != NULL; end = end->next) {
-        _channel_close_channelend(chan, end, 1);
-    }
+typedef struct _channel {
+    PyThread_type_lock mutex;
+    _channelqueue *queue;
+    _channelends *ends;
+    int open;
+} _PyChannelState;
 
-    // Ensure all the "recv"-associated interpreters are closed.
-    for (end = chan->recv; end != NULL; end = end->next) {
-        _channel_close_channelend(chan, end, 0);
+static _PyChannelState *
+_channel_new(void)
+{
+    _PyChannelState *chan = PyMem_NEW(_PyChannelState, 1);
+    if (chan == NULL) {
+        return NULL;
+    }
+    chan->mutex = PyThread_allocate_lock();
+    if (chan->mutex == NULL) {
+        PyMem_Free(chan);
+        PyErr_SetString(ChannelError,
+                        "can't initialize mutex for new channel");
+        return NULL;
+    }
+    chan->queue = _channelqueue_new();
+    if (chan->queue == NULL) {
+        PyMem_Free(chan);
+        return NULL;
+    }
+    chan->ends = _channelends_new();
+    if (chan->ends == NULL) {
+        _channelqueue_free(chan->queue);
+        PyMem_Free(chan);
+        return NULL;
     }
+    chan->open = 1;
+    return chan;
+}
 
-    res = 0;
-done:
+static void
+_channel_free(_PyChannelState *chan)
+{
+    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
+    _channelqueue_free(chan->queue);
+    _channelends_free(chan->ends);
     PyThread_release_lock(chan->mutex);
-    return res;
+
+    PyThread_free_lock(chan->mutex);
+    PyMem_Free(chan);
 }
 
 static int
@@ -506,24 +767,19 @@ _channel_add(_PyChannelState *chan, int64_t interp,
              _PyCrossInterpreterData *data)
 {
     int res = -1;
-
     PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
-    if (_channel_associate_end(chan, interp, 1) == NULL) {
+
+    if (!chan->open) {
+        PyErr_SetString(ChannelClosedError, "channel closed");
         goto done;
     }
-
-    _channelitem *item = PyMem_NEW(_channelitem, 1);
-    if (item == NULL) {
+    if (_channelends_associate(chan->ends, interp, 1) != 0) {
         goto done;
     }
-    item->data = data;
-    item->next = NULL;
 
-    chan->count += 1;
-    if (chan->first == NULL) {
-        chan->first = item;
+    if (_channelqueue_put(chan->queue, data) != 0) {
+        goto done;
     }
-    chan->last = item;
 
     res = 0;
 done:
@@ -536,56 +792,68 @@ _channel_next(_PyChannelState *chan, int64_t interp)
 {
     _PyCrossInterpreterData *data = NULL;
     PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
-    if (_channel_associate_end(chan, interp, 0) == NULL) {
-        goto done;
-    }
 
-    _channelitem *item = chan->first;
-    if (item == NULL) {
+    if (!chan->open) {
+        PyErr_SetString(ChannelClosedError, "channel closed");
         goto done;
     }
-    chan->first = item->next;
-    if (chan->last == item) {
-        chan->last = NULL;
+    if (_channelends_associate(chan->ends, interp, 0) != 0) {
+        goto done;
     }
-    chan->count -= 1;
-
-    data = item->data;
-    PyMem_Free(item);
 
+    data = _channelqueue_get(chan->queue);
 done:
     PyThread_release_lock(chan->mutex);
     return data;
 }
 
-static void
-_channel_clear(_PyChannelState *chan)
+static int
+_channel_close_interpreter(_PyChannelState *chan, int64_t interp, int which)
 {
-    _channelitem *item = chan->first;
-    while (item != NULL) {
-        _PyCrossInterpreterData_Release(item->data);
-        PyMem_Free(item->data);
-        _channelitem *last = item;
-        item = item->next;
-        PyMem_Free(last);
+    PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
+
+    int res = -1;
+    if (!chan->open) {
+        PyErr_SetString(ChannelClosedError, "channel already closed");
+        goto done;
     }
-    chan->first = NULL;
-    chan->last = NULL;
+
+    if (_channelends_close_interpreter(chan->ends, interp, which) != 0) {
+        goto done;
+    }
+    chan->open = _channelends_is_open(chan->ends);
+
+    res = 0;
+done:
+    PyThread_release_lock(chan->mutex);
+    return res;
 }
 
-static void
-_channel_free(_PyChannelState *chan)
+static int
+_channel_close_all(_PyChannelState *chan)
 {
+    int res = -1;
     PyThread_acquire_lock(chan->mutex, WAIT_LOCK);
-    _channel_clear(chan);
-    _channelend_free_all(chan->send);
-    _channelend_free_all(chan->recv);
-    PyThread_release_lock(chan->mutex);
 
-    PyThread_free_lock(chan->mutex);
-    PyMem_Free(chan);
+    if (!chan->open) {
+        PyErr_SetString(ChannelClosedError, "channel already closed");
+        goto done;
+    }
+
+    chan->open = 0;
+
+    // We *could* also just leave these in place, since we've marked
+    // the channel as closed already.
+    _channelends_close_all(chan->ends);
+
+    res = 0;
+done:
+    PyThread_release_lock(chan->mutex);
+    return res;
 }
 
+/* the set of channels */
+
 struct _channelref;
 
 typedef struct _channelref {
@@ -609,6 +877,22 @@ _channelref_new(int64_t id, _PyChannelState *chan)
     return ref;
 }
 
+//static void
+//_channelref_clear(_channelref *ref)
+//{
+//    ref->id = -1;
+//    ref->chan = NULL;
+//    ref->next = NULL;
+//    ref->objcount = 0;
+//}
+
+static void
+_channelref_free(_channelref *ref)
+{
+    //_channelref_clear(ref);
+    PyMem_Free(ref);
+}
+
 static _channelref *
 _channelref_find(_channelref *first, int64_t id, _channelref **pprev)
 {
@@ -640,7 +924,6 @@ _channels_init(_channels *channels)
     if (channels->mutex == NULL) {
         channels->mutex = PyThread_allocate_lock();
         if (channels->mutex == NULL) {
-            PyMem_Free(channels);
             PyErr_SetString(ChannelError,
                             "can't initialize mutex for channel management");
             return -1;
@@ -752,6 +1035,9 @@ _channels_close(_channels *channels, int64_t cid, _PyChannelState **pchan)
         if (pchan != NULL) {
             *pchan = ref->chan;
         }
+        else {
+            _channel_free(ref->chan);
+        }
         ref->chan = NULL;
     }
 
@@ -776,7 +1062,7 @@ _channels_remove_ref(_channels *channels, _channelref *ref, _channelref *prev,
     if (pchan != NULL) {
         *pchan = ref->chan;
     }
-    PyMem_Free(ref);
+    _channelref_free(ref);
 }
 
 static int
@@ -974,6 +1260,7 @@ _channel_recv(_channels *channels, int64_t id)
         return NULL;
     }
     _PyCrossInterpreterData_Release(data);
+    PyMem_Free(data);
 
     return obj;
 }
@@ -995,7 +1282,7 @@ _channel_drop(_channels *channels, int64_t id, int send, int recv)
     // Past this point we are responsible for releasing the mutex.
 
     // Close one or both of the two ends.
-    int res =_channel_close_interpreter(chan, interp->id, send-recv);
+    int res = _channel_close_interpreter(chan, interp->id, send-recv);
     PyThread_release_lock(mutex);
     return res;
 }
@@ -1078,6 +1365,7 @@ channelid_new(PyTypeObject *cls, PyObject *args, PyObject *kwds)
                         "'send' and 'recv' cannot both be False");
         return NULL;
     }
+
     int end = 0;
     if (send == 1) {
         if (recv == 0 || recv == -1) {
@@ -1176,7 +1464,9 @@ channelid_hash(PyObject *self)
     if (id == NULL) {
         return -1;
     }
-    return PyObject_Hash(id);
+    Py_hash_t hash = PyObject_Hash(id);
+    Py_DECREF(id);
+    return hash;
 }
 
 static PyObject *
@@ -1208,11 +1498,11 @@ channelid_richcompare(PyObject *self, PyObject *other, int op)
             Py_RETURN_NOTIMPLEMENTED;
         }
         int64_t othercid = PyLong_AsLongLong(other);
-        // XXX decref other here?
+        Py_DECREF(other);
         if (othercid == -1 && PyErr_Occurred() != NULL) {
             return NULL;
         }
-        if (othercid < 0 || othercid > INT64_MAX) {
+        if (othercid < 0) {
             equal = 0;
         }
         else {
@@ -1338,7 +1628,30 @@ static PyTypeObject ChannelIDtype = {
     NULL,                           /* tp_new */
 };
 
-/* interpreter-specific functions *******************************************/
+
+/* interpreter-specific code ************************************************/
+
+static PyObject * RunFailedError = NULL;
+
+static int
+interp_exceptions_init(PyObject *ns)
+{
+    // XXX Move the exceptions into per-module memory?
+
+    if (RunFailedError == NULL) {
+        // An uncaught exception came out of interp_run_string().
+        RunFailedError = PyErr_NewException("_xxsubinterpreters.RunFailedError",
+                                            PyExc_RuntimeError, NULL);
+        if (RunFailedError == NULL) {
+            return -1;
+        }
+        if (PyDict_SetItemString(ns, "RunFailedError", RunFailedError) != 0) {
+            return -1;
+        }
+    }
+
+    return 0;
+}
 
 static PyInterpreterState *
 _look_up(PyObject *requested_id)
@@ -1396,10 +1709,12 @@ _ensure_not_running(PyInterpreterState *interp)
 
 static int
 _run_script(PyInterpreterState *interp, const char *codestr,
-            _shareditem *shared, Py_ssize_t num_shared,
-            _sharedexception **exc)
+            _sharedns *shared, _sharedexception **exc)
 {
-    assert(num_shared >= 0);
+    PyObject *exctype = NULL;
+    PyObject *excval = NULL;
+    PyObject *tb = NULL;
+
     PyObject *main_mod = PyMapping_GetItemString(interp->modules, "__main__");
     if (main_mod == NULL) {
         goto error;
@@ -1413,12 +1728,9 @@ _run_script(PyInterpreterState *interp, const char *codestr,
 
     // Apply the cross-interpreter data.
     if (shared != NULL) {
-        for (Py_ssize_t i=0; i < num_shared; i++) {
-            _shareditem *item = &shared[i];
-            if (_shareditem_apply(item, ns) != 0) {
-                Py_DECREF(ns);
-                goto error;
-            }
+        if (_sharedns_apply(shared, ns) != 0) {
+            Py_DECREF(ns);
+            goto error;
         }
     }
 
@@ -1432,11 +1744,25 @@ _run_script(PyInterpreterState *interp, const char *codestr,
         Py_DECREF(result);  // We throw away the result.
     }
 
+    *exc = NULL;
     return 0;
 
 error:
-    *exc = _get_shared_exception();
-    PyErr_Clear();
+    PyErr_Fetch(&exctype, &excval, &tb);
+
+    _sharedexception *sharedexc = _sharedexception_bind(exctype, excval, tb);
+    Py_XDECREF(exctype);
+    Py_XDECREF(excval);
+    Py_XDECREF(tb);
+    if (sharedexc == NULL) {
+        fprintf(stderr, "RunFailedError: script raised an uncaught exception");
+        PyErr_Clear();
+        sharedexc = NULL;
+    }
+    else {
+        assert(!PyErr_Occurred());
+    }
+    *exc = sharedexc;
     return -1;
 }
 
@@ -1448,8 +1774,7 @@ _run_script_in_interpreter(PyInterpreterState *interp, const char *codestr,
         return -1;
     }
 
-    Py_ssize_t num_shared = -1;
-    _shareditem *shared = _get_shared_ns(shareables, &num_shared);
+    _sharedns *shared = _get_shared_ns(shareables);
     if (shared == NULL && PyErr_Occurred()) {
         return -1;
     }
@@ -1460,7 +1785,7 @@ _run_script_in_interpreter(PyInterpreterState *interp, const char *codestr,
 
     // Run the script.
     _sharedexception *exc = NULL;
-    int result = _run_script(interp, codestr, shared, num_shared, &exc);
+    int result = _run_script(interp, codestr, shared, &exc);
 
     // Switch back.
     if (save_tstate != NULL) {
@@ -1469,8 +1794,8 @@ _run_script_in_interpreter(PyInterpreterState *interp, const char *codestr,
 
     // Propagate any exception out to the caller.
     if (exc != NULL) {
-        _apply_shared_exception(exc);
-        PyMem_Free(exc);
+        _sharedexception_apply(exc, RunFailedError);
+        _sharedexception_free(exc);
     }
     else if (result != 0) {
         // We were unable to allocate a shared exception.
@@ -1478,8 +1803,7 @@ _run_script_in_interpreter(PyInterpreterState *interp, const char *codestr,
     }
 
     if (shared != NULL) {
-        _sharedns_clear(shared);
-        PyMem_Free(shared);
+        _sharedns_free(shared);
     }
 
     return result;
@@ -1612,7 +1936,9 @@ interp_list_all(PyObject *self)
             return NULL;
         }
         // insert at front of list
-        if (PyList_Insert(ids, 0, id) < 0) {
+        int res = PyList_Insert(ids, 0, id);
+        Py_DECREF(id);
+        if (res < 0) {
             Py_DECREF(ids);
             return NULL;
         }
@@ -1822,11 +2148,11 @@ channel_list_all(PyObject *self)
     }
     PyObject *ids = PyList_New((Py_ssize_t)count);
     if (ids == NULL) {
-        // XXX free cids
-        return NULL;
+        goto finally;
     }
-    for (int64_t i=0; i < count; cids++, i++) {
-        PyObject *id = (PyObject *)newchannelid(&ChannelIDtype, *cids, 0,
+    int64_t *cur = cids;
+    for (int64_t i=0; i < count; cur++, i++) {
+        PyObject *id = (PyObject *)newchannelid(&ChannelIDtype, *cur, 0,
                                                 &_globals.channels, 0);
         if (id == NULL) {
             Py_DECREF(ids);
@@ -1835,7 +2161,9 @@ channel_list_all(PyObject *self)
         }
         PyList_SET_ITEM(ids, i, id);
     }
-    // XXX free cids
+
+finally:
+    PyMem_Free(cids);
     return ids;
 }
 
diff --git a/Python/pystate.c b/Python/pystate.c
index a474549a8c..8dbda73de7 100644
--- a/Python/pystate.c
+++ b/Python/pystate.c
@@ -1242,6 +1242,7 @@ _PyCrossInterpreterData_Lookup(PyObject *obj)
             break;
         }
     }
+    Py_DECREF(cls);
     PyThread_release_lock(_PyRuntime.xidregistry.mutex);
     return getdata;
 }

[ML] commit 0cd6bca65519109a8a7862d38ba1b8924e432a16
Author: Pablo Galindo <Pablogsal@gmail.com>
Date:   Mon Jan 29 20:34:42 2018 +0000

    bpo-20104: Fix leaks and errors in new os.posix_spawn (GH-5418)
    
    * Fix memory leaks and error handling in posix spawn
    * Improve error handling when destroying the file_actions object
    * Py_DECREF the result of PySequence_Fast on error
    * Handle uninitialized pid
    * Use OSError if file actions fails to initialize
    * Move _file_actions to outer scope to avoid undefined behaviour
    * Remove HAVE_POSIX_SPAWN define in Modules/posixmodule.c
    * Unshadow exception and clean error message

diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index 8b11e981f1..46f3adaf4d 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -176,14 +176,6 @@ corresponding Unix manual entries for more information on calls.");
 #else
 /* Unix functions that the configure script doesn't check for */
 #define HAVE_EXECV      1
-/* bpo-32705: Current Android does not have posix_spawn
- * Most likely posix_spawn will be available in next Android version (Android
- * P, API 28). Need revisit then. See
- * https://android-review.googlesource.com/c/platform/bionic/+/504842
- **/
-#ifndef __ANDROID__
-#define HAVE_POSIX_SPAWN 1
-#endif
 #define HAVE_FORK       1
 #if defined(__USLC__) && defined(__SCO_VERSION__)       /* SCO UDK Compiler */
 #define HAVE_FORK1      1
@@ -5139,17 +5131,22 @@ os_posix_spawn_impl(PyObject *module, path_t *path, PyObject *argv,
 /*[clinic end generated code: output=d023521f541c709c input=0ec9f1cfdc890be5]*/
 {
     EXECV_CHAR **argvlist = NULL;
-    EXECV_CHAR **envlist;
+    EXECV_CHAR **envlist = NULL;
+    posix_spawn_file_actions_t _file_actions;
+    posix_spawn_file_actions_t *file_actionsp = NULL;
     Py_ssize_t argc, envc;
+    PyObject* result = NULL;
+    PyObject* seq = NULL;
+ 
 
     /* posix_spawn has three arguments: (path, argv, env), where
    argv is a list or tuple of strings and env is a dictionary
        like posix.environ. */
 
-    if (!PySequence_Check(argv)){
+    if (!PySequence_Check(argv)) {
         PyErr_SetString(PyExc_TypeError,
                         "posix_spawn: argv must be a tuple or list");
-        goto fail;
+        goto exit;
     }
     argc = PySequence_Size(argv);
     if (argc < 1) {
@@ -5160,40 +5157,37 @@ os_posix_spawn_impl(PyObject *module, path_t *path, PyObject *argv,
     if (!PyMapping_Check(env)) {
         PyErr_SetString(PyExc_TypeError,
                         "posix_spawn: environment must be a mapping object");
-        goto fail;
+        goto exit;
     }
 
     argvlist = parse_arglist(argv, &argc);
     if (argvlist == NULL) {
-        goto fail;
+        goto exit;
     }
     if (!argvlist[0][0]) {
         PyErr_SetString(PyExc_ValueError,
             "posix_spawn: argv first element cannot be empty");
-        goto fail;
+        goto exit;
     }
 
     envlist = parse_envlist(env, &envc);
-    if (envlist == NULL)
-        goto fail;
+    if (envlist == NULL) {
+        goto exit;
+    }
 
     pid_t pid;
-    posix_spawn_file_actions_t *file_actionsp = NULL;
-    if (file_actions  != NULL && file_actions != Py_None){
-        posix_spawn_file_actions_t _file_actions;
+    if (file_actions != NULL && file_actions != Py_None) {
         if(posix_spawn_file_actions_init(&_file_actions) != 0){
-            PyErr_SetString(PyExc_TypeError,
+            PyErr_SetString(PyExc_OSError,
                             "Error initializing file actions");
-            goto fail;
+            goto exit;
         }
 
-
         file_actionsp = &_file_actions;
 
-
-        PyObject* seq = PySequence_Fast(file_actions, "file_actions must be a sequence");
-        if(seq == NULL){
-            goto fail;
+        seq = PySequence_Fast(file_actions, "file_actions must be a sequence");
+        if(seq == NULL) {
+            goto exit;
         }
         PyObject* file_actions_obj;
         PyObject* mode_obj;
@@ -5201,9 +5195,9 @@ os_posix_spawn_impl(PyObject *module, path_t *path, PyObject *argv,
         for (int i = 0; i < PySequence_Fast_GET_SIZE(seq); ++i) {
             file_actions_obj = PySequence_Fast_GET_ITEM(seq, i);
 
-            if(!PySequence_Check(file_actions_obj) | !PySequence_Size(file_actions_obj)){
+            if(!PySequence_Check(file_actions_obj) | !PySequence_Size(file_actions_obj)) {
                 PyErr_SetString(PyExc_TypeError,"Each file_action element must be a non empty sequence");
-                goto fail;
+                goto exit;
             }
 
 
@@ -5215,83 +5209,103 @@ os_posix_spawn_impl(PyObject *module, path_t *path, PyObject *argv,
             switch(mode) {
 
                 case POSIX_SPAWN_OPEN:
-                    if(PySequence_Size(file_actions_obj) != 5){
+                    if(PySequence_Size(file_actions_obj) != 5) {
                         PyErr_SetString(PyExc_TypeError,"A open file_action object must have 5 elements");
-                        goto fail;
+                        goto exit;
                     }
 
                     long open_fd = PyLong_AsLong(PySequence_GetItem(file_actions_obj, 1));
                     if(PyErr_Occurred()) {
-                        goto fail;
+                        goto exit;
                     }
                     const char* open_path = PyUnicode_AsUTF8(PySequence_GetItem(file_actions_obj, 2));
-                    if(open_path == NULL){
-                        goto fail;
+                    if(open_path == NULL) {
+                        goto exit;
                     }
                     long open_oflag = PyLong_AsLong(PySequence_GetItem(file_actions_obj, 3));
                     if(PyErr_Occurred()) {
-                        goto fail;
+                        goto exit;
                     }
                     long open_mode = PyLong_AsLong(PySequence_GetItem(file_actions_obj, 4));
                     if(PyErr_Occurred()) {
-                        goto fail;
+                        goto exit;
+                    }
+                    if(posix_spawn_file_actions_addopen(file_actionsp, open_fd, open_path, open_oflag, open_mode)) {
+                        PyErr_SetString(PyExc_OSError,"Failed to add open file action");
+                        goto exit;
                     }
-                    posix_spawn_file_actions_addopen(file_actionsp, open_fd, open_path, open_oflag, open_mode);
+   
                     break;
 
                 case POSIX_SPAWN_CLOSE:
                     if(PySequence_Size(file_actions_obj) != 2){
                         PyErr_SetString(PyExc_TypeError,"A close file_action object must have 2 elements");
-                        goto fail;
+                        goto exit;
                     }
 
                     long close_fd = PyLong_AsLong(PySequence_GetItem(file_actions_obj, 1));
                     if(PyErr_Occurred()) {
-                        goto fail;
+                        goto exit;
+                    }
+                    if(posix_spawn_file_actions_addclose(file_actionsp, close_fd)) {
+                        PyErr_SetString(PyExc_OSError,"Failed to add close file action");
+                        goto exit;
                     }
-                    posix_spawn_file_actions_addclose(file_actionsp, close_fd);
                     break;
 
                 case POSIX_SPAWN_DUP2:
                     if(PySequence_Size(file_actions_obj) != 3){
                         PyErr_SetString(PyExc_TypeError,"A dup2 file_action object must have 3 elements");
-                        goto fail;
+                        goto exit;
                     }
 
                     long fd1 = PyLong_AsLong(PySequence_GetItem(file_actions_obj, 1));
                     if(PyErr_Occurred()) {
-                        goto fail;
+                        goto exit;
                     }
                     long fd2 = PyLong_AsLong(PySequence_GetItem(file_actions_obj, 2));
                     if(PyErr_Occurred()) {
-                        goto fail;
+                        goto exit;
+                    }
+                    if(posix_spawn_file_actions_adddup2(file_actionsp, fd1, fd2)) {
+                        PyErr_SetString(PyExc_OSError,"Failed to add dup2 file action");
+                        goto exit;
                     }
-                    posix_spawn_file_actions_adddup2(file_actionsp, fd1, fd2);
                     break;
 
                 default:
                     PyErr_SetString(PyExc_TypeError,"Unknown file_actions identifier");
-                    goto fail;
+                    goto exit;
             }
         }
-        Py_DECREF(seq);
-}
+    }
 
     _Py_BEGIN_SUPPRESS_IPH
-        posix_spawn(&pid, path->narrow, file_actionsp, NULL, argvlist, envlist);
-        return PyLong_FromPid(pid);
+    int err_code = posix_spawn(&pid, path->narrow, file_actionsp, NULL, argvlist, envlist);
     _Py_END_SUPPRESS_IPH
+    if(err_code) {
+        PyErr_SetString(PyExc_OSError,"posix_spawn call failed");
+        goto exit;
+    }
+    result = PyLong_FromPid(pid);
 
-    path_error(path);
+exit:
 
-    free_string_array(envlist, envc);
+    Py_XDECREF(seq);
 
-fail:
+    if(file_actionsp) {
+        posix_spawn_file_actions_destroy(file_actionsp);
+    }
+    
+    if (envlist) {
+        free_string_array(envlist, envc);
+    }
 
     if (argvlist) {
         free_string_array(argvlist, argc);
     }
-    return NULL;
+
+    return result;
 
 
 }

[ML] commit dd0e087edc8f1e4d2c0913236b1a62a77d9db6d8
Author: Martin Teichmann <lkb.teichmann@gmail.com>
Date:   Sun Jan 28 05:17:46 2018 +0100

    bpo-30306: release arguments of contextmanager (GH-1500)
    
    The arguments to a generator function which is declared as a
    contextmanager are stored inside the context manager, and
    thus are kept alive, even when it is used as a regular context
    manager, and not as a function decorator (where it needs
    the original arguments to recreate the generator on each
    call).
    
    This is a possible unnecessary memory leak, so this changes
    contextmanager.__enter__ to release the saved arguments,
    as that method being called means that particular CM instance
    isn't going to need to recreate the underlying generator.
    
    Patch by Martin Teichmann.

diff --git a/Lib/contextlib.py b/Lib/contextlib.py
index ef8f8c9f55..1ff8cdf1ce 100644
--- a/Lib/contextlib.py
+++ b/Lib/contextlib.py
@@ -105,6 +105,9 @@ def _recreate_cm(self):
         return self.__class__(self.func, self.args, self.kwds)
 
     def __enter__(self):
+        # do not keep args and kwds alive unnecessarily
+        # they are only needed for recreation, which is not possible anymore
+        del self.args, self.kwds, self.func
         try:
             return next(self.gen)
         except StopIteration:
diff --git a/Lib/test/test_contextlib.py b/Lib/test/test_contextlib.py
index 96ceaa7f06..2a44404a60 100644
--- a/Lib/test/test_contextlib.py
+++ b/Lib/test/test_contextlib.py
@@ -8,6 +8,7 @@
 import unittest
 from contextlib import *  # Tests __all__
 from test import support
+import weakref
 
 
 class TestAbstractContextManager(unittest.TestCase):
@@ -219,6 +220,52 @@ def woohoo(self, func, args, kwds):
         with woohoo(self=11, func=22, args=33, kwds=44) as target:
             self.assertEqual(target, (11, 22, 33, 44))
 
+    def test_nokeepref(self):
+        class A:
+            pass
+
+        @contextmanager
+        def woohoo(a, b):
+            a = weakref.ref(a)
+            b = weakref.ref(b)
+            self.assertIsNone(a())
+            self.assertIsNone(b())
+            yield
+
+        with woohoo(A(), b=A()):
+            pass
+
+    def test_param_errors(self):
+        @contextmanager
+        def woohoo(a, *, b):
+            yield
+
+        with self.assertRaises(TypeError):
+            woohoo()
+        with self.assertRaises(TypeError):
+            woohoo(3, 5)
+        with self.assertRaises(TypeError):
+            woohoo(b=3)
+
+    def test_recursive(self):
+        depth = 0
+        @contextmanager
+        def woohoo():
+            nonlocal depth
+            before = depth
+            depth += 1
+            yield
+            depth -= 1
+            self.assertEqual(depth, before)
+
+        @woohoo()
+        def recursive():
+            if depth < 10:
+                recursive()
+
+        recursive()
+        self.assertEqual(depth, 0)
+
 
 class ClosingTestCase(unittest.TestCase):
 

