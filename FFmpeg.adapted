[NR] **new** commit e6ae8fc18e579e1ca750ed392da2df3474b88976
Date:   Sun Aug 8 16:25:33 2021 +0530

    lavfi/dnn_backend_tf: TFInferRequest Execution and Documentation
    
    This commit adds a function for execution of TFInferRequest and documentation
    for functions related to TFInferRequest.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -93,5 +93,12 @@
 static void free_buffer(void *data, size_t length)
 {
     av_freep(&data);
 }
 
+/**
+ * Free the contents of TensorFlow inference request.
+ * It does not free the TFInferRequest instance.
+ *
+ * @param request pointer to TFInferRequest instance.
+ * NULL pointer is allowed.
+ */
[func] **new** commit 2063745a93f3a17ee14ffd01905878b8fdc17023
Date:   Sun Aug 8 16:25:39 2021 +0530

    lavfi/dnn: DNNAsyncExecModule Execution Failure Handling
    
    This commit adds the case handling if the asynchronous execution
    of a request fails by checking the exit status of the thread when
    joining before starting another execution. On failure, it does the
    cleanup as well.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -94,1 +94,2 @@
+static inline void destroy_request_item(TFRequestItem **arg);
 
[func] **new** commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +39,15 @@
+ObjPool *objpool_alloc(ObjPoolCBAlloc cb_alloc, ObjPoolCBReset cb_reset,
+                       ObjPoolCBFree cb_free)
+{
+    ObjPool *op = av_mallocz(sizeof(*op));
+
+    if (!op)
+        return NULL;
+
+    op->alloc = cb_alloc;
+    op->reset = cb_reset;
+    op->free  = cb_free;
+
+    return op;
+}
+
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +93,4 @@
+static void *alloc_packet(void)
+{
+    return av_packet_alloc();
+}
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +97,5 @@
+static void *alloc_frame(void)
+{
+    return av_frame_alloc();
+}
+
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +124,4 @@
+ObjPool *objpool_alloc_packets(void)
+{
+    return objpool_alloc(alloc_packet, reset_packet, free_packet);
+}
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +128,4 @@
+ObjPool *objpool_alloc_frames(void)
+{
+    return objpool_alloc(alloc_frame, reset_frame, free_frame);
+}
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +54,13 @@
+void objpool_free(ObjPool **pop)
+{
+    ObjPool *op = *pop;
+
+    if (!op)
+        return;
+
+    for (unsigned int i = 0; i < op->pool_count; i++)
+        op->free(&op->pool[i]);
+
+    av_freep(pop);
+}
+
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +111,6 @@
+static void free_packet(void **obj)
+{
+    AVPacket *pkt = *obj;
+    av_packet_free(&pkt);
+    *obj = NULL;
+}
commit 9ac78fb347e26270ebaf5ed41e55d34065853583
Date:   Thu Jun 16 10:25:00 2022 +0200

    fftools: add an object pool
    
    Allows to avoid constantly allocating and freeing objects like AVFrame
    or AVPacket.

diff --git a/fftools/objpool.c b/fftools/objpool.c
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +117,7 @@
+static void free_frame(void **obj)
+{
+    AVFrame *frame = *obj;
+    av_frame_free(&frame);
+    *obj = NULL;
+}
+
[func] **new** commit 4740fea7ddf5f81577c9f5a0c096a8a16a54716e
Date:   Fri Jun 10 14:21:42 2022 +0200

    fftools/ffmpeg: rework -shortest implementation
    
    The -shortest option (which finishes the output file at the time the
    shortest stream ends) is currently implemented by faking the -t option
    when an output stream ends. This approach is fragile, since it depends
    on the frames/packets being processed in a specific order. E.g. there
    are currently some situations in which the output file length will
    depend unpredictably on unrelated factors like encoder delay. More
    importantly, the present work aiming at splitting various ffmpeg
    components into different threads will make this approach completely
    unworkable, since the frames/packets will arrive in effectively random
    order.
    
    This commit introduces a "sync queue", which is essentially a collection
    of FIFOs, one per stream. Frames/packets are submitted to these FIFOs
    and are then released for further processing (encoding or muxing) when
    it is ensured that the frame in question will not cause its stream to
    get ahead of the other streams (the logic is similar to libavformat's
    interleaving queue).
    
    These sync queues are then used for encoding and/or muxing when the
    -shortest option is specified.
    
    A new option – -shortest_buf_duration – controls the maximum number of
    queued packets, to avoid runaway memory usage.
    
    This commit changes the results of the following tests:
    - copy-shortest[12]: the last audio frame is now gone. This is
      correct, since it actually outlasts the last video frame.
    - shortest-sub: the video packets following the last subtitle packet are
      now gone. This is also correct.

diff --git a/fftools/sync_queue.c b/fftools/sync_queue.c
--- /dev/null
+++ b/fftools/sync_queue.c
@@ -0,0 +382,23 @@
+SyncQueue *sq_alloc(enum SyncQueueType type, int64_t buf_size_us)
+{
+    SyncQueue *sq = av_mallocz(sizeof(*sq));
+
+    if (!sq)
+        return NULL;
+
+    sq->type                 = type;
+    sq->buf_size_us          = buf_size_us;
+
+    sq->head_stream          = -1;
+    sq->head_finished_stream = -1;
+
+    sq->pool = (type == SYNC_QUEUE_PACKETS) ? objpool_alloc_packets() :
+                                              objpool_alloc_frames();
+    if (!sq->pool) {
+        av_freep(&sq);
+        return NULL;
+    }
+
+    return sq;
+}
+
commit 4740fea7ddf5f81577c9f5a0c096a8a16a54716e
Date:   Fri Jun 10 14:21:42 2022 +0200

    fftools/ffmpeg: rework -shortest implementation
    
    The -shortest option (which finishes the output file at the time the
    shortest stream ends) is currently implemented by faking the -t option
    when an output stream ends. This approach is fragile, since it depends
    on the frames/packets being processed in a specific order. E.g. there
    are currently some situations in which the output file length will
    depend unpredictably on unrelated factors like encoder delay. More
    importantly, the present work aiming at splitting various ffmpeg
    components into different threads will make this approach completely
    unworkable, since the frames/packets will arrive in effectively random
    order.
    
    This commit introduces a "sync queue", which is essentially a collection
    of FIFOs, one per stream. Frames/packets are submitted to these FIFOs
    and are then released for further processing (encoding or muxing) when
    it is ensured that the frame in question will not cause its stream to
    get ahead of the other streams (the logic is similar to libavformat's
    interleaving queue).
    
    These sync queues are then used for encoding and/or muxing when the
    -shortest option is specified.
    
    A new option – -shortest_buf_duration – controls the maximum number of
    queued packets, to avoid runaway memory usage.
    
    This commit changes the results of the following tests:
    - copy-shortest[12]: the last audio frame is now gone. This is
      correct, since it actually outlasts the last video frame.
    - shortest-sub: the video packets following the last subtitle packet are
      now gone. This is also correct.

diff --git a/fftools/sync_queue.c b/fftools/sync_queue.c
--- /dev/null
+++ b/fftools/sync_queue.c
@@ -0,0 +405,21 @@
+void sq_free(SyncQueue **psq)
+{
+    SyncQueue *sq = *psq;
+
+    if (!sq)
+        return;
+
+    for (unsigned int i = 0; i < sq->nb_streams; i++) {
+        SyncQueueFrame frame;
+        while (av_fifo_read(sq->streams[i].fifo, &frame, 1) >= 0)
+            objpool_release(sq->pool, (void**)&frame);
+
+        av_fifo_freep2(&sq->streams[i].fifo);
+    }
+
+    av_freep(&sq->streams);
+
+    objpool_free(&sq->pool);
+
+    av_freep(psq);
+}
[perf] **new** commit b4e7fc4b4b4aa71ae6806b57ebe1293239497f71
Date:   Sat May 8 18:36:28 2021 -0300

    avcodec/avpacket: use av_malloc() to allocate an AVPacket
    
    av_mallocz() is superfluous as get_packet_defaults() is called immediately
    after it's allocated, which will initialize the entire struct to default
    values.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -59,11 +59,11 @@
 AVPacket *av_packet_alloc(void)
 {
-    AVPacket *pkt = av_mallocz(sizeof(AVPacket));
+    AVPacket *pkt = av_malloc(sizeof(AVPacket));
     if (!pkt)
         return pkt;
 
     get_packet_defaults(pkt);
 
     return pkt;
 }
 

[func] **new** commit f7db77bd8785d1715d3e7ed7e69bd1cc991f2d07
Date:   Wed Jan 27 16:24:10 2021 -0300

    avcodec/packet: deprecate av_init_packet()
    
    Once removed, sizeof(AVPacket) will stop being a part of the public ABI.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -53,11 +64,11 @@
 AVPacket *av_packet_alloc(void)
 {
     AVPacket *pkt = av_mallocz(sizeof(AVPacket));
     if (!pkt)
         return pkt;
 
-    av_init_packet(pkt);
+    get_packet_defaults(pkt);
 
     return pkt;
 }
 
commit b4e7fc4b4b4aa71ae6806b57ebe1293239497f71
Date:   Sat May 8 18:36:28 2021 -0300

    avcodec/avpacket: use av_malloc() to allocate an AVPacket
    
    av_mallocz() is superfluous as get_packet_defaults() is called immediately
    after it's allocated, which will initialize the entire struct to default
    values.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -59,11 +59,11 @@
 AVPacket *av_packet_alloc(void)
 {
-    AVPacket *pkt = av_mallocz(sizeof(AVPacket));
+    AVPacket *pkt = av_malloc(sizeof(AVPacket));
     if (!pkt)
         return pkt;
 
     get_packet_defaults(pkt);
 
     return pkt;
 }
 

commit f7db77bd8785d1715d3e7ed7e69bd1cc991f2d07
Date:   Wed Jan 27 16:24:10 2021 -0300

    avcodec/packet: deprecate av_init_packet()
    
    Once removed, sizeof(AVPacket) will stop being a part of the public ABI.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -53,11 +64,11 @@
 AVPacket *av_packet_alloc(void)
 {
     AVPacket *pkt = av_mallocz(sizeof(AVPacket));
     if (!pkt)
         return pkt;
 
-    av_init_packet(pkt);
+    get_packet_defaults(pkt);
 
     return pkt;
 }
 
commit f7db77bd8785d1715d3e7ed7e69bd1cc991f2d07
Date:   Wed Jan 27 16:24:10 2021 -0300

    avcodec/packet: deprecate av_init_packet()
    
    Once removed, sizeof(AVPacket) will stop being a part of the public ABI.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -88,15 +99,15 @@
 int av_new_packet(AVPacket *pkt, int size)
 {
     AVBufferRef *buf = NULL;
     int ret = packet_alloc(&buf, size);
     if (ret < 0)
         return ret;
 
-    av_init_packet(pkt);
+    get_packet_defaults(pkt);
     pkt->buf      = buf;
     pkt->data     = buf->data;
     pkt->size     = size;
 
     return 0;
 }
 
[incr] **new** commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -220,25 +220,21 @@
 uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                                 buffer_size_t size)
+                                 size_t size)
 {
     int ret;
     uint8_t *data;
 
-#if FF_API_BUFFER_SIZE_T
-    if ((unsigned)size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE)
-#else
     if (size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE)
-#endif
         return NULL;
     data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
     if (!data)
         return NULL;
 
     ret = av_packet_add_side_data(pkt, type, data, size);
     if (ret < 0) {
         av_freep(&data);
         return NULL;
     }
 
     return data;
 }
 

[incr] **new** commit d79e0fe65c51491f9bf8a470bbe36fb09f3e1280
Date:   Sat Mar 6 12:43:52 2021 -0300

    avcodec/packet: change side data related public function and struct size types to size_t
    
    av_packet_add_side_data() already defines size as a size_t, so this makes it
    consistent across all side data functions
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -332,21 +332,25 @@
 uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
-                                 int size)
+                                 buffer_size_t size)
 {
     int ret;
     uint8_t *data;
 
+#if FF_API_BUFFER_SIZE_T
     if ((unsigned)size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE)
+#else
+    if (size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE)
+#endif
         return NULL;
     data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
     if (!data)
         return NULL;
 
     ret = av_packet_add_side_data(pkt, type, data, size);
     if (ret < 0) {
         av_freep(&data);
         return NULL;
     }
 
     return data;
 }
 
[func] **new** commit d61240f8c95e9cf7a0aaef2bb4495960d3fec62c
Date:   Thu Dec 16 01:49:39 2021 +0100

    avcodec/packet_internal: Add proper PacketList struct
    
    Up until now, we had a PacketList structure which is actually
    a PacketListEntry; a proper PacketList did not exist
    and all the related functions just passed pointers to pointers
    to the head and tail elements around. All these pointers were
    actually consecutive elements of their containing structs,
    i.e. the users already treated them as if they were a struct.
    
    So add a proper PacketList struct and rename the current PacketList
    to PacketListEntry; also make the functions use this structure
    instead of the pair of pointers.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -538,40 +538,39 @@
-int avpriv_packet_list_put(PacketList **packet_buffer,
-                           PacketList **plast_pktl,
+int avpriv_packet_list_put(PacketList *packet_buffer,
                            AVPacket      *pkt,
                            int (*copy)(AVPacket *dst, const AVPacket *src),
                            int flags)
 {
-    PacketList *pktl = av_malloc(sizeof(PacketList));
+    PacketListEntry *pktl = av_malloc(sizeof(*pktl));
     int ret;
 
     if (!pktl)
         return AVERROR(ENOMEM);
 
     if (copy) {
         get_packet_defaults(&pktl->pkt);
         ret = copy(&pktl->pkt, pkt);
         if (ret < 0) {
             av_free(pktl);
             return ret;
         }
     } else {
         ret = av_packet_make_refcounted(pkt);
         if (ret < 0) {
             av_free(pktl);
             return ret;
         }
         av_packet_move_ref(&pktl->pkt, pkt);
     }
 
     pktl->next = NULL;
 
-    if (*packet_buffer)
-        (*plast_pktl)->next = pktl;
+    if (packet_buffer->head)
+        packet_buffer->tail->next = pktl;
     else
-        *packet_buffer = pktl;
+        packet_buffer->head = pktl;
 
     /* Add the packet in the buffered packet list. */
-    *plast_pktl = pktl;
+    packet_buffer->tail = pktl;
     return 0;
 }
 

[func] **new** commit 0a029906b205613c7744bcef4cdda184199dd1a9
Date:   Thu May 6 23:55:32 2021 -0300

    avcodec/avpacket: always initialize the new packet in avpriv_packet_list_put()
    
    If a copy callback is provided by the caller, the packet passed to it
    was zeroed instead of initialized with default values.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -516,37 +516,40 @@
 int avpriv_packet_list_put(PacketList **packet_buffer,
                            PacketList **plast_pktl,
                            AVPacket      *pkt,
                            int (*copy)(AVPacket *dst, const AVPacket *src),
                            int flags)
 {
-    PacketList *pktl = av_mallocz(sizeof(PacketList));
+    PacketList *pktl = av_malloc(sizeof(PacketList));
     int ret;
 
     if (!pktl)
         return AVERROR(ENOMEM);
 
     if (copy) {
+        get_packet_defaults(&pktl->pkt);
         ret = copy(&pktl->pkt, pkt);
         if (ret < 0) {
             av_free(pktl);
             return ret;
         }
     } else {
         ret = av_packet_make_refcounted(pkt);
         if (ret < 0) {
             av_free(pktl);
             return ret;
         }
         av_packet_move_ref(&pktl->pkt, pkt);
     }
 
+    pktl->next = NULL;
+
     if (*packet_buffer)
         (*plast_pktl)->next = pktl;
     else
         *packet_buffer = pktl;
 
     /* Add the packet in the buffered packet list. */
     *plast_pktl = pktl;
     return 0;
 }
 

[func] **new** commit d422b2ed87ee7d3b3014cd3fac553e6aad7d4f14
Date:   Fri Mar 5 11:26:24 2021 -0300

    avcodec/packet_internal: make avpriv_packet_list_* functions use an internal struct
    
    The next pointer is kept at the end for backwards compatability until the
    major bump, when it should ideally be moved at the front.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -740,37 +740,37 @@
-int avpriv_packet_list_put(AVPacketList **packet_buffer,
-                           AVPacketList **plast_pktl,
+int avpriv_packet_list_put(PacketList **packet_buffer,
+                           PacketList **plast_pktl,
                            AVPacket      *pkt,
                            int (*copy)(AVPacket *dst, const AVPacket *src),
                            int flags)
 {
-    AVPacketList *pktl = av_mallocz(sizeof(AVPacketList));
+    PacketList *pktl = av_mallocz(sizeof(PacketList));
     int ret;
 
     if (!pktl)
         return AVERROR(ENOMEM);
 
     if (copy) {
         ret = copy(&pktl->pkt, pkt);
         if (ret < 0) {
             av_free(pktl);
             return ret;
         }
     } else {
         ret = av_packet_make_refcounted(pkt);
         if (ret < 0) {
             av_free(pktl);
             return ret;
         }
         av_packet_move_ref(&pktl->pkt, pkt);
     }
 
     if (*packet_buffer)
         (*plast_pktl)->next = pktl;
     else
         *packet_buffer = pktl;
 
     /* Add the packet in the buffered packet list. */
     *plast_pktl = pktl;
     return 0;
 }
 
commit d61240f8c95e9cf7a0aaef2bb4495960d3fec62c
Date:   Thu Dec 16 01:49:39 2021 +0100

    avcodec/packet_internal: Add proper PacketList struct
    
    Up until now, we had a PacketList structure which is actually
    a PacketListEntry; a proper PacketList did not exist
    and all the related functions just passed pointers to pointers
    to the head and tail elements around. All these pointers were
    actually consecutive elements of their containing structs,
    i.e. the users already treated them as if they were a struct.
    
    So add a proper PacketList struct and rename the current PacketList
    to PacketListEntry; also make the functions use this structure
    instead of the pair of pointers.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -594,14 +591,13 @@
-void avpriv_packet_list_free(PacketList **pkt_buf, PacketList **pkt_buf_end)
+void avpriv_packet_list_free(PacketList *pkt_buf)
 {
-    PacketList *tmp = *pkt_buf;
+    PacketListEntry *tmp = pkt_buf->head;
 
     while (tmp) {
-        PacketList *pktl = tmp;
+        PacketListEntry *pktl = tmp;
         tmp = pktl->next;
         av_packet_unref(&pktl->pkt);
         av_freep(&pktl);
     }
-    *pkt_buf     = NULL;
-    *pkt_buf_end = NULL;
+    pkt_buf->head = pkt_buf->tail = NULL;
 }
 

commit d422b2ed87ee7d3b3014cd3fac553e6aad7d4f14
Date:   Fri Mar 5 11:26:24 2021 -0300

    avcodec/packet_internal: make avpriv_packet_list_* functions use an internal struct
    
    The next pointer is kept at the end for backwards compatability until the
    major bump, when it should ideally be moved at the front.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -793,14 +793,14 @@
-void avpriv_packet_list_free(AVPacketList **pkt_buf, AVPacketList **pkt_buf_end)
+void avpriv_packet_list_free(PacketList **pkt_buf, PacketList **pkt_buf_end)
 {
-    AVPacketList *tmp = *pkt_buf;
+    PacketList *tmp = *pkt_buf;
 
     while (tmp) {
-        AVPacketList *pktl = tmp;
+        PacketList *pktl = tmp;
         tmp = pktl->next;
         av_packet_unref(&pktl->pkt);
         av_freep(&pktl);
     }
     *pkt_buf     = NULL;
     *pkt_buf_end = NULL;
 }
 
[func] **new** commit f4098bbc3b10926f618cf89e24780c9e6ae9b8b5
Date:   Mon Mar 21 22:25:27 2022 +0100

    avcodec/bsf: Add FFBitStreamFilter, hide internals of BSFs
    
    This patch is analogous to 20f972701806be20a77f808db332d9489343bb78:
    It hides the internal part of AVBitStreamFilter by adding a new
    internal structure FFBitStreamFilter (declared in bsf_internal.h)
    that has an AVBitStreamFilter as its first member; the internal
    part of AVBitStreamFilter is moved to this new structure.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -101,40 +105,40 @@
 int av_bsf_alloc(const AVBitStreamFilter *filter, AVBSFContext **pctx)
 {
     AVBSFContext *ctx;
     FFBSFContext *bsfi;
     int ret;
 
     bsfi = av_mallocz(sizeof(*bsfi));
     if (!bsfi)
         return AVERROR(ENOMEM);
     ctx  = &bsfi->pub;
 
     ctx->av_class = &bsf_class;
     ctx->filter   = filter;
 
     ctx->par_in  = avcodec_parameters_alloc();
     ctx->par_out = avcodec_parameters_alloc();
     if (!ctx->par_in || !ctx->par_out) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
     /* allocate priv data and init private options */
-    if (filter->priv_data_size) {
-        ctx->priv_data = av_mallocz(filter->priv_data_size);
+    if (ff_bsf(filter)->priv_data_size) {
+        ctx->priv_data = av_mallocz(ff_bsf(filter)->priv_data_size);
         if (!ctx->priv_data) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         if (filter->priv_class) {
             *(const AVClass **)ctx->priv_data = filter->priv_class;
             av_opt_set_defaults(ctx->priv_data);
         }
     }
     bsfi->buffer_pkt = av_packet_alloc();
     if (!bsfi->buffer_pkt) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
 
     *pctx = ctx;
     return 0;

[func] **new** commit afeefb306e89b3ea3eb8ac8227996dc79589b669
Date:   Thu Aug 5 05:13:32 2021 +0200

    avcodec/bsf: Avoid allocation for AVBSFInternal
    
    Do this by allocating AVBSFContext together with the data that is
    currently in AVBSFInternal; or rather: Put AVBSFContext at the beginning
    of a new structure called FFBSFContext (which encompasses more than just
    the internal fields and is a proper context in its own right, hence the
    name) and remove the AVBSFInternal altogether.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -92,48 +98,40 @@
 int av_bsf_alloc(const AVBitStreamFilter *filter, AVBSFContext **pctx)
 {
     AVBSFContext *ctx;
-    AVBSFInternal *bsfi;
+    FFBSFContext *bsfi;
     int ret;
 
-    ctx = av_mallocz(sizeof(*ctx));
-    if (!ctx)
+    bsfi = av_mallocz(sizeof(*bsfi));
+    if (!bsfi)
         return AVERROR(ENOMEM);
+    ctx  = &bsfi->pub;
 
     ctx->av_class = &bsf_class;
     ctx->filter   = filter;
 
     ctx->par_in  = avcodec_parameters_alloc();
     ctx->par_out = avcodec_parameters_alloc();
     if (!ctx->par_in || !ctx->par_out) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
     /* allocate priv data and init private options */
     if (filter->priv_data_size) {
         ctx->priv_data = av_mallocz(filter->priv_data_size);
         if (!ctx->priv_data) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         if (filter->priv_class) {
             *(const AVClass **)ctx->priv_data = filter->priv_class;
             av_opt_set_defaults(ctx->priv_data);
         }
     }
-    /* Allocate AVBSFInternal; must happen after priv_data has been allocated
-     * so that a filter->close needing priv_data is never called without. */
-    bsfi = av_mallocz(sizeof(*bsfi));
-    if (!bsfi) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-    ctx->internal = bsfi;
-
     bsfi->buffer_pkt = av_packet_alloc();
     if (!bsfi->buffer_pkt) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
 
     *pctx = ctx;
     return 0;

[safe] **new** commit 9bf2b32da048732ad79e075dfefd40777e9f935a
Date:   Fri Apr 2 14:17:56 2021 +0200

    avcodec/bsf: Fix segfault when freeing half-allocated BSF
    
    When allocating a BSF fails, it could happen that the BSF's close
    function has been called despite a failure to allocate the private data.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -94,48 +95,48 @@
 int av_bsf_alloc(const AVBitStreamFilter *filter, AVBSFContext **pctx)
 {
     AVBSFContext *ctx;
     AVBSFInternal *bsfi;
     int ret;
 
     ctx = av_mallocz(sizeof(*ctx));
     if (!ctx)
         return AVERROR(ENOMEM);
 
     ctx->av_class = &bsf_class;
     ctx->filter   = filter;
 
     ctx->par_in  = avcodec_parameters_alloc();
     ctx->par_out = avcodec_parameters_alloc();
     if (!ctx->par_in || !ctx->par_out) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
-
-    bsfi = av_mallocz(sizeof(*bsfi));
-    if (!bsfi) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-    ctx->internal = bsfi;
-
-    bsfi->buffer_pkt = av_packet_alloc();
-    if (!bsfi->buffer_pkt) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
     /* allocate priv data and init private options */
     if (filter->priv_data_size) {
         ctx->priv_data = av_mallocz(filter->priv_data_size);
         if (!ctx->priv_data) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }
         if (filter->priv_class) {
             *(const AVClass **)ctx->priv_data = filter->priv_class;
             av_opt_set_defaults(ctx->priv_data);
         }
     }
+    /* Allocate AVBSFInternal; must happen after priv_data has been allocated
+     * so that a filter->close needing priv_data is never called without. */
+    bsfi = av_mallocz(sizeof(*bsfi));
+    if (!bsfi) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    ctx->internal = bsfi;
+
+    bsfi->buffer_pkt = av_packet_alloc();
+    if (!bsfi->buffer_pkt) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
 
     *pctx = ctx;
     return 0;
commit f4098bbc3b10926f618cf89e24780c9e6ae9b8b5
Date:   Mon Mar 21 22:25:27 2022 +0100

    avcodec/bsf: Add FFBitStreamFilter, hide internals of BSFs
    
    This patch is analogous to 20f972701806be20a77f808db332d9489343bb78:
    It hides the internal part of AVBitStreamFilter by adding a new
    internal structure FFBitStreamFilter (declared in bsf_internal.h)
    that has an AVBitStreamFilter as its first member; the internal
    part of AVBitStreamFilter is moved to this new structure.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -550,9 +554,9 @@
 int av_bsf_get_null_filter(AVBSFContext **bsf)
 {
 #if CONFIG_NULL_BSF
-    extern const AVBitStreamFilter ff_null_bsf;
-    return av_bsf_alloc(&ff_null_bsf, bsf);
+    extern const FFBitStreamFilter ff_null_bsf;
+    return av_bsf_alloc(&ff_null_bsf.p, bsf);
 #else
-    return av_bsf_alloc(&list_bsf, bsf);
+    return av_bsf_alloc(&list_bsf.p, bsf);
 #endif
 }

[func] **new** commit b99fb4df42871e16077c3248ab9cfd8cfd034a85
Date:   Mon Sep 6 19:39:19 2021 +0200

    avcodec/bsf: Use null-bsf for passthrough when available
    
    When an empty list bsf is used for passthrough, there is a check
    for every packet in bsf_list_filter() before ff_bsf_get_packet_ref()
    is called. Directly using the null bsf avoids that.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -545,4 +547,9 @@
 int av_bsf_get_null_filter(AVBSFContext **bsf)
 {
+#if CONFIG_NULL_BSF
+    extern const AVBitStreamFilter ff_null_bsf;
+    return av_bsf_alloc(&ff_null_bsf, bsf);
+#else
     return av_bsf_alloc(&list_bsf, bsf);
+#endif
 }

[incr] **new** commit 97bc4695fb7a51574d863812af58ab63746558fd
Date:   Mon Sep 6 12:15:42 2021 +0200

    avcodec/bsf: ff_list_bsf static
    
    It is a special BSF that is only available via the av_bsf_list-API;
    it is not part of the list generated from the declarations in
    bitstream_filters.c and therefore needn't have external linkage.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -545,4 +545,4 @@
 int av_bsf_get_null_filter(AVBSFContext **bsf)
 {
-    return av_bsf_alloc(&ff_list_bsf, bsf);
+    return av_bsf_alloc(&list_bsf, bsf);
 }
[func] **new** commit 301d275301d72387732ccdc526babaf984ddafe5
Date:   Sat Jul 3 17:02:59 2021 +0530

    avcodec/bsf: switch to av_get_token to parse bsf list string
    
    The recently added setts bsf makes use of the eval API whose
    expressions can contain commas. The existing parsing in
    av_bsf_list_parse_str() uses av_strtok to naively split
    the string at commas, thus preventing the use of setts filter
    with expressions containing commas.
    
    av_get_token can work with escaped commas, allowing full use of setts.

diff --git a/libavcodec/bsf.c b/libavcodec/bsf.c
--- a/libavcodec/bsf.c
+++ b/libavcodec/bsf.c
@@ -520,27 +520,21 @@
 int av_bsf_list_parse_str(const char *str, AVBSFContext **bsf_lst)
 {
     AVBSFList *lst;
-    char *bsf_str, *buf, *dup, *saveptr;
     int ret;
 
     if (!str)
         return av_bsf_get_null_filter(bsf_lst);
 
     lst = av_bsf_list_alloc();
     if (!lst)
         return AVERROR(ENOMEM);
 
-    if (!(dup = buf = av_strdup(str))) {
-        ret = AVERROR(ENOMEM);
-        goto end;
-    }
-
-    while (bsf_str = av_strtok(buf, ",", &saveptr)) {
+    do {
+        char *bsf_str = av_get_token(&str, ",");
         ret = bsf_parse_single(bsf_str, lst);
+        av_free(bsf_str);
         if (ret < 0)
             goto end;
-
-        buf = NULL;
-    }
+    } while (*str && *++str);
 
     ret = av_bsf_list_finalize(&lst, bsf_lst);
[func] **new** commit 4057a060f62b2f1dade799fb9fdf0eec5708e0a7
Date:   Wed Mar 17 01:25:22 2021 -0300

    avcodec: move AVCodecParameters related functions from util.c to a new file
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/codec_par.c b/libavcodec/codec_par.c
--- /dev/null
+++ b/libavcodec/codec_par.c
@@ -0,0 +51,10 @@
+AVCodecParameters *avcodec_parameters_alloc(void)
+{
+    AVCodecParameters *par = av_mallocz(sizeof(*par));
+
+    if (!par)
+        return NULL;
+    codec_parameters_reset(par);
+    return par;
+}
+
commit 4057a060f62b2f1dade799fb9fdf0eec5708e0a7
Date:   Wed Mar 17 01:25:22 2021 -0300

    avcodec: move AVCodecParameters related functions from util.c to a new file
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/codec_par.c b/libavcodec/codec_par.c
--- /dev/null
+++ b/libavcodec/codec_par.c
@@ -0,0 +61,11 @@
+void avcodec_parameters_free(AVCodecParameters **ppar)
+{
+    AVCodecParameters *par = *ppar;
+
+    if (!par)
+        return;
+    codec_parameters_reset(par);
+
+    av_freep(ppar);
+}
+
[func] **new** commit b92e14147f8efb32f3dbbb112dbaa5a5ab9bcd03
Date:   Mon Aug 15 14:46:09 2022 -0300

    avcodec: add a bsf to reorder DTS into PTS
    
    Starting with an h264 implementation. Can be extended to support other codecs.
    
    A few caveats:
    - OpenGOP streams are currently not supported. The firt packet must be an IDR
      frame.
    - In some streams, a few frames at the end may not get a reordered PTS when
      they reference frames past EOS. The code added to derive timestamps from
      previous frames needs to extended.
    
    Addresses ticket #502.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/dts2pts_bsf.c b/libavcodec/dts2pts_bsf.c
--- /dev/null
+++ b/libavcodec/dts2pts_bsf.c
@@ -0,0 +107,8 @@
+static int free_node(void *opaque, void *elem)
+{
+    DTS2PTSNode *node = elem;
+    av_free(node);
+    return 0;
+}
+
+// Shared functions
[func] **new** commit 56e9e0273a79fb4ff4276503e69981f8e383f22b
Date:   Tue May 11 15:17:13 2021 +0200

    avcodec/encode: Always use intermediate buffer in ff_alloc_packet2()
    
    Up until now, ff_alloc_packet2() has a min_size parameter:
    It is supposed to be a lower bound on the final size of the packet
    to allocate. If it is not too far from the upper bound (namely,
    if it is at least half the upper bound), then ff_alloc_packet2()
    already allocates the final, already refcounted packet; if it is
    not, then the packet is not refcounted and its data only points to
    a buffer owned by the AVCodecContext (in this case, the packet will
    be made refcounted in encode_simple_internal() in libavcodec/encode.c).
    The goal of this was to avoid data copies and intermediate buffers
    if one has a precise lower bound.
    
    Yet those encoders for which precise lower bounds exist have recently
    been switched to ff_get_encode_buffer() (which automatically allocates
    final buffers), leaving only two encoders to actually set the min_size
    to something else than zero (namely aliaspixenc and hapenc). Both of
    these encoders use a very low lower bound that is not helpful in any
    nontrivial case.
    
    This commit therefore removes the min_size parameter as well as the
    codepath in ff_alloc_packet2() for the allocation of final buffers.
    Furthermore, the function has been renamed to ff_alloc_packet() and
    moved to encode.h alongside ff_get_encode_buffer().
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/encode.c b/libavcodec/encode.c
--- a/libavcodec/encode.c
+++ b/libavcodec/encode.c
@@ -33,26 +33,22 @@
-int ff_alloc_packet2(AVCodecContext *avctx, AVPacket *avpkt, int64_t size, int64_t min_size)
+int ff_alloc_packet(AVCodecContext *avctx, AVPacket *avpkt, int64_t size)
 {
     if (size < 0 || size > INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
         av_log(avctx, AV_LOG_ERROR, "Invalid minimum required packet size %"PRId64" (max allowed is %d)\n",
                size, INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE);
         return AVERROR(EINVAL);
     }
 
     av_assert0(!avpkt->data);
 
-    if (avctx && 2*min_size < size) { // FIXME The factor needs to be finetuned
-        av_fast_padded_malloc(&avctx->internal->byte_buffer, &avctx->internal->byte_buffer_size, size);
-        avpkt->data = avctx->internal->byte_buffer;
-        avpkt->size = size;
-    }
-
+    av_fast_padded_malloc(&avctx->internal->byte_buffer,
+                          &avctx->internal->byte_buffer_size, size);
+    avpkt->data = avctx->internal->byte_buffer;
     if (!avpkt->data) {
-        int ret = av_new_packet(avpkt, size);
-        if (ret < 0)
-            av_log(avctx, AV_LOG_ERROR, "Failed to allocate packet of size %"PRId64"\n", size);
-        return ret;
+        av_log(avctx, AV_LOG_ERROR, "Failed to allocate packet of size %"PRId64"\n", size);
+        return AVERROR(ENOMEM);
     }
+    avpkt->size = size;
 
     return 0;
 }
 
[NR] **new** commit 211619ad7f43b99a0c1100398f157544b5724460
Date:   Sat Jul 31 22:20:47 2021 +0200

    avcodec: Remove the FFT_FIXED_32 define
    
    Since the removal of the 16-bit FFT said define is unnecessary as
    FFT_FIXED_32 is always !FFT_FLOAT. But one wouldn't believe it when
    looking at the code.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/fft_template.c b/libavcodec/fft_template.c
--- a/libavcodec/fft_template.c
+++ b/libavcodec/fft_template.c
@@ -308,9 +306,9 @@
 av_cold void ff_fft_end(FFTContext *s)
 {
     av_freep(&s->revtab);
     av_freep(&s->revtab32);
     av_freep(&s->tmp_buf);
 }
 
-#if FFT_FIXED_32
+#if !FFT_FLOAT
 
[func] **new** commit 55ccbfd790410560a112a067cd205adf7a7fecd0
Date:   Wed Dec 29 17:02:46 2021 +0100

    lavc/flac_parser: use a custom FIFO implementation
    
    FLAC parser currently uses AVFifoBuffer in a highly non-trivial manner,
    modifying its "internals" (the whole struct is currently public, but no
    other code touches its contents directly). E.g. it does not use any
    av_fifo functions for reading the FIFO contents, but implements its own.
    
    Reimplement the needed parts of the AVFifoBuffer API in the FLAC parser,
    making it completely self-contained. This will allow us to make
    AVFifoBuffer private.

diff --git a/libavcodec/flac_parser.c b/libavcodec/flac_parser.c
--- a/libavcodec/flac_parser.c
+++ b/libavcodec/flac_parser.c
@@ -194,0 +291,17 @@
+static int flac_fifo_alloc(FifoBuffer *f, size_t size)
+{
+    memset(f, 0, sizeof(*f));
+
+    f->buffer = av_realloc(NULL, size);
+    if (!f->buffer)
+        return AVERROR(ENOMEM);
+
+    f->wptr = f->buffer;
+    f->rptr = f->buffer;
+    f->end  = f->buffer + size;
+
+    f->empty = 1;
+
+    return 0;
+}
+
commit 55ccbfd790410560a112a067cd205adf7a7fecd0
Date:   Wed Dec 29 17:02:46 2021 +0100

    lavc/flac_parser: use a custom FIFO implementation
    
    FLAC parser currently uses AVFifoBuffer in a highly non-trivial manner,
    modifying its "internals" (the whole struct is currently public, but no
    other code touches its contents directly). E.g. it does not use any
    av_fifo functions for reading the FIFO contents, but implements its own.
    
    Reimplement the needed parts of the AVFifoBuffer API in the FLAC parser,
    making it completely self-contained. This will allow us to make
    AVFifoBuffer private.

diff --git a/libavcodec/flac_parser.c b/libavcodec/flac_parser.c
--- a/libavcodec/flac_parser.c
+++ b/libavcodec/flac_parser.c
@@ -194,0 +308,6 @@
+static void flac_fifo_free(FifoBuffer *f)
+{
+    av_freep(&f->buffer);
+    memset(f, 0, sizeof(*f));
+}
+
[func] **new** commit ce3c20f2aa349557cb0e6cacf1ad76bc4499b518
Date:   Wed Mar 23 15:44:01 2022 +0100

    lavc: move default get_buffer2() to its own file
    
    It is also used by some encoders, so decode.c is not the right place for
    it.

diff --git a/libavcodec/get_buffer.c b/libavcodec/get_buffer.c
--- /dev/null
+++ b/libavcodec/get_buffer.c
@@ -0,0 +66,18 @@
+static AVBufferRef *frame_pool_alloc(void)
+{
+    FramePool *pool = av_mallocz(sizeof(*pool));
+    AVBufferRef *buf;
+
+    if (!pool)
+        return NULL;
+
+    buf = av_buffer_create((uint8_t*)pool, sizeof(*pool),
+                           frame_pool_free, NULL, 0);
+    if (!buf) {
+        av_freep(&pool);
+        return NULL;
+    }
+
+    return buf;
+}
+
commit ce3c20f2aa349557cb0e6cacf1ad76bc4499b518
Date:   Wed Mar 23 15:44:01 2022 +0100

    lavc: move default get_buffer2() to its own file
    
    It is also used by some encoders, so decode.c is not the right place for
    it.

diff --git a/libavcodec/get_buffer.c b/libavcodec/get_buffer.c
--- /dev/null
+++ b/libavcodec/get_buffer.c
@@ -0,0 +55,11 @@
+static void frame_pool_free(void *opaque, uint8_t *data)
+{
+    FramePool *pool = (FramePool*)data;
+    int i;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
+        av_buffer_pool_uninit(&pool->pools[i]);
+
+    av_freep(&data);
+}
+
[func] **new** commit 634a187b9bd7d3f01deab6e79e63371933ab702e
Date:   Thu Apr 29 17:27:00 2021 +0200

    avcodec/jpeglsenc: Allocate buffer with fixed size only once
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/jpeglsenc.c b/libavcodec/jpeglsenc.c
--- a/libavcodec/jpeglsenc.c
+++ b/libavcodec/jpeglsenc.c
@@ -422,5 +440,10 @@
+static av_cold int encode_jpegls_close(AVCodecContext *avctx)
+{
+    JPEGLSContext *ctx = avctx->priv_data;
+
+    av_freep(&ctx->buf);
     return 0;
 }
 
 #define OFFSET(x) offsetof(JPEGLSContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM

[func] **new** commit 79402e2c36301fb0ecb1ff797a8de7f79b178c70
Date:   Thu Apr 29 13:38:16 2021 +0200

    avcodec/jpeglsenc: Check for invalid dimensions
    
    The dimensions are written on two bytes.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/jpeglsenc.c b/libavcodec/jpeglsenc.c
--- a/libavcodec/jpeglsenc.c
+++ b/libavcodec/jpeglsenc.c
@@ -416,2 +422,5 @@
+    return 0;
+}
+
 #define OFFSET(x) offsetof(JPEGLSContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
[func] **new** commit b27f3f9b501cdf1ba6a558c07d271bba4c0c210e
Date:   Thu Dec 8 10:05:00 2022 -0300

    avcodec/libdav1d: set frame props from the reordered packet
    
    Attach the AVPacket instead of only a few values to the corresponding Dav1dData
    struct and use it to set all output frame props.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/libdav1d.c b/libavcodec/libdav1d.c
--- a/libavcodec/libdav1d.c
+++ b/libavcodec/libdav1d.c
@@ -288,5 +288,7 @@
 static void libdav1d_user_data_free(const uint8_t *data, void *opaque) {
+    AVPacket *pkt = opaque;
     av_assert0(data == opaque);
-    av_free(opaque);
+    av_free(pkt->opaque);
+    av_packet_free(&pkt);
 }
 
[func] **new** commit 458cc7e314e1a00017dd090db388db6659d1bb5f
Date:   Sun Apr 17 09:22:34 2022 -0400

    avcodec/libjxl: add Jpeg XL decoding via libjxl
    
    This commit adds decoding support to libavcodec
    for Jpeg XL images via the external library libjxl.

diff --git a/libavcodec/libjxl.c b/libavcodec/libjxl.c
--- /dev/null
+++ b/libavcodec/libjxl.c
@@ -0,0 +49,11 @@
+static void *libjxl_av_malloc(void *opaque, size_t size)
+{
+    return av_malloc(size);
+}
+
+/**
+ * Wrapper around av_free used as a jpegxl_free_func.
+ *
+ * @param opaque  opaque pointer for jpegxl_free_func, always ignored
+ * @param address Pointer to the allocated block, to free. `NULL` permitted as a no-op.
+ */
commit 458cc7e314e1a00017dd090db388db6659d1bb5f
Date:   Sun Apr 17 09:22:34 2022 -0400

    avcodec/libjxl: add Jpeg XL decoding via libjxl
    
    This commit adds decoding support to libavcodec
    for Jpeg XL images via the external library libjxl.

diff --git a/libavcodec/libjxl.c b/libavcodec/libjxl.c
--- /dev/null
+++ b/libavcodec/libjxl.c
@@ -0,0 +60,5 @@
+static void libjxl_av_free(void *opaque, void *address)
+{
+    av_free(address);
+}
+
[func] **new** commit 3a5944696768e3b5680ae78d9d84ba9846050e61
Date:   Thu Oct 20 14:35:32 2022 +0000

    avcodec/mediacodec: add ANativeWindow support
    
    ANativeWindow can be used without JVM.

diff --git a/libavcodec/mediacodec_surface.c b/libavcodec/mediacodec_surface.c
--- a/libavcodec/mediacodec_surface.c
+++ b/libavcodec/mediacodec_surface.c
@@ -28,12 +30,29 @@
-FFANativeWindow *ff_mediacodec_surface_ref(void *surface, void *log_ctx)
+FFANativeWindow *ff_mediacodec_surface_ref(void *surface, void *native_window, void *log_ctx)
 {
-    JNIEnv *env = NULL;
+    FFANativeWindow *ret;
 
-    env = ff_jni_get_env(log_ctx);
-    if (!env) {
+    ret = av_mallocz(sizeof(*ret));
+    if (!ret)
         return NULL;
+
+    if (surface) {
+        JNIEnv *env = NULL;
+
+        env = ff_jni_get_env(log_ctx);
+        if (env)
+            ret->surface = (*env)->NewGlobalRef(env, surface);
+    }
+
+    if (native_window) {
+        ANativeWindow_acquire(native_window);
+        ret->native_window = native_window;
     }
 
-    return (*env)->NewGlobalRef(env, surface);
+    if (!ret->surface && !ret->native_window) {
+        av_log(log_ctx, AV_LOG_ERROR, "Both surface and native_window are NULL\n");
+        av_freep(&ret);
+    }
+
+    return ret;
 }
 
commit 3a5944696768e3b5680ae78d9d84ba9846050e61
Date:   Thu Oct 20 14:35:32 2022 +0000

    avcodec/mediacodec: add ANativeWindow support
    
    ANativeWindow can be used without JVM.

diff --git a/libavcodec/mediacodec_surface.c b/libavcodec/mediacodec_surface.c
--- a/libavcodec/mediacodec_surface.c
+++ b/libavcodec/mediacodec_surface.c
@@ -40,13 +59,20 @@
 int ff_mediacodec_surface_unref(FFANativeWindow *window, void *log_ctx)
 {
-    JNIEnv *env = NULL;
+    if (!window)
+        return 0;
 
-    env = ff_jni_get_env(log_ctx);
-    if (!env) {
-        return AVERROR_EXTERNAL;
+    if (window->surface) {
+        JNIEnv *env = NULL;
+
+        env = ff_jni_get_env(log_ctx);
+        if (env)
+            (*env)->DeleteGlobalRef(env, window->surface);
     }
 
-    (*env)->DeleteGlobalRef(env, window);
+    if (window->native_window)
+        ANativeWindow_release(window->native_window);
+
+    av_free(window);
 
     return 0;
 }
[func] **new** commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -625,32 +628,32 @@
-FFAMediaFormat *ff_AMediaFormat_new(void)
+static FFAMediaFormat *mediaformat_jni_new(void)
 {
     JNIEnv *env = NULL;
-    FFAMediaFormat *format = NULL;
+    FFAMediaFormatJni *format = NULL;
     jobject object = NULL;
 
-    format = av_mallocz(sizeof(FFAMediaFormat));
+    format = av_mallocz(sizeof(*format));
     if (!format) {
         return NULL;
     }
-    format->class = &amediaformat_class;
+    format->api = media_format_jni;
 
     env = ff_jni_get_env(format);
     if (!env) {
         av_freep(&format);
         return NULL;
     }
 
     if (ff_jni_init_jfields(env, &format->jfields, jni_amediaformat_mapping, 1, format) < 0) {
         goto fail;
     }
 
     object = (*env)->NewObject(env, format->jfields.mediaformat_class, format->jfields.init_id);
     if (!object) {
         goto fail;
     }
 
     format->object = (*env)->NewGlobalRef(env, object);
     if (!format->object) {
         goto fail;
     }
 
commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -670,27 +673,27 @@
-static FFAMediaFormat *ff_AMediaFormat_newFromObject(void *object)
+static FFAMediaFormat *mediaformat_jni_newFromObject(void *object)
 {
     JNIEnv *env = NULL;
-    FFAMediaFormat *format = NULL;
+    FFAMediaFormatJni *format = NULL;
 
-    format = av_mallocz(sizeof(FFAMediaFormat));
+    format = av_mallocz(sizeof(*format));
     if (!format) {
         return NULL;
     }
-    format->class = &amediaformat_class;
+    format->api = media_format_jni;
 
     env = ff_jni_get_env(format);
     if (!env) {
         av_freep(&format);
         return NULL;
     }
 
     if (ff_jni_init_jfields(env, &format->jfields, jni_amediaformat_mapping, 1, format) < 0) {
         goto fail;
     }
 
     format->object = (*env)->NewGlobalRef(env, object);
     if (!format->object) {
         goto fail;
     }
 
-    return format;
+    return (FFAMediaFormat *)format;
commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1192,71 +1200,71 @@
 static inline FFAMediaCodec *codec_create(int method, const char *arg)
 {
     int ret = -1;
     JNIEnv *env = NULL;
-    FFAMediaCodec *codec = NULL;
+    FFAMediaCodecJni *codec = NULL;
     jstring jarg = NULL;
     jobject object = NULL;
     jobject buffer_info = NULL;
     jmethodID create_id = NULL;
 
-    codec = av_mallocz(sizeof(FFAMediaCodec));
+    codec = av_mallocz(sizeof(*codec));
     if (!codec) {
         return NULL;
     }
-    codec->class = &amediacodec_class;
+    codec->api = media_codec_jni;
 
     env = ff_jni_get_env(codec);
     if (!env) {
         av_freep(&codec);
         return NULL;
     }
 
     if (ff_jni_init_jfields(env, &codec->jfields, jni_amediacodec_mapping, 1, codec) < 0) {
         goto fail;
     }
 
     jarg = ff_jni_utf_chars_to_jstring(env, arg, codec);
     if (!jarg) {
         goto fail;
     }
 
     switch (method) {
     case CREATE_CODEC_BY_NAME:   create_id = codec->jfields.create_by_codec_name_id;   break;
     case CREATE_DECODER_BY_TYPE: create_id = codec->jfields.create_decoder_by_type_id; break;
     case CREATE_ENCODER_BY_TYPE: create_id = codec->jfields.create_encoder_by_type_id; break;
     default:
         av_assert0(0);
     }
 
     object = (*env)->CallStaticObjectMethod(env,
                                             codec->jfields.mediacodec_class,
                                             create_id,
                                             jarg);
     if (ff_jni_exception_check(env, 1, codec) < 0) {
         goto fail;
     }
 
     codec->object = (*env)->NewGlobalRef(env, object);
     if (!codec->object) {
         goto fail;
     }
 
     if (codec_init_static_fields(codec) < 0) {
         goto fail;
     }
 
     if (codec->jfields.get_input_buffer_id && codec->jfields.get_output_buffer_id) {
         codec->has_get_i_o_buffer = 1;
     }
 
     buffer_info = (*env)->NewObject(env, codec->jfields.mediainfo_class, codec->jfields.init_id);
     if (ff_jni_exception_check(env, 1, codec) < 0) {
         goto fail;
     }
 
     codec->buffer_info = (*env)->NewGlobalRef(env, buffer_info);
     if (!codec->buffer_info) {
         goto fail;
     }
 
     ret = 0;
[func] **new** commit 4df9cb918eb645d3690a5209212be7f0471e35eb
Date:   Mon Oct 17 00:50:02 2022 +0800

    avcodec/mediacodec: add NDK media codec wrapper
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1797,1 +1935,5 @@
-FFAMediaFormat *ff_AMediaFormat_new(void)
+static FFAMediaFormat *mediaformat_ndk_new(void)
+{
+    return mediaformat_ndk_create(NULL);
+}
+

commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1709,0 +1797,1 @@
+FFAMediaFormat *ff_AMediaFormat_new(void)
[func] **new** commit a63834b236c17eae72faf23aebcba32f911809e6
Date:   Thu Nov 24 00:49:25 2022 +0800

    avcodec/mediacodec: fix missing crop info when use NDK MediaCodec
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1931,47 +1935,53 @@
 static FFAMediaFormat *mediaformat_ndk_create(AMediaFormat *impl)
 {
     FFAMediaFormatNdk *format = av_mallocz(sizeof(*format));
     if (!format)
         return NULL;
 
     format->api = media_format_ndk;
 
     format->libmedia = dlopen("libmediandk.so", RTLD_NOW);
     if (!format->libmedia)
         goto error;
 
-#define GET_SYMBOL(sym) \
-    format->sym = dlsym(format->libmedia, "AMediaFormat_" #sym);    \
-    if (!format->sym)                                               \
+#define GET_OPTIONAL_SYMBOL(sym) \
+    format->sym = dlsym(format->libmedia, "AMediaFormat_" #sym);
+
+#define GET_SYMBOL(sym)         \
+    GET_OPTIONAL_SYMBOL(sym)    \
+    if (!format->sym)           \
         goto error;
 
     GET_SYMBOL(new)
     GET_SYMBOL(delete)
 
     GET_SYMBOL(toString)
 
     GET_SYMBOL(getInt32)
     GET_SYMBOL(getInt64)
     GET_SYMBOL(getFloat)
     GET_SYMBOL(getSize)
     GET_SYMBOL(getBuffer)
     GET_SYMBOL(getString)
+    GET_OPTIONAL_SYMBOL(getRect)
 
     GET_SYMBOL(setInt32)
     GET_SYMBOL(setInt64)
     GET_SYMBOL(setFloat)
     GET_SYMBOL(setString)
     GET_SYMBOL(setBuffer)
+    GET_OPTIONAL_SYMBOL(setRect)
 
 #undef GET_SYMBOL
+#undef GET_OPTIONAL_SYMBOL
 
     if (impl) {
         format->impl = impl;
     } else {
         format->impl = format->new();
         if (!format->impl)
             goto error;
     }
 
     return (FFAMediaFormat *)format;
 

commit 4df9cb918eb645d3690a5209212be7f0471e35eb
Date:   Mon Oct 17 00:50:02 2022 +0800

    avcodec/mediacodec: add NDK media codec wrapper
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1797,1 +1881,47 @@
-FFAMediaFormat *ff_AMediaFormat_new(void)
+static FFAMediaFormat *mediaformat_ndk_create(AMediaFormat *impl)
+{
+    FFAMediaFormatNdk *format = av_mallocz(sizeof(*format));
+    if (!format)
+        return NULL;
+
+    format->api = media_format_ndk;
+
+    format->libmedia = dlopen("libmediandk.so", RTLD_NOW);
+    if (!format->libmedia)
+        goto error;
+
+#define GET_SYMBOL(sym) \
+    format->sym = dlsym(format->libmedia, "AMediaFormat_" #sym);    \
+    if (!format->sym)                                               \
+        goto error;
+
+    GET_SYMBOL(new)
+    GET_SYMBOL(delete)
+
+    GET_SYMBOL(toString)
+
+    GET_SYMBOL(getInt32)
+    GET_SYMBOL(getInt64)
+    GET_SYMBOL(getFloat)
+    GET_SYMBOL(getSize)
+    GET_SYMBOL(getBuffer)
+    GET_SYMBOL(getString)
+
+    GET_SYMBOL(setInt32)
+    GET_SYMBOL(setInt64)
+    GET_SYMBOL(setFloat)
+    GET_SYMBOL(setString)
+    GET_SYMBOL(setBuffer)
+
+#undef GET_SYMBOL
+
+    if (impl) {
+        format->impl = impl;
+    } else {
+        format->impl = format->new();
+        if (!format->impl)
+            goto error;
+    }
+
+    return (FFAMediaFormat *)format;
+

commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1709,0 +1797,1 @@
+FFAMediaFormat *ff_AMediaFormat_new(void)
[func] **new** commit 0ff18a7d6d496f89d9e007ddd1cad7116baf5c7c
Date:   Tue Oct 18 00:23:08 2022 +0800

    avcodec: add MediaCodec encoder
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -2055,66 +2100,69 @@
 static inline FFAMediaCodec *ndk_codec_create(int method, const char *arg) {
     FFAMediaCodecNdk *codec = av_mallocz(sizeof(*codec));
     const char *lib_name = "libmediandk.so";
 
     if (!codec)
         return NULL;
 
     codec->api = media_codec_ndk;
     codec->libmedia = dlopen(lib_name, RTLD_NOW);
     if (!codec->libmedia)
         goto error;
 
 #define GET_SYMBOL(sym, required)                                   \
     codec->sym = dlsym(codec->libmedia, "AMediaCodec_" #sym);       \
     if (!codec->sym) {                                              \
         av_log(codec, required ? AV_LOG_ERROR : AV_LOG_INFO,        \
                #sym "() unavailable from %s\n", lib_name);          \
         if (required)                                               \
             goto error;                                             \
     }
 
     GET_SYMBOL(createCodecByName, 1)
     GET_SYMBOL(createDecoderByType, 1)
     GET_SYMBOL(createEncoderByType, 1)
     GET_SYMBOL(delete, 1)
 
     GET_SYMBOL(configure, 1)
     GET_SYMBOL(start, 1)
     GET_SYMBOL(stop, 1)
     GET_SYMBOL(flush, 1)
 
     GET_SYMBOL(getInputBuffer, 1)
     GET_SYMBOL(getOutputBuffer, 1)
 
     GET_SYMBOL(dequeueInputBuffer, 1)
     GET_SYMBOL(queueInputBuffer, 1)
 
     GET_SYMBOL(dequeueOutputBuffer, 1)
     GET_SYMBOL(getOutputFormat, 1)
 
     GET_SYMBOL(releaseOutputBuffer, 1)
     GET_SYMBOL(releaseOutputBufferAtTime, 1)
 
     GET_SYMBOL(getName, 0)
     GET_SYMBOL(releaseName, 0)
 
+    GET_SYMBOL(setInputSurface, 0)
+    GET_SYMBOL(signalEndOfInputStream, 0)
+
 #undef GET_SYMBOL
 
     switch (method) {
     case CREATE_CODEC_BY_NAME:
         codec->impl = codec->createCodecByName(arg);
         break;
     case CREATE_DECODER_BY_TYPE:
         codec->impl = codec->createDecoderByType(arg);
         break;
     case CREATE_ENCODER_BY_TYPE:
         codec->impl = codec->createEncoderByType(arg);
         break;
     default:
         av_assert0(0);
     }
     if (!codec->impl)
         goto error;
 
     return (FFAMediaCodec *)codec;
 

commit 4df9cb918eb645d3690a5209212be7f0471e35eb
Date:   Mon Oct 17 00:50:02 2022 +0800

    avcodec/mediacodec: add NDK media codec wrapper
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1797,1 +2050,66 @@
-FFAMediaFormat *ff_AMediaFormat_new(void)
+static inline FFAMediaCodec *ndk_codec_create(int method, const char *arg) {
+    FFAMediaCodecNdk *codec = av_mallocz(sizeof(*codec));
+    const char *lib_name = "libmediandk.so";
+
+    if (!codec)
+        return NULL;
+
+    codec->api = media_codec_ndk;
+    codec->libmedia = dlopen(lib_name, RTLD_NOW);
+    if (!codec->libmedia)
+        goto error;
+
+#define GET_SYMBOL(sym, required)                                   \
+    codec->sym = dlsym(codec->libmedia, "AMediaCodec_" #sym);       \
+    if (!codec->sym) {                                              \
+        av_log(codec, required ? AV_LOG_ERROR : AV_LOG_INFO,        \
+               #sym "() unavailable from %s\n", lib_name);          \
+        if (required)                                               \
+            goto error;                                             \
+    }
+
+    GET_SYMBOL(createCodecByName, 1)
+    GET_SYMBOL(createDecoderByType, 1)
+    GET_SYMBOL(createEncoderByType, 1)
+    GET_SYMBOL(delete, 1)
+
+    GET_SYMBOL(configure, 1)
+    GET_SYMBOL(start, 1)
+    GET_SYMBOL(stop, 1)
+    GET_SYMBOL(flush, 1)
+
+    GET_SYMBOL(getInputBuffer, 1)
+    GET_SYMBOL(getOutputBuffer, 1)
+
+    GET_SYMBOL(dequeueInputBuffer, 1)
+    GET_SYMBOL(queueInputBuffer, 1)
+
+    GET_SYMBOL(dequeueOutputBuffer, 1)
+    GET_SYMBOL(getOutputFormat, 1)
+
+    GET_SYMBOL(releaseOutputBuffer, 1)
+    GET_SYMBOL(releaseOutputBufferAtTime, 1)
+
+    GET_SYMBOL(getName, 0)
+    GET_SYMBOL(releaseName, 0)
+
+#undef GET_SYMBOL
+
+    switch (method) {
+    case CREATE_CODEC_BY_NAME:
+        codec->impl = codec->createCodecByName(arg);
+        break;
+    case CREATE_DECODER_BY_TYPE:
+        codec->impl = codec->createDecoderByType(arg);
+        break;
+    case CREATE_ENCODER_BY_TYPE:
+        codec->impl = codec->createEncoderByType(arg);
+        break;
+    default:
+        av_assert0(0);
+    }
+    if (!codec->impl)
+        goto error;
+
+    return (FFAMediaCodec *)codec;
+

commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1709,0 +1797,1 @@
+FFAMediaFormat *ff_AMediaFormat_new(void)
commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -705,22 +708,22 @@
-int ff_AMediaFormat_delete(FFAMediaFormat* format)
+static int mediaformat_jni_delete(FFAMediaFormat* ctx)
 {
     int ret = 0;
-
+    FFAMediaFormatJni *format = (FFAMediaFormatJni *)ctx;
     JNIEnv *env = NULL;
 
     if (!format) {
         return 0;
     }
 
     JNI_GET_ENV_OR_RETURN(env, format, AVERROR_EXTERNAL);
 
     (*env)->DeleteGlobalRef(env, format->object);
     format->object = NULL;
 
     ff_jni_reset_jfields(env, &format->jfields, jni_amediaformat_mapping, 1, format);
 
     av_freep(&format);
 
     return ret;
 }
 
commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1302,36 +1310,36 @@
-int ff_AMediaCodec_delete(FFAMediaCodec* codec)
+static int mediacodec_jni_delete(FFAMediaCodec* ctx)
 {
     int ret = 0;
-
+    FFAMediaCodecJni *codec = (FFAMediaCodecJni *)ctx;
     JNIEnv *env = NULL;
 
     if (!codec) {
         return 0;
     }
 
     JNI_GET_ENV_OR_RETURN(env, codec, AVERROR_EXTERNAL);
 
     (*env)->CallVoidMethod(env, codec->object, codec->jfields.release_id);
     if (ff_jni_exception_check(env, 1, codec) < 0) {
         ret = AVERROR_EXTERNAL;
     }
 
     (*env)->DeleteGlobalRef(env, codec->input_buffers);
     codec->input_buffers = NULL;
 
     (*env)->DeleteGlobalRef(env, codec->output_buffers);
     codec->output_buffers = NULL;
 
     (*env)->DeleteGlobalRef(env, codec->object);
     codec->object = NULL;
 
     (*env)->DeleteGlobalRef(env, codec->buffer_info);
     codec->buffer_info = NULL;
 
     ff_jni_reset_jfields(env, &codec->jfields, jni_amediacodec_mapping, 1, codec);
 
     av_freep(&codec);
 
     return ret;
 }
 
commit 4df9cb918eb645d3690a5209212be7f0471e35eb
Date:   Mon Oct 17 00:50:02 2022 +0800

    avcodec/mediacodec: add NDK media codec wrapper
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1797,1 +1940,18 @@
-FFAMediaFormat *ff_AMediaFormat_new(void)
+static int mediaformat_ndk_delete(FFAMediaFormat* ctx)
+{
+    FFAMediaFormatNdk *format = (FFAMediaFormatNdk *)ctx;
+    int ret = 0;
+    if (!format)
+        return 0;
+
+    av_assert0(format->api.class == &amediaformat_ndk_class);
+
+    if (format->impl && (format->delete(format->impl) != AMEDIA_OK))
+            ret = AVERROR_EXTERNAL;
+    if (format->libmedia)
+        dlclose(format->libmedia);
+    av_free(format);
+
+    return ret;
+}
+

commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1709,0 +1797,1 @@
+FFAMediaFormat *ff_AMediaFormat_new(void)
commit 4df9cb918eb645d3690a5209212be7f0471e35eb
Date:   Mon Oct 17 00:50:02 2022 +0800

    avcodec/mediacodec: add NDK media codec wrapper
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1797,1 +2133,21 @@
-FFAMediaFormat *ff_AMediaFormat_new(void)
+static int mediacodec_ndk_delete(FFAMediaCodec* ctx)
+{
+    FFAMediaCodecNdk *codec = (FFAMediaCodecNdk *)ctx;
+    int ret = 0;
+
+    if (!codec)
+        return 0;
+
+    av_assert0(codec->api.class == &amediacodec_ndk_class);
+
+    if (codec->impl && (codec->delete(codec->impl) != AMEDIA_OK))
+        ret = AVERROR_EXTERNAL;
+    if (codec->window)
+        ANativeWindow_release(codec->window);
+    if (codec->libmedia)
+        dlclose(codec->libmedia);
+    av_free(codec);
+
+    return ret;
+}
+

commit 4f2ea862b3de1647de0d9e00702801671764a762
Date:   Fri Oct 14 01:43:14 2022 +0800

    avcodec/mediacodec_wrapper: separate implementation from interface
    
    This is in preparation for NDK media codec wrapper.
    
    Signed-off-by: Zhao Zhili <zhilizhao@tencent.com>

diff --git a/libavcodec/mediacodec_wrapper.c b/libavcodec/mediacodec_wrapper.c
--- a/libavcodec/mediacodec_wrapper.c
+++ b/libavcodec/mediacodec_wrapper.c
@@ -1709,0 +1797,1 @@
+FFAMediaFormat *ff_AMediaFormat_new(void)
[safe] **new** commit b645138a34321fb1d1b7988cd0d78b897e4d65ca
Date:   Mon Aug 8 10:29:05 2022 +0200

    avcodec/mpegpicture: Don't copy unnecessarily, fix race
    
    mpegvideo uses an array of Pictures and when it is done with using
    them, it only unreferences them incompletely: Some buffers are kept
    so that they can be reused lateron if the same slot in the Picture
    array is reused, making this a sort of a bufferpool.
    (Basically, a Picture is considered used if the AVFrame's buf is set.)
    Yet given that other pieces of the decoder may have a reference to
    these buffers, they need not be writable and are made writable using
    av_buffer_make_writable() when preparing a new Picture. This involves
    reading the buffer's data, although the old content of the buffer
    need not be retained.
    
    Worse, this read can be racy, because the buffer can be used by another
    thread at the same time. This happens for Real Video 3 and 4.
    
    This commit fixes this race by no longer copying the data;
    instead the old buffer is replaced by a new, zero-allocated buffer.
    
    (Here are the details of what happens with three or more decoding threads
    when decoding rv30.rm from the FATE-suite as happens in the rv30 test:
    The first decoding thread uses the first slot of its picture array
    to store its current pic; update_thread_context copies this for the
    second thread that decodes a P-frame. It uses the second slot in its
    Picture array to store its P-frame. This arrangement is then copied
    to the third decode thread, which decodes a B-frame. It uses the third
    slot in its Picture array for its current frame.
    update_thread_context copies this to the next thread. It unreferences
    the third slot containing the other B-frame and then it reuses this
    slot for its current frame. Because the pic array slots are only
    incompletely unreferenced, the buffers of the previous B-frame are
    still in there and they are not writable; in fact the previous
    thread is concurrently writing to them, causing races when making
    the buffer writable.)
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/mpegpicture.c b/libavcodec/mpegpicture.c
--- a/libavcodec/mpegpicture.c
+++ b/libavcodec/mpegpicture.c
@@ -50,0 +50,14 @@
+static int make_table_writable(AVBufferRef **ref)
+{
+    AVBufferRef *old = *ref, *new;
+
+    if (av_buffer_is_writable(old))
+        return 0;
+    new = av_buffer_allocz(old->size);
+    if (!new)
+        return AVERROR(ENOMEM);
+    av_buffer_unref(ref);
+    *ref = new;
+    return 0;
+}
+
[perf] **new** commit bc109a53c722f7b1ce9c3bede906717b4e271496
Date:   Sun Aug 7 09:02:51 2022 +0200

    avcodec/mpegpicture: Move mb_var, mc_mb_var and mb_mean to MpegEncCtx
    
    These tables are only used by encoders and only for the current picture;
    ergo they need not be put into the picture at all, but rather into
    the encoder's context. They also don't need to be refcounted,
    because there is only one owner.
    
    In contrast to this, the earlier code refcounts them which
    incurs unnecessary overhead. These references are not unreferenced
    in ff_mpeg_unref_picture() (they are kept in order to have something
    like a buffer pool), so that several buffers are kept at the same
    time, although only one is needed, thereby wasting memory.
    
    The code also propagates references to other pictures not part of
    the pictures array (namely the copy of the current/next/last picture
    in the MpegEncContext which get references of their own). These
    references are not unreferenced in ff_mpeg_unref_picture() (the
    buffers are probably kept in order to have something like a pool),
    yet if the current picture is a B-frame, it gets unreferenced
    at the end of ff_mpv_encode_picture() and its slot in the picture
    array will therefore be reused the next time; but the copy of the
    current picture also still has its references and therefore
    these buffers will be made duplicated in order to make them writable
    in the next call to ff_mpv_encode_picture(). This is of course
    unnecessary.
    
    Finally, ff_find_unused_picture() is supposed to just return
    any unused picture and the code is supposed to work with it;
    yet for the vsynth*-mpeg4-adap tests the result depends upon
    the content of these buffers; given that this patchset
    changes the content of these buffers (the initial content is now
    the state of these buffers after encoding the last frame;
    before this patch the buffers used came from the last picture
    that occupied the same slot in the picture array) their ref-files
    needed to be changed. This points to a bug somewhere (if one removes
    the initialization, one gets uninitialized reads in
    adaptive_quantization in ratecontrol.c).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/mpegpicture.c b/libavcodec/mpegpicture.c
--- a/libavcodec/mpegpicture.c
+++ b/libavcodec/mpegpicture.c
@@ -35,18 +35,15 @@
 static void av_noinline free_picture_tables(Picture *pic)
 {
     pic->alloc_mb_width  =
     pic->alloc_mb_height = 0;
 
-    av_buffer_unref(&pic->mb_var_buf);
-    av_buffer_unref(&pic->mc_mb_var_buf);
-    av_buffer_unref(&pic->mb_mean_buf);
     av_buffer_unref(&pic->mbskip_table_buf);
     av_buffer_unref(&pic->qscale_table_buf);
     av_buffer_unref(&pic->mb_type_buf);
 
     for (int i = 0; i < 2; i++) {
         av_buffer_unref(&pic->motion_val_buf[i]);
         av_buffer_unref(&pic->ref_index_buf[i]);
     }
 }
 

[func] **new** commit 5a04c6a2697568c2b7233a0a9f4f20aa8a2a1706
Date:   Wed Jan 26 19:02:37 2022 +0100

    avcodec/mpegpicture: Add function to completely free MPEG-Picture
    
    Also use said function in mpegvideo.c and mpegvideo_enc.c;
    and make ff_free_picture_tables() static as it isn't needed anymore
    outside of mpegpicture.c.
    
    Reviewed-by: James Almer <jamrial@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/mpegpicture.c b/libavcodec/mpegpicture.c
--- a/libavcodec/mpegpicture.c
+++ b/libavcodec/mpegpicture.c
@@ -33,0 +33,18 @@
+static void av_noinline free_picture_tables(Picture *pic)
+{
+    pic->alloc_mb_width  =
+    pic->alloc_mb_height = 0;
+
+    av_buffer_unref(&pic->mb_var_buf);
+    av_buffer_unref(&pic->mc_mb_var_buf);
+    av_buffer_unref(&pic->mb_mean_buf);
+    av_buffer_unref(&pic->mbskip_table_buf);
+    av_buffer_unref(&pic->qscale_table_buf);
+    av_buffer_unref(&pic->mb_type_buf);
+
+    for (int i = 0; i < 2; i++) {
+        av_buffer_unref(&pic->motion_val_buf[i]);
+        av_buffer_unref(&pic->ref_index_buf[i]);
+    }
+}
+
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/nvdec.c b/libavcodec/nvdec.c
--- a/libavcodec/nvdec.c
+++ b/libavcodec/nvdec.c
@@ -245,17 +245,17 @@
-static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, size_t size)
 {
     NVDECFramePool *pool = opaque;
     AVBufferRef *ret;
 
     if (pool->nb_allocated >= pool->dpb_size)
         return NULL;
 
     ret = av_buffer_alloc(sizeof(unsigned int));
     if (!ret)
         return NULL;
 
     *(unsigned int*)ret->data = pool->nb_allocated++;
 
     return ret;
 }
 

[incr] **new** commit d8a18c8fc2907004448cb45e704dc82bcd2df528
Date:   Sat Mar 6 13:29:37 2021 -0300

    avcodec: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/nvdec.c b/libavcodec/nvdec.c
--- a/libavcodec/nvdec.c
+++ b/libavcodec/nvdec.c
@@ -245,17 +245,17 @@
-static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, int size)
+static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, buffer_size_t size)
 {
     NVDECFramePool *pool = opaque;
     AVBufferRef *ret;
 
     if (pool->nb_allocated >= pool->dpb_size)
         return NULL;
 
     ret = av_buffer_alloc(sizeof(unsigned int));
     if (!ret)
         return NULL;
 
     *(unsigned int*)ret->data = pool->nb_allocated++;
 
     return ret;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/nvdec.c b/libavcodec/nvdec.c
--- a/libavcodec/nvdec.c
+++ b/libavcodec/nvdec.c
@@ -245,17 +245,17 @@
-static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, size_t size)
 {
     NVDECFramePool *pool = opaque;
     AVBufferRef *ret;
 
     if (pool->nb_allocated >= pool->dpb_size)
         return NULL;
 
     ret = av_buffer_alloc(sizeof(unsigned int));
     if (!ret)
         return NULL;
 
     *(unsigned int*)ret->data = pool->nb_allocated++;
 
     return ret;
 }
 

commit d8a18c8fc2907004448cb45e704dc82bcd2df528
Date:   Sat Mar 6 13:29:37 2021 -0300

    avcodec: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/nvdec.c b/libavcodec/nvdec.c
--- a/libavcodec/nvdec.c
+++ b/libavcodec/nvdec.c
@@ -245,17 +245,17 @@
-static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, int size)
+static AVBufferRef *nvdec_decoder_frame_alloc(void *opaque, buffer_size_t size)
 {
     NVDECFramePool *pool = opaque;
     AVBufferRef *ret;
 
     if (pool->nb_allocated >= pool->dpb_size)
         return NULL;
 
     ret = av_buffer_alloc(sizeof(unsigned int));
     if (!ret)
         return NULL;
 
     *(unsigned int*)ret->data = pool->nb_allocated++;
 
     return ret;
 }
 
 
commit 548aeb93834b8425c86d1ce60fddc1d41805724d
Date:   Fri Apr 7 18:08:41 2017 +0200

    lavc: switch to the new channel layout API
    
    Since the request_channel_layout is used only by a handful of codecs,
    move the option to codec private contexts.
    
    Signed-off-by: Anton Khirnov <anton@khirnov.net>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/options.c b/libavcodec/options.c
--- a/libavcodec/options.c
+++ b/libavcodec/options.c
@@ -156,18 +159,19 @@
 void avcodec_free_context(AVCodecContext **pavctx)
 {
     AVCodecContext *avctx = *pavctx;
 
     if (!avctx)
         return;
 
     avcodec_close(avctx);
 
     av_freep(&avctx->extradata);
     av_freep(&avctx->subtitle_header);
     av_freep(&avctx->intra_matrix);
     av_freep(&avctx->inter_matrix);
     av_freep(&avctx->rc_override);
+    av_channel_layout_uninit(&avctx->ch_layout);
 
     av_freep(pavctx);
 }
 
[func] **new** commit ba30744213c8ee8df2281a681f41c56c8f4d88b5
Date:   Fri Oct 7 18:01:57 2022 +0200

    avcodec/opus_pvq: Don't build ppp_pvq_search_c when unused
    
    Reviewed-by: Lynne <dev@lynne.ee>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/opus_pvq.c b/libavcodec/opus_pvq.c
--- a/libavcodec/opus_pvq.c
+++ b/libavcodec/opus_pvq.c
@@ -904,18 +906,20 @@
 int av_cold ff_celt_pvq_init(CeltPVQ **pvq, int encode)
 {
     CeltPVQ *s = av_malloc(sizeof(CeltPVQ));
     if (!s)
         return AVERROR(ENOMEM);
 
-    s->pvq_search = ppp_pvq_search_c;
     s->quant_band = encode ? pvq_encode_band : pvq_decode_band;
 
-#if CONFIG_OPUS_ENCODER && ARCH_X86
+#if CONFIG_OPUS_ENCODER
+    s->pvq_search = ppp_pvq_search_c;
+#if ARCH_X86
     ff_celt_pvq_init_x86(s);
 #endif
+#endif
 
     *pvq = s;
 
     return 0;
 }
 

[func] **new** commit 40e6575aa3eed64cd32bf28c00ae57edc5acb25a
Date:   Sun Jun 12 05:51:12 2022 +0200

    all: Replace if (ARCH_FOO) checks by #if ARCH_FOO
    
    This is more spec-compliant because it does not rely
    on dead-code elimination by the compiler. Especially
    MSVC has problems with this, as can be seen in
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/296373.html
    or
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/297022.html
    
    This commit does not eliminate every instance where we rely
    on dead code elimination: It only tackles branching to
    the initialization of arch-specific dsp code, not e.g. all
    uses of CONFIG_ and HAVE_ checks. But maybe it is already
    enough to compile FFmpeg with MSVC with whole-programm-optimizations
    enabled (if one does not disable too many components).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/opus_pvq.c b/libavcodec/opus_pvq.c
--- a/libavcodec/opus_pvq.c
+++ b/libavcodec/opus_pvq.c
@@ -899,17 +899,18 @@
 int av_cold ff_celt_pvq_init(CeltPVQ **pvq, int encode)
 {
     CeltPVQ *s = av_malloc(sizeof(CeltPVQ));
     if (!s)
         return AVERROR(ENOMEM);
 
     s->pvq_search = ppp_pvq_search_c;
     s->quant_band = encode ? pvq_encode_band : pvq_decode_band;
 
-    if (CONFIG_OPUS_ENCODER && ARCH_X86)
-        ff_celt_pvq_init_x86(s);
+#if CONFIG_OPUS_ENCODER && ARCH_X86
+    ff_celt_pvq_init_x86(s);
+#endif
 
     *pvq = s;
 
     return 0;
 }
 
[func] **new** commit 8320e236c1f11e7a397ddce7e4206c11ac9de9a9
Date:   Fri Oct 7 20:17:06 2022 +0200

    avcodec/opus: Rename opus.c->opus_celt.c, opus_celt.c->opusdec_celt.c
    
    Since commit 4fc2531fff112836026aad2bdaf128c9d15a72e3 opus.c
    contains only the celt stuff shared between decoder and encoder.
    meanwhile, opus_celt.c is decoder-only. So the new names
    reflect the actual content better than the current ones.
    
    Reviewed-by: Lynne <dev@lynne.ee>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/opusdec_celt.c b/libavcodec/opusdec_celt.c
--- /dev/null
+++ b/libavcodec/opusdec_celt.c
@@ -0,0 +542,41 @@
+int ff_celt_init(AVCodecContext *avctx, CeltFrame **f, int output_channels,
+                 int apply_phase_inv)
+{
+    CeltFrame *frm;
+    int i, ret;
+
+    if (output_channels != 1 && output_channels != 2) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid number of output channels: %d\n",
+               output_channels);
+        return AVERROR(EINVAL);
+    }
+
+    frm = av_mallocz(sizeof(*frm));
+    if (!frm)
+        return AVERROR(ENOMEM);
+
+    frm->avctx           = avctx;
+    frm->output_channels = output_channels;
+    frm->apply_phase_inv = apply_phase_inv;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(frm->tx); i++) {
+        const float scale = -1.0f/32768;
+        if ((ret = av_tx_init(&frm->tx[i], &frm->tx_fn[i], AV_TX_FLOAT_MDCT, 1, 15 << (i + 3), &scale, 0)) < 0)
+            goto fail;
+    }
+
+    if ((ret = ff_celt_pvq_init(&frm->pvq, 0)) < 0)
+        goto fail;
+
+    frm->dsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);
+    if (!frm->dsp) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    ff_opus_dsp_init(&frm->opusdsp);
+    ff_celt_flush(frm);
+
+    *f = frm;
+
+    return 0;
commit 8320e236c1f11e7a397ddce7e4206c11ac9de9a9
Date:   Fri Oct 7 20:17:06 2022 +0200

    avcodec/opus: Rename opus.c->opus_celt.c, opus_celt.c->opusdec_celt.c
    
    Since commit 4fc2531fff112836026aad2bdaf128c9d15a72e3 opus.c
    contains only the celt stuff shared between decoder and encoder.
    meanwhile, opus_celt.c is decoder-only. So the new names
    reflect the actual content better than the current ones.
    
    Reviewed-by: Lynne <dev@lynne.ee>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/opusdec_celt.c b/libavcodec/opusdec_celt.c
--- /dev/null
+++ b/libavcodec/opusdec_celt.c
@@ -0,0 +525,17 @@
+void ff_celt_free(CeltFrame **f)
+{
+    CeltFrame *frm = *f;
+    int i;
+
+    if (!frm)
+        return;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(frm->tx); i++)
+        av_tx_uninit(&frm->tx[i]);
+
+    ff_celt_pvq_uninit(&frm->pvq);
+
+    av_freep(&frm->dsp);
+    av_freep(f);
+}
+
 
 

[incr] **new** commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/psymodel.c b/libavcodec/psymodel.c
--- a/libavcodec/psymodel.c
+++ b/libavcodec/psymodel.c
@@ -103,36 +103,36 @@
 av_cold struct FFPsyPreprocessContext* ff_psy_preprocess_init(AVCodecContext *avctx)
 {
     FFPsyPreprocessContext *ctx;
     int i;
     float cutoff_coeff = 0;
     ctx        = av_mallocz(sizeof(FFPsyPreprocessContext));
     if (!ctx)
         return NULL;
     ctx->avctx = avctx;
 
     /* AAC has its own LP method */
     if (avctx->codec_id != AV_CODEC_ID_AAC) {
         if (avctx->cutoff > 0)
             cutoff_coeff = 2.0 * avctx->cutoff / avctx->sample_rate;
 
         if (cutoff_coeff && cutoff_coeff < 0.98)
         ctx->fcoeffs = ff_iir_filter_init_coeffs(avctx, FF_FILTER_TYPE_BUTTERWORTH,
                                                  FF_FILTER_MODE_LOWPASS, FILT_ORDER,
                                                  cutoff_coeff, 0.0, 0.0);
         if (ctx->fcoeffs) {
-            ctx->fstate = av_mallocz_array(sizeof(ctx->fstate[0]), avctx->channels);
+            ctx->fstate = av_calloc(avctx->channels, sizeof(ctx->fstate[0]));
             if (!ctx->fstate) {
                 av_free(ctx->fcoeffs);
                 av_free(ctx);
                 return NULL;
             }
             for (i = 0; i < avctx->channels; i++)
                 ctx->fstate[i] = ff_iir_filter_init_state(FILT_ORDER);
         }
     }
 
     ff_iir_filter_init(&ctx->fiir);
 
     return ctx;
 }
 
commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/snow.c b/libavcodec/snow.c
--- a/libavcodec/snow.c
+++ b/libavcodec/snow.c
@@ -111,15 +111,15 @@
 int ff_snow_alloc_blocks(SnowContext *s){
     int w= AV_CEIL_RSHIFT(s->avctx->width,  LOG2_MB_SIZE);
     int h= AV_CEIL_RSHIFT(s->avctx->height, LOG2_MB_SIZE);
 
     s->b_width = w;
     s->b_height= h;
 
     av_free(s->block);
-    s->block= av_mallocz_array(w * h,  sizeof(BlockNode) << (s->block_max_depth*2));
+    s->block = av_calloc(w * h,  sizeof(*s->block) << (s->block_max_depth*2));
     if (!s->block)
         return AVERROR(ENOMEM);
 
     return 0;
 }
 
[func] **new** commit e44cb7363fed11b638f1cfc798d942bcf1e4db50
Date:   Sun May 23 11:18:18 2021 -0300

    avcodec/utils: don't use ff_fast_mallocz() in av_fast_padded_malloc()
    
    It will be removed in the next commit.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/utils.c b/libavcodec/utils.c
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -50,12 +50,13 @@
 void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
 {
     uint8_t **p = ptr;
     if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
         av_freep(p);
         *size = 0;
         return;
     }
-    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))
+    av_fast_mallocz(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (*p)
         memset(*p + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 }
 
commit e44cb7363fed11b638f1cfc798d942bcf1e4db50
Date:   Sun May 23 11:18:18 2021 -0300

    avcodec/utils: don't use ff_fast_mallocz() in av_fast_padded_malloc()
    
    It will be removed in the next commit.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavcodec/utils.c b/libavcodec/utils.c
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -62,12 +63,13 @@
 void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
 {
     uint8_t **p = ptr;
     if (min_size > SIZE_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {
         av_freep(p);
         *size = 0;
         return;
     }
-    if (!ff_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE, 1))
+    av_fast_malloc(p, size, min_size + AV_INPUT_BUFFER_PADDING_SIZE);
+    if (*p)
         memset(*p, 0, min_size + AV_INPUT_BUFFER_PADDING_SIZE);
 }
 
[safe] **new** commit 26e7d7b14e7a3912aa0ce59ebab191a9c2d9edfa
Date:   Tue Jun 28 11:15:12 2022 +0000

    avcodec/v4l2_m2m: Check if the file descriptor is valid before closing
    
    Fixes ticket #9507.
    
    Reviewed-by: Steven Liu <liuqi05@kuaishou.com>
    Signed-off-by: wujian_nanjing <wujian2@huawei.com>

diff --git a/libavcodec/v4l2_m2m.c b/libavcodec/v4l2_m2m.c
--- a/libavcodec/v4l2_m2m.c
+++ b/libavcodec/v4l2_m2m.c
@@ -247,15 +247,16 @@
 static void v4l2_m2m_destroy_context(void *opaque, uint8_t *context)
 {
     V4L2m2mContext *s = (V4L2m2mContext*)context;
 
     ff_v4l2_context_release(&s->capture);
     sem_destroy(&s->refsync);
 
-    close(s->fd);
+    if (s->fd >= 0)
+        close(s->fd);
     av_frame_unref(s->frame);
     av_frame_free(&s->frame);
     av_packet_unref(&s->buf_pkt);
 
     av_free(s);
 }
 
[func] **new** commit 2146b6555343964b79261e5ab3865cc6ed7ba254
Date:   Mon Aug 2 05:29:06 2021 +0200

    avutil/internal: Move MAKE_ACCESSORS to its only user
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/vdpau.c b/libavcodec/vdpau.c
--- a/libavcodec/vdpau.c
+++ b/libavcodec/vdpau.c
@@ -67,5 +67,8 @@
 AVVDPAUContext *av_alloc_vdpaucontext(void)
 {
     return av_vdpau_alloc_context();
 }
 
+#define MAKE_ACCESSORS(str, name, type, field) \
+    type av_##name##_get_##field(const str *s) { return s->field; } \
+    void av_##name##_set_##field(str *s, type v) { s->field = v; }
[func] **new** commit 0d629c390ea7a51ffe35b08cff692046ec3efd4d
Date:   Tue Mar 15 13:08:54 2022 +0100

    avcodec/zlib_wrapper: Use our allocation, freeing functions
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/zlib_wrapper.c b/libavcodec/zlib_wrapper.c
--- a/libavcodec/zlib_wrapper.c
+++ b/libavcodec/zlib_wrapper.c
@@ -28,0 +29,5 @@
+static void *alloc_wrapper(void *opaque, uInt items, uInt size)
+{
+    return av_malloc_array(items, size);
+}
+
[func] **new** commit 9cae7f94502b7d8dca7f3458b02b8f3ef2b1a324
Date:   Tue Mar 15 17:56:38 2022 +0100

    avcodec/zlib_wrapper: Add wrapper for deflateInit()
    
    The rationale is the same as for the wrappers for inflateInit(),
    although the case for it is admittedly not so strong because
    there are less users of deflateInit().
    Also remove an unnecessary inclusion of config.h in
    libavformat/protocols.c in order to trigger a request for reconfigure
    (which is needed for CONFIG_DEFLATE_WRAPPER to take effect).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/zlib_wrapper.c b/libavcodec/zlib_wrapper.c
--- a/libavcodec/zlib_wrapper.c
+++ b/libavcodec/zlib_wrapper.c
@@ -34,5 +35,6 @@
 static void free_wrapper(void *opaque, void *ptr)
 {
     av_free(ptr);
 }
 
+#if CONFIG_INFLATE_WRAPPER

commit 0d629c390ea7a51ffe35b08cff692046ec3efd4d
Date:   Tue Mar 15 13:08:54 2022 +0100

    avcodec/zlib_wrapper: Use our allocation, freeing functions
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavcodec/zlib_wrapper.c b/libavcodec/zlib_wrapper.c
--- a/libavcodec/zlib_wrapper.c
+++ b/libavcodec/zlib_wrapper.c
@@ -28,0 +34,5 @@
+static void free_wrapper(void *opaque, void *ptr)
+{
+    av_free(ptr);
+}
+
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavdevice/xcbgrab.c b/libavdevice/xcbgrab.c
--- a/libavdevice/xcbgrab.c
+++ b/libavdevice/xcbgrab.c
@@ -239,26 +239,26 @@
-static AVBufferRef *allocate_shm_buffer(void *opaque, buffer_size_t size)
+static AVBufferRef *allocate_shm_buffer(void *opaque, size_t size)
 {
     xcb_connection_t *conn = opaque;
     xcb_shm_seg_t segment;
     AVBufferRef *ref;
     uint8_t *data;
     int id;
 
     id = shmget(IPC_PRIVATE, size, IPC_CREAT | 0777);
     if (id == -1)
         return NULL;
 
     segment = xcb_generate_id(conn);
     xcb_shm_attach(conn, segment, id, 0);
     data = shmat(id, NULL, 0);
     shmctl(id, IPC_RMID, 0);
     if ((intptr_t)data == -1 || !data)
         return NULL;
 
     ref = av_buffer_create(data, size, free_shm_buffer, (void *)(ptrdiff_t)segment, 0);
     if (!ref)
         shmdt(data);
 
     return ref;
 }
 

[incr] **new** commit f7abb53cb427515faac582f114ab97cbbd590280
Date:   Sat Mar 6 13:30:00 2021 -0300

    avdevice: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavdevice/xcbgrab.c b/libavdevice/xcbgrab.c
--- a/libavdevice/xcbgrab.c
+++ b/libavdevice/xcbgrab.c
@@ -239,26 +239,26 @@
-static AVBufferRef *allocate_shm_buffer(void *opaque, int size)
+static AVBufferRef *allocate_shm_buffer(void *opaque, buffer_size_t size)
 {
     xcb_connection_t *conn = opaque;
     xcb_shm_seg_t segment;
     AVBufferRef *ref;
     uint8_t *data;
     int id;
 
     id = shmget(IPC_PRIVATE, size, IPC_CREAT | 0777);
     if (id == -1)
         return NULL;
 
     segment = xcb_generate_id(conn);
     xcb_shm_attach(conn, segment, id, 0);
     data = shmat(id, NULL, 0);
     shmctl(id, IPC_RMID, 0);
     if ((intptr_t)data == -1 || !data)
         return NULL;
 
     ref = av_buffer_create(data, size, free_shm_buffer, (void *)(ptrdiff_t)segment, 0);
     if (!ref)
         shmdt(data);
 
     return ref;
 }
 
commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -663,59 +663,59 @@
 AVFilterContext *ff_filter_alloc(const AVFilter *filter, const char *inst_name)
 {
     AVFilterContext *ret;
     int preinited = 0;
 
     if (!filter)
         return NULL;
 
     ret = av_mallocz(sizeof(AVFilterContext));
     if (!ret)
         return NULL;
 
     ret->av_class = &avfilter_class;
     ret->filter   = filter;
     ret->name     = inst_name ? av_strdup(inst_name) : NULL;
     if (filter->priv_size) {
         ret->priv     = av_mallocz(filter->priv_size);
         if (!ret->priv)
             goto err;
     }
     if (filter->preinit) {
         if (filter->preinit(ret) < 0)
             goto err;
         preinited = 1;
     }
 
     av_opt_set_defaults(ret);
     if (filter->priv_class) {
         *(const AVClass**)ret->priv = filter->priv_class;
         av_opt_set_defaults(ret->priv);
     }
 
     ret->internal = av_mallocz(sizeof(*ret->internal));
     if (!ret->internal)
         goto err;
     ret->internal->execute = default_execute;
 
     ret->nb_inputs  = filter->nb_inputs;
     if (ret->nb_inputs ) {
         ret->input_pads   = av_memdup(filter->inputs,  ret->nb_inputs  * sizeof(*filter->inputs));
         if (!ret->input_pads)
             goto err;
-        ret->inputs       = av_mallocz_array(ret->nb_inputs, sizeof(AVFilterLink*));
+        ret->inputs      = av_calloc(ret->nb_inputs, sizeof(*ret->inputs));
         if (!ret->inputs)
             goto err;
     }
 
     ret->nb_outputs = filter->nb_outputs;
     if (ret->nb_outputs) {
         ret->output_pads  = av_memdup(filter->outputs, ret->nb_outputs * sizeof(*filter->outputs));
         if (!ret->output_pads)
             goto err;
-        ret->outputs      = av_mallocz_array(ret->nb_outputs, sizeof(AVFilterLink*));
+        ret->outputs     = av_calloc(ret->nb_outputs, sizeof(*ret->outputs));
         if (!ret->outputs)
             goto err;
     }
 
     return ret;
 

[func] **new** commit 8be701d9f7f77ff2282cc7fe6e0791ca5419de70
Date:   Thu Aug 12 13:05:31 2021 +0200

    avfilter/avfilter: Add numbers of (in|out)pads directly to AVFilter
    
    Up until now, an AVFilter's lists of input and output AVFilterPads
    were terminated by a sentinel and the only way to get the length
    of these lists was by using avfilter_pad_count(). This has two
    drawbacks: first, sizeof(AVFilterPad) is not negligible
    (i.e. 64B on 64bit systems); second, getting the size involves
    a function call instead of just reading the data.
    
    This commit therefore changes this. The sentinels are removed and new
    private fields nb_inputs and nb_outputs are added to AVFilter that
    contain the number of elements of the respective AVFilterPad array.
    
    Given that AVFilter.(in|out)puts are the only arrays of zero-terminated
    AVFilterPads an API user has access to (AVFilterContext.(in|out)put_pads
    are not zero-terminated and they already have a size field) the argument
    to avfilter_pad_count() is always one of these lists, so it just has to
    find the filter the list belongs to and read said number. This is slower
    than before, but a replacement function that just reads the internal numbers
    that users are expected to switch to will be added soon; and furthermore,
    avfilter_pad_count() is probably never called in hot loops anyway.
    
    This saves about 49KiB from the binary; notice that these sentinels are
    not in .bss despite being zeroed: they are in .data.rel.ro due to the
    non-sentinels.
    
    Reviewed-by: Nicolas George <george@nsup.org>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -616,59 +622,59 @@
 AVFilterContext *ff_filter_alloc(const AVFilter *filter, const char *inst_name)
 {
     AVFilterContext *ret;
     int preinited = 0;
 
     if (!filter)
         return NULL;
 
     ret = av_mallocz(sizeof(AVFilterContext));
     if (!ret)
         return NULL;
 
     ret->av_class = &avfilter_class;
     ret->filter   = filter;
     ret->name     = inst_name ? av_strdup(inst_name) : NULL;
     if (filter->priv_size) {
         ret->priv     = av_mallocz(filter->priv_size);
         if (!ret->priv)
             goto err;
     }
     if (filter->preinit) {
         if (filter->preinit(ret) < 0)
             goto err;
         preinited = 1;
     }
 
     av_opt_set_defaults(ret);
     if (filter->priv_class) {
         *(const AVClass**)ret->priv = filter->priv_class;
         av_opt_set_defaults(ret->priv);
     }
 
     ret->internal = av_mallocz(sizeof(*ret->internal));
     if (!ret->internal)
         goto err;
     ret->internal->execute = default_execute;
 
-    ret->nb_inputs = avfilter_pad_count(filter->inputs);
+    ret->nb_inputs  = filter->nb_inputs;
     if (ret->nb_inputs ) {
         ret->input_pads   = av_memdup(filter->inputs,  ret->nb_inputs  * sizeof(*filter->inputs));
         if (!ret->input_pads)
             goto err;
         ret->inputs       = av_mallocz_array(ret->nb_inputs, sizeof(AVFilterLink*));
         if (!ret->inputs)
             goto err;
     }
 
-    ret->nb_outputs = avfilter_pad_count(filter->outputs);
+    ret->nb_outputs = filter->nb_outputs;
     if (ret->nb_outputs) {
         ret->output_pads  = av_memdup(filter->outputs, ret->nb_outputs * sizeof(*filter->outputs));
         if (!ret->output_pads)
             goto err;
         ret->outputs      = av_mallocz_array(ret->nb_outputs, sizeof(AVFilterLink*));
         if (!ret->outputs)
             goto err;
     }
 
     return ret;
 

[func] **new** commit 35b1f46d7930b052d8accb63ccf0993451ae36f2
Date:   Mon Aug 9 08:45:00 2021 +0200

    avfilter/avfilter: Use av_memdup where appropriate
    
    Reviewed-by: Nicolas George <george@nsup.org>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -623,61 +623,59 @@
 AVFilterContext *ff_filter_alloc(const AVFilter *filter, const char *inst_name)
 {
     AVFilterContext *ret;
     int preinited = 0;
 
     if (!filter)
         return NULL;
 
     ret = av_mallocz(sizeof(AVFilterContext));
     if (!ret)
         return NULL;
 
     ret->av_class = &avfilter_class;
     ret->filter   = filter;
     ret->name     = inst_name ? av_strdup(inst_name) : NULL;
     if (filter->priv_size) {
         ret->priv     = av_mallocz(filter->priv_size);
         if (!ret->priv)
             goto err;
     }
     if (filter->preinit) {
         if (filter->preinit(ret) < 0)
             goto err;
         preinited = 1;
     }
 
     av_opt_set_defaults(ret);
     if (filter->priv_class) {
         *(const AVClass**)ret->priv = filter->priv_class;
         av_opt_set_defaults(ret->priv);
     }
 
     ret->internal = av_mallocz(sizeof(*ret->internal));
     if (!ret->internal)
         goto err;
     ret->internal->execute = default_execute;
 
     ret->nb_inputs = avfilter_pad_count(filter->inputs);
     if (ret->nb_inputs ) {
-        ret->input_pads   = av_malloc_array(ret->nb_inputs, sizeof(AVFilterPad));
+        ret->input_pads   = av_memdup(filter->inputs,  ret->nb_inputs  * sizeof(*filter->inputs));
         if (!ret->input_pads)
             goto err;
-        memcpy(ret->input_pads, filter->inputs, sizeof(AVFilterPad) * ret->nb_inputs);
         ret->inputs       = av_mallocz_array(ret->nb_inputs, sizeof(AVFilterLink*));
         if (!ret->inputs)
             goto err;
     }
 
     ret->nb_outputs = avfilter_pad_count(filter->outputs);
     if (ret->nb_outputs) {
-        ret->output_pads  = av_malloc_array(ret->nb_outputs, sizeof(AVFilterPad));
+        ret->output_pads  = av_memdup(filter->outputs, ret->nb_outputs * sizeof(*filter->outputs));
         if (!ret->output_pads)
             goto err;
-        memcpy(ret->output_pads, filter->outputs, sizeof(AVFilterPad) * ret->nb_outputs);
         ret->outputs      = av_mallocz_array(ret->nb_outputs, sizeof(AVFilterLink*));
         if (!ret->outputs)
             goto err;
     }
 
     return ret;
 
[func] **new** commit 1f96db959c1235bb7079d354e09914a0a2608f62
Date:   Tue Aug 31 11:03:14 2021 -0300

    avfilter: convert to new channel layout API
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -200,11 +200,12 @@
 void avfilter_link_free(AVFilterLink **link)
 {
     if (!*link)
         return;
 
     ff_framequeue_free(&(*link)->fifo);
     ff_frame_pool_uninit((FFFramePool**)&(*link)->frame_pool);
+    av_channel_layout_uninit(&(*link)->ch_layout);
 
     av_freep(link);
 }
 

[func] **new** commit 304cb08693220b1e8a09273f28688537fd9ff39e
Date:   Thu Aug 5 06:30:54 2021 +0200

    avfilter/avfilter: Remove unused partial_buf
    
    It is unused since 02aa0701ae0dc2def8db640c9e3c06dc1b5de70c.
    The corresponding size field is write-only since then.
    
    Reviewed-by: Nicolas George <george@nsup.org>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -175,12 +175,11 @@
 void avfilter_link_free(AVFilterLink **link)
 {
     if (!*link)
         return;
 
-    av_frame_free(&(*link)->partial_buf);
     ff_framequeue_free(&(*link)->fifo);
     ff_frame_pool_uninit((FFFramePool**)&(*link)->frame_pool);
 
     av_freep(link);
 }
 
[func] **new** commit 5a7978a694e7cab4684181ca4020caf0ce8cbb06
Date:   Wed Sep 21 03:51:39 2022 +0200

    avfilter/avfilter: Make ff_command_queue_pop() static
    
    Only used here.
    
    Reviewed-by: Nicolas George <george@nsup.org>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -747,46 +747,46 @@
 void avfilter_free(AVFilterContext *filter)
 {
     int i;
 
     if (!filter)
         return;
 
     if (filter->graph)
         ff_filter_graph_remove_filter(filter->graph, filter);
 
     if (filter->filter->uninit)
         filter->filter->uninit(filter);
 
     for (i = 0; i < filter->nb_inputs; i++) {
         free_link(filter->inputs[i]);
         if (filter->input_pads[i].flags  & AVFILTERPAD_FLAG_FREE_NAME)
             av_freep(&filter->input_pads[i].name);
     }
     for (i = 0; i < filter->nb_outputs; i++) {
         free_link(filter->outputs[i]);
         if (filter->output_pads[i].flags & AVFILTERPAD_FLAG_FREE_NAME)
             av_freep(&filter->output_pads[i].name);
     }
 
     if (filter->filter->priv_class)
         av_opt_free(filter->priv);
 
     av_buffer_unref(&filter->hw_device_ctx);
 
     av_freep(&filter->name);
     av_freep(&filter->input_pads);
     av_freep(&filter->output_pads);
     av_freep(&filter->inputs);
     av_freep(&filter->outputs);
     av_freep(&filter->priv);
     while(filter->command_queue){
-        ff_command_queue_pop(filter);
+        command_queue_pop(filter);
     }
     av_opt_free(filter);
     av_expr_free(filter->enable);
     filter->enable = NULL;
     av_freep(&filter->var_values);
     av_freep(&filter->internal);
     av_free(filter);
 }
 

[func] **new** commit f308f37441ec0d49166641843acd5302c1e26e6a
Date:   Wed Aug 11 21:54:31 2021 +0200

    avfilter/avfilter: Allow to free non-static pads generically
    
    This can be enabled/disabled on a per-pad basis by setting
    the AVFILTERPAD_FLAG_FREE_NAME flag; variants of ff_append_(in|out)pads
    that do this for you have been added and will be put to use in the
    following commits.
    
    Reviewed-by: Nicolas George <george@nsup.org>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -742,42 +757,46 @@
 void avfilter_free(AVFilterContext *filter)
 {
     int i;
 
     if (!filter)
         return;
 
     if (filter->graph)
         ff_filter_graph_remove_filter(filter->graph, filter);
 
     if (filter->filter->uninit)
         filter->filter->uninit(filter);
 
     for (i = 0; i < filter->nb_inputs; i++) {
         free_link(filter->inputs[i]);
+        if (filter->input_pads[i].flags  & AVFILTERPAD_FLAG_FREE_NAME)
+            av_freep(&filter->input_pads[i].name);
     }
     for (i = 0; i < filter->nb_outputs; i++) {
         free_link(filter->outputs[i]);
+        if (filter->output_pads[i].flags & AVFILTERPAD_FLAG_FREE_NAME)
+            av_freep(&filter->output_pads[i].name);
     }
 
     if (filter->filter->priv_class)
         av_opt_free(filter->priv);
 
     av_buffer_unref(&filter->hw_device_ctx);
 
     av_freep(&filter->name);
     av_freep(&filter->input_pads);
     av_freep(&filter->output_pads);
     av_freep(&filter->inputs);
     av_freep(&filter->outputs);
     av_freep(&filter->priv);
     while(filter->command_queue){
         ff_command_queue_pop(filter);
     }
     av_opt_free(filter);
     av_expr_free(filter->enable);
     filter->enable = NULL;
     av_freep(&filter->var_values);
     av_freep(&filter->internal);
     av_free(filter);
 }
 
[func] **new** commit 0615a39fed74c3d557c54ddb3c646bf98aa6bcf0
Date:   Tue Sep 28 08:32:30 2021 +0200

    avfilter/avfiltergraph: Free AVFilterGraph options properly
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/avfiltergraph.c b/libavfilter/avfiltergraph.c
--- a/libavfilter/avfiltergraph.c
+++ b/libavfilter/avfiltergraph.c
@@ -121,19 +121,19 @@
 void avfilter_graph_free(AVFilterGraph **graph)
 {
     if (!*graph)
         return;
 
     while ((*graph)->nb_filters)
         avfilter_free((*graph)->filters[0]);
 
     ff_graph_thread_free(*graph);
 
     av_freep(&(*graph)->sink_links);
 
-    av_freep(&(*graph)->scale_sws_opts);
-    av_freep(&(*graph)->aresample_swr_opts);
+    av_opt_free(*graph);
+
     av_freep(&(*graph)->filters);
     av_freep(&(*graph)->internal);
     av_freep(graph);
 }
 

[func] **new** commit 339af976b6fd9c05d1e75e75a5323efdb3d6afa1
Date:   Sat Mar 6 17:52:24 2021 +0100

    avfilter: Remove deprecated resample_lavr_opts
    
    Deprecated in 3796fb2692f87d0000fc0aa4572ac025a6469c2b.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/avfiltergraph.c b/libavfilter/avfiltergraph.c
--- a/libavfilter/avfiltergraph.c
+++ b/libavfilter/avfiltergraph.c
@@ -120,22 +120,19 @@
 void avfilter_graph_free(AVFilterGraph **graph)
 {
     if (!*graph)
         return;
 
     while ((*graph)->nb_filters)
         avfilter_free((*graph)->filters[0]);
 
     ff_graph_thread_free(*graph);
 
     av_freep(&(*graph)->sink_links);
 
     av_freep(&(*graph)->scale_sws_opts);
     av_freep(&(*graph)->aresample_swr_opts);
-#if FF_API_LAVR_OPTS
-    av_freep(&(*graph)->resample_lavr_opts);
-#endif
     av_freep(&(*graph)->filters);
     av_freep(&(*graph)->internal);
     av_freep(graph);
 }
 
[func] **new** commit d0a999a0ab8313fd1b5e9cb09e35fb769fb3e51c
Date:   Wed Mar 2 23:35:56 2022 +0530

    libavfilter: Remove DNNReturnType from DNN Module
    
    This patch removes all occurences of DNNReturnType from the DNN module.
    This commit replaces DNN_SUCCESS by 0 (essentially the same), so the
    functions with DNNReturnType now return 0 in case of success, the negative
    values otherwise.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -137,21 +137,21 @@
 static TFInferRequest *tf_create_inference_request(void)
 {
     TFInferRequest *infer_request = av_malloc(sizeof(TFInferRequest));
     if (!infer_request) {
         return NULL;
     }
     infer_request->tf_outputs = NULL;
     infer_request->tf_input = NULL;
     infer_request->input_tensor = NULL;
     infer_request->output_tensors = NULL;
     return infer_request;
 }
 
 /**
  * Start synchronous inference for the TensorFlow model.
  *
  * @param request pointer to the TFRequestItem for inference
- * @retval DNN_SUCCESS if execution is successful
+ * @retval 0 if execution is successful
  * @retval AVERROR(EINVAL) if request is NULL
  * @retval DNN_GENERIC_ERROR if execution fails
  */

[func] **new** commit 3fa89bd7587f725eeebf1b42adda987eacef1962
Date:   Wed Mar 2 23:35:53 2022 +0530

    lavfi/dnn_backend_tf: Return Specific Error Codes
    
    Switch to returning specific error codes or DNN_GENERIC_ERROR
    when an error is encountered. For TensorFlow C API errors, currently
    DNN_GENERIC_ERROR is returned.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -137,20 +137,21 @@
 static TFInferRequest *tf_create_inference_request(void)
 {
     TFInferRequest *infer_request = av_malloc(sizeof(TFInferRequest));
     if (!infer_request) {
         return NULL;
     }
     infer_request->tf_outputs = NULL;
     infer_request->tf_input = NULL;
     infer_request->input_tensor = NULL;
     infer_request->output_tensors = NULL;
     return infer_request;
 }
 
 /**
  * Start synchronous inference for the TensorFlow model.
  *
  * @param request pointer to the TFRequestItem for inference
  * @retval DNN_SUCCESS if execution is successful
- * @retval DNN_ERROR if execution fails
+ * @retval AVERROR(EINVAL) if request is NULL
+ * @retval DNN_GENERIC_ERROR if execution fails
  */

[safe] **new** commit 371e5672f39284a8422574770f2505a61f73b683
Date:   Sun Aug 8 16:25:38 2021 +0530

    lavfi/dnn_backend_tf: Error Handling for tf_create_inference_request
    
    This commit includes the check for the case when the newly created
    TFInferRequest is NULL.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -135,17 +135,20 @@
 static TFInferRequest *tf_create_inference_request(void)
 {
     TFInferRequest *infer_request = av_malloc(sizeof(TFInferRequest));
+    if (!infer_request) {
+        return NULL;
+    }
     infer_request->tf_outputs = NULL;
     infer_request->tf_input = NULL;
     infer_request->input_tensor = NULL;
     infer_request->output_tensors = NULL;
     return infer_request;
 }
 
 /**
  * Start synchronous inference for the TensorFlow model.
  *
  * @param request pointer to the TFRequestItem for inference
  * @retval DNN_SUCCESS if execution is successful
  * @retval DNN_ERROR if execution fails
  */

commit e6ae8fc18e579e1ca750ed392da2df3474b88976
Date:   Sun Aug 8 16:25:33 2021 +0530

    lavfi/dnn_backend_tf: TFInferRequest Execution and Documentation
    
    This commit adds a function for execution of TFInferRequest and documentation
    for functions related to TFInferRequest.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -120,10 +133,17 @@
 static TFInferRequest *tf_create_inference_request(void)
 {
     TFInferRequest *infer_request = av_malloc(sizeof(TFInferRequest));
     infer_request->tf_outputs = NULL;
     infer_request->tf_input = NULL;
     infer_request->input_tensor = NULL;
     infer_request->output_tensors = NULL;
     return infer_request;
 }
 
+/**
+ * Start synchronous inference for the TensorFlow model.
+ *
+ * @param request pointer to the TFRequestItem for inference
+ * @retval DNN_SUCCESS if execution is successful
+ * @retval DNN_ERROR if execution fails
+ */

[func] **new** commit a4de605110cb19ea6cf9fc244028f0f37fb40fc0
Date:   Mon Jul 5 16:00:54 2021 +0530

    lavfi/dnn_backend_tf: Add TFInferRequest and TFRequestItem
    
    This commit introduces a typedef TFInferRequest to store
    execution parameters for a single call to the TensorFlow C API.
    This typedef is used in the TFRequestItem.
    
    Signed-off-by: Shubhanshu Saxena <shubhanshu.e01@gmail.com>

diff --git a/libavfilter/dnn/dnn_backend_tf.c b/libavfilter/dnn/dnn_backend_tf.c
--- a/libavfilter/dnn/dnn_backend_tf.c
+++ b/libavfilter/dnn/dnn_backend_tf.c
@@ -75,0 +114,10 @@
+static TFInferRequest *tf_create_inference_request(void)
+{
+    TFInferRequest *infer_request = av_malloc(sizeof(TFInferRequest));
+    infer_request->tf_outputs = NULL;
+    infer_request->tf_input = NULL;
+    infer_request->input_tensor = NULL;
+    infer_request->output_tensors = NULL;
+    return infer_request;
+}
+
[safe] **new** commit ee88804d07c145bc7bca40c94bf6fd4cf71c06e4
Date:   Thu Mar 3 14:01:36 2022 -0300

    avfilter/framepool: remove superfluous pallete buffer allocation
    
    av_image_fill_plane_sizes() already sets sizes[1] to AVPALETTE_SIZE.
    Should fix memory leaks.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -51,68 +51,58 @@
 FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(size_t size),
                                       int width,
                                       int height,
                                       enum AVPixelFormat format,
                                       int align)
 {
     int i, ret;
     FFFramePool *pool;
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
     ptrdiff_t linesizes[4];
     size_t sizes[4];
 
-    if (!desc)
-        return NULL;
-
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     pool->type = AVMEDIA_TYPE_VIDEO;
     pool->width = width;
     pool->height = height;
     pool->format = format;
     pool->align = align;
 
     if ((ret = av_image_check_size2(width, height, INT64_MAX, format, 0, NULL)) < 0) {
         goto fail;
     }
 
     if (!pool->linesize[0]) {
         ret = av_image_fill_linesizes(pool->linesize, pool->format,
                                       FFALIGN(pool->width, align));
         if (ret < 0) {
             goto fail;
         }
 
         for (i = 0; i < 4 && pool->linesize[i]; i++) {
             pool->linesize[i] = FFALIGN(pool->linesize[i], pool->align);
             if ((pool->linesize[i] & (pool->align - 1)))
                 goto fail;
         }
     }
 
     for (i = 0; i < 4; i++)
         linesizes[i] = pool->linesize[i];
 
     if (av_image_fill_plane_sizes(sizes, pool->format,
                                   pool->height,
                                   linesizes) < 0) {
         goto fail;
     }
 
     for (i = 0; i < 4 && sizes[i]; i++) {
         if (sizes[i] > SIZE_MAX - align)
             goto fail;
         pool->pools[i] = av_buffer_pool_init(sizes[i] + align, alloc);
         if (!pool->pools[i])
             goto fail;
     }
 
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
-        pool->pools[1] = av_buffer_pool_init(AVPALETTE_SIZE, alloc);
-        if (!pool->pools[1])
-            goto fail;
-    }
-
     return pool;
 

[func] **new** commit 8fcd9d7375979baf2d09e97b36dd482b6210a999
Date:   Tue Mar 1 11:05:40 2022 -0300

    avfilter/framepool: use av_image_fill_plane_sizes() to calculate pool sizes
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -51,60 +51,68 @@
 FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(size_t size),
                                       int width,
                                       int height,
                                       enum AVPixelFormat format,
                                       int align)
 {
     int i, ret;
     FFFramePool *pool;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
+    ptrdiff_t linesizes[4];
+    size_t sizes[4];
 
     if (!desc)
         return NULL;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     pool->type = AVMEDIA_TYPE_VIDEO;
     pool->width = width;
     pool->height = height;
     pool->format = format;
     pool->align = align;
 
     if ((ret = av_image_check_size2(width, height, INT64_MAX, format, 0, NULL)) < 0) {
         goto fail;
     }
 
     if (!pool->linesize[0]) {
         ret = av_image_fill_linesizes(pool->linesize, pool->format,
                                       FFALIGN(pool->width, align));
         if (ret < 0) {
             goto fail;
         }
 
         for (i = 0; i < 4 && pool->linesize[i]; i++) {
             pool->linesize[i] = FFALIGN(pool->linesize[i], pool->align);
             if ((pool->linesize[i] & (pool->align - 1)))
                 goto fail;
         }
     }
 
-    for (i = 0; i < 4 && pool->linesize[i]; i++) {
-        int h = pool->height;
-        if (i == 1 || i == 2)
-            h = AV_CEIL_RSHIFT(h, desc->log2_chroma_h);
+    for (i = 0; i < 4; i++)
+        linesizes[i] = pool->linesize[i];
 
-        pool->pools[i] = av_buffer_pool_init(pool->linesize[i] * h + align,
-                                             alloc);
+    if (av_image_fill_plane_sizes(sizes, pool->format,
+                                  pool->height,
+                                  linesizes) < 0) {
+        goto fail;
+    }
+
+    for (i = 0; i < 4 && sizes[i]; i++) {
+        if (sizes[i] > SIZE_MAX - align)
+            goto fail;
+        pool->pools[i] = av_buffer_pool_init(sizes[i] + align, alloc);
         if (!pool->pools[i])
             goto fail;
     }
 
     if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         pool->pools[1] = av_buffer_pool_init(AVPALETTE_SIZE, alloc);
         if (!pool->pools[1])
             goto fail;
     }
 
     return pool;
 

[func] **new** commit 17a59a634c39b00a680c6ebbaea58db95594d13d
Date:   Sun Feb 20 19:06:52 2022 +0100

    avfilter/framepool: fix alignment requirements for audio and video filters

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -51,62 +51,60 @@
 FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(size_t size),
                                       int width,
                                       int height,
                                       enum AVPixelFormat format,
                                       int align)
 {
     int i, ret;
     FFFramePool *pool;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
 
     if (!desc)
         return NULL;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     pool->type = AVMEDIA_TYPE_VIDEO;
     pool->width = width;
     pool->height = height;
     pool->format = format;
     pool->align = align;
 
     if ((ret = av_image_check_size2(width, height, INT64_MAX, format, 0, NULL)) < 0) {
         goto fail;
     }
 
     if (!pool->linesize[0]) {
-        for(i = 1; i <= align; i += i) {
-            ret = av_image_fill_linesizes(pool->linesize, pool->format,
-                                          FFALIGN(pool->width, i));
-            if (ret < 0) {
-                goto fail;
-            }
-            if (!(pool->linesize[0] & (pool->align - 1)))
-                break;
+        ret = av_image_fill_linesizes(pool->linesize, pool->format,
+                                      FFALIGN(pool->width, align));
+        if (ret < 0) {
+            goto fail;
         }
 
         for (i = 0; i < 4 && pool->linesize[i]; i++) {
             pool->linesize[i] = FFALIGN(pool->linesize[i], pool->align);
+            if ((pool->linesize[i] & (pool->align - 1)))
+                goto fail;
         }
     }
 
     for (i = 0; i < 4 && pool->linesize[i]; i++) {
-        int h = FFALIGN(pool->height, 32);
+        int h = pool->height;
         if (i == 1 || i == 2)
             h = AV_CEIL_RSHIFT(h, desc->log2_chroma_h);
 
-        pool->pools[i] = av_buffer_pool_init(pool->linesize[i] * h + 16 + 16 - 1,
+        pool->pools[i] = av_buffer_pool_init(pool->linesize[i] * h + align,
                                              alloc);
         if (!pool->pools[i])
             goto fail;
     }
 
     if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         pool->pools[1] = av_buffer_pool_init(AVPALETTE_SIZE, alloc);
         if (!pool->pools[1])
             goto fail;
     }
 
     return pool;
 

commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -51,62 +51,62 @@
-FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(buffer_size_t size),
+FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(size_t size),
                                       int width,
                                       int height,
                                       enum AVPixelFormat format,
                                       int align)
 {
     int i, ret;
     FFFramePool *pool;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
 
     if (!desc)
         return NULL;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     pool->type = AVMEDIA_TYPE_VIDEO;
     pool->width = width;
     pool->height = height;
     pool->format = format;
     pool->align = align;
 
     if ((ret = av_image_check_size2(width, height, INT64_MAX, format, 0, NULL)) < 0) {
         goto fail;
     }
 
     if (!pool->linesize[0]) {
         for(i = 1; i <= align; i += i) {
             ret = av_image_fill_linesizes(pool->linesize, pool->format,
                                           FFALIGN(pool->width, i));
             if (ret < 0) {
                 goto fail;
             }
             if (!(pool->linesize[0] & (pool->align - 1)))
                 break;
         }
 
         for (i = 0; i < 4 && pool->linesize[i]; i++) {
             pool->linesize[i] = FFALIGN(pool->linesize[i], pool->align);
         }
     }
 
     for (i = 0; i < 4 && pool->linesize[i]; i++) {
         int h = FFALIGN(pool->height, 32);
         if (i == 1 || i == 2)
             h = AV_CEIL_RSHIFT(h, desc->log2_chroma_h);
 
         pool->pools[i] = av_buffer_pool_init(pool->linesize[i] * h + 16 + 16 - 1,
                                              alloc);
         if (!pool->pools[i])
             goto fail;
     }
 
     if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         pool->pools[1] = av_buffer_pool_init(AVPALETTE_SIZE, alloc);
         if (!pool->pools[1])
             goto fail;
     }
 
     return pool;
 

[func] **new** commit 985c0dac674846721ec8ff23344c16ac7d1c9a1e
Date:   Wed Apr 14 01:46:26 2021 +0200

    avutil/pixdesc: Remove deprecated AV_PIX_FMT_FLAG_PSEUDOPAL
    
    Deprecated in d6fc031caf64eed921bbdef86d79d56bfc2633b0.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -51,63 +51,62 @@
 FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(buffer_size_t size),
                                       int width,
                                       int height,
                                       enum AVPixelFormat format,
                                       int align)
 {
     int i, ret;
     FFFramePool *pool;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
 
     if (!desc)
         return NULL;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     pool->type = AVMEDIA_TYPE_VIDEO;
     pool->width = width;
     pool->height = height;
     pool->format = format;
     pool->align = align;
 
     if ((ret = av_image_check_size2(width, height, INT64_MAX, format, 0, NULL)) < 0) {
         goto fail;
     }
 
     if (!pool->linesize[0]) {
         for(i = 1; i <= align; i += i) {
             ret = av_image_fill_linesizes(pool->linesize, pool->format,
                                           FFALIGN(pool->width, i));
             if (ret < 0) {
                 goto fail;
             }
             if (!(pool->linesize[0] & (pool->align - 1)))
                 break;
         }
 
         for (i = 0; i < 4 && pool->linesize[i]; i++) {
             pool->linesize[i] = FFALIGN(pool->linesize[i], pool->align);
         }
     }
 
     for (i = 0; i < 4 && pool->linesize[i]; i++) {
         int h = FFALIGN(pool->height, 32);
         if (i == 1 || i == 2)
             h = AV_CEIL_RSHIFT(h, desc->log2_chroma_h);
 
         pool->pools[i] = av_buffer_pool_init(pool->linesize[i] * h + 16 + 16 - 1,
                                              alloc);
         if (!pool->pools[i])
             goto fail;
     }
 
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL ||
-        desc->flags & FF_PSEUDOPAL) {
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         pool->pools[1] = av_buffer_pool_init(AVPALETTE_SIZE, alloc);
         if (!pool->pools[1])
             goto fail;
     }
 
     return pool;
 

[incr] **new** commit 5d9af1670ef2be16722f2ce8c9d8365bfbcaca23
Date:   Sat Mar 6 14:16:45 2021 -0300

    avfilter: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -51,63 +51,63 @@
-FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(int size),
+FFFramePool *ff_frame_pool_video_init(AVBufferRef* (*alloc)(buffer_size_t size),
                                       int width,
                                       int height,
                                       enum AVPixelFormat format,
                                       int align)
 {
     int i, ret;
     FFFramePool *pool;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(format);
 
     if (!desc)
         return NULL;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     pool->type = AVMEDIA_TYPE_VIDEO;
     pool->width = width;
     pool->height = height;
     pool->format = format;
     pool->align = align;
 
     if ((ret = av_image_check_size2(width, height, INT64_MAX, format, 0, NULL)) < 0) {
         goto fail;
     }
 
     if (!pool->linesize[0]) {
         for(i = 1; i <= align; i += i) {
             ret = av_image_fill_linesizes(pool->linesize, pool->format,
                                           FFALIGN(pool->width, i));
             if (ret < 0) {
                 goto fail;
             }
             if (!(pool->linesize[0] & (pool->align - 1)))
                 break;
         }
 
         for (i = 0; i < 4 && pool->linesize[i]; i++) {
             pool->linesize[i] = FFALIGN(pool->linesize[i], pool->align);
         }
     }
 
     for (i = 0; i < 4 && pool->linesize[i]; i++) {
         int h = FFALIGN(pool->height, 32);
         if (i == 1 || i == 2)
             h = AV_CEIL_RSHIFT(h, desc->log2_chroma_h);
 
         pool->pools[i] = av_buffer_pool_init(pool->linesize[i] * h + 16 + 16 - 1,
                                              alloc);
         if (!pool->pools[i])
             goto fail;
     }
 
     if (desc->flags & AV_PIX_FMT_FLAG_PAL ||
         desc->flags & FF_PSEUDOPAL) {
         pool->pools[1] = av_buffer_pool_init(AVPALETTE_SIZE, alloc);
         if (!pool->pools[1])
             goto fail;
     }
 
     return pool;
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -118,33 +118,33 @@
-FFFramePool *ff_frame_pool_audio_init(AVBufferRef* (*alloc)(buffer_size_t size),
+FFFramePool *ff_frame_pool_audio_init(AVBufferRef* (*alloc)(size_t size),
                                       int channels,
                                       int nb_samples,
                                       enum AVSampleFormat format,
                                       int align)
 {
     int ret, planar;
     FFFramePool *pool;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     planar = av_sample_fmt_is_planar(format);
 
     pool->type = AVMEDIA_TYPE_AUDIO;
     pool->planes = planar ? channels : 1;
     pool->channels = channels;
     pool->nb_samples = nb_samples;
     pool->format = format;
     pool->align = align;
 
     ret = av_samples_get_buffer_size(&pool->linesize[0], channels,
                                      nb_samples, format, 0);
     if (ret < 0)
         goto fail;
 
     pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
     if (!pool->pools[0])
         goto fail;
 
     return pool;
 

commit 5d9af1670ef2be16722f2ce8c9d8365bfbcaca23
Date:   Sat Mar 6 14:16:45 2021 -0300

    avfilter: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavfilter/framepool.c b/libavfilter/framepool.c
--- a/libavfilter/framepool.c
+++ b/libavfilter/framepool.c
@@ -119,33 +119,33 @@
-FFFramePool *ff_frame_pool_audio_init(AVBufferRef* (*alloc)(int size),
+FFFramePool *ff_frame_pool_audio_init(AVBufferRef* (*alloc)(buffer_size_t size),
                                       int channels,
                                       int nb_samples,
                                       enum AVSampleFormat format,
                                       int align)
 {
     int ret, planar;
     FFFramePool *pool;
 
     pool = av_mallocz(sizeof(FFFramePool));
     if (!pool)
         return NULL;
 
     planar = av_sample_fmt_is_planar(format);
 
     pool->type = AVMEDIA_TYPE_AUDIO;
     pool->planes = planar ? channels : 1;
     pool->channels = channels;
     pool->nb_samples = nb_samples;
     pool->format = format;
     pool->align = align;
 
     ret = av_samples_get_buffer_size(&pool->linesize[0], channels,
                                      nb_samples, format, 0);
     if (ret < 0)
         goto fail;
 
     pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
     if (!pool->pools[0])
         goto fail;
 
     return pool;
 
 

[func] **new** commit 85c938fa287c61334d01adfb038ca47bed6d106c
Date:   Fri Jan 7 11:41:42 2022 +0100

    lavfi/qsvvpp: switch to new FIFO API

diff --git a/libavfilter/qsvvpp.c b/libavfilter/qsvvpp.c
--- a/libavfilter/qsvvpp.c
+++ b/libavfilter/qsvvpp.c
@@ -655,112 +650,112 @@
 int ff_qsvvpp_create(AVFilterContext *avctx, QSVVPPContext **vpp, QSVVPPParam *param)
 {
     int i;
     int ret;
     QSVVPPContext *s;
 
     s = av_mallocz(sizeof(*s));
     if (!s)
         return AVERROR(ENOMEM);
 
     s->filter_frame  = param->filter_frame;
     if (!s->filter_frame)
         s->filter_frame = ff_filter_frame;
     s->out_sw_format = param->out_sw_format;
 
     /* create the vpp session */
     ret = init_vpp_session(avctx, s);
     if (ret < 0)
         goto failed;
 
     s->frame_infos = av_calloc(avctx->nb_inputs, sizeof(*s->frame_infos));
     if (!s->frame_infos) {
         ret = AVERROR(ENOMEM);
         goto failed;
     }
 
     /* Init each input's information */
     for (i = 0; i < avctx->nb_inputs; i++) {
         ret = fill_frameinfo_by_link(&s->frame_infos[i], avctx->inputs[i]);
         if (ret < 0)
             goto failed;
     }
 
     /* Update input's frame info according to crop */
     for (i = 0; i < param->num_crop; i++) {
         QSVVPPCrop *crop = param->crop + i;
         if (crop->in_idx > avctx->nb_inputs) {
             ret = AVERROR(EINVAL);
             goto failed;
         }
         s->frame_infos[crop->in_idx].CropX = crop->x;
         s->frame_infos[crop->in_idx].CropY = crop->y;
         s->frame_infos[crop->in_idx].CropW = crop->w;
         s->frame_infos[crop->in_idx].CropH = crop->h;
     }
 
     s->vpp_param.vpp.In = s->frame_infos[0];
 
     ret = fill_frameinfo_by_link(&s->vpp_param.vpp.Out, avctx->outputs[0]);
     if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR, "Fail to get frame info from link.\n");
         goto failed;
     }
 
     if (IS_OPAQUE_MEMORY(s->in_mem_mode) || IS_OPAQUE_MEMORY(s->out_mem_mode)) {
         s->nb_ext_buffers = param->num_ext_buf + 1;
         s->ext_buffers = av_calloc(s->nb_ext_buffers, sizeof(*s->ext_buffers));
         if (!s->ext_buffers) {
             ret = AVERROR(ENOMEM);
             goto failed;
         }
 
         s->ext_buffers[0] = (mfxExtBuffer *)&s->opaque_alloc;
         for (i = 1; i < param->num_ext_buf; i++)
             s->ext_buffers[i]    = param->ext_buf[i - 1];
         s->vpp_param.ExtParam    = s->ext_buffers;
         s->vpp_param.NumExtParam = s->nb_ext_buffers;
     } else {
         s->vpp_param.NumExtParam = param->num_ext_buf;
         s->vpp_param.ExtParam    = param->ext_buf;
     }
 
     s->got_frame = 0;
 
     /** keep fifo size at least 1. Even when async_depth is 0, fifo is used. */
-    s->async_fifo  = av_fifo_alloc((param->async_depth + 1) * qsv_fifo_item_size());
+    s->async_fifo  = av_fifo_alloc2(param->async_depth + 1, sizeof(QSVAsyncFrame), 0);
     s->async_depth = param->async_depth;
     if (!s->async_fifo) {
         ret = AVERROR(ENOMEM);
         goto failed;
     }
 
     s->vpp_param.AsyncDepth = param->async_depth;
 
     if (IS_SYSTEM_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_VIDEO_MEMORY;
     else if (IS_OPAQUE_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_OPAQUE_MEMORY;
 
     if (IS_SYSTEM_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_VIDEO_MEMORY;
     else if (IS_OPAQUE_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
 
     /* Print input memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0x0F, "VPP");
     /* Print output memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0xF0, "VPP");
     ret = MFXVideoVPP_Init(s->session, &s->vpp_param);
     if (ret < 0) {
         ret = ff_qsvvpp_print_error(avctx, ret, "Failed to create a qsvvpp");
         goto failed;
     } else if (ret > 0)
         ff_qsvvpp_print_warning(avctx, ret, "Warning When creating qsvvpp");
 
     *vpp = s;
     return 0;
 

commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/qsvvpp.c b/libavfilter/qsvvpp.c
--- a/libavfilter/qsvvpp.c
+++ b/libavfilter/qsvvpp.c
@@ -655,112 +655,112 @@
 int ff_qsvvpp_create(AVFilterContext *avctx, QSVVPPContext **vpp, QSVVPPParam *param)
 {
     int i;
     int ret;
     QSVVPPContext *s;
 
     s = av_mallocz(sizeof(*s));
     if (!s)
         return AVERROR(ENOMEM);
 
     s->filter_frame  = param->filter_frame;
     if (!s->filter_frame)
         s->filter_frame = ff_filter_frame;
     s->out_sw_format = param->out_sw_format;
 
     /* create the vpp session */
     ret = init_vpp_session(avctx, s);
     if (ret < 0)
         goto failed;
 
-    s->frame_infos = av_mallocz_array(avctx->nb_inputs, sizeof(*s->frame_infos));
+    s->frame_infos = av_calloc(avctx->nb_inputs, sizeof(*s->frame_infos));
     if (!s->frame_infos) {
         ret = AVERROR(ENOMEM);
         goto failed;
     }
 
     /* Init each input's information */
     for (i = 0; i < avctx->nb_inputs; i++) {
         ret = fill_frameinfo_by_link(&s->frame_infos[i], avctx->inputs[i]);
         if (ret < 0)
             goto failed;
     }
 
     /* Update input's frame info according to crop */
     for (i = 0; i < param->num_crop; i++) {
         QSVVPPCrop *crop = param->crop + i;
         if (crop->in_idx > avctx->nb_inputs) {
             ret = AVERROR(EINVAL);
             goto failed;
         }
         s->frame_infos[crop->in_idx].CropX = crop->x;
         s->frame_infos[crop->in_idx].CropY = crop->y;
         s->frame_infos[crop->in_idx].CropW = crop->w;
         s->frame_infos[crop->in_idx].CropH = crop->h;
     }
 
     s->vpp_param.vpp.In = s->frame_infos[0];
 
     ret = fill_frameinfo_by_link(&s->vpp_param.vpp.Out, avctx->outputs[0]);
     if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR, "Fail to get frame info from link.\n");
         goto failed;
     }
 
     if (IS_OPAQUE_MEMORY(s->in_mem_mode) || IS_OPAQUE_MEMORY(s->out_mem_mode)) {
         s->nb_ext_buffers = param->num_ext_buf + 1;
-        s->ext_buffers = av_mallocz_array(s->nb_ext_buffers, sizeof(*s->ext_buffers));
+        s->ext_buffers = av_calloc(s->nb_ext_buffers, sizeof(*s->ext_buffers));
         if (!s->ext_buffers) {
             ret = AVERROR(ENOMEM);
             goto failed;
         }
 
         s->ext_buffers[0] = (mfxExtBuffer *)&s->opaque_alloc;
         for (i = 1; i < param->num_ext_buf; i++)
             s->ext_buffers[i]    = param->ext_buf[i - 1];
         s->vpp_param.ExtParam    = s->ext_buffers;
         s->vpp_param.NumExtParam = s->nb_ext_buffers;
     } else {
         s->vpp_param.NumExtParam = param->num_ext_buf;
         s->vpp_param.ExtParam    = param->ext_buf;
     }
 
     s->got_frame = 0;
 
     /** keep fifo size at least 1. Even when async_depth is 0, fifo is used. */
     s->async_fifo  = av_fifo_alloc((param->async_depth + 1) * qsv_fifo_item_size());
     s->async_depth = param->async_depth;
     if (!s->async_fifo) {
         ret = AVERROR(ENOMEM);
         goto failed;
     }
 
     s->vpp_param.AsyncDepth = param->async_depth;
 
     if (IS_SYSTEM_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_VIDEO_MEMORY;
     else if (IS_OPAQUE_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_OPAQUE_MEMORY;
 
     if (IS_SYSTEM_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_VIDEO_MEMORY;
     else if (IS_OPAQUE_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
 
     /* Print input memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0x0F, "VPP");
     /* Print output memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0xF0, "VPP");
     ret = MFXVideoVPP_Init(s->session, &s->vpp_param);
     if (ret < 0) {
         ret = ff_qsvvpp_print_error(avctx, ret, "Failed to create a qsvvpp");
         goto failed;
     } else if (ret > 0)
         ff_qsvvpp_print_warning(avctx, ret, "Warning When creating qsvvpp");
 
     *vpp = s;
     return 0;
 

[perf] **new** commit 89ffcd1bbe1150aa07ae52a4e1545668a4e83a3e
Date:   Wed Mar 31 10:07:44 2021 +0800

    lavfi/qsvvpp: support async depth
    
    Async depth will allow qsv filter cache few frames, and avoid force
    switch and end filter task frame by frame. This change will improve
    performance for some multi-task case, for example 1:N transcode(
    decode + vpp + encode) with all QSV plugins.
    
    Performance data test on my Coffee Lake Desktop(i7-8700K) by using
    the following 1:8 transcode test case improvement:
    1. Fps improved from 55 to 130.
    2. Render/Video usage improved from ~61%/~38% to ~100%/~70%.(Data get
    from intel_gpu_top)
    
    test CMD:
    ffmpeg -v verbose -init_hw_device qsv=hw:/dev/dri/renderD128 -filter_hw_device                 \
     hw -hwaccel qsv -hwaccel_output_format qsv -c:v h264_qsv -i 1920x1080.264                     \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null -
    
    Signed-off-by: Fei Wang <fei.w.wang@intel.com>
    Reviewed-by: Linjie Fu <linjie.justin.fu@gmail.com>
    Signed-off-by: Zhong Li <zhongli_dev@126.com>

diff --git a/libavfilter/qsvvpp.c b/libavfilter/qsvvpp.c
--- a/libavfilter/qsvvpp.c
+++ b/libavfilter/qsvvpp.c
@@ -669,102 +650,112 @@
 int ff_qsvvpp_create(AVFilterContext *avctx, QSVVPPContext **vpp, QSVVPPParam *param)
 {
     int i;
     int ret;
     QSVVPPContext *s;
 
     s = av_mallocz(sizeof(*s));
     if (!s)
         return AVERROR(ENOMEM);
 
     s->filter_frame  = param->filter_frame;
     if (!s->filter_frame)
         s->filter_frame = ff_filter_frame;
     s->out_sw_format = param->out_sw_format;
 
     /* create the vpp session */
     ret = init_vpp_session(avctx, s);
     if (ret < 0)
         goto failed;
 
     s->frame_infos = av_mallocz_array(avctx->nb_inputs, sizeof(*s->frame_infos));
     if (!s->frame_infos) {
         ret = AVERROR(ENOMEM);
         goto failed;
     }
 
     /* Init each input's information */
     for (i = 0; i < avctx->nb_inputs; i++) {
         ret = fill_frameinfo_by_link(&s->frame_infos[i], avctx->inputs[i]);
         if (ret < 0)
             goto failed;
     }
 
     /* Update input's frame info according to crop */
     for (i = 0; i < param->num_crop; i++) {
         QSVVPPCrop *crop = param->crop + i;
         if (crop->in_idx > avctx->nb_inputs) {
             ret = AVERROR(EINVAL);
             goto failed;
         }
         s->frame_infos[crop->in_idx].CropX = crop->x;
         s->frame_infos[crop->in_idx].CropY = crop->y;
         s->frame_infos[crop->in_idx].CropW = crop->w;
         s->frame_infos[crop->in_idx].CropH = crop->h;
     }
 
     s->vpp_param.vpp.In = s->frame_infos[0];
 
     ret = fill_frameinfo_by_link(&s->vpp_param.vpp.Out, avctx->outputs[0]);
     if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR, "Fail to get frame info from link.\n");
         goto failed;
     }
 
     if (IS_OPAQUE_MEMORY(s->in_mem_mode) || IS_OPAQUE_MEMORY(s->out_mem_mode)) {
         s->nb_ext_buffers = param->num_ext_buf + 1;
         s->ext_buffers = av_mallocz_array(s->nb_ext_buffers, sizeof(*s->ext_buffers));
         if (!s->ext_buffers) {
             ret = AVERROR(ENOMEM);
             goto failed;
         }
 
         s->ext_buffers[0] = (mfxExtBuffer *)&s->opaque_alloc;
         for (i = 1; i < param->num_ext_buf; i++)
             s->ext_buffers[i]    = param->ext_buf[i - 1];
         s->vpp_param.ExtParam    = s->ext_buffers;
         s->vpp_param.NumExtParam = s->nb_ext_buffers;
     } else {
         s->vpp_param.NumExtParam = param->num_ext_buf;
         s->vpp_param.ExtParam    = param->ext_buf;
     }
 
-    s->vpp_param.AsyncDepth = 1;
+    s->got_frame = 0;
+
+    /** keep fifo size at least 1. Even when async_depth is 0, fifo is used. */
+    s->async_fifo  = av_fifo_alloc((param->async_depth + 1) * qsv_fifo_item_size());
+    s->async_depth = param->async_depth;
+    if (!s->async_fifo) {
+        ret = AVERROR(ENOMEM);
+        goto failed;
+    }
+
+    s->vpp_param.AsyncDepth = param->async_depth;
 
     if (IS_SYSTEM_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_VIDEO_MEMORY;
     else if (IS_OPAQUE_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_OPAQUE_MEMORY;
 
     if (IS_SYSTEM_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_VIDEO_MEMORY;
     else if (IS_OPAQUE_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
 
     /* Print input memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0x0F, "VPP");
     /* Print output memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0xF0, "VPP");
     ret = MFXVideoVPP_Init(s->session, &s->vpp_param);
     if (ret < 0) {
         ret = ff_qsvvpp_print_error(avctx, ret, "Failed to create a qsvvpp");
         goto failed;
     } else if (ret > 0)
         ff_qsvvpp_print_warning(avctx, ret, "Warning When creating qsvvpp");
 
     *vpp = s;
     return 0;
 
commit 85c938fa287c61334d01adfb038ca47bed6d106c
Date:   Fri Jan 7 11:41:42 2022 +0100

    lavfi/qsvvpp: switch to new FIFO API

diff --git a/libavfilter/qsvvpp.c b/libavfilter/qsvvpp.c
--- a/libavfilter/qsvvpp.c
+++ b/libavfilter/qsvvpp.c
@@ -773,25 +768,25 @@
 int ff_qsvvpp_free(QSVVPPContext **vpp)
 {
     QSVVPPContext *s = *vpp;
 
     if (!s)
         return 0;
 
     if (s->session) {
         MFXVideoVPP_Close(s->session);
         MFXClose(s->session);
     }
 
     /* release all the resources */
     clear_frame_list(&s->in_frame_list);
     clear_frame_list(&s->out_frame_list);
     av_freep(&s->surface_ptrs_in);
     av_freep(&s->surface_ptrs_out);
     av_freep(&s->ext_buffers);
     av_freep(&s->frame_infos);
-    av_fifo_free(s->async_fifo);
+    av_fifo_freep2(&s->async_fifo);
     av_freep(vpp);
 
     return 0;
 }
 

commit 89ffcd1bbe1150aa07ae52a4e1545668a4e83a3e
Date:   Wed Mar 31 10:07:44 2021 +0800

    lavfi/qsvvpp: support async depth
    
    Async depth will allow qsv filter cache few frames, and avoid force
    switch and end filter task frame by frame. This change will improve
    performance for some multi-task case, for example 1:N transcode(
    decode + vpp + encode) with all QSV plugins.
    
    Performance data test on my Coffee Lake Desktop(i7-8700K) by using
    the following 1:8 transcode test case improvement:
    1. Fps improved from 55 to 130.
    2. Render/Video usage improved from ~61%/~38% to ~100%/~70%.(Data get
    from intel_gpu_top)
    
    test CMD:
    ffmpeg -v verbose -init_hw_device qsv=hw:/dev/dri/renderD128 -filter_hw_device                 \
     hw -hwaccel qsv -hwaccel_output_format qsv -c:v h264_qsv -i 1920x1080.264                     \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null - \
    -vf 'vpp_qsv=w=1280:h=720:async_depth=4' -c:v h264_qsv -r:v 30 -preset 7 -g 33 -refs 2 -bf 3 -q 24 -f null -
    
    Signed-off-by: Fei Wang <fei.w.wang@intel.com>
    Reviewed-by: Linjie Fu <linjie.justin.fu@gmail.com>
    Signed-off-by: Zhong Li <zhongli_dev@126.com>

diff --git a/libavfilter/qsvvpp.c b/libavfilter/qsvvpp.c
--- a/libavfilter/qsvvpp.c
+++ b/libavfilter/qsvvpp.c
@@ -777,24 +768,25 @@
 int ff_qsvvpp_free(QSVVPPContext **vpp)
 {
     QSVVPPContext *s = *vpp;
 
     if (!s)
         return 0;
 
     if (s->session) {
         MFXVideoVPP_Close(s->session);
         MFXClose(s->session);
     }
 
     /* release all the resources */
     clear_frame_list(&s->in_frame_list);
     clear_frame_list(&s->out_frame_list);
     av_freep(&s->surface_ptrs_in);
     av_freep(&s->surface_ptrs_out);
     av_freep(&s->ext_buffers);
     av_freep(&s->frame_infos);
+    av_fifo_free(s->async_fifo);
     av_freep(vpp);
 
     return 0;
 }
 
[safe] **new** commit 2ee4077248dcd96e50efc0738e60519ffb9a4c7f
Date:   Sun Oct 3 10:10:49 2021 +0200

    avfilter/vf_morpho: Fix invalid frees on error
    
    The current code used a pointer to an array (of arrays) that
    is offset relative to the start of the actually allocated buffer.
    Yet offsetting the pointer is only done on success, whereas the
    freeing code believes it to have happened even on error.
    So if any of the subarrays (or the subarrays' subarrays) can't
    be successfully allocated, one gets a bad free in free_lut().
    
    Furthermore, said offsetting is only permissible in case the
    offsetted pointer points in the allocated buffer (here: in case
    the LUT's min_r is <= 0), as pointer arithmetic is undefined
    in case it exceeds the allocated object.
    
    Moreover, in case one of the subarrays couldn't be allocated,
    the code nevertheless tried to free the subarray's subarrays;
    and in case one of the subarray's subarrays could not be allocated
    successfully, there will be an invalid free, too, because the
    pointers for the subarrays' subarrays are also offset compared
    to the base pointer.
    
    This commit fixes all of this, by using the actually allocated
    pointer for freeing and by adding appropriate checks before
    freeing the subarrays. The former also allows to distinguish
    the cases in which the lut is currently only half-allocated due to
    an error in an earlier allocation attempt from the success case.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/vf_morpho.c b/libavfilter/vf_morpho.c
--- a/libavfilter/vf_morpho.c
+++ b/libavfilter/vf_morpho.c
@@ -263,35 +266,36 @@
 static int alloc_lut(LUT *Ty, chord_set *SE, int type_size, int mode)
 {
-    const int size = Ty->max_r + 1 - Ty->min_r;
+    const int min = FFMAX(Ty->min_r, 0);
+    const int max = min + (Ty->max_r - Ty->min_r);
     int pre_pad_x = 0;
 
     if (SE->minX < 0)
         pre_pad_x = 0 - SE->minX;
     Ty->pre_pad_x = pre_pad_x;
     Ty->type_size = type_size;
 
-    Ty->arr = av_calloc(size, sizeof(*Ty->arr));
-    if (!Ty->arr)
+    Ty->base_arr = av_calloc(max + 1, sizeof(*Ty->base_arr));
+    if (!Ty->base_arr)
         return AVERROR(ENOMEM);
-    for (int r = 0; r < Ty->max_r - Ty->min_r + 1; r++) {
-        Ty->arr[r] = av_calloc(Ty->I, sizeof(uint8_t *));
-        if (!Ty->arr[r])
+    for (int r = min; r <= max; r++) {
+        uint8_t **arr = Ty->base_arr[r] = av_calloc(Ty->I, sizeof(uint8_t *));
+        if (!Ty->base_arr[r])
             return AVERROR(ENOMEM);
         for (int i = 0; i < Ty->I; i++) {
-            Ty->arr[r][i] = av_calloc(Ty->X + pre_pad_x, type_size);
-            if (!Ty->arr[r][i])
+            arr[i] = av_calloc(Ty->X + pre_pad_x, type_size);
+            if (!arr[i])
                 return AVERROR(ENOMEM);
             if (mode == ERODE)
-                memset(Ty->arr[r][i], UINT8_MAX, pre_pad_x * type_size);
+                memset(arr[i], UINT8_MAX, pre_pad_x * type_size);
             /* Shifting the X index such that negative indices correspond to
              * the pre-padding.
              */
-            Ty->arr[r][i] = &(Ty->arr[r][i][pre_pad_x * type_size]);
+            arr[i] = &(arr[i][pre_pad_x * type_size]);
         }
     }
 
-    Ty->arr = &(Ty->arr[0 - Ty->min_r]);
+    Ty->arr = &(Ty->base_arr[min - Ty->min_r]);
 
     return 0;
 }
 

[func] **new** commit b2ec4edef798af1112ed7c3aadc3a2c91f7d3665
Date:   Mon Sep 20 13:47:45 2021 +0200

    avfilter: add morpho filter

diff --git a/libavfilter/vf_morpho.c b/libavfilter/vf_morpho.c
--- /dev/null
+++ b/libavfilter/vf_morpho.c
@@ -0,0 +225,35 @@
+static int alloc_lut(LUT *Ty, chord_set *SE, int type_size, int mode)
+{
+    const int size = Ty->max_r + 1 - Ty->min_r;
+    int pre_pad_x = 0;
+
+    if (SE->minX < 0)
+        pre_pad_x = 0 - SE->minX;
+    Ty->pre_pad_x = pre_pad_x;
+    Ty->type_size = type_size;
+
+    Ty->arr = av_calloc(size, sizeof(*Ty->arr));
+    if (!Ty->arr)
+        return AVERROR(ENOMEM);
+    for (int r = 0; r < Ty->max_r - Ty->min_r + 1; r++) {
+        Ty->arr[r] = av_calloc(Ty->I, sizeof(uint8_t *));
+        if (!Ty->arr[r])
+            return AVERROR(ENOMEM);
+        for (int i = 0; i < Ty->I; i++) {
+            Ty->arr[r][i] = av_calloc(Ty->X + pre_pad_x, type_size);
+            if (!Ty->arr[r][i])
+                return AVERROR(ENOMEM);
+            if (mode == ERODE)
+                memset(Ty->arr[r][i], UINT8_MAX, pre_pad_x * type_size);
+            /* Shifting the X index such that negative indices correspond to
+             * the pre-padding.
+             */
+            Ty->arr[r][i] = &(Ty->arr[r][i][pre_pad_x * type_size]);
+        }
+    }
+
+    Ty->arr = &(Ty->arr[0 - Ty->min_r]);
+
+    return 0;
+}
+
commit 2ee4077248dcd96e50efc0738e60519ffb9a4c7f
Date:   Sun Oct 3 10:10:49 2021 +0200

    avfilter/vf_morpho: Fix invalid frees on error
    
    The current code used a pointer to an array (of arrays) that
    is offset relative to the start of the actually allocated buffer.
    Yet offsetting the pointer is only done on success, whereas the
    freeing code believes it to have happened even on error.
    So if any of the subarrays (or the subarrays' subarrays) can't
    be successfully allocated, one gets a bad free in free_lut().
    
    Furthermore, said offsetting is only permissible in case the
    offsetted pointer points in the allocated buffer (here: in case
    the LUT's min_r is <= 0), as pointer arithmetic is undefined
    in case it exceeds the allocated object.
    
    Moreover, in case one of the subarrays couldn't be allocated,
    the code nevertheless tried to free the subarray's subarrays;
    and in case one of the subarray's subarrays could not be allocated
    successfully, there will be an invalid free, too, because the
    pointers for the subarrays' subarrays are also offset compared
    to the base pointer.
    
    This commit fixes all of this, by using the actually allocated
    pointer for freeing and by adding appropriate checks before
    freeing the subarrays. The former also allows to distinguish
    the cases in which the lut is currently only half-allocated due to
    an error in an earlier allocation attempt from the success case.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavfilter/vf_morpho.c b/libavfilter/vf_morpho.c
--- a/libavfilter/vf_morpho.c
+++ b/libavfilter/vf_morpho.c
@@ -298,20 +302,23 @@
 static void free_lut(LUT *table)
 {
-    uint8_t ***rp;
+    const int min = FFMAX(table->min_r, 0);
+    const int max = min + (table->max_r - table->min_r);
 
-    if (!table->arr)
+    if (!table->base_arr)
         return;
 
-    // The R index was shifted, create a pointer to the original array
-    rp = &(table->arr[table->min_r]);
-
-    for (int r = table->min_r; r <= table->max_r; r++) {
+    for (int r = min; r <= max; r++) {
+        if (!table->base_arr[r])
+            break;
         for (int i = 0; i < table->I; i++) {
+            if (!table->base_arr[r][i])
+                break;
             // The X index was also shifted, for padding purposes.
-            av_free(table->arr[r][i] - table->pre_pad_x * table->type_size);
+            av_free(table->base_arr[r][i] - table->pre_pad_x * table->type_size);
         }
-        av_freep(&table->arr[r]);
+        av_freep(&table->base_arr[r]);
     }
-    av_freep(&rp);
+    av_freep(&table->base_arr);
+    table->arr = NULL;
 }
 

commit b2ec4edef798af1112ed7c3aadc3a2c91f7d3665
Date:   Mon Sep 20 13:47:45 2021 +0200

    avfilter: add morpho filter

diff --git a/libavfilter/vf_morpho.c b/libavfilter/vf_morpho.c
--- /dev/null
+++ b/libavfilter/vf_morpho.c
@@ -0,0 +260,20 @@
+static void free_lut(LUT *table)
+{
+    uint8_t ***rp;
+
+    if (!table->arr)
+        return;
+
+    // The R index was shifted, create a pointer to the original array
+    rp = &(table->arr[table->min_r]);
+
+    for (int r = table->min_r; r <= table->max_r; r++) {
+        for (int i = 0; i < table->I; i++) {
+            // The X index was also shifted, for padding purposes.
+            av_free(table->arr[r][i] - table->pre_pad_x * table->type_size);
+        }
+        av_freep(&table->arr[r]);
+    }
+    av_freep(&rp);
+}
+
[func] **new** commit ea5bf12a9a7e05c34b55ff3bcc9ecddb39431800
Date:   Wed Feb 24 07:43:37 2021 +0100

    avformat/avio: Use av_strstart instead of strncmp
    
    It makes the intent clearer and avoids calculating the length
    in advance.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>

diff --git a/libavformat/avio.c b/libavformat/avio.c
--- a/libavformat/avio.c
+++ b/libavformat/avio.c
@@ -77,81 +77,80 @@
 static int url_alloc_for_protocol(URLContext **puc, const URLProtocol *up,
                                   const char *filename, int flags,
                                   const AVIOInterruptCB *int_cb)
 {
     URLContext *uc;
     int err;
 
 #if CONFIG_NETWORK
     if (up->flags & URL_PROTOCOL_FLAG_NETWORK && !ff_network_init())
         return AVERROR(EIO);
 #endif
     if ((flags & AVIO_FLAG_READ) && !up->url_read) {
         av_log(NULL, AV_LOG_ERROR,
                "Impossible to open the '%s' protocol for reading\n", up->name);
         return AVERROR(EIO);
     }
     if ((flags & AVIO_FLAG_WRITE) && !up->url_write) {
         av_log(NULL, AV_LOG_ERROR,
                "Impossible to open the '%s' protocol for writing\n", up->name);
         return AVERROR(EIO);
     }
     uc = av_mallocz(sizeof(URLContext) + strlen(filename) + 1);
     if (!uc) {
         err = AVERROR(ENOMEM);
         goto fail;
     }
     uc->av_class = &ffurl_context_class;
     uc->filename = (char *)&uc[1];
     strcpy(uc->filename, filename);
     uc->prot            = up;
     uc->flags           = flags;
     uc->is_streamed     = 0; /* default = not streamed */
     uc->max_packet_size = 0; /* default: stream file */
     if (up->priv_data_size) {
         uc->priv_data = av_mallocz(up->priv_data_size);
         if (!uc->priv_data) {
             err = AVERROR(ENOMEM);
             goto fail;
         }
         if (up->priv_data_class) {
-            int proto_len= strlen(up->name);
-            char *start = strchr(uc->filename, ',');
+            char *start;
             *(const AVClass **)uc->priv_data = up->priv_data_class;
             av_opt_set_defaults(uc->priv_data);
-            if(!strncmp(up->name, uc->filename, proto_len) && uc->filename + proto_len == start){
+            if (av_strstart(uc->filename, up->name, (const char**)&start) && *start == ',') {
                 int ret= 0;
                 char *p= start;
                 char sep= *++p;
                 char *key, *val;
                 p++;
 
                 if (strcmp(up->name, "subfile"))
                     ret = AVERROR(EINVAL);
 
                 while(ret >= 0 && (key= strchr(p, sep)) && p<key && (val = strchr(key+1, sep))){
                     *val= *key= 0;
                     if (strcmp(p, "start") && strcmp(p, "end")) {
                         ret = AVERROR_OPTION_NOT_FOUND;
                     } else
                         ret= av_opt_set(uc->priv_data, p, key+1, 0);
                     if (ret == AVERROR_OPTION_NOT_FOUND)
                         av_log(uc, AV_LOG_ERROR, "Key '%s' not found.\n", p);
                     *val= *key= sep;
                     p= val+1;
                 }
                 if(ret<0 || p!=key){
                     av_log(uc, AV_LOG_ERROR, "Error parsing options string %s\n", start);
                     av_freep(&uc->priv_data);
                     av_freep(&uc);
                     err = AVERROR(EINVAL);
                     goto fail;
                 }
                 memmove(start, key+1, strlen(key));
             }
         }
     }
     if (int_cb)
         uc->interrupt_callback = *int_cb;
 
     *puc = uc;
     return 0;
[func] **new** commit 45bfe8b838275235412777dd430206d9a24eb3ee
Date:   Wed Aug 4 16:52:07 2021 +0200

    avformat/avio: Move internal AVIOContext fields to avio_internal.h
    
    Currently AVIOContext's private fields are all over AVIOContext.
    This commit moves them into a new structure in avio_internal.h instead.
    Said structure contains the public AVIOContext as its first element
    in order to avoid having to allocate a separate AVIOContextInternal
    which is costly for those use cases where one just wants to access
    an already existing buffer via the AVIOContext-API.
    For these cases ffio_init_context() can't fail and always returned zero,
    which was typically not checked. Therefore it has been made to not
    return anything.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavformat/aviobuf.c b/libavformat/aviobuf.c
--- a/libavformat/aviobuf.c
+++ b/libavformat/aviobuf.c
@@ -130,17 +130,17 @@
 AVIOContext *avio_alloc_context(
                   unsigned char *buffer,
                   int buffer_size,
                   int write_flag,
                   void *opaque,
                   int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                   int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                   int64_t (*seek)(void *opaque, int64_t offset, int whence))
 {
-    AVIOContext *s = av_malloc(sizeof(AVIOContext));
+    FFIOContext *s = av_malloc(sizeof(*s));
     if (!s)
         return NULL;
     ffio_init_context(s, buffer, buffer_size, write_flag, opaque,
                   read_packet, write_packet, seek);
-    return s;
+    return &s->pub;
 }
 
[func] **new** commit 73f6cce936130abde06ec3a39d0a4cdabfef01e4
Date:   Sun Dec 26 16:47:57 2021 -0800

    avformat/imf: Demuxer
    
    Signed-off-by: Pierre-Anthony Lemieux <pal@palemieux.com>
    Signed-off-by: Zane van Iperen <zane@zanevaniperen.com>

diff --git a/libavformat/imf_cpl.c b/libavformat/imf_cpl.c
--- /dev/null
+++ b/libavformat/imf_cpl.c
@@ -0,0 +758,11 @@
+FFIMFCPL *ff_imf_cpl_alloc(void)
+{
+    FFIMFCPL *cpl;
+
+    cpl = av_malloc(sizeof(FFIMFCPL));
+    if (!cpl)
+        return NULL;
+    imf_cpl_init(cpl);
+    return cpl;
+}
+
[func] **new** commit 94922f6caba8f1739d4aa0517d8df6e93cf19b8a
Date:   Sun Oct 2 09:27:53 2022 -0700

    avformat/imfdec: use CPL start timecode if available
    
    The IMF CPL contains an optional timecode start address. This patch reads the
    latter, if present, into the context's timecode metadata parameter.
    This addresses https://trac.ffmpeg.org/ticket/9842.

diff --git a/libavformat/imf_cpl.c b/libavformat/imf_cpl.c
--- a/libavformat/imf_cpl.c
+++ b/libavformat/imf_cpl.c
@@ -661,27 +761,29 @@
 int ff_imf_parse_cpl_from_xml_dom(xmlDocPtr doc, FFIMFCPL **cpl)
 {
     int ret = 0;
     xmlNodePtr cpl_element = NULL;
 
     *cpl = ff_imf_cpl_alloc();
     if (!*cpl) {
         ret = AVERROR(ENOMEM);
         goto cleanup;
     }
 
     cpl_element = xmlDocGetRootElement(doc);
     if (!cpl_element || xmlStrcmp(cpl_element->name, "CompositionPlaylist")) {
         av_log(NULL, AV_LOG_ERROR, "The root element of the CPL is not CompositionPlaylist\n");
         ret = AVERROR_INVALIDDATA;
         goto cleanup;
     }
 
     if ((ret = fill_content_title(cpl_element, *cpl)))
         goto cleanup;
     if ((ret = fill_id(cpl_element, *cpl)))
         goto cleanup;
     if ((ret = fill_edit_rate(cpl_element, *cpl)))
         goto cleanup;
+    if ((ret = fill_timecode(cpl_element, *cpl)))
+        goto cleanup;
     if ((ret = fill_virtual_tracks(cpl_element, *cpl)))
         goto cleanup;
 

[safe] **new** commit c1b55cb70ce748c1193d3251575b639daf9e96f0
Date:   Mon Jan 3 22:11:27 2022 -0800

    avformat/imf: fix error CPL root element is absent
    
    Signed-off-by: Pierre-Anthony Lemieux <pal@palemieux.com>
    Signed-off-by: Zane van Iperen <zane@zanevaniperen.com>

diff --git a/libavformat/imf_cpl.c b/libavformat/imf_cpl.c
--- a/libavformat/imf_cpl.c
+++ b/libavformat/imf_cpl.c
@@ -679,27 +679,27 @@
 int ff_imf_parse_cpl_from_xml_dom(xmlDocPtr doc, FFIMFCPL **cpl)
 {
     int ret = 0;
     xmlNodePtr cpl_element = NULL;
 
     *cpl = ff_imf_cpl_alloc();
     if (!*cpl) {
         ret = AVERROR(ENOMEM);
         goto cleanup;
     }
 
     cpl_element = xmlDocGetRootElement(doc);
-    if (xmlStrcmp(cpl_element->name, "CompositionPlaylist")) {
+    if (!cpl_element || xmlStrcmp(cpl_element->name, "CompositionPlaylist")) {
         av_log(NULL, AV_LOG_ERROR, "The root element of the CPL is not CompositionPlaylist\n");
         ret = AVERROR_INVALIDDATA;
         goto cleanup;
     }
 
     if ((ret = fill_content_title(cpl_element, *cpl)))
         goto cleanup;
     if ((ret = fill_id(cpl_element, *cpl)))
         goto cleanup;
     if ((ret = fill_edit_rate(cpl_element, *cpl)))
         goto cleanup;
     if ((ret = fill_virtual_tracks(cpl_element, *cpl)))
         goto cleanup;
 

commit 73f6cce936130abde06ec3a39d0a4cdabfef01e4
Date:   Sun Dec 26 16:47:57 2021 -0800

    avformat/imf: Demuxer
    
    Signed-off-by: Pierre-Anthony Lemieux <pal@palemieux.com>
    Signed-off-by: Zane van Iperen <zane@zanevaniperen.com>

diff --git a/libavformat/imf_cpl.c b/libavformat/imf_cpl.c
--- /dev/null
+++ b/libavformat/imf_cpl.c
@@ -0,0 +679,27 @@
+int ff_imf_parse_cpl_from_xml_dom(xmlDocPtr doc, FFIMFCPL **cpl)
+{
+    int ret = 0;
+    xmlNodePtr cpl_element = NULL;
+
+    *cpl = ff_imf_cpl_alloc();
+    if (!*cpl) {
+        ret = AVERROR(ENOMEM);
+        goto cleanup;
+    }
+
+    cpl_element = xmlDocGetRootElement(doc);
+    if (xmlStrcmp(cpl_element->name, "CompositionPlaylist")) {
+        av_log(NULL, AV_LOG_ERROR, "The root element of the CPL is not CompositionPlaylist\n");
+        ret = AVERROR_INVALIDDATA;
+        goto cleanup;
+    }
+
+    if ((ret = fill_content_title(cpl_element, *cpl)))
+        goto cleanup;
+    if ((ret = fill_id(cpl_element, *cpl)))
+        goto cleanup;
+    if ((ret = fill_edit_rate(cpl_element, *cpl)))
+        goto cleanup;
+    if ((ret = fill_virtual_tracks(cpl_element, *cpl)))
+        goto cleanup;
+
commit 94922f6caba8f1739d4aa0517d8df6e93cf19b8a
Date:   Sun Oct 2 09:27:53 2022 -0700

    avformat/imfdec: use CPL start timecode if available
    
    The IMF CPL contains an optional timecode start address. This patch reads the
    latter, if present, into the context's timecode metadata parameter.
    This addresses https://trac.ffmpeg.org/ticket/9842.

diff --git a/libavformat/imf_cpl.c b/libavformat/imf_cpl.c
--- a/libavformat/imf_cpl.c
+++ b/libavformat/imf_cpl.c
@@ -751,26 +854,29 @@
 void ff_imf_cpl_free(FFIMFCPL *cpl)
 {
     if (!cpl)
         return;
 
+    if (cpl->tc)
+        av_freep(&cpl->tc);
+
     xmlFree(cpl->content_title_utf8);
 
     imf_marker_virtual_track_free(cpl->main_markers_track);
 
     if (cpl->main_markers_track)
         av_freep(&cpl->main_markers_track);
 
     imf_trackfile_virtual_track_free(cpl->main_image_2d_track);
 
     if (cpl->main_image_2d_track)
         av_freep(&cpl->main_image_2d_track);
 
     for (uint32_t i = 0; i < cpl->main_audio_track_count; i++)
         imf_trackfile_virtual_track_free(&cpl->main_audio_tracks[i]);
 
     if (cpl->main_audio_tracks)
         av_freep(&cpl->main_audio_tracks);
 
     av_freep(&cpl);
 }
 

commit 73f6cce936130abde06ec3a39d0a4cdabfef01e4
Date:   Sun Dec 26 16:47:57 2021 -0800

    avformat/imf: Demuxer
    
    Signed-off-by: Pierre-Anthony Lemieux <pal@palemieux.com>
    Signed-off-by: Zane van Iperen <zane@zanevaniperen.com>

diff --git a/libavformat/imf_cpl.c b/libavformat/imf_cpl.c
--- /dev/null
+++ b/libavformat/imf_cpl.c
@@ -0,0 +769,26 @@
+void ff_imf_cpl_free(FFIMFCPL *cpl)
+{
+    if (!cpl)
+        return;
+
+    xmlFree(cpl->content_title_utf8);
+
+    imf_marker_virtual_track_free(cpl->main_markers_track);
+
+    if (cpl->main_markers_track)
+        av_freep(&cpl->main_markers_track);
+
+    imf_trackfile_virtual_track_free(cpl->main_image_2d_track);
+
+    if (cpl->main_image_2d_track)
+        av_freep(&cpl->main_image_2d_track);
+
+    for (uint32_t i = 0; i < cpl->main_audio_track_count; i++)
+        imf_trackfile_virtual_track_free(&cpl->main_audio_tracks[i]);
+
+    if (cpl->main_audio_tracks)
+        av_freep(&cpl->main_audio_tracks);
+
+    av_freep(&cpl);
+}
+
[func] **new** commit 30f7021aa0be2c978aefb73894b643c9bafbf51c
Date:   Fri Feb 26 11:33:09 2021 +0100

    avformat: Remove deprecated filename field from AVFormatContext
    
    Deprecated in fa8308d3d4f27d6fb38ac2069887a7b259f1c6ab.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavformat/mux.c b/libavformat/mux.c
--- a/libavformat/mux.c
+++ b/libavformat/mux.c
@@ -136,53 +136,48 @@
 int avformat_alloc_output_context2(AVFormatContext **avctx, const AVOutputFormat *oformat,
                                    const char *format, const char *filename)
 {
     AVFormatContext *s = avformat_alloc_context();
     int ret = 0;
 
     *avctx = NULL;
     if (!s)
         goto nomem;
 
     if (!oformat) {
         if (format) {
             oformat = av_guess_format(format, NULL, NULL);
             if (!oformat) {
                 av_log(s, AV_LOG_ERROR, "Requested output format '%s' is not a suitable output format\n", format);
                 ret = AVERROR(EINVAL);
                 goto error;
             }
         } else {
             oformat = av_guess_format(NULL, filename, NULL);
             if (!oformat) {
                 ret = AVERROR(EINVAL);
                 av_log(s, AV_LOG_ERROR, "Unable to find a suitable output format for '%s'\n",
                        filename);
                 goto error;
             }
         }
     }
 
     s->oformat = oformat;
     if (s->oformat->priv_data_size > 0) {
         s->priv_data = av_mallocz(s->oformat->priv_data_size);
         if (!s->priv_data)
             goto nomem;
         if (s->oformat->priv_class) {
             *(const AVClass**)s->priv_data= s->oformat->priv_class;
             av_opt_set_defaults(s->priv_data);
         }
     } else
         s->priv_data = NULL;
 
     if (filename) {
-#if FF_API_FORMAT_FILENAME
-FF_DISABLE_DEPRECATION_WARNINGS
-        av_strlcpy(s->filename, filename, sizeof(s->filename));
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         if (!(s->url = av_strdup(filename)))
             goto nomem;
 
     }
     *avctx = s;
     return 0;

[incr] **new** commit 56450a0ee4fdda160f4039fc2ae33edfd27765c9
Date:   Thu Feb 25 03:11:32 2021 +0100

    avformat: Constify the API wrt AV(In|Out)putFormat
    
    Also constify AVProbeData.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavformat/mux.c b/libavformat/mux.c
--- a/libavformat/mux.c
+++ b/libavformat/mux.c
@@ -136,53 +136,53 @@
-int avformat_alloc_output_context2(AVFormatContext **avctx, ff_const59 AVOutputFormat *oformat,
+int avformat_alloc_output_context2(AVFormatContext **avctx, const AVOutputFormat *oformat,
                                    const char *format, const char *filename)
 {
     AVFormatContext *s = avformat_alloc_context();
     int ret = 0;
 
     *avctx = NULL;
     if (!s)
         goto nomem;
 
     if (!oformat) {
         if (format) {
             oformat = av_guess_format(format, NULL, NULL);
             if (!oformat) {
                 av_log(s, AV_LOG_ERROR, "Requested output format '%s' is not a suitable output format\n", format);
                 ret = AVERROR(EINVAL);
                 goto error;
             }
         } else {
             oformat = av_guess_format(NULL, filename, NULL);
             if (!oformat) {
                 ret = AVERROR(EINVAL);
                 av_log(s, AV_LOG_ERROR, "Unable to find a suitable output format for '%s'\n",
                        filename);
                 goto error;
             }
         }
     }
 
     s->oformat = oformat;
     if (s->oformat->priv_data_size > 0) {
         s->priv_data = av_mallocz(s->oformat->priv_data_size);
         if (!s->priv_data)
             goto nomem;
         if (s->oformat->priv_class) {
             *(const AVClass**)s->priv_data= s->oformat->priv_class;
             av_opt_set_defaults(s->priv_data);
         }
     } else
         s->priv_data = NULL;
 
     if (filename) {
 #if FF_API_FORMAT_FILENAME
 FF_DISABLE_DEPRECATION_WARNINGS
         av_strlcpy(s->filename, filename, sizeof(s->filename));
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
         if (!(s->url = av_strdup(filename)))
             goto nomem;
 
     }
     *avctx = s;
     return 0;
[func] **new** commit c602deb138562a2a7ff9e2c05d9ba9b1fb76668c
Date:   Tue Jan 18 19:56:14 2022 +0100

    avformat/mux: Preserve sync even if later packet has negative ts
    
    write_packet() has code to shift the packets timestamps
    to make them nonnegative or even make them start at ts zero;
    this code inspects every packet that is written and if a packet
    with negative timestamp (whether this is dts or pts depends upon
    another flag; basically: Matroska uses pts, everyone else dts)
    is encountered, this is offset to make the timestamp zero.
    All further packets will be offset accordingly (with the offset
    converted according to the streams' timebases).
    
    This is based around an assumption, namely that the timestamps
    are indeed non-decreasing, so that the first packet with negative
    timestamps is the first packet with timestamps. This assumption
    is often fulfilled given that the default interleavement function
    by default interleaves per dts; yet there are scenarios in which
    it may not be fulfilled:
    a) av_write_frame() instead of av_interleaved_write_frame() is used.
    b) The audio_preload option is used.
    c) When the timestamps that are made nonnegative/zero are pts
    (i.e. with Matroska), because the packet with the smallest dts
    is not necessarily the packet with the smallest pts.
    d) Possibly with custom interleavement functions.
    In these cases the relative sync of the first few packet(s) is offset
    relative to the later packets. This contradicts the documentation
    ("When shifting is enabled, all output timestamps are shifted by
    the same amount").
    
    Therefore this commit changes this: As soon as the first packet
    with valid timestamps is output, it is checked and recorded whether
    the timestamps need to be shifted. Further packets are no longer
    checked for needing to be offset; instead they are simply offset.
    In the cases above this leads to packets with negative timestamps
    (and the appropriate warnings) instead of desync. This will mostly
    be fixed in the next commit.
    
    This commit also factors handling the avoid_negative_ts stuff out
    of write_packet() in order to be able to return immediately.
    
    Tickets #4536 and #5784 as well as the matroska-avoid-negative-ts-test
    are examples of c); as has been said, some timestamps are now negative,
    yet the ref file update does not show it because ffmpeg.c sanitizes
    the timestamps (-copyts disables it; ffprobe and mkvinfo also show
    the original timestamps).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavformat/options.c b/libavformat/options.c
--- a/libavformat/options.c
+++ b/libavformat/options.c
@@ -154,29 +154,28 @@
 AVFormatContext *avformat_alloc_context(void)
 {
     FFFormatContext *const si = av_mallocz(sizeof(*si));
     AVFormatContext *s;
 
     if (!si)
         return NULL;
 
     s = &si->pub;
     s->av_class = &av_format_context_class;
     s->io_open  = io_open_default;
     s->io_close = ff_format_io_close_default;
     s->io_close2= io_close2_default;
 
     av_opt_set_defaults(s);
 
     si->pkt = av_packet_alloc();
     si->parse_pkt = av_packet_alloc();
     if (!si->pkt || !si->parse_pkt) {
         avformat_free_context(s);
         return NULL;
     }
 
-    si->offset = AV_NOPTS_VALUE;
     si->shortest_end = AV_NOPTS_VALUE;
 
     return s;
 }
 

[func] **new** commit 64834bb86a133400970d203656a30ae6a3d2832f
Date:   Tue Nov 30 00:38:30 2021 +0100

    avformat: introduce AVFormatContext io_close2 which returns an int
    
    Otherwise there is no way to detect an error returned by avio_close() because
    ff_format_io_close cannot get the return value.
    
    Checking the return value of the close function is important in order to check
    if all data was successfully written and the underlying close() operation was
    successful.
    
    It can also be useful even for read mode because it can return any pending
    AVIOContext error, so the user don't have to manually check AVIOContext->error.
    
    In order to still support if the user overrides io_close, the generic code only
    uses io_close2 if io_close is either NULL or the default io_close callback.
    
    Signed-off-by: Marton Balint <cus@passwd.hu>

diff --git a/libavformat/options.c b/libavformat/options.c
--- a/libavformat/options.c
+++ b/libavformat/options.c
@@ -154,28 +154,29 @@
 AVFormatContext *avformat_alloc_context(void)
 {
     FFFormatContext *const si = av_mallocz(sizeof(*si));
     AVFormatContext *s;
 
     if (!si)
         return NULL;
 
     s = &si->pub;
     s->av_class = &av_format_context_class;
     s->io_open  = io_open_default;
-    s->io_close = io_close_default;
+    s->io_close = ff_format_io_close_default;
+    s->io_close2= io_close2_default;
 
     av_opt_set_defaults(s);
 
     si->pkt = av_packet_alloc();
     si->parse_pkt = av_packet_alloc();
     if (!si->pkt || !si->parse_pkt) {
         avformat_free_context(s);
         return NULL;
     }
 
     si->offset = AV_NOPTS_VALUE;
     si->shortest_end = AV_NOPTS_VALUE;
 
     return s;
 }
 

[func] **new** commit 406ffd9b9b99fa096bcfe31b467453824d1542e7
Date:   Sun Nov 7 18:21:17 2021 +0100

    avformat/demux: allow total size of packets in raw_packet_buffer to reach probesize
    
    Previously this was hardcoded to 2500000 bytes, so probing of the stream codecs
    was always limited by this, and not probesize.
    
    Also keep track of the actual size of packets in raw_packet_buffer and not the
    remaining size for simplicity.
    
    Fixes ticket #5860.
    
    Signed-off-by: Marton Balint <cus@passwd.hu>

diff --git a/libavformat/options.c b/libavformat/options.c
--- a/libavformat/options.c
+++ b/libavformat/options.c
@@ -154,29 +154,28 @@
 AVFormatContext *avformat_alloc_context(void)
 {
     FFFormatContext *const si = av_mallocz(sizeof(*si));
     AVFormatContext *s;
 
     if (!si)
         return NULL;
 
     s = &si->pub;
     s->av_class = &av_format_context_class;
     s->io_open  = io_open_default;
     s->io_close = io_close_default;
 
     av_opt_set_defaults(s);
 
     si->pkt = av_packet_alloc();
     si->parse_pkt = av_packet_alloc();
     if (!si->pkt || !si->parse_pkt) {
         avformat_free_context(s);
         return NULL;
     }
 
     si->offset = AV_NOPTS_VALUE;
-    si->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
     si->shortest_end = AV_NOPTS_VALUE;
 
     return s;
 }
 

[func] **new** commit fed02825081bd6441f865c9cfcf50e384b2392f5
Date:   Tue Aug 24 14:58:07 2021 +0200

    avformat: Avoid allocation for AVFormatInternal
    
    Do this by allocating AVFormatContext together with the data that is
    currently in AVFormatInternal; or rather: Put AVFormatContext at the
    beginning of a new structure called FFFormatContext (which encompasses
    more than just the internal fields and is a proper context in its own
    right, hence the name) and remove AVFormatInternal altogether.
    
    The biggest simplifications occured in avformat_alloc_context(), where
    one can now simply call avformat_free_context() in case of errors.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavformat/options.c b/libavformat/options.c
--- a/libavformat/options.c
+++ b/libavformat/options.c
@@ -154,42 +154,29 @@
-static void avformat_get_context_defaults(AVFormatContext *s)
+AVFormatContext *avformat_alloc_context(void)
 {
-    memset(s, 0, sizeof(AVFormatContext));
+    FFFormatContext *const si = av_mallocz(sizeof(*si));
+    AVFormatContext *s;
 
-    s->av_class = &av_format_context_class;
+    if (!si)
+        return NULL;
 
+    s = &si->pub;
+    s->av_class = &av_format_context_class;
     s->io_open  = io_open_default;
     s->io_close = io_close_default;
 
     av_opt_set_defaults(s);
-}
 
-AVFormatContext *avformat_alloc_context(void)
-{
-    AVFormatContext *ic;
-    AVFormatInternal *internal;
-    ic = av_malloc(sizeof(AVFormatContext));
-    if (!ic) return ic;
-
-    internal = av_mallocz(sizeof(*internal));
-    if (!internal) {
-        av_free(ic);
+    si->pkt = av_packet_alloc();
+    si->parse_pkt = av_packet_alloc();
+    if (!si->pkt || !si->parse_pkt) {
+        avformat_free_context(s);
         return NULL;
     }
-    internal->pkt = av_packet_alloc();
-    internal->parse_pkt = av_packet_alloc();
-    if (!internal->pkt || !internal->parse_pkt) {
-        av_packet_free(&internal->pkt);
-        av_packet_free(&internal->parse_pkt);
-        av_free(internal);
-        av_free(ic);
-        return NULL;
-    }
-    avformat_get_context_defaults(ic);
-    ic->internal = internal;
-    ic->internal->offset = AV_NOPTS_VALUE;
-    ic->internal->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
-    ic->internal->shortest_end = AV_NOPTS_VALUE;
 
-    return ic;
+    si->offset = AV_NOPTS_VALUE;
+    si->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
+    si->shortest_end = AV_NOPTS_VALUE;
+
+    return s;
 }
 

[func] **new** commit 01f4d33b4195c4d95642ac3e548b8d9250b7de1f
Date:   Sun Jan 31 13:05:49 2021 -0300

    avformat/utils: use av_packet_alloc() to allocate packets
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavformat/options.c b/libavformat/options.c
--- a/libavformat/options.c
+++ b/libavformat/options.c
@@ -199,39 +199,42 @@
 static void avformat_get_context_defaults(AVFormatContext *s)
 {
     memset(s, 0, sizeof(AVFormatContext));
 
     s->av_class = &av_format_context_class;
 
     s->io_open  = io_open_default;
     s->io_close = io_close_default;
 
     av_opt_set_defaults(s);
 }
 
 AVFormatContext *avformat_alloc_context(void)
 {
     AVFormatContext *ic;
     AVFormatInternal *internal;
     ic = av_malloc(sizeof(AVFormatContext));
     if (!ic) return ic;
 
     internal = av_mallocz(sizeof(*internal));
     if (!internal) {
         av_free(ic);
         return NULL;
     }
     internal->pkt = av_packet_alloc();
-    if (!internal->pkt) {
+    internal->parse_pkt = av_packet_alloc();
+    if (!internal->pkt || !internal->parse_pkt) {
+        av_packet_free(&internal->pkt);
+        av_packet_free(&internal->parse_pkt);
         av_free(internal);
         av_free(ic);
         return NULL;
     }
     avformat_get_context_defaults(ic);
     ic->internal = internal;
     ic->internal->offset = AV_NOPTS_VALUE;
     ic->internal->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
     ic->internal->shortest_end = AV_NOPTS_VALUE;
 
     return ic;
 }
 

[func] **new** commit 9066969713e6a7bad0b76f1936ee60cac456bbe0
Date:   Sat Jan 30 15:04:24 2021 -0300

    avformat/mux: use av_packet_alloc() to allocate packets
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavformat/options.c b/libavformat/options.c
--- a/libavformat/options.c
+++ b/libavformat/options.c
@@ -199,33 +199,39 @@
 static void avformat_get_context_defaults(AVFormatContext *s)
 {
     memset(s, 0, sizeof(AVFormatContext));
 
     s->av_class = &av_format_context_class;
 
     s->io_open  = io_open_default;
     s->io_close = io_close_default;
 
     av_opt_set_defaults(s);
 }
 
 AVFormatContext *avformat_alloc_context(void)
 {
     AVFormatContext *ic;
     AVFormatInternal *internal;
     ic = av_malloc(sizeof(AVFormatContext));
     if (!ic) return ic;
 
     internal = av_mallocz(sizeof(*internal));
     if (!internal) {
         av_free(ic);
         return NULL;
     }
+    internal->pkt = av_packet_alloc();
+    if (!internal->pkt) {
+        av_free(internal);
+        av_free(ic);
+        return NULL;
+    }
     avformat_get_context_defaults(ic);
     ic->internal = internal;
     ic->internal->offset = AV_NOPTS_VALUE;
     ic->internal->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
     ic->internal->shortest_end = AV_NOPTS_VALUE;
 
     return ic;
 }
 
[safe] **new** commit c6f4e10111debf5b547a399661a5fe997d761033
Date:   Mon Nov 22 00:25:16 2021 +0100

    avformat: do not use AVIO_FLAG_* with avio_alloc_context
    
    The documentation states that here 0 should be used for read-only and
    1 for a writable buffer. AVIO_FLAG_WRITE however is 2, while it works
    due to the way the flag is handled internally, it is still wrong
    according to the documentation.
    
    Additionally it makes it seem as if the AVIO_FLAG_* values could be used
    here, which is actually not true, as when AVIO_FLAG_READ would be used
    here it would create a writable buffer as AVIO_FLAG_READ is defined as 1.
    
    Signed-off-by: Anton Khirnov <anton@khirnov.net>

diff --git a/libavformat/segment.c b/libavformat/segment.c
--- a/libavformat/segment.c
+++ b/libavformat/segment.c
@@ -566,14 +566,14 @@
 static int open_null_ctx(AVIOContext **ctx)
 {
     int buf_size = 32768;
     uint8_t *buf = av_malloc(buf_size);
     if (!buf)
         return AVERROR(ENOMEM);
-    *ctx = avio_alloc_context(buf, buf_size, AVIO_FLAG_WRITE, NULL, NULL, NULL, NULL);
+    *ctx = avio_alloc_context(buf, buf_size, 1, NULL, NULL, NULL, NULL);
     if (!*ctx) {
         av_free(buf);
         return AVERROR(ENOMEM);
     }
     return 0;
 }
 
[func] **new** commit fbbe7729f0fc7db3daad584b0e5f5a898f2b8acf
Date:   Mon Dec 6 01:14:28 2021 +0100

    avutil/aes_ctr: Avoid allocation of AVAES struct
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/aes_ctr.c b/libavutil/aes_ctr.c
--- a/libavutil/aes_ctr.c
+++ b/libavutil/aes_ctr.c
@@ -84,8 +80,5 @@
 void av_aes_ctr_free(struct AVAESCTR *a)
 {
-    if (a) {
-        av_freep(&a->aes);
-        av_free(a);
-    }
+    av_free(a);
 }
 
[func] **new** commit d1bd189c6318fc016a9b6f9c8fee8a47e9b7e173
Date:   Fri Jan 7 11:41:42 2022 +0100

    lavu/audio_fifo: switch to new FIFO API

diff --git a/libavutil/audio_fifo.c b/libavutil/audio_fifo.c
--- a/libavutil/audio_fifo.c
+++ b/libavutil/audio_fifo.c
@@ -59,32 +59,32 @@
 AVAudioFifo *av_audio_fifo_alloc(enum AVSampleFormat sample_fmt, int channels,
                                  int nb_samples)
 {
     AVAudioFifo *af;
     int buf_size, i;
 
     /* get channel buffer size (also validates parameters) */
     if (av_samples_get_buffer_size(&buf_size, channels, nb_samples, sample_fmt, 1) < 0)
         return NULL;
 
     af = av_mallocz(sizeof(*af));
     if (!af)
         return NULL;
 
     af->channels    = channels;
     af->sample_fmt  = sample_fmt;
     af->sample_size = buf_size / nb_samples;
     af->nb_buffers  = av_sample_fmt_is_planar(sample_fmt) ? channels : 1;
 
     af->buf = av_calloc(af->nb_buffers, sizeof(*af->buf));
     if (!af->buf)
         goto error;
 
     for (i = 0; i < af->nb_buffers; i++) {
-        af->buf[i] = av_fifo_alloc(buf_size);
+        af->buf[i] = av_fifo_alloc2(buf_size, 1, 0);
         if (!af->buf[i])
             goto error;
     }
     af->allocated_samples = nb_samples;
 
     return af;
 

commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/audio_fifo.c b/libavutil/audio_fifo.c
--- a/libavutil/audio_fifo.c
+++ b/libavutil/audio_fifo.c
@@ -59,32 +59,32 @@
 AVAudioFifo *av_audio_fifo_alloc(enum AVSampleFormat sample_fmt, int channels,
                                  int nb_samples)
 {
     AVAudioFifo *af;
     int buf_size, i;
 
     /* get channel buffer size (also validates parameters) */
     if (av_samples_get_buffer_size(&buf_size, channels, nb_samples, sample_fmt, 1) < 0)
         return NULL;
 
     af = av_mallocz(sizeof(*af));
     if (!af)
         return NULL;
 
     af->channels    = channels;
     af->sample_fmt  = sample_fmt;
     af->sample_size = buf_size / nb_samples;
     af->nb_buffers  = av_sample_fmt_is_planar(sample_fmt) ? channels : 1;
 
-    af->buf = av_mallocz_array(af->nb_buffers, sizeof(*af->buf));
+    af->buf = av_calloc(af->nb_buffers, sizeof(*af->buf));
     if (!af->buf)
         goto error;
 
     for (i = 0; i < af->nb_buffers; i++) {
         af->buf[i] = av_fifo_alloc(buf_size);
         if (!af->buf[i])
             goto error;
     }
     af->allocated_samples = nb_samples;
 
     return af;
 
commit d1bd189c6318fc016a9b6f9c8fee8a47e9b7e173
Date:   Fri Jan 7 11:41:42 2022 +0100

    lavu/audio_fifo: switch to new FIFO API

diff --git a/libavutil/audio_fifo.c b/libavutil/audio_fifo.c
--- a/libavutil/audio_fifo.c
+++ b/libavutil/audio_fifo.c
@@ -45,14 +45,14 @@
 void av_audio_fifo_free(AVAudioFifo *af)
 {
     if (af) {
         if (af->buf) {
             int i;
             for (i = 0; i < af->nb_buffers; i++) {
-                av_fifo_freep(&af->buf[i]);
+                av_fifo_freep2(&af->buf[i]);
             }
             av_freep(&af->buf);
         }
         av_free(af);
     }
 }
 
[func] **new** commit 4e0da7d3117bbf84203358940cba82ef10b6dfde
Date:   Tue Sep 14 11:29:23 2021 +0200

    avutil/buffer: Avoid allocation of AVBuffer when using buffer pool
    
    Do this by putting an AVBuffer structure into BufferPoolEntry and
    reuse it for all subsequent uses of said BufferPoolEntry.
    
    Reviewed-by: James Almer <jamrial@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -29,33 +29,26 @@
-AVBufferRef *av_buffer_create(uint8_t *data, size_t size,
-                              void (*free)(void *opaque, uint8_t *data),
-                              void *opaque, int flags)
+static AVBufferRef *buffer_create(AVBuffer *buf, uint8_t *data, size_t size,
+                                  void (*free)(void *opaque, uint8_t *data),
+                                  void *opaque, int flags)
 {
     AVBufferRef *ref = NULL;
-    AVBuffer    *buf = NULL;
-
-    buf = av_mallocz(sizeof(*buf));
-    if (!buf)
-        return NULL;
 
     buf->data     = data;
     buf->size     = size;
     buf->free     = free ? free : av_buffer_default_free;
     buf->opaque   = opaque;
 
     atomic_init(&buf->refcount, 1);
 
     buf->flags = flags;
 
     ref = av_mallocz(sizeof(*ref));
-    if (!ref) {
-        av_freep(&buf);
+    if (!ref)
         return NULL;
-    }
 
     ref->buffer = buf;
     ref->data   = data;
     ref->size   = size;
 
     return ref;
 }
 

commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -29,33 +29,33 @@
-AVBufferRef *av_buffer_create(uint8_t *data, buffer_size_t size,
+AVBufferRef *av_buffer_create(uint8_t *data, size_t size,
                               void (*free)(void *opaque, uint8_t *data),
                               void *opaque, int flags)
 {
     AVBufferRef *ref = NULL;
     AVBuffer    *buf = NULL;
 
     buf = av_mallocz(sizeof(*buf));
     if (!buf)
         return NULL;
 
     buf->data     = data;
     buf->size     = size;
     buf->free     = free ? free : av_buffer_default_free;
     buf->opaque   = opaque;
 
     atomic_init(&buf->refcount, 1);
 
     buf->flags = flags;
 
     ref = av_mallocz(sizeof(*ref));
     if (!ref) {
         av_freep(&buf);
         return NULL;
     }
 
     ref->buffer = buf;
     ref->data   = data;
     ref->size   = size;
 
     return ref;
 }
 

[incr] **new** commit 14040a1d913794d9a3fd6406a6d8c2f0e37e0062
Date:   Sat Mar 6 12:26:16 2021 -0300

    avutil/buffer: change public function and struct size parameter types to size_t
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -29,33 +29,33 @@
-AVBufferRef *av_buffer_create(uint8_t *data, int size,
+AVBufferRef *av_buffer_create(uint8_t *data, buffer_size_t size,
                               void (*free)(void *opaque, uint8_t *data),
                               void *opaque, int flags)
 {
     AVBufferRef *ref = NULL;
     AVBuffer    *buf = NULL;
 
     buf = av_mallocz(sizeof(*buf));
     if (!buf)
         return NULL;
 
     buf->data     = data;
     buf->size     = size;
     buf->free     = free ? free : av_buffer_default_free;
     buf->opaque   = opaque;
 
     atomic_init(&buf->refcount, 1);
 
     buf->flags = flags;
 
     ref = av_mallocz(sizeof(*ref));
     if (!ref) {
         av_freep(&buf);
         return NULL;
     }
 
     ref->buffer = buf;
     ref->data   = data;
     ref->size   = size;
 
     return ref;
 }
 
commit 4e0da7d3117bbf84203358940cba82ef10b6dfde
Date:   Tue Sep 14 11:29:23 2021 +0200

    avutil/buffer: Avoid allocation of AVBuffer when using buffer pool
    
    Do this by putting an AVBuffer structure into BufferPoolEntry and
    reuse it for all subsequent uses of said BufferPoolEntry.
    
    Reviewed-by: James Almer <jamrial@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -62,0 +55,17 @@
+AVBufferRef *av_buffer_create(uint8_t *data, size_t size,
+                              void (*free)(void *opaque, uint8_t *data),
+                              void *opaque, int flags)
+{
+    AVBufferRef *ret;
+    AVBuffer *buf = av_mallocz(sizeof(*buf));
+    if (!buf)
+        return NULL;
+
+    ret = buffer_create(buf, data, size, free, opaque, flags);
+    if (!ret) {
+        av_free(buf);
+        return NULL;
+    }
+    return ret;
+}
+
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -67,16 +67,16 @@
-AVBufferRef *av_buffer_alloc(buffer_size_t size)
+AVBufferRef *av_buffer_alloc(size_t size)
 {
     AVBufferRef *ret = NULL;
     uint8_t    *data = NULL;
 
     data = av_malloc(size);
     if (!data)
         return NULL;
 
     ret = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);
     if (!ret)
         av_freep(&data);
 
     return ret;
 }
 

commit 14040a1d913794d9a3fd6406a6d8c2f0e37e0062
Date:   Sat Mar 6 12:26:16 2021 -0300

    avutil/buffer: change public function and struct size parameter types to size_t
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -67,16 +67,16 @@
-AVBufferRef *av_buffer_alloc(int size)
+AVBufferRef *av_buffer_alloc(buffer_size_t size)
 {
     AVBufferRef *ret = NULL;
     uint8_t    *data = NULL;
 
     data = av_malloc(size);
     if (!data)
         return NULL;
 
     ret = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);
     if (!ret)
         av_freep(&data);
 
     return ret;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -83,10 +83,10 @@
-AVBufferRef *av_buffer_allocz(buffer_size_t size)
+AVBufferRef *av_buffer_allocz(size_t size)
 {
     AVBufferRef *ret = av_buffer_alloc(size);
     if (!ret)
         return NULL;
 
     memset(ret->data, 0, size);
     return ret;
 }
 

commit 14040a1d913794d9a3fd6406a6d8c2f0e37e0062
Date:   Sat Mar 6 12:26:16 2021 -0300

    avutil/buffer: change public function and struct size parameter types to size_t
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -83,10 +83,10 @@
-AVBufferRef *av_buffer_allocz(int size)
+AVBufferRef *av_buffer_allocz(buffer_size_t size)
 {
     AVBufferRef *ret = av_buffer_alloc(size);
     if (!ret)
         return NULL;
 
     memset(ret->data, 0, size);
     return ret;
 }
 
[func] **new** commit ccfdef79b132bef49f4654266d5d3da8d1deb305
Date:   Fri Sep 17 00:06:45 2021 -0300

    avutil/buffer: constify some function parameters
    
    Reviewed-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -93,14 +93,14 @@
-AVBufferRef *av_buffer_ref(AVBufferRef *buf)
+AVBufferRef *av_buffer_ref(const AVBufferRef *buf)
 {
     AVBufferRef *ret = av_mallocz(sizeof(*ret));
 
     if (!ret)
         return NULL;
 
     *ret = *buf;
 
     atomic_fetch_add_explicit(&buf->buffer->refcount, 1, memory_order_relaxed);
 
     return ret;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -169,50 +169,50 @@
-int av_buffer_realloc(AVBufferRef **pbuf, buffer_size_t size)
+int av_buffer_realloc(AVBufferRef **pbuf, size_t size)
 {
     AVBufferRef *buf = *pbuf;
     uint8_t *tmp;
     int ret;
 
     if (!buf) {
         /* allocate a new buffer with av_realloc(), so it will be reallocatable
          * later */
         uint8_t *data = av_realloc(NULL, size);
         if (!data)
             return AVERROR(ENOMEM);
 
         buf = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);
         if (!buf) {
             av_freep(&data);
             return AVERROR(ENOMEM);
         }
 
         buf->buffer->flags_internal |= BUFFER_FLAG_REALLOCATABLE;
         *pbuf = buf;
 
         return 0;
     } else if (buf->size == size)
         return 0;
 
     if (!(buf->buffer->flags_internal & BUFFER_FLAG_REALLOCATABLE) ||
         !av_buffer_is_writable(buf) || buf->data != buf->buffer->data) {
         /* cannot realloc, allocate a new reallocable buffer and copy data */
         AVBufferRef *new = NULL;
 
         ret = av_buffer_realloc(&new, size);
         if (ret < 0)
             return ret;
 
         memcpy(new->data, buf->data, FFMIN(size, buf->size));
 
         buffer_replace(pbuf, &new);
         return 0;
     }
 
     tmp = av_realloc(buf->buffer->data, size);
     if (!tmp)
         return AVERROR(ENOMEM);
 
     buf->buffer->data = buf->data = tmp;
     buf->buffer->size = buf->size = size;
     return 0;
 }
 

commit 14040a1d913794d9a3fd6406a6d8c2f0e37e0062
Date:   Sat Mar 6 12:26:16 2021 -0300

    avutil/buffer: change public function and struct size parameter types to size_t
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -169,50 +169,50 @@
-int av_buffer_realloc(AVBufferRef **pbuf, int size)
+int av_buffer_realloc(AVBufferRef **pbuf, buffer_size_t size)
 {
     AVBufferRef *buf = *pbuf;
     uint8_t *tmp;
     int ret;
 
     if (!buf) {
         /* allocate a new buffer with av_realloc(), so it will be reallocatable
          * later */
         uint8_t *data = av_realloc(NULL, size);
         if (!data)
             return AVERROR(ENOMEM);
 
         buf = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);
         if (!buf) {
             av_freep(&data);
             return AVERROR(ENOMEM);
         }
 
         buf->buffer->flags_internal |= BUFFER_FLAG_REALLOCATABLE;
         *pbuf = buf;
 
         return 0;
     } else if (buf->size == size)
         return 0;
 
     if (!(buf->buffer->flags_internal & BUFFER_FLAG_REALLOCATABLE) ||
         !av_buffer_is_writable(buf) || buf->data != buf->buffer->data) {
         /* cannot realloc, allocate a new reallocable buffer and copy data */
         AVBufferRef *new = NULL;
 
         ret = av_buffer_realloc(&new, size);
         if (ret < 0)
             return ret;
 
         memcpy(new->data, buf->data, FFMIN(size, buf->size));
 
         buffer_replace(pbuf, &new);
         return 0;
     }
 
     tmp = av_realloc(buf->buffer->data, size);
     if (!tmp)
         return AVERROR(ENOMEM);
 
     buf->buffer->data = buf->data = tmp;
     buf->buffer->size = buf->size = size;
     return 0;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -245,21 +245,21 @@
-AVBufferPool *av_buffer_pool_init2(buffer_size_t size, void *opaque,
-                                   AVBufferRef* (*alloc)(void *opaque, buffer_size_t size),
+AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque,
+                                   AVBufferRef* (*alloc)(void *opaque, size_t size),
                                    void (*pool_free)(void *opaque))
 {
     AVBufferPool *pool = av_mallocz(sizeof(*pool));
     if (!pool)
         return NULL;
 
     ff_mutex_init(&pool->mutex, NULL);
 
     pool->size      = size;
     pool->opaque    = opaque;
     pool->alloc2    = alloc;
     pool->alloc     = av_buffer_alloc; // fallback
     pool->pool_free = pool_free;
 
     atomic_init(&pool->refcount, 1);
 
     return pool;
 }
 

commit 14040a1d913794d9a3fd6406a6d8c2f0e37e0062
Date:   Sat Mar 6 12:26:16 2021 -0300

    avutil/buffer: change public function and struct size parameter types to size_t
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -245,21 +245,21 @@
-AVBufferPool *av_buffer_pool_init2(int size, void *opaque,
-                                   AVBufferRef* (*alloc)(void *opaque, int size),
+AVBufferPool *av_buffer_pool_init2(buffer_size_t size, void *opaque,
+                                   AVBufferRef* (*alloc)(void *opaque, buffer_size_t size),
                                    void (*pool_free)(void *opaque))
 {
     AVBufferPool *pool = av_mallocz(sizeof(*pool));
     if (!pool)
         return NULL;
 
     ff_mutex_init(&pool->mutex, NULL);
 
     pool->size      = size;
     pool->opaque    = opaque;
     pool->alloc2    = alloc;
     pool->alloc     = av_buffer_alloc; // fallback
     pool->pool_free = pool_free;
 
     atomic_init(&pool->refcount, 1);
 
     return pool;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -245,21 +245,21 @@
-AVBufferPool *av_buffer_pool_init2(buffer_size_t size, void *opaque,
-                                   AVBufferRef* (*alloc)(void *opaque, buffer_size_t size),
+AVBufferPool *av_buffer_pool_init2(size_t size, void *opaque,
+                                   AVBufferRef* (*alloc)(void *opaque, size_t size),
                                    void (*pool_free)(void *opaque))
 {
     AVBufferPool *pool = av_mallocz(sizeof(*pool));
     if (!pool)
         return NULL;
 
     ff_mutex_init(&pool->mutex, NULL);
 
     pool->size      = size;
     pool->opaque    = opaque;
     pool->alloc2    = alloc;
     pool->alloc     = av_buffer_alloc; // fallback
     pool->pool_free = pool_free;
 
     atomic_init(&pool->refcount, 1);
 
     return pool;
 }
 

commit 14040a1d913794d9a3fd6406a6d8c2f0e37e0062
Date:   Sat Mar 6 12:26:16 2021 -0300

    avutil/buffer: change public function and struct size parameter types to size_t
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -245,21 +245,21 @@
-AVBufferPool *av_buffer_pool_init2(int size, void *opaque,
-                                   AVBufferRef* (*alloc)(void *opaque, int size),
+AVBufferPool *av_buffer_pool_init2(buffer_size_t size, void *opaque,
+                                   AVBufferRef* (*alloc)(void *opaque, buffer_size_t size),
                                    void (*pool_free)(void *opaque))
 {
     AVBufferPool *pool = av_mallocz(sizeof(*pool));
     if (!pool)
         return NULL;
 
     ff_mutex_init(&pool->mutex, NULL);
 
     pool->size      = size;
     pool->opaque    = opaque;
     pool->alloc2    = alloc;
     pool->alloc     = av_buffer_alloc; // fallback
     pool->pool_free = pool_free;
 
     atomic_init(&pool->refcount, 1);
 
     return pool;
 }
 
commit 4e0da7d3117bbf84203358940cba82ef10b6dfde
Date:   Tue Sep 14 11:29:23 2021 +0200

    avutil/buffer: Avoid allocation of AVBuffer when using buffer pool
    
    Do this by putting an AVBuffer structure into BufferPoolEntry and
    reuse it for all subsequent uses of said BufferPoolEntry.
    
    Reviewed-by: James Almer <jamrial@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -373,25 +387,27 @@
 AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)
 {
     AVBufferRef *ret;
     BufferPoolEntry *buf;
 
     ff_mutex_lock(&pool->mutex);
     buf = pool->pool;
     if (buf) {
-        ret = av_buffer_create(buf->data, pool->size, pool_release_buffer,
-                               buf, 0);
+        memset(&buf->buffer, 0, sizeof(buf->buffer));
+        ret = buffer_create(&buf->buffer, buf->data, pool->size,
+                            pool_release_buffer, buf, 0);
         if (ret) {
             pool->pool = buf->next;
             buf->next = NULL;
+            buf->buffer.flags_internal |= BUFFER_FLAG_NO_FREE;
         }
     } else {
         ret = pool_alloc_buffer(pool);
     }
     ff_mutex_unlock(&pool->mutex);
 
     if (ret)
         atomic_fetch_add_explicit(&pool->refcount, 1, memory_order_relaxed);
 
     return ret;
 }
 
[perf] **new** commit 45a29029761297535296ddf66bcdeca3086a468d
Date:   Sat Feb 20 10:21:47 2021 -0300

    avutil/buffer: free all pooled buffers immediately after uninitializing the pool
    
    No buffer will be fetched from the pool after it's uninitialized, so there's
    no benefit from waiting until every single buffer has been returned to it
    before freeing them all.
    This should free some memory in certain scenarios, which can be beneficial in
    low memory systems.
    
    Based on a patch by Jonas Karlman.
    
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -282,13 +282,15 @@
-/*
- * This function gets called when the pool has been uninited and
- * all the buffers returned to it.
- */
-static void buffer_pool_free(AVBufferPool *pool)
+static void buffer_pool_flush(AVBufferPool *pool)
 {
     while (pool->pool) {
         BufferPoolEntry *buf = pool->pool;
         pool->pool = buf->next;
 
         buf->free(buf->opaque, buf->data);
         av_freep(&buf);
     }
+}
+
+/*
+ * This function gets called when the pool has been uninited and
+ * all the buffers returned to it.
+ */
commit 45a29029761297535296ddf66bcdeca3086a468d
Date:   Sat Feb 20 10:21:47 2021 -0300

    avutil/buffer: free all pooled buffers immediately after uninitializing the pool
    
    No buffer will be fetched from the pool after it's uninitialized, so there's
    no benefit from waiting until every single buffer has been returned to it
    before freeing them all.
    This should free some memory in certain scenarios, which can be beneficial in
    low memory systems.
    
    Based on a patch by Jonas Karlman.
    
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -295,8 +297,11 @@
+static void buffer_pool_free(AVBufferPool *pool)
+{
+    buffer_pool_flush(pool);
     ff_mutex_destroy(&pool->mutex);
 
     if (pool->pool_free)
         pool->pool_free(pool->opaque);
 
     av_freep(&pool);
 }
 
commit 45a29029761297535296ddf66bcdeca3086a468d
Date:   Sat Feb 20 10:21:47 2021 -0300

    avutil/buffer: free all pooled buffers immediately after uninitializing the pool
    
    No buffer will be fetched from the pool after it's uninitialized, so there's
    no benefit from waiting until every single buffer has been returned to it
    before freeing them all.
    This should free some memory in certain scenarios, which can be beneficial in
    low memory systems.
    
    Based on a patch by Jonas Karlman.
    
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -303,13 +308,17 @@
 void av_buffer_pool_uninit(AVBufferPool **ppool)
 {
     AVBufferPool *pool;
 
     if (!ppool || !*ppool)
         return;
     pool   = *ppool;
     *ppool = NULL;
 
+    ff_mutex_lock(&pool->mutex);
+    buffer_pool_flush(pool);
+    ff_mutex_unlock(&pool->mutex);
+
     if (atomic_fetch_sub_explicit(&pool->refcount, 1, memory_order_acq_rel) == 1)
         buffer_pool_free(pool);
 }
 
[func] **new** commit d576b37fa7e2d23737f04b6c1df2a132ff4b113f
Date:   Mon Oct 4 16:44:46 2021 +0200

    avutil/buffer: Never poison returned buffers
    
    Poisoning returned buffers is based around the implicit assumption
    that the contents of said buffers are transient. Yet this is not true
    for the buffer pools used by the various hardware contexts which store
    important state in there that needs to be preserved.
    Furthermore, the current code is also based on the assumption
    that the complete buffer pointed to by AVBuffer->data coincides with
    AVBufferRef->data; yet an implementation might store some data of its
    own before the actual user-visible data (accessible via AVBufferRef)
    which would be broken by the current code.
    
    (This is of course yet more proof that the AVBuffer API is not the right
    tool for the hardware contexts.)
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/buffer.c b/libavutil/buffer.c
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -339,19 +339,16 @@
 static void pool_release_buffer(void *opaque, uint8_t *data)
 {
     BufferPoolEntry *buf = opaque;
     AVBufferPool *pool = buf->pool;
 
-    if(CONFIG_MEMORY_POISONING)
-        memset(buf->data, FF_MEMORY_POISON, pool->size);
-
     ff_mutex_lock(&pool->mutex);
     buf->next = pool->pool;
     pool->pool = buf;
     ff_mutex_unlock(&pool->mutex);
 
     if (atomic_fetch_sub_explicit(&pool->refcount, 1, memory_order_acq_rel) == 1)
         buffer_pool_free(pool);
 }
 
 /* allocate a new buffer and override its free() callback so that
  * it is returned to the pool on free */
[safe] **new** commit 9997047a1802b5174e423cf0863041639664ab87
Date:   Sat Sep 25 10:27:10 2021 +0800

    avutil/detection_bbox: Fix av_detection_bbox_alloc failed if nb_bboxes == 0
    
    Signed-off-by: Limin Wang <lance.lmwang@gmail.com>

diff --git a/libavutil/detection_bbox.c b/libavutil/detection_bbox.c
--- a/libavutil/detection_bbox.c
+++ b/libavutil/detection_bbox.c
@@ -21,28 +21,30 @@
 AVDetectionBBoxHeader *av_detection_bbox_alloc(uint32_t nb_bboxes, size_t *out_size)
 {
     size_t size;
     struct BBoxContext {
         AVDetectionBBoxHeader header;
-        AVDetectionBBox boxes[1];
-    } *ret;
+        AVDetectionBBox boxes;
+    };
     const size_t bboxes_offset = offsetof(struct BBoxContext, boxes);
+    const size_t bbox_size = sizeof(AVDetectionBBox);
+    AVDetectionBBoxHeader *header;
 
-    size = sizeof(*ret);
-    if (nb_bboxes - 1 > (SIZE_MAX - size) / sizeof(*ret->boxes))
+    size = bboxes_offset;
+    if (nb_bboxes > (SIZE_MAX - size) / bbox_size)
         return NULL;
-    size += sizeof(*ret->boxes) * (nb_bboxes - 1);
+    size += bbox_size * nb_bboxes;
 
-    ret = av_mallocz(size);
-    if (!ret)
+    header = av_mallocz(size);
+    if (!header)
         return NULL;
 
-    ret->header.nb_bboxes = nb_bboxes;
-    ret->header.bbox_size = sizeof(*ret->boxes);
-    ret->header.bboxes_offset = bboxes_offset;
+    header->nb_bboxes     = nb_bboxes;
+    header->bbox_size     = bbox_size;
+    header->bboxes_offset = bboxes_offset;
 
     if (out_size)
         *out_size = size;
 
-    return &ret->header;
+    return header;
 }
 

[func] **new** commit e724004fd8d2c5d7753f7b997e3d02a2155ceef6
Date:   Sat Sep 25 09:31:17 2021 +0800

    avutil/detection_bbox: use offsetof for bboxes_offset
    
    Signed-off-by: Limin Wang <lance.lmwang@gmail.com>

diff --git a/libavutil/detection_bbox.c b/libavutil/detection_bbox.c
--- a/libavutil/detection_bbox.c
+++ b/libavutil/detection_bbox.c
@@ -21,27 +21,28 @@
 AVDetectionBBoxHeader *av_detection_bbox_alloc(uint32_t nb_bboxes, size_t *out_size)
 {
     size_t size;
-    struct {
+    struct BBoxContext {
         AVDetectionBBoxHeader header;
         AVDetectionBBox boxes[1];
     } *ret;
+    const size_t bboxes_offset = offsetof(struct BBoxContext, boxes);
 
     size = sizeof(*ret);
     if (nb_bboxes - 1 > (SIZE_MAX - size) / sizeof(*ret->boxes))
         return NULL;
     size += sizeof(*ret->boxes) * (nb_bboxes - 1);
 
     ret = av_mallocz(size);
     if (!ret)
         return NULL;
 
     ret->header.nb_bboxes = nb_bboxes;
     ret->header.bbox_size = sizeof(*ret->boxes);
-    ret->header.bboxes_offset = (char *)&ret->boxes - (char *)&ret->header;
+    ret->header.bboxes_offset = bboxes_offset;
 
     if (out_size)
         *out_size = size;
 
     return &ret->header;
 }
 

[func] **new** commit f1bf465aa03a255e31dfe2a7f25dba85b0d9a36c
Date:   Thu Feb 18 12:51:48 2021 +0800

    lavu: add side data AV_FRAME_DATA_DETECTION_BBOXES for object detection/classification

diff --git a/libavutil/detection_bbox.c b/libavutil/detection_bbox.c
--- /dev/null
+++ b/libavutil/detection_bbox.c
@@ -0,0 +21,27 @@
+AVDetectionBBoxHeader *av_detection_bbox_alloc(uint32_t nb_bboxes, size_t *out_size)
+{
+    size_t size;
+    struct {
+        AVDetectionBBoxHeader header;
+        AVDetectionBBox boxes[1];
+    } *ret;
+
+    size = sizeof(*ret);
+    if (nb_bboxes - 1 > (SIZE_MAX - size) / sizeof(*ret->boxes))
+        return NULL;
+    size += sizeof(*ret->boxes) * (nb_bboxes - 1);
+
+    ret = av_mallocz(size);
+    if (!ret)
+        return NULL;
+
+    ret->header.nb_bboxes = nb_bboxes;
+    ret->header.bbox_size = sizeof(*ret->boxes);
+    ret->header.bboxes_offset = (char *)&ret->boxes - (char *)&ret->header;
+
+    if (out_size)
+        *out_size = size;
+
+    return &ret->header;
+}
+
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/detection_bbox.c b/libavutil/detection_bbox.c
--- a/libavutil/detection_bbox.c
+++ b/libavutil/detection_bbox.c
@@ -48,26 +48,22 @@
 AVDetectionBBoxHeader *av_detection_bbox_create_side_data(AVFrame *frame, uint32_t nb_bboxes)
 {
     AVBufferRef         *buf;
     AVDetectionBBoxHeader *header;
     size_t size;
 
     header = av_detection_bbox_alloc(nb_bboxes, &size);
     if (!header)
         return NULL;
-    if (size > INT_MAX) {
-        av_freep(&header);
-        return NULL;
-    }
     buf = av_buffer_create((uint8_t *)header, size, NULL, NULL, 0);
     if (!buf) {
         av_freep(&header);
         return NULL;
     }
 
     if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_DETECTION_BBOXES, buf)) {
         av_buffer_unref(&buf);
         return NULL;
     }
 
     return header;
 }

commit f1bf465aa03a255e31dfe2a7f25dba85b0d9a36c
Date:   Thu Feb 18 12:51:48 2021 +0800

    lavu: add side data AV_FRAME_DATA_DETECTION_BBOXES for object detection/classification

diff --git a/libavutil/detection_bbox.c b/libavutil/detection_bbox.c
--- /dev/null
+++ b/libavutil/detection_bbox.c
@@ -0,0 +48,26 @@
+AVDetectionBBoxHeader *av_detection_bbox_create_side_data(AVFrame *frame, uint32_t nb_bboxes)
+{
+    AVBufferRef         *buf;
+    AVDetectionBBoxHeader *header;
+    size_t size;
+
+    header = av_detection_bbox_alloc(nb_bboxes, &size);
+    if (!header)
+        return NULL;
+    if (size > INT_MAX) {
+        av_freep(&header);
+        return NULL;
+    }
+    buf = av_buffer_create((uint8_t *)header, size, NULL, NULL, 0);
+    if (!buf) {
+        av_freep(&header);
+        return NULL;
+    }
+
+    if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_DETECTION_BBOXES, buf)) {
+        av_buffer_unref(&buf);
+        return NULL;
+    }
+
+    return header;
+}
[func] **new** commit 78dc21b123e71ef49f45390d826a1c25e3805ec7
Date:   Mon Jan 3 09:55:11 2022 +0100

    lavu/frame: Add Dolby Vision metadata side data type
    
    In order to be able to extend this struct later (as the Dolby Vision RPU
    evolves), all of the 'container' structs are considered extensible, and
    the individual constituent fields must instead be accessed via offsets.
    The precedent for this style of access is set in
    <libavutil/detection_bbox.h>
    
    Signed-off-by: Niklas Haas <git@haasn.dev>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/dovi_meta.c b/libavutil/dovi_meta.c
--- a/libavutil/dovi_meta.c
+++ b/libavutil/dovi_meta.c
@@ -24,12 +24,13 @@
 AVDOVIDecoderConfigurationRecord *av_dovi_alloc(size_t *size)
 {
     AVDOVIDecoderConfigurationRecord *dovi =
         av_mallocz(sizeof(AVDOVIDecoderConfigurationRecord));
     if (!dovi)
         return NULL;
 
      if (size)
         *size = sizeof(*dovi);
 
     return dovi;
 }
+
commit 78dc21b123e71ef49f45390d826a1c25e3805ec7
Date:   Mon Jan 3 09:55:11 2022 +0100

    lavu/frame: Add Dolby Vision metadata side data type
    
    In order to be able to extend this struct later (as the Dolby Vision RPU
    evolves), all of the 'container' structs are considered extensible, and
    the individual constituent fields must instead be accessed via offsets.
    The precedent for this style of access is set in
    <libavutil/detection_bbox.h>
    
    Signed-off-by: Niklas Haas <git@haasn.dev>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/dovi_meta.c b/libavutil/dovi_meta.c
--- a/libavutil/dovi_meta.c
+++ b/libavutil/dovi_meta.c
@@ -36,0 +44,17 @@
+AVDOVIMetadata *av_dovi_metadata_alloc(size_t *size)
+{
+    AVDOVIMetadataInternal *dovi = av_mallocz(sizeof(AVDOVIMetadataInternal));
+    if (!dovi)
+        return NULL;
+
+    if (size)
+        *size = sizeof(*dovi);
+
+    dovi->metadata = (struct AVDOVIMetadata) {
+        .header_offset  = offsetof(AVDOVIMetadataInternal, header),
+        .mapping_offset = offsetof(AVDOVIMetadataInternal, mapping),
+        .color_offset   = offsetof(AVDOVIMetadataInternal, color),
+    };
+
+    return &dovi->metadata;
+}
commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/encryption_info.c b/libavutil/encryption_info.c
--- a/libavutil/encryption_info.c
+++ b/libavutil/encryption_info.c
@@ -39,24 +39,24 @@
 AVEncryptionInfo *av_encryption_info_alloc(uint32_t subsample_count, uint32_t key_id_size, uint32_t iv_size)
 {
     AVEncryptionInfo *info;
 
     info = av_mallocz(sizeof(*info));
     if (!info)
         return NULL;
 
     info->key_id = av_mallocz(key_id_size);
     info->key_id_size = key_id_size;
     info->iv = av_mallocz(iv_size);
     info->iv_size = iv_size;
-    info->subsamples = av_mallocz_array(subsample_count, sizeof(*info->subsamples));
+    info->subsamples = av_calloc(subsample_count, sizeof(*info->subsamples));
     info->subsample_count = subsample_count;
 
     // Allow info->subsamples to be NULL if there are no subsamples.
     if (!info->key_id || !info->iv || (!info->subsamples && subsample_count)) {
         av_encryption_info_free(info);
         return NULL;
     }
 
     return info;
 }
 
commit 1ea365082318f06cd42a8b37dd0c7724b599c821
Date:   Tue Sep 14 21:31:53 2021 +0200

    Replace all occurences of av_mallocz_array() by av_calloc()
    
    They do the same.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/encryption_info.c b/libavutil/encryption_info.c
--- a/libavutil/encryption_info.c
+++ b/libavutil/encryption_info.c
@@ -176,38 +176,38 @@
 AVEncryptionInitInfo *av_encryption_init_info_alloc(
     uint32_t system_id_size, uint32_t num_key_ids, uint32_t key_id_size, uint32_t data_size)
 {
     AVEncryptionInitInfo *info;
     uint32_t i;
 
     info = av_mallocz(sizeof(*info));
     if (!info)
         return NULL;
 
     info->system_id = av_mallocz(system_id_size);
     info->system_id_size = system_id_size;
-    info->key_ids = key_id_size ? av_mallocz_array(num_key_ids, sizeof(*info->key_ids)) : NULL;
+    info->key_ids = key_id_size ? av_calloc(num_key_ids, sizeof(*info->key_ids)) : NULL;
     info->num_key_ids = num_key_ids;
     info->key_id_size = key_id_size;
     info->data = av_mallocz(data_size);
     info->data_size = data_size;
 
     // Allow pointers to be NULL if the size is 0.
     if ((!info->system_id && system_id_size) || (!info->data && data_size) ||
         (!info->key_ids && num_key_ids && key_id_size)) {
         av_encryption_init_info_free(info);
         return NULL;
     }
 
     if (key_id_size) {
         for (i = 0; i < num_key_ids; i++) {
             info->key_ids[i] = av_mallocz(key_id_size);
             if (!info->key_ids[i]) {
                 av_encryption_init_info_free(info);
                 return NULL;
             }
         }
     }
 
     return info;
 }
 
[func] **new** commit 14429f8fec231e1d6e0bfdb3f646e7461d11c736
Date:   Thu Jan 6 16:32:49 2022 +0100

    lavu/fifo: add a flag for automatically growing the FIFO as needed
    
    This will not increase the FIFO beyond 1MB, unless the caller explicitly
    specifies otherwise.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -38,27 +44,30 @@
 AVFifo *av_fifo_alloc2(size_t nb_elems, size_t elem_size,
                        unsigned int flags)
 {
     AVFifo *f;
     void *buffer = NULL;
 
     if (!elem_size)
         return NULL;
 
     if (nb_elems) {
         buffer = av_realloc_array(NULL, nb_elems, elem_size);
         if (!buffer)
             return NULL;
     }
     f = av_mallocz(sizeof(*f));
     if (!f) {
         av_free(buffer);
         return NULL;
     }
     f->buffer    = buffer;
     f->nb_elems  = nb_elems;
     f->elem_size = elem_size;
     f->is_empty  = 1;
 
+    f->flags           = flags;
+    f->auto_grow_limit = FFMAX(AUTO_GROW_DEFAULT_BYTES / elem_size, 1);
+
     return f;
 }
 

[func] **new** commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +38,27 @@
+AVFifo *av_fifo_alloc2(size_t nb_elems, size_t elem_size,
+                       unsigned int flags)
+{
+    AVFifo *f;
+    void *buffer = NULL;
+
+    if (!elem_size)
+        return NULL;
+
+    if (nb_elems) {
+        buffer = av_realloc_array(NULL, nb_elems, elem_size);
+        if (!buffer)
+            return NULL;
+    }
+    f = av_mallocz(sizeof(*f));
+    if (!f) {
+        av_free(buffer);
+        return NULL;
+    }
+    f->buffer    = buffer;
+    f->nb_elems  = nb_elems;
+    f->elem_size = elem_size;
+    f->is_empty  = 1;
+
+    return f;
+}
+
[safe] **new** commit 5939c8d3616a559fb5994e570c96e1a0ecad528b
Date:   Mon Jan 3 13:09:33 2022 +0100

    lavu/fifo: disallow overly large fifo sizes
    
    The API currently allows creating FIFOs up to
    - UINT_MAX: av_fifo_alloc(), av_fifo_realloc(), av_fifo_grow()
    - SIZE_MAX: av_fifo_alloc_array()
    However the usable limit is determined by
    - rndx/wndx being uint32_t
    - av_fifo_[size,space] returning int
    so no FIFO should be larger than the smallest of
    - INT_MAX
    - UINT32_MAX
    - SIZE_MAX
    (which should be INT_MAX an all commonly used platforms).
    Return an error on trying to allocate FIFOs larger than this limit.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -27,17 +31,22 @@
 AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size)
 {
     AVFifoBuffer *f;
-    void *buffer = av_realloc_array(NULL, nmemb, size);
+    void *buffer;
+
+    if (nmemb > OLD_FIFO_SIZE_MAX / size)
+        return NULL;
+
+    buffer = av_realloc_array(NULL, nmemb, size);
     if (!buffer)
         return NULL;
     f = av_mallocz(sizeof(AVFifoBuffer));
     if (!f) {
         av_free(buffer);
         return NULL;
     }
     f->buffer = buffer;
     f->end    = f->buffer + nmemb * size;
     av_fifo_reset(f);
     return f;
 }
 

[func] **new** commit 549ccea54e61e2e35b01a288466476504df03fd8
Date:   Thu Dec 30 15:06:15 2021 +0100

    lavu/fifo: do not copy the whole fifo when reallocating
    
    av_realloc() the buffer and only move the part of the ring buffer that
    needs it. Also avoids allocating a temporary fifo.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -27,17 +27,17 @@
 AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size)
 {
     AVFifoBuffer *f;
-    void *buffer = av_malloc_array(nmemb, size);
+    void *buffer = av_realloc_array(NULL, nmemb, size);
     if (!buffer)
         return NULL;
     f = av_mallocz(sizeof(AVFifoBuffer));
     if (!f) {
         av_free(buffer);
         return NULL;
     }
     f->buffer = buffer;
     f->end    = f->buffer + nmemb * size;
     av_fifo_reset(f);
     return f;
 }
 

[func] **new** commit 5010c481d1a4bbd52655c43f5d7627d4c0a90f72
Date:   Thu Dec 30 13:44:06 2021 +0100

    lavu/fifo: simplify av_fifo_alloc()
    
    Turn it into a wrapper around av_fifo_alloc_array().

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -27,16 +27,17 @@
-static AVFifoBuffer *fifo_alloc_common(void *buffer, size_t size)
+AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size)
 {
     AVFifoBuffer *f;
+    void *buffer = av_malloc_array(nmemb, size);
     if (!buffer)
         return NULL;
     f = av_mallocz(sizeof(AVFifoBuffer));
     if (!f) {
         av_free(buffer);
         return NULL;
     }
     f->buffer = buffer;
-    f->end    = f->buffer + size;
+    f->end    = f->buffer + nmemb * size;
     av_fifo_reset(f);
     return f;
 }
 
commit 14429f8fec231e1d6e0bfdb3f646e7461d11c736
Date:   Thu Jan 6 16:32:49 2022 +0100

    lavu/fifo: add a flag for automatically growing the FIFO as needed
    
    This will not increase the FIFO beyond 1MB, unless the caller explicitly
    specifies otherwise.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -38,27 +44,30 @@
 AVFifo *av_fifo_alloc2(size_t nb_elems, size_t elem_size,
                        unsigned int flags)
 {
     AVFifo *f;
     void *buffer = NULL;
 
     if (!elem_size)
         return NULL;
 
     if (nb_elems) {
         buffer = av_realloc_array(NULL, nb_elems, elem_size);
         if (!buffer)
             return NULL;
     }
     f = av_mallocz(sizeof(*f));
     if (!f) {
         av_free(buffer);
         return NULL;
     }
     f->buffer    = buffer;
     f->nb_elems  = nb_elems;
     f->elem_size = elem_size;
     f->is_empty  = 1;
 
+    f->flags           = flags;
+    f->auto_grow_limit = FFMAX(AUTO_GROW_DEFAULT_BYTES / elem_size, 1);
+
     return f;
 }
 

commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +38,27 @@
+AVFifo *av_fifo_alloc2(size_t nb_elems, size_t elem_size,
+                       unsigned int flags)
+{
+    AVFifo *f;
+    void *buffer = NULL;
+
+    if (!elem_size)
+        return NULL;
+
+    if (nb_elems) {
+        buffer = av_realloc_array(NULL, nb_elems, elem_size);
+        if (!buffer)
+            return NULL;
+    }
+    f = av_mallocz(sizeof(*f));
+    if (!f) {
+        av_free(buffer);
+        return NULL;
+    }
+    f->buffer    = buffer;
+    f->nb_elems  = nb_elems;
+    f->elem_size = elem_size;
+    f->is_empty  = 1;
+
+    return f;
+}
+
commit 5939c8d3616a559fb5994e570c96e1a0ecad528b
Date:   Mon Jan 3 13:09:33 2022 +0100

    lavu/fifo: disallow overly large fifo sizes
    
    The API currently allows creating FIFOs up to
    - UINT_MAX: av_fifo_alloc(), av_fifo_realloc(), av_fifo_grow()
    - SIZE_MAX: av_fifo_alloc_array()
    However the usable limit is determined by
    - rndx/wndx being uint32_t
    - av_fifo_[size,space] returning int
    so no FIFO should be larger than the smallest of
    - INT_MAX
    - UINT32_MAX
    - SIZE_MAX
    (which should be INT_MAX an all commonly used platforms).
    Return an error on trying to allocate FIFOs larger than this limit.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -81,34 +90,37 @@
 int av_fifo_realloc2(AVFifoBuffer *f, unsigned int new_size)
 {
     unsigned int old_size = f->end - f->buffer;
 
+    if (new_size > OLD_FIFO_SIZE_MAX)
+        return AVERROR(EINVAL);
+
     if (old_size < new_size) {
         size_t offset_r = f->rptr - f->buffer;
         size_t offset_w = f->wptr - f->buffer;
         uint8_t *tmp;
 
         tmp = av_realloc(f->buffer, new_size);
         if (!tmp)
             return AVERROR(ENOMEM);
 
         // move the data from the beginning of the ring buffer
         // to the newly allocated space
         // the second condition distinguishes full vs empty fifo
         if (offset_w <= offset_r && av_fifo_size(f)) {
             const size_t copy = FFMIN(new_size - old_size, offset_w);
             memcpy(tmp + old_size, tmp, copy);
             if (copy < offset_w) {
                 memmove(tmp, tmp + copy , offset_w - copy);
                 offset_w -= copy;
             } else
                 offset_w = old_size + copy;
         }
 
         f->buffer = tmp;
         f->end    = f->buffer + new_size;
         f->rptr   = f->buffer + offset_r;
         f->wptr   = f->buffer + offset_w;
     }
     return 0;
 }
 

commit 549ccea54e61e2e35b01a288466476504df03fd8
Date:   Thu Dec 30 15:06:15 2021 +0100

    lavu/fifo: do not copy the whole fifo when reallocating
    
    av_realloc() the buffer and only move the part of the ring buffer that
    needs it. Also avoids allocating a temporary fifo.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -81,20 +81,34 @@
 int av_fifo_realloc2(AVFifoBuffer *f, unsigned int new_size)
 {
     unsigned int old_size = f->end - f->buffer;
 
     if (old_size < new_size) {
-        int len          = av_fifo_size(f);
-        AVFifoBuffer *f2 = av_fifo_alloc(new_size);
+        size_t offset_r = f->rptr - f->buffer;
+        size_t offset_w = f->wptr - f->buffer;
+        uint8_t *tmp;
 
-        if (!f2)
+        tmp = av_realloc(f->buffer, new_size);
+        if (!tmp)
             return AVERROR(ENOMEM);
-        av_fifo_generic_read(f, f2->buffer, len, NULL);
-        f2->wptr += len;
-        f2->wndx += len;
-        av_free(f->buffer);
-        *f = *f2;
-        av_free(f2);
+
+        // move the data from the beginning of the ring buffer
+        // to the newly allocated space
+        // the second condition distinguishes full vs empty fifo
+        if (offset_w <= offset_r && av_fifo_size(f)) {
+            const size_t copy = FFMIN(new_size - old_size, offset_w);
+            memcpy(tmp + old_size, tmp, copy);
+            if (copy < offset_w) {
+                memmove(tmp, tmp + copy , offset_w - copy);
+                offset_w -= copy;
+            } else
+                offset_w = old_size + copy;
+        }
+
+        f->buffer = tmp;
+        f->end    = f->buffer + new_size;
+        f->rptr   = f->buffer + offset_r;
+        f->wptr   = f->buffer + offset_w;
     }
     return 0;
 }
 
[safe] **new** commit e9acff8a013bdd6d459116ceb35f8a53b60ff521
Date:   Tue Feb 8 19:13:45 2022 +0100

    lavu/fifo: fix a corner case in av_fifo_grow2()
    
    When the fifo is grown by exactly the current write offset, it would end
    up with offset_w = nb_elems. If av_fifo_write_from_cb() is called in
    such a state, the user callback would get callled with *nb_elems=0,
    which will then cause the write to return without writing anything.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -96,30 +96,30 @@
 int av_fifo_grow2(AVFifo *f, size_t inc)
 {
     uint8_t *tmp;
 
     if (inc > SIZE_MAX - f->nb_elems)
         return AVERROR(EINVAL);
 
     tmp = av_realloc_array(f->buffer, f->nb_elems + inc, f->elem_size);
     if (!tmp)
         return AVERROR(ENOMEM);
     f->buffer = tmp;
 
     // move the data from the beginning of the ring buffer
     // to the newly allocated space
     if (f->offset_w <= f->offset_r && !f->is_empty) {
         const size_t copy = FFMIN(inc, f->offset_w);
         memcpy(tmp + f->nb_elems * f->elem_size, tmp, copy * f->elem_size);
         if (copy < f->offset_w) {
             memmove(tmp, tmp + copy * f->elem_size,
                     (f->offset_w - copy) * f->elem_size);
             f->offset_w -= copy;
         } else
-            f->offset_w = f->nb_elems + copy;
+            f->offset_w = copy == inc ? 0 : f->nb_elems + copy;
     }
 
     f->nb_elems += inc;
 
     return 0;
 }
 

commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +82,30 @@
+int av_fifo_grow2(AVFifo *f, size_t inc)
+{
+    uint8_t *tmp;
+
+    if (inc > SIZE_MAX - f->nb_elems)
+        return AVERROR(EINVAL);
+
+    tmp = av_realloc_array(f->buffer, f->nb_elems + inc, f->elem_size);
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    f->buffer = tmp;
+
+    // move the data from the beginning of the ring buffer
+    // to the newly allocated space
+    if (f->offset_w <= f->offset_r && !f->is_empty) {
+        const size_t copy = FFMIN(inc, f->offset_w);
+        memcpy(tmp + f->nb_elems * f->elem_size, tmp, copy * f->elem_size);
+        if (copy < f->offset_w) {
+            memmove(tmp, tmp + copy * f->elem_size,
+                    (f->offset_w - copy) * f->elem_size);
+            f->offset_w -= copy;
+        } else
+            f->offset_w = f->nb_elems + copy;
+    }
+
+    f->nb_elems += inc;
+
+    return 0;
+}
+
commit e9acff8a013bdd6d459116ceb35f8a53b60ff521
Date:   Tue Feb 8 19:13:45 2022 +0100

    lavu/fifo: fix a corner case in av_fifo_grow2()
    
    When the fifo is grown by exactly the current write offset, it would end
    up with offset_w = nb_elems. If av_fifo_write_from_cb() is called in
    such a state, the user callback would get callled with *nb_elems=0,
    which will then cause the write to return without writing anything.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -96,30 +96,30 @@
 int av_fifo_grow2(AVFifo *f, size_t inc)
 {
     uint8_t *tmp;
 
     if (inc > SIZE_MAX - f->nb_elems)
         return AVERROR(EINVAL);
 
     tmp = av_realloc_array(f->buffer, f->nb_elems + inc, f->elem_size);
     if (!tmp)
         return AVERROR(ENOMEM);
     f->buffer = tmp;
 
     // move the data from the beginning of the ring buffer
     // to the newly allocated space
     if (f->offset_w <= f->offset_r && !f->is_empty) {
         const size_t copy = FFMIN(inc, f->offset_w);
         memcpy(tmp + f->nb_elems * f->elem_size, tmp, copy * f->elem_size);
         if (copy < f->offset_w) {
             memmove(tmp, tmp + copy * f->elem_size,
                     (f->offset_w - copy) * f->elem_size);
             f->offset_w -= copy;
         } else
-            f->offset_w = f->nb_elems + copy;
+            f->offset_w = copy == inc ? 0 : f->nb_elems + copy;
     }
 
     f->nb_elems += inc;
 
     return 0;
 }
 

commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +82,30 @@
+int av_fifo_grow2(AVFifo *f, size_t inc)
+{
+    uint8_t *tmp;
+
+    if (inc > SIZE_MAX - f->nb_elems)
+        return AVERROR(EINVAL);
+
+    tmp = av_realloc_array(f->buffer, f->nb_elems + inc, f->elem_size);
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    f->buffer = tmp;
+
+    // move the data from the beginning of the ring buffer
+    // to the newly allocated space
+    if (f->offset_w <= f->offset_r && !f->is_empty) {
+        const size_t copy = FFMIN(inc, f->offset_w);
+        memcpy(tmp + f->nb_elems * f->elem_size, tmp, copy * f->elem_size);
+        if (copy < f->offset_w) {
+            memmove(tmp, tmp + copy * f->elem_size,
+                    (f->offset_w - copy) * f->elem_size);
+            f->offset_w -= copy;
+        } else
+            f->offset_w = f->nb_elems + copy;
+    }
+
+    f->nb_elems += inc;
+
+    return 0;
+}
+
[func] **new** commit a10f1aec1fe59ff3aee3fb93be44142ba33a5c1d
Date:   Thu Dec 30 13:49:12 2021 +0100

    avutil/fifo: Deprecate old FIFO API
    
    Users should switch to the superior AVFifo API.
    
    Unfortunately AVFifoBuffer fields cannot be marked as deprecated because
    it would trigger a warning wherever fifo.h is #included, due to
    inlined av_fifo_peek2().

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -281,9 +281,10 @@
 void av_fifo_freep2(AVFifo **f)
 {
     if (*f) {
         av_freep(&(*f)->buffer);
         av_freep(f);
     }
 }
 
 
+#if FF_API_FIFO_OLD_API

commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +246,9 @@
+void av_fifo_freep2(AVFifo **f)
+{
+    if (*f) {
+        av_freep(&(*f)->buffer);
+        av_freep(f);
+    }
+}
+
+
commit a10f1aec1fe59ff3aee3fb93be44142ba33a5c1d
Date:   Thu Dec 30 13:49:12 2021 +0100

    avutil/fifo: Deprecate old FIFO API
    
    Users should switch to the superior AVFifo API.
    
    Unfortunately AVFifoBuffer fields cannot be marked as deprecated because
    it would trigger a warning wherever fifo.h is #included, due to
    inlined av_fifo_peek2().

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -281,9 +281,10 @@
 void av_fifo_freep2(AVFifo **f)
 {
     if (*f) {
         av_freep(&(*f)->buffer);
         av_freep(f);
     }
 }
 
 
+#if FF_API_FIFO_OLD_API

commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +246,9 @@
+void av_fifo_freep2(AVFifo **f)
+{
+    if (*f) {
+        av_freep(&(*f)->buffer);
+        av_freep(f);
+    }
+}
+
+
commit a10f1aec1fe59ff3aee3fb93be44142ba33a5c1d
Date:   Thu Dec 30 13:49:12 2021 +0100

    avutil/fifo: Deprecate old FIFO API
    
    Users should switch to the superior AVFifo API.
    
    Unfortunately AVFifoBuffer fields cannot be marked as deprecated because
    it would trigger a warning wherever fifo.h is #included, due to
    inlined av_fifo_peek2().

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -281,9 +281,10 @@
 void av_fifo_freep2(AVFifo **f)
 {
     if (*f) {
         av_freep(&(*f)->buffer);
         av_freep(f);
     }
 }
 
 
+#if FF_API_FIFO_OLD_API

commit 7329b22c058cf271e9ea3aa6e8ab2bb1c462d99f
Date:   Thu Dec 30 19:56:11 2021 +0100

    lavu/fifo: Add new AVFifo API based upon the notion of element size
    
    Many AVFifoBuffer users operate on fixed-size elements (e.g. pointers),
    but the current FIFO API deals exclusively in bytes, requiring extra
    complexity in all these callers.
    
    Add a new AVFifo API creating a FIFO with an element size
    that may be larger than a byte. All operations on such a FIFO then
    operate on complete elements.
    
    This API does not reuse AVFifoBuffer and its API at all, but instead uses
    an opaque struct called AVFifo. The AVFifoBuffer API will be deprecated
    in a future commit once all of its users have been switched to the new
    API.
    
    Not reusing AVFifoBuffer also allowed to use the full range of size_t
    from the beginning.

diff --git a/libavutil/fifo.c b/libavutil/fifo.c
--- a/libavutil/fifo.c
+++ b/libavutil/fifo.c
@@ -29,0 +246,9 @@
+void av_fifo_freep2(AVFifo **f)
+{
+    if (*f) {
+        av_freep(&(*f)->buffer);
+        av_freep(f);
+    }
+}
+
+
[func] **new** commit c1bb19e263e14887ad286c16352edbaa39be4f66
Date:   Mon Sep 26 17:52:39 2022 +0300

    lavu/fixeddsp: RISC-V V butterflies_fixed

diff --git a/libavutil/fixed_dsp.c b/libavutil/fixed_dsp.c
--- a/libavutil/fixed_dsp.c
+++ b/libavutil/fixed_dsp.c
@@ -150,21 +150,23 @@
 AVFixedDSPContext * avpriv_alloc_fixed_dsp(int bit_exact)
 {
     AVFixedDSPContext * fdsp = av_malloc(sizeof(AVFixedDSPContext));
 
     if (!fdsp)
         return NULL;
 
     fdsp->vector_fmul_window_scaled = vector_fmul_window_scaled_c;
     fdsp->vector_fmul_window = vector_fmul_window_c;
     fdsp->vector_fmul = vector_fmul_c;
     fdsp->vector_fmul_add = vector_fmul_add_c;
     fdsp->vector_fmul_reverse = vector_fmul_reverse_c;
     fdsp->butterflies_fixed = butterflies_fixed_c;
     fdsp->scalarproduct_fixed = scalarproduct_fixed_c;
 
-#if ARCH_X86
+#if ARCH_RISCV
+    ff_fixed_dsp_init_riscv(fdsp);
+#elif ARCH_X86
     ff_fixed_dsp_init_x86(fdsp);
 #endif
 
     return fdsp;
 }

commit 40e6575aa3eed64cd32bf28c00ae57edc5acb25a
Date:   Sun Jun 12 05:51:12 2022 +0200

    all: Replace if (ARCH_FOO) checks by #if ARCH_FOO
    
    This is more spec-compliant because it does not rely
    on dead-code elimination by the compiler. Especially
    MSVC has problems with this, as can be seen in
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/296373.html
    or
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/297022.html
    
    This commit does not eliminate every instance where we rely
    on dead code elimination: It only tackles branching to
    the initialization of arch-specific dsp code, not e.g. all
    uses of CONFIG_ and HAVE_ checks. But maybe it is already
    enough to compile FFmpeg with MSVC with whole-programm-optimizations
    enabled (if one does not disable too many components).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/fixed_dsp.c b/libavutil/fixed_dsp.c
--- a/libavutil/fixed_dsp.c
+++ b/libavutil/fixed_dsp.c
@@ -150,20 +150,21 @@
 AVFixedDSPContext * avpriv_alloc_fixed_dsp(int bit_exact)
 {
     AVFixedDSPContext * fdsp = av_malloc(sizeof(AVFixedDSPContext));
 
     if (!fdsp)
         return NULL;
 
     fdsp->vector_fmul_window_scaled = vector_fmul_window_scaled_c;
     fdsp->vector_fmul_window = vector_fmul_window_c;
     fdsp->vector_fmul = vector_fmul_c;
     fdsp->vector_fmul_add = vector_fmul_add_c;
     fdsp->vector_fmul_reverse = vector_fmul_reverse_c;
     fdsp->butterflies_fixed = butterflies_fixed_c;
     fdsp->scalarproduct_fixed = scalarproduct_fixed_c;
 
-    if (ARCH_X86)
-        ff_fixed_dsp_init_x86(fdsp);
+#if ARCH_X86
+    ff_fixed_dsp_init_x86(fdsp);
+#endif
 
     return fdsp;
 }
[func] **new** commit a6c10d05fe26dcfb5920fa4ce8ea8f74bf5f82dc
Date:   Mon Sep 26 17:52:28 2022 +0300

    lavu/floatdsp: RISC-V V vector_fmul_scalar
    
    This is based on existing code from the VLC git tree with two minor
    changes to account for the different function prototypes.

diff --git a/libavutil/float_dsp.c b/libavutil/float_dsp.c
--- a/libavutil/float_dsp.c
+++ b/libavutil/float_dsp.c
@@ -135,31 +135,33 @@
 av_cold AVFloatDSPContext *avpriv_float_dsp_alloc(int bit_exact)
 {
     AVFloatDSPContext *fdsp = av_mallocz(sizeof(AVFloatDSPContext));
     if (!fdsp)
         return NULL;
 
     fdsp->vector_fmul = vector_fmul_c;
     fdsp->vector_dmul = vector_dmul_c;
     fdsp->vector_fmac_scalar = vector_fmac_scalar_c;
     fdsp->vector_fmul_scalar = vector_fmul_scalar_c;
     fdsp->vector_dmac_scalar = vector_dmac_scalar_c;
     fdsp->vector_dmul_scalar = vector_dmul_scalar_c;
     fdsp->vector_fmul_window = vector_fmul_window_c;
     fdsp->vector_fmul_add = vector_fmul_add_c;
     fdsp->vector_fmul_reverse = vector_fmul_reverse_c;
     fdsp->butterflies_float = butterflies_float_c;
     fdsp->scalarproduct_float = avpriv_scalarproduct_float_c;
 
 #if ARCH_AARCH64
     ff_float_dsp_init_aarch64(fdsp);
 #elif ARCH_ARM
     ff_float_dsp_init_arm(fdsp);
 #elif ARCH_PPC
     ff_float_dsp_init_ppc(fdsp, bit_exact);
+#elif ARCH_RISCV
+    ff_float_dsp_init_riscv(fdsp);
 #elif ARCH_X86
     ff_float_dsp_init_x86(fdsp);
 #elif ARCH_MIPS
     ff_float_dsp_init_mips(fdsp);
 #endif
     return fdsp;
 }

commit 40e6575aa3eed64cd32bf28c00ae57edc5acb25a
Date:   Sun Jun 12 05:51:12 2022 +0200

    all: Replace if (ARCH_FOO) checks by #if ARCH_FOO
    
    This is more spec-compliant because it does not rely
    on dead-code elimination by the compiler. Especially
    MSVC has problems with this, as can be seen in
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/296373.html
    or
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/297022.html
    
    This commit does not eliminate every instance where we rely
    on dead code elimination: It only tackles branching to
    the initialization of arch-specific dsp code, not e.g. all
    uses of CONFIG_ and HAVE_ checks. But maybe it is already
    enough to compile FFmpeg with MSVC with whole-programm-optimizations
    enabled (if one does not disable too many components).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/float_dsp.c b/libavutil/float_dsp.c
--- a/libavutil/float_dsp.c
+++ b/libavutil/float_dsp.c
@@ -135,30 +135,31 @@
 av_cold AVFloatDSPContext *avpriv_float_dsp_alloc(int bit_exact)
 {
     AVFloatDSPContext *fdsp = av_mallocz(sizeof(AVFloatDSPContext));
     if (!fdsp)
         return NULL;
 
     fdsp->vector_fmul = vector_fmul_c;
     fdsp->vector_dmul = vector_dmul_c;
     fdsp->vector_fmac_scalar = vector_fmac_scalar_c;
     fdsp->vector_fmul_scalar = vector_fmul_scalar_c;
     fdsp->vector_dmac_scalar = vector_dmac_scalar_c;
     fdsp->vector_dmul_scalar = vector_dmul_scalar_c;
     fdsp->vector_fmul_window = vector_fmul_window_c;
     fdsp->vector_fmul_add = vector_fmul_add_c;
     fdsp->vector_fmul_reverse = vector_fmul_reverse_c;
     fdsp->butterflies_float = butterflies_float_c;
     fdsp->scalarproduct_float = avpriv_scalarproduct_float_c;
 
-    if (ARCH_AARCH64)
-        ff_float_dsp_init_aarch64(fdsp);
-    if (ARCH_ARM)
-        ff_float_dsp_init_arm(fdsp);
-    if (ARCH_PPC)
-        ff_float_dsp_init_ppc(fdsp, bit_exact);
-    if (ARCH_X86)
-        ff_float_dsp_init_x86(fdsp);
-    if (ARCH_MIPS)
-        ff_float_dsp_init_mips(fdsp);
+#if ARCH_AARCH64
+    ff_float_dsp_init_aarch64(fdsp);
+#elif ARCH_ARM
+    ff_float_dsp_init_arm(fdsp);
+#elif ARCH_PPC
+    ff_float_dsp_init_ppc(fdsp, bit_exact);
+#elif ARCH_X86
+    ff_float_dsp_init_x86(fdsp);
+#elif ARCH_MIPS
+    ff_float_dsp_init_mips(fdsp);
+#endif
     return fdsp;
 }
[func] **new** commit 6c57e0b4a8825de01e363bc6a6ab598aaf4188e4
Date:   Fri Dec 3 21:19:04 2021 +0100

    avutil/frame: Treat frame as uninitialized in get_frame_defaults()
    
    Currently, it also tests whether extended_data points to something
    different than the AVFrame's data array and frees extended_data
    if it is different. Yet this is only necessary for one of its three
    callers, namely av_frame_unref(); meanwhile the other two callers
    took measures to avoid this (or rather, to make it to an av_free(NULL)).
    
    This commit moves this chunk to av_frame_unref() (so that
    get_frame_defaults() now treats its input as uninitialized)
    and removes the now superfluous code in the other two callers.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/frame.c b/libavutil/frame.c
--- a/libavutil/frame.c
+++ b/libavutil/frame.c
@@ -100,13 +97,12 @@
 AVFrame *av_frame_alloc(void)
 {
-    AVFrame *frame = av_mallocz(sizeof(*frame));
+    AVFrame *frame = av_malloc(sizeof(*frame));
 
     if (!frame)
         return NULL;
 
-    frame->extended_data = NULL;
     get_frame_defaults(frame);
 
     return frame;
 }
 
 

commit 6c57e0b4a8825de01e363bc6a6ab598aaf4188e4
Date:   Fri Dec 3 21:19:04 2021 +0100

    avutil/frame: Treat frame as uninitialized in get_frame_defaults()
    
    Currently, it also tests whether extended_data points to something
    different than the AVFrame's data array and frees extended_data
    if it is different. Yet this is only necessary for one of its three
    callers, namely av_frame_unref(); meanwhile the other two callers
    took measures to avoid this (or rather, to make it to an av_free(NULL)).
    
    This commit moves this chunk to av_frame_unref() (so that
    get_frame_defaults() now treats its input as uninitialized)
    and removes the now superfluous code in the other two callers.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/frame.c b/libavutil/frame.c
--- a/libavutil/frame.c
+++ b/libavutil/frame.c
@@ -439,24 +435,27 @@
 void av_frame_unref(AVFrame *frame)
 {
     int i;
 
     if (!frame)
         return;
 
     wipe_side_data(frame);
 
     for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)
         av_buffer_unref(&frame->buf[i]);
     for (i = 0; i < frame->nb_extended_buf; i++)
         av_buffer_unref(&frame->extended_buf[i]);
     av_freep(&frame->extended_buf);
     av_dict_free(&frame->metadata);
 
     av_buffer_unref(&frame->hw_frames_ctx);
 
     av_buffer_unref(&frame->opaque_ref);
     av_buffer_unref(&frame->private_ref);
 
+    if (frame->extended_data != frame->data)
+        av_freep(&frame->extended_data);
+
     get_frame_defaults(frame);
 }
 

[func] **new** commit b8accd1175d20ab308de69dbd06bda06a02183e3
Date:   Sat Mar 6 19:33:32 2021 +0100

    avutil/frame: Remove AVFrame QP table API
    
    Originally deprecated in 1296b1f6c0631ab79464e22d48a6a1548450b943;
    scheduled again for removal in a9915268327b097bba84a07f68968d8c07f4b549.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/frame.c b/libavutil/frame.c
--- a/libavutil/frame.c
+++ b/libavutil/frame.c
@@ -554,29 +466,24 @@
 void av_frame_unref(AVFrame *frame)
 {
     int i;
 
     if (!frame)
         return;
 
     wipe_side_data(frame);
 
     for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)
         av_buffer_unref(&frame->buf[i]);
     for (i = 0; i < frame->nb_extended_buf; i++)
         av_buffer_unref(&frame->extended_buf[i]);
     av_freep(&frame->extended_buf);
     av_dict_free(&frame->metadata);
-#if FF_API_FRAME_QP
-FF_DISABLE_DEPRECATION_WARNINGS
-    av_buffer_unref(&frame->qp_table_buf);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     av_buffer_unref(&frame->hw_frames_ctx);
 
     av_buffer_unref(&frame->opaque_ref);
     av_buffer_unref(&frame->private_ref);
 
     get_frame_defaults(frame);
 }
 
[func] **new** commit 188faab2bba234dab488b07a0dd425255eae8c23
Date:   Wed Feb 16 21:54:58 2022 +0800

    avutil: support for CUVA Vivid HDR metadata
    
    Signed-off-by: Limin Wang <lance.lmwang@gmail.com>

diff --git a/libavutil/hdr_dynamic_vivid_metadata.c b/libavutil/hdr_dynamic_vivid_metadata.c
--- /dev/null
+++ b/libavutil/hdr_dynamic_vivid_metadata.c
@@ -0,0 +24,12 @@
+AVDynamicHDRVivid *av_dynamic_hdr_vivid_alloc(size_t *size)
+{
+    AVDynamicHDRVivid *hdr_vivid = av_mallocz(sizeof(AVDynamicHDRVivid));
+    if (!hdr_vivid)
+        return NULL;
+
+    if (size)
+        *size = sizeof(*hdr_vivid);
+
+    return hdr_vivid;
+}
+
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_cuda.c b/libavutil/hwcontext_cuda.c
--- a/libavutil/hwcontext_cuda.c
+++ b/libavutil/hwcontext_cuda.c
@@ -96,26 +96,26 @@
-static AVBufferRef *cuda_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *cuda_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext        *ctx = opaque;
     AVHWDeviceContext *device_ctx = ctx->device_ctx;
     AVCUDADeviceContext    *hwctx = device_ctx->hwctx;
     CudaFunctions             *cu = hwctx->internal->cuda_dl;
 
     AVBufferRef *ret = NULL;
     CUcontext dummy = NULL;
     CUdeviceptr data;
     int err;
 
     err = CHECK_CU(cu->cuCtxPushCurrent(hwctx->cuda_ctx));
     if (err < 0)
         return NULL;
 
     err = CHECK_CU(cu->cuMemAlloc(&data, size));
     if (err < 0)
         goto fail;
 
     ret = av_buffer_create((uint8_t*)data, size, cuda_buffer_free, ctx, 0);
     if (!ret) {
         CHECK_CU(cu->cuMemFree(data));
         goto fail;
     }
 

[func] **new** commit e36eb940484b8b8ef5f3e7542d12240e24839fcf
Date:   Sat Mar 6 13:58:26 2021 -0300

    avutil: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_cuda.c b/libavutil/hwcontext_cuda.c
--- a/libavutil/hwcontext_cuda.c
+++ b/libavutil/hwcontext_cuda.c
@@ -96,26 +96,26 @@
-static AVBufferRef *cuda_pool_alloc(void *opaque, int size)
+static AVBufferRef *cuda_pool_alloc(void *opaque, buffer_size_t size)
 {
     AVHWFramesContext        *ctx = opaque;
     AVHWDeviceContext *device_ctx = ctx->device_ctx;
     AVCUDADeviceContext    *hwctx = device_ctx->hwctx;
     CudaFunctions             *cu = hwctx->internal->cuda_dl;
 
     AVBufferRef *ret = NULL;
     CUcontext dummy = NULL;
     CUdeviceptr data;
     int err;
 
     err = CHECK_CU(cu->cuCtxPushCurrent(hwctx->cuda_ctx));
     if (err < 0)
         return NULL;
 
     err = CHECK_CU(cu->cuMemAlloc(&data, size));
     if (err < 0)
         goto fail;
 
     ret = av_buffer_create((uint8_t*)data, size, cuda_buffer_free, ctx, 0);
     if (!ret) {
         CHECK_CU(cu->cuMemFree(data));
         goto fail;
     }
 
[func] **new** commit 30bbc0a624bc43fa4aaabd695546ad426d0d086b
Date:   Wed Jul 6 01:32:27 2022 +0200

    avutil/hwcontext_d3d11va: fix texture_infos writes on non-fixed-size pools

diff --git a/libavutil/hwcontext_d3d11va.c b/libavutil/hwcontext_d3d11va.c
--- a/libavutil/hwcontext_d3d11va.c
+++ b/libavutil/hwcontext_d3d11va.c
@@ -158,28 +158,39 @@
 static AVBufferRef *wrap_texture_buf(AVHWFramesContext *ctx, ID3D11Texture2D *tex, int index)
 {
     AVBufferRef *buf;
     AVD3D11FrameDescriptor         *desc = av_mallocz(sizeof(*desc));
     D3D11VAFramesContext              *s = ctx->internal->priv;
     AVD3D11VAFramesContext *frames_hwctx = ctx->hwctx;
     if (!desc) {
         ID3D11Texture2D_Release(tex);
         return NULL;
     }
 
+    if (s->nb_surfaces <= s->nb_surfaces_used) {
+        frames_hwctx->texture_infos = av_realloc_f(frames_hwctx->texture_infos,
+                                                   s->nb_surfaces_used + 1,
+                                                   sizeof(*frames_hwctx->texture_infos));
+        if (!frames_hwctx->texture_infos) {
+            ID3D11Texture2D_Release(tex);
+            return NULL;
+        }
+        s->nb_surfaces = s->nb_surfaces_used + 1;
+    }
+
     frames_hwctx->texture_infos[s->nb_surfaces_used].texture = tex;
     frames_hwctx->texture_infos[s->nb_surfaces_used].index = index;
     s->nb_surfaces_used++;
 
     desc->texture = tex;
     desc->index   = index;
 
     buf = av_buffer_create((uint8_t *)desc, sizeof(desc), free_texture, tex, 0);
     if (!buf) {
         ID3D11Texture2D_Release(tex);
         av_free(desc);
         return NULL;
     }
 
     return buf;
 }
 

[func] **new** commit 4f78711f9c28b11dae4e4b96be46b6b4925eb8c6
Date:   Fri Aug 20 22:48:05 2021 +0100

    libavutil/hwcontext_d3d11va: adding more texture information to the D3D11 hwcontext API
    
    Microsoft VideoProcessor requires texture with D3DUSAGE_RENDERTARGET flag as output.
    There is no way to allocate array of textures with D3D11_BIND_RENDER_TARGET flag
    and .ArraySize > 2 by ID3D11Device_CreateTexture2D due to the Microsoft limitation.
    Adding AVD3D11FrameDescriptors array to store array of single textures
    instead of texture with multiple slices resolves this.
    
    Signed-off-by: Artem Galin <artem.galin@intel.com>

diff --git a/libavutil/hwcontext_d3d11va.c b/libavutil/hwcontext_d3d11va.c
--- a/libavutil/hwcontext_d3d11va.c
+++ b/libavutil/hwcontext_d3d11va.c
@@ -155,22 +158,28 @@
-static AVBufferRef *wrap_texture_buf(ID3D11Texture2D *tex, int index)
+static AVBufferRef *wrap_texture_buf(AVHWFramesContext *ctx, ID3D11Texture2D *tex, int index)
 {
     AVBufferRef *buf;
-    AVD3D11FrameDescriptor *desc = av_mallocz(sizeof(*desc));
+    AVD3D11FrameDescriptor         *desc = av_mallocz(sizeof(*desc));
+    D3D11VAFramesContext              *s = ctx->internal->priv;
+    AVD3D11VAFramesContext *frames_hwctx = ctx->hwctx;
     if (!desc) {
         ID3D11Texture2D_Release(tex);
         return NULL;
     }
 
+    frames_hwctx->texture_infos[s->nb_surfaces_used].texture = tex;
+    frames_hwctx->texture_infos[s->nb_surfaces_used].index = index;
+    s->nb_surfaces_used++;
+
     desc->texture = tex;
     desc->index   = index;
 
     buf = av_buffer_create((uint8_t *)desc, sizeof(desc), free_texture, tex, 0);
     if (!buf) {
         ID3D11Texture2D_Release(tex);
         av_free(desc);
         return NULL;
     }
 
     return buf;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_dxva2.c b/libavutil/hwcontext_dxva2.c
--- a/libavutil/hwcontext_dxva2.c
+++ b/libavutil/hwcontext_dxva2.c
@@ -127,15 +127,15 @@
-static AVBufferRef *dxva2_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *dxva2_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext      *ctx = (AVHWFramesContext*)opaque;
     DXVA2FramesContext       *s = ctx->internal->priv;
     AVDXVA2FramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
         return av_buffer_create((uint8_t*)s->surfaces_internal[s->nb_surfaces_used - 1],
                                 sizeof(*hwctx->surfaces), dxva2_pool_release_dummy, 0, 0);
     }
 
     return NULL;
 }
 

commit e36eb940484b8b8ef5f3e7542d12240e24839fcf
Date:   Sat Mar 6 13:58:26 2021 -0300

    avutil: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_dxva2.c b/libavutil/hwcontext_dxva2.c
--- a/libavutil/hwcontext_dxva2.c
+++ b/libavutil/hwcontext_dxva2.c
@@ -127,15 +127,15 @@
-static AVBufferRef *dxva2_pool_alloc(void *opaque, int size)
+static AVBufferRef *dxva2_pool_alloc(void *opaque, buffer_size_t size)
 {
     AVHWFramesContext      *ctx = (AVHWFramesContext*)opaque;
     DXVA2FramesContext       *s = ctx->internal->priv;
     AVDXVA2FramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
         return av_buffer_create((uint8_t*)s->surfaces_internal[s->nb_surfaces_used - 1],
                                 sizeof(*hwctx->surfaces), dxva2_pool_release_dummy, 0, 0);
     }
 
     return NULL;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_opencl.c b/libavutil/hwcontext_opencl.c
--- a/libavutil/hwcontext_opencl.c
+++ b/libavutil/hwcontext_opencl.c
@@ -1620,49 +1620,49 @@
-static AVBufferRef *opencl_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *opencl_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext      *hwfc = opaque;
     AVOpenCLDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     AVOpenCLFrameDescriptor *desc;
     cl_int cle;
     cl_mem image;
     cl_image_format image_format;
     cl_image_desc   image_desc;
     int err, p;
     AVBufferRef *ref;
 
     desc = av_mallocz(sizeof(*desc));
     if (!desc)
         return NULL;
 
     for (p = 0;; p++) {
         err = opencl_get_plane_format(hwfc->sw_format, p,
                                       hwfc->width, hwfc->height,
                                       &image_format, &image_desc);
         if (err == AVERROR(ENOENT))
             break;
         if (err < 0)
             goto fail;
 
         // For generic image objects, the pitch is determined by the
         // implementation.
         image_desc.image_row_pitch = 0;
 
         image = clCreateImage(hwctx->context, CL_MEM_READ_WRITE,
                               &image_format, &image_desc, NULL, &cle);
         if (!image) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to create image for "
                    "plane %d: %d.\n", p, cle);
             goto fail;
         }
 
         desc->planes[p] = image;
     }
 
     desc->nb_planes = p;
 
     ref = av_buffer_create((uint8_t*)desc, sizeof(*desc),
                            &opencl_pool_free, hwfc, 0);
     if (!ref)
         goto fail;
 
     return ref;
 

commit e36eb940484b8b8ef5f3e7542d12240e24839fcf
Date:   Sat Mar 6 13:58:26 2021 -0300

    avutil: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_opencl.c b/libavutil/hwcontext_opencl.c
--- a/libavutil/hwcontext_opencl.c
+++ b/libavutil/hwcontext_opencl.c
@@ -1620,49 +1620,49 @@
-static AVBufferRef *opencl_pool_alloc(void *opaque, int size)
+static AVBufferRef *opencl_pool_alloc(void *opaque, buffer_size_t size)
 {
     AVHWFramesContext      *hwfc = opaque;
     AVOpenCLDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     AVOpenCLFrameDescriptor *desc;
     cl_int cle;
     cl_mem image;
     cl_image_format image_format;
     cl_image_desc   image_desc;
     int err, p;
     AVBufferRef *ref;
 
     desc = av_mallocz(sizeof(*desc));
     if (!desc)
         return NULL;
 
     for (p = 0;; p++) {
         err = opencl_get_plane_format(hwfc->sw_format, p,
                                       hwfc->width, hwfc->height,
                                       &image_format, &image_desc);
         if (err == AVERROR(ENOENT))
             break;
         if (err < 0)
             goto fail;
 
         // For generic image objects, the pitch is determined by the
         // implementation.
         image_desc.image_row_pitch = 0;
 
         image = clCreateImage(hwctx->context, CL_MEM_READ_WRITE,
                               &image_format, &image_desc, NULL, &cle);
         if (!image) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to create image for "
                    "plane %d: %d.\n", p, cle);
             goto fail;
         }
 
         desc->planes[p] = image;
     }
 
     desc->nb_planes = p;
 
     ref = av_buffer_create((uint8_t*)desc, sizeof(*desc),
                            &opencl_pool_free, hwfc, 0);
     if (!ref)
         goto fail;
 
     return ref;
 
[func] **new** commit 7c6f9b9d638a9ae6020c8a388d5a6f2a89620663
Date:   Wed Jan 5 11:52:07 2022 +0800

    Revert "avutils/hwcontext: When deriving a hwdevice, search for existing device in both directions"
    
    This reverts commit a4289497755386435783774a4f520eb7fc23cbc9.
    There were objections on ML (see
    https://ffmpeg.org/pipermail/ffmpeg-devel/2021-December/290530.html)
    
    Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>

diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -281,15 +281,15 @@
 static AVBufferRef *qsv_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext    *ctx = (AVHWFramesContext*)opaque;
     QSVFramesContext       *s = ctx->internal->priv;
     AVQSVFramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
         return av_buffer_create((uint8_t*)(s->surfaces_internal + s->nb_surfaces_used - 1),
-                                sizeof(*hwctx->surfaces), qsv_release_dummy, NULL, 0);
+                                sizeof(*hwctx->surfaces), qsv_pool_release_dummy, NULL, 0);
     }
 
     return NULL;
 }
 

[func] **new** commit a4289497755386435783774a4f520eb7fc23cbc9
Date:   Thu Nov 25 02:41:32 2021 +0000

    avutils/hwcontext: When deriving a hwdevice, search for existing device in both directions
    
    The test /libavutil/tests/hwdevice checks that when deriving a device
    from a source device and then deriving back to the type of the source
    device, the result is matching the original source device, i.e. the
    derivation mechanism doesn't create a new device in this case.
    
    Previously, this test was usually passed, but only due to two different
    kind of flaws:
    
    1. The test covers only a single level of derivation (and back)
    
    It derives device Y from device X and then Y back to the type of X and
    checks whether the result matches X.
    
    What it doesn't check for, are longer chains of derivation like:
    
    CUDA1 > OpenCL2 > CUDA3 and then back to OpenCL4
    
    In that case, the second derivation returns the first device (CUDA3 ==
    CUDA1), but when deriving OpenCL4, hwcontext.c was creating a new
    OpenCL4 context instead of returning OpenCL2, because there was no link
    from CUDA1 to OpenCL2 (only backwards from OpenCL2 to CUDA1)
    
    If the test would check for two levels of derivation, it would have
    failed.
    
    This patch fixes those (yet untested) cases by introducing forward
    references (derived_device) in addition to the existing back references
    (source_device).
    
    2. hwcontext_qsv didn't properly set the source_device
    
    In case of QSV, hwcontext_qsv creates a source context internally
    (vaapi, dxva2 or d3d11va) without calling av_hwdevice_ctx_create_derived
    and without setting source_device.
    
    This way, the hwcontext test ran successful, but what practically
    happened, was that - for example - deriving vaapi from qsv didn't return
    the original underlying vaapi device and a new one was created instead:
    Exactly what the test is intended to detect and prevent. It just
    couldn't do so, because the original device was hidden (= not set as the
    source_device of the QSV device).
    
    This patch properly makes these setting and fixes all derivation
    scenarios.
    
    (at a later stage, /libavutil/tests/hwdevice should be extended to check
    longer derivation chains as well)
    
    Reviewed-by: Lynne <dev@lynne.ee>
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Tested-by: Wenbin Chen <wenbin.chen@intel.com>
    Signed-off-by: softworkz <softworkz@hotmail.com>
    Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>

diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -281,15 +281,15 @@
 static AVBufferRef *qsv_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext    *ctx = (AVHWFramesContext*)opaque;
     QSVFramesContext       *s = ctx->internal->priv;
     AVQSVFramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
         return av_buffer_create((uint8_t*)(s->surfaces_internal + s->nb_surfaces_used - 1),
-                                sizeof(*hwctx->surfaces), qsv_pool_release_dummy, NULL, 0);
+                                sizeof(*hwctx->surfaces), qsv_release_dummy, NULL, 0);
     }
 
     return NULL;
 }
 

[safe] **new** commit bd5ec3601f03c8fb5514673e862223defa6f7673
Date:   Sat Sep 25 12:27:16 2021 +0200

    avutil/hwcontext_qsv: Fix leak of AVBuffer and AVBufferRef
    
    This av_buffer_create() does nothing but leak an AVBuffer and an
    AVBufferRef (except on allocation error).
    
    Fixes Coverity issue 1491393.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -230,17 +230,15 @@
 static AVBufferRef *qsv_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext    *ctx = (AVHWFramesContext*)opaque;
     QSVFramesContext       *s = ctx->internal->priv;
     AVQSVFramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
-        av_buffer_create((uint8_t*)(s->handle_pairs_internal + s->nb_surfaces_used - 1),
-                                sizeof(*s->handle_pairs_internal), qsv_pool_release_dummy, NULL, 0);
         return av_buffer_create((uint8_t*)(s->surfaces_internal + s->nb_surfaces_used - 1),
                                 sizeof(*hwctx->surfaces), qsv_pool_release_dummy, NULL, 0);
     }
 
     return NULL;
 }
 

[func] **new** commit a08a5299ac68b1151179c8b0ca1e920ee6c96e2b
Date:   Fri Aug 20 22:48:03 2021 +0100

    libavutil/hwcontext_qsv: supporting d3d11va device type
    
    This enables usage of non-powered/headless GPU, better HDR support.
    Pool of resources is allocated as one texture with array of slices.
    
    Signed-off-by: Artem Galin <artem.galin@intel.com>

diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -197,15 +213,17 @@
 static AVBufferRef *qsv_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext    *ctx = (AVHWFramesContext*)opaque;
     QSVFramesContext       *s = ctx->internal->priv;
     AVQSVFramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
+        av_buffer_create((uint8_t*)(s->handle_pairs_internal + s->nb_surfaces_used - 1),
+                                sizeof(*s->handle_pairs_internal), qsv_pool_release_dummy, NULL, 0);
         return av_buffer_create((uint8_t*)(s->surfaces_internal + s->nb_surfaces_used - 1),
                                 sizeof(*hwctx->surfaces), qsv_pool_release_dummy, NULL, 0);
     }
 
     return NULL;
 }
 

commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -197,15 +197,15 @@
-static AVBufferRef *qsv_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *qsv_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext    *ctx = (AVHWFramesContext*)opaque;
     QSVFramesContext       *s = ctx->internal->priv;
     AVQSVFramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
         return av_buffer_create((uint8_t*)(s->surfaces_internal + s->nb_surfaces_used - 1),
                                 sizeof(*hwctx->surfaces), qsv_pool_release_dummy, NULL, 0);
     }
 
     return NULL;
 }
 

commit e36eb940484b8b8ef5f3e7542d12240e24839fcf
Date:   Sat Mar 6 13:58:26 2021 -0300

    avutil: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -197,15 +197,15 @@
-static AVBufferRef *qsv_pool_alloc(void *opaque, int size)
+static AVBufferRef *qsv_pool_alloc(void *opaque, buffer_size_t size)
 {
     AVHWFramesContext    *ctx = (AVHWFramesContext*)opaque;
     QSVFramesContext       *s = ctx->internal->priv;
     AVQSVFramesContext *hwctx = ctx->hwctx;
 
     if (s->nb_surfaces_used < hwctx->nb_surfaces) {
         s->nb_surfaces_used++;
         return av_buffer_create((uint8_t*)(s->surfaces_internal + s->nb_surfaces_used - 1),
                                 sizeof(*hwctx->surfaces), qsv_pool_release_dummy, NULL, 0);
     }
 
     return NULL;
 }
 
[func] **new** commit b62940bec388e1810d946457bc8127d5be76724c
Date:   Mon Dec 5 14:33:21 2022 -0800

    lavu/hwcontext_vaapi: Skip 'vgem' driver
    
    There can be more than one available render node, and it's not
    guaranteed the first node we come across is the correct one. In
    particular, 'vgem' devices are common, and are
    never VAAPI-enabled and thus not valid here.
    
    We have a 'kernel_driver' arg already for specifying a single driver we
    *do* want, but it doesn't support a negation, nor a list. It's easier
    just to automatically skip 'vgem' anyway, to avoid foisting this burden
    on users.
    
    This has precedent in libva-utils already:
    
      bfb6b98ed62a exclude vgem node and invalid drm node in vainfo
      https://github.com/intel/libva-utils/commit/bfb6b98ed62ac14a840ba62639ab902a23912258
    
    Signed-off-by: Brian Norris <briannorris@chromium.org>

diff --git a/libavutil/hwcontext_vaapi.c b/libavutil/hwcontext_vaapi.c
--- a/libavutil/hwcontext_vaapi.c
+++ b/libavutil/hwcontext_vaapi.c
@@ -1651,155 +1651,170 @@
 static int vaapi_device_create(AVHWDeviceContext *ctx, const char *device,
                                AVDictionary *opts, int flags)
 {
     VAAPIDevicePriv *priv;
     VADisplay display = NULL;
     const AVDictionaryEntry *ent;
     int try_drm, try_x11, try_all;
 
     priv = av_mallocz(sizeof(*priv));
     if (!priv)
         return AVERROR(ENOMEM);
 
     priv->drm_fd = -1;
 
     ctx->user_opaque = priv;
     ctx->free        = vaapi_device_free;
 
     ent = av_dict_get(opts, "connection_type", NULL, 0);
     if (ent) {
         try_all = try_drm = try_x11 = 0;
         if (!strcmp(ent->value, "drm")) {
             try_drm = 1;
         } else if (!strcmp(ent->value, "x11")) {
             try_x11 = 1;
         } else {
             av_log(ctx, AV_LOG_ERROR, "Invalid connection type %s.\n",
                    ent->value);
             return AVERROR(EINVAL);
         }
     } else {
         try_all = 1;
         try_drm = HAVE_VAAPI_DRM;
         try_x11 = HAVE_VAAPI_X11;
     }
 
 #if HAVE_VAAPI_DRM
     while (!display && try_drm) {
         // If the device is specified, try to open it as a DRM device node.
         // If not, look for a usable render node, possibly restricted to those
         // using a specified kernel driver.
         int loglevel = try_all ? AV_LOG_VERBOSE : AV_LOG_ERROR;
         if (device) {
             priv->drm_fd = open(device, O_RDWR);
             if (priv->drm_fd < 0) {
                 av_log(ctx, loglevel, "Failed to open %s as "
                        "DRM device node.\n", device);
                 break;
             }
         } else {
             char path[64];
             int n, max_devices = 8;
 #if CONFIG_LIBDRM
+            drmVersion *info;
             const AVDictionaryEntry *kernel_driver;
             kernel_driver = av_dict_get(opts, "kernel_driver", NULL, 0);
 #endif
             for (n = 0; n < max_devices; n++) {
                 snprintf(path, sizeof(path),
                          "/dev/dri/renderD%d", 128 + n);
                 priv->drm_fd = open(path, O_RDWR);
                 if (priv->drm_fd < 0) {
                     av_log(ctx, AV_LOG_VERBOSE, "Cannot open "
                            "DRM render node for device %d.\n", n);
                     break;
                 }
 #if CONFIG_LIBDRM
+                info = drmGetVersion(priv->drm_fd);
+                if (!info) {
+                    av_log(ctx, AV_LOG_VERBOSE,
+                           "Failed to get DRM version for device %d.\n", n);
+                    close(priv->drm_fd);
+                    priv->drm_fd = -1;
+                    continue;
+                }
                 if (kernel_driver) {
-                    drmVersion *info;
-                    info = drmGetVersion(priv->drm_fd);
                     if (strcmp(kernel_driver->value, info->name)) {
                         av_log(ctx, AV_LOG_VERBOSE, "Ignoring device %d "
                                "with non-matching kernel driver (%s).\n",
                                n, info->name);
                         drmFreeVersion(info);
                         close(priv->drm_fd);
                         priv->drm_fd = -1;
                         continue;
                     }
                     av_log(ctx, AV_LOG_VERBOSE, "Trying to use "
                            "DRM render node for device %d, "
                            "with matching kernel driver (%s).\n",
                            n, info->name);
                     drmFreeVersion(info);
-                } else
-#endif
-                {
-                    av_log(ctx, AV_LOG_VERBOSE, "Trying to use "
-                           "DRM render node for device %d.\n", n);
+                    break;
+                // drmGetVersion() ensures |info->name| is 0-terminated.
+                } else if (!strcmp(info->name, "vgem")) {
+                    av_log(ctx, AV_LOG_VERBOSE,
+                           "Skipping vgem node for device %d.\n", n);
+                    drmFreeVersion(info);
+                    close(priv->drm_fd);
+                    priv->drm_fd = -1;
+                    continue;
                 }
+                drmFreeVersion(info);
+#endif
+                av_log(ctx, AV_LOG_VERBOSE, "Trying to use "
+                       "DRM render node for device %d.\n", n);
                 break;
             }
             if (n >= max_devices)
                 break;
         }
 
         display = vaGetDisplayDRM(priv->drm_fd);
         if (!display) {
             av_log(ctx, AV_LOG_VERBOSE, "Cannot open a VA display "
                    "from DRM device %s.\n", device);
             return AVERROR_EXTERNAL;
         }
         break;
     }
 #endif
 
 #if HAVE_VAAPI_X11
     if (!display && try_x11) {
         // Try to open the device as an X11 display.
         priv->x11_display = XOpenDisplay(device);
         if (!priv->x11_display) {
             av_log(ctx, AV_LOG_VERBOSE, "Cannot open X11 display "
                    "%s.\n", XDisplayName(device));
         } else {
             display = vaGetDisplay(priv->x11_display);
             if (!display) {
                 av_log(ctx, AV_LOG_ERROR, "Cannot open a VA display "
                        "from X11 display %s.\n", XDisplayName(device));
                 return AVERROR_UNKNOWN;
             }
 
             av_log(ctx, AV_LOG_VERBOSE, "Opened VA display via "
                    "X11 display %s.\n", XDisplayName(device));
         }
     }
 #endif
 
     if (!display) {
         if (device)
             av_log(ctx, AV_LOG_ERROR, "No VA display found for "
                    "device %s.\n", device);
         else
             av_log(ctx, AV_LOG_ERROR, "No VA display found for "
                    "any default device.\n");
         return AVERROR(EINVAL);
     }
 
     ent = av_dict_get(opts, "driver", NULL, 0);
     if (ent) {
 #if VA_CHECK_VERSION(0, 38, 0)
         VAStatus vas;
         vas = vaSetDriverName(display, ent->value);
         if (vas != VA_STATUS_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Failed to set driver name to "
                    "%s: %d (%s).\n", ent->value, vas, vaErrorStr(vas));
             vaTerminate(display);
             return AVERROR_EXTERNAL;
         }
 #else
         av_log(ctx, AV_LOG_WARNING, "Driver name setting is not "
                "supported with this VAAPI version.\n");
 #endif
     }
 
     return vaapi_device_connect(ctx, display);
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_vdpau.c b/libavutil/hwcontext_vdpau.c
--- a/libavutil/hwcontext_vdpau.c
+++ b/libavutil/hwcontext_vdpau.c
@@ -228,28 +228,28 @@
-static AVBufferRef *vdpau_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *vdpau_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext             *ctx = opaque;
     VDPAUFramesContext           *priv = ctx->internal->priv;
     AVVDPAUDeviceContext *device_hwctx = ctx->device_ctx->hwctx;
     VDPAUDeviceContext    *device_priv = ctx->device_ctx->internal->priv;
 
     AVBufferRef *ret;
     VdpVideoSurface surf;
     VdpStatus err;
 
     err = device_priv->surf_create(device_hwctx->device, priv->chroma_type,
                                    ctx->width, ctx->height, &surf);
     if (err != VDP_STATUS_OK) {
         av_log(ctx, AV_LOG_ERROR, "Error allocating a VDPAU video surface\n");
         return NULL;
     }
 
     ret = av_buffer_create((uint8_t*)(uintptr_t)surf, sizeof(surf),
                            vdpau_buffer_free, ctx, AV_BUFFER_FLAG_READONLY);
     if (!ret) {
         device_priv->surf_destroy(surf);
         return NULL;
     }
 
     return ret;
 }
 

commit e36eb940484b8b8ef5f3e7542d12240e24839fcf
Date:   Sat Mar 6 13:58:26 2021 -0300

    avutil: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_vdpau.c b/libavutil/hwcontext_vdpau.c
--- a/libavutil/hwcontext_vdpau.c
+++ b/libavutil/hwcontext_vdpau.c
@@ -228,28 +228,28 @@
-static AVBufferRef *vdpau_pool_alloc(void *opaque, int size)
+static AVBufferRef *vdpau_pool_alloc(void *opaque, buffer_size_t size)
 {
     AVHWFramesContext             *ctx = opaque;
     VDPAUFramesContext           *priv = ctx->internal->priv;
     AVVDPAUDeviceContext *device_hwctx = ctx->device_ctx->hwctx;
     VDPAUDeviceContext    *device_priv = ctx->device_ctx->internal->priv;
 
     AVBufferRef *ret;
     VdpVideoSurface surf;
     VdpStatus err;
 
     err = device_priv->surf_create(device_hwctx->device, priv->chroma_type,
                                    ctx->width, ctx->height, &surf);
     if (err != VDP_STATUS_OK) {
         av_log(ctx, AV_LOG_ERROR, "Error allocating a VDPAU video surface\n");
         return NULL;
     }
 
     ret = av_buffer_create((uint8_t*)(uintptr_t)surf, sizeof(surf),
                            vdpau_buffer_free, ctx, AV_BUFFER_FLAG_READONLY);
     if (!ret) {
         device_priv->surf_destroy(surf);
         return NULL;
     }
 
     return ret;
 }
 
[func] **new** commit 504c60660d3194758823ddd45ceddb86e35d806f
Date:   Tue Jun 29 14:43:16 2021 -0700

    avutil/hwcontext_videotoolbox: implement hwupload to convert AVFrame to CVPixelBuffer
    
    Teach AV_HWDEVICE_TYPE_VIDEOTOOLBOX to be able to create AVFrames of type
    AV_PIX_FMT_VIDEOTOOLBOX. This can be used to hwupload a regular AVFrame
    into its CVPixelBuffer equivalent.
    
        ffmpeg -init_hw_device videotoolbox -f lavfi -i color=black:640x480 -vf hwupload -c:v h264_videotoolbox -f null -y /dev/null
    
    Signed-off-by: Aman Karmani <aman@tmm1.net>

diff --git a/libavutil/hwcontext_videotoolbox.c b/libavutil/hwcontext_videotoolbox.c
--- a/libavutil/hwcontext_videotoolbox.c
+++ b/libavutil/hwcontext_videotoolbox.c
@@ -201,26 +604,30 @@
 static int vt_transfer_data_to(AVHWFramesContext *hwfc,
                                AVFrame *dst, const AVFrame *src)
 {
     AVFrame *map;
     int err;
 
     if (src->width > hwfc->width || src->height > hwfc->height)
         return AVERROR(EINVAL);
 
     map = av_frame_alloc();
     if (!map)
         return AVERROR(ENOMEM);
     map->format = src->format;
 
     err = vt_map_frame(hwfc, map, dst, AV_HWFRAME_MAP_WRITE | AV_HWFRAME_MAP_OVERWRITE);
     if (err)
         goto fail;
 
     map->width  = src->width;
     map->height = src->height;
 
     err = av_frame_copy(map, src);
     if (err)
         goto fail;
 
+    err = vt_pixbuf_set_attachments(hwfc, (CVPixelBufferRef)dst->data[3], src);
+    if (err)
+        goto fail;
+
     err = 0;
[func] **new** commit 2ece70090d61ccc1aea8000ba57d2fd759f204f7
Date:   Sat Nov 13 20:00:50 2021 +0100

    avutil/hwcontext_vulkan: add support for exporting memory via Win32 Handles

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1798,90 +1813,100 @@
 static int create_frame(AVHWFramesContext *hwfc, AVVkFrame **frame,
                         VkImageTiling tiling, VkImageUsageFlagBits usage,
                         void *create_pnext)
 {
     int err;
     VkResult ret;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     VulkanDevicePriv *p = ctx->internal->priv;
     FFVulkanFunctions *vk = &p->vkfn;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     enum AVPixelFormat format = hwfc->sw_format;
     const VkFormat *img_fmts = av_vkfmt_from_pixfmt(format);
     const int planes = av_pix_fmt_count_planes(format);
 
     VkExportSemaphoreCreateInfo ext_sem_info = {
         .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
+#ifdef _WIN32
+        .handleTypes = IsWindows8OrGreater()
+            ? VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT
+            : VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
+#else
         .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
+#endif
     };
 
     VkSemaphoreTypeCreateInfo sem_type_info = {
         .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
+#ifdef _WIN32
+        .pNext         = p->extensions & FF_VK_EXT_EXTERNAL_WIN32_SEM ? &ext_sem_info : NULL,
+#else
         .pNext         = p->extensions & FF_VK_EXT_EXTERNAL_FD_SEM ? &ext_sem_info : NULL,
+#endif
         .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
         .initialValue  = 0,
     };
 
     VkSemaphoreCreateInfo sem_spawn = {
         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
         .pNext = &sem_type_info,
     };
 
     AVVkFrame *f = av_vk_frame_alloc();
     if (!f) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         return AVERROR(ENOMEM);
     }
 
     /* Create the images */
     for (int i = 0; i < planes; i++) {
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = create_pnext,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = img_fmts[i],
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
             .tiling                = tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED,
             .usage                 = usage,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      format, hwfc->width, hwfc->height, i);
 
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         /* Create semaphore */
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
         f->sem_value[i] = 0;
     }
 
     f->flags     = 0x0;
     f->tiling    = tiling;
 
     *frame = f;
     return 0;
 

[func] **new** commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1951,90 +1792,90 @@
 static int create_frame(AVHWFramesContext *hwfc, AVVkFrame **frame,
                         VkImageTiling tiling, VkImageUsageFlagBits usage,
                         void *create_pnext)
 {
     int err;
     VkResult ret;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     VulkanDevicePriv *p = ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     enum AVPixelFormat format = hwfc->sw_format;
     const VkFormat *img_fmts = av_vkfmt_from_pixfmt(format);
     const int planes = av_pix_fmt_count_planes(format);
 
     VkExportSemaphoreCreateInfo ext_sem_info = {
         .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
         .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
     };
 
     VkSemaphoreTypeCreateInfo sem_type_info = {
         .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
-        .pNext         = p->extensions & EXT_EXTERNAL_FD_SEM ? &ext_sem_info : NULL,
+        .pNext         = p->extensions & FF_VK_EXT_EXTERNAL_FD_SEM ? &ext_sem_info : NULL,
         .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
         .initialValue  = 0,
     };
 
     VkSemaphoreCreateInfo sem_spawn = {
         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
         .pNext = &sem_type_info,
     };
 
     AVVkFrame *f = av_vk_frame_alloc();
     if (!f) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         return AVERROR(ENOMEM);
     }
 
     /* Create the images */
     for (int i = 0; i < planes; i++) {
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = create_pnext,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = img_fmts[i],
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
             .tiling                = tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED,
             .usage                 = usage,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      format, hwfc->width, hwfc->height, i);
 
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         /* Create semaphore */
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
         f->sem_value[i] = 0;
     }
 
     f->flags     = 0x0;
     f->tiling    = tiling;
 
     *frame = f;
     return 0;
 

[func] **new** commit 00ef53c3eabb0e99fd9b62dfd30992824de27e23
Date:   Thu Nov 4 12:17:06 2021 +0100

    hwcontext_vulkan: switch to using timeline semaphores

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1817,82 +1858,90 @@
 static int create_frame(AVHWFramesContext *hwfc, AVVkFrame **frame,
                         VkImageTiling tiling, VkImageUsageFlagBits usage,
                         void *create_pnext)
 {
     int err;
     VkResult ret;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     VulkanDevicePriv *p = ctx->internal->priv;
     VulkanFunctions *vk = &p->vkfn;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     enum AVPixelFormat format = hwfc->sw_format;
     const VkFormat *img_fmts = av_vkfmt_from_pixfmt(format);
     const int planes = av_pix_fmt_count_planes(format);
 
     VkExportSemaphoreCreateInfo ext_sem_info = {
         .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
         .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
     };
 
+    VkSemaphoreTypeCreateInfo sem_type_info = {
+        .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
+        .pNext         = p->extensions & EXT_EXTERNAL_FD_SEM ? &ext_sem_info : NULL,
+        .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
+        .initialValue  = 0,
+    };
+
     VkSemaphoreCreateInfo sem_spawn = {
         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
-        .pNext = p->extensions & EXT_EXTERNAL_FD_SEM ? &ext_sem_info : NULL,
+        .pNext = &sem_type_info,
     };
 
     AVVkFrame *f = av_vk_frame_alloc();
     if (!f) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         return AVERROR(ENOMEM);
     }
 
     /* Create the images */
     for (int i = 0; i < planes; i++) {
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = create_pnext,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = img_fmts[i],
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
             .tiling                = tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED,
             .usage                 = usage,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      format, hwfc->width, hwfc->height, i);
 
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         /* Create semaphore */
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
+        f->sem_value[i] = 0;
     }
 
     f->flags     = 0x0;
     f->tiling    = tiling;
 
     *frame = f;
     return 0;
 

[func] **new** commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1572,81 +1774,82 @@
 static int create_frame(AVHWFramesContext *hwfc, AVVkFrame **frame,
                         VkImageTiling tiling, VkImageUsageFlagBits usage,
                         void *create_pnext)
 {
     int err;
     VkResult ret;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     VulkanDevicePriv *p = ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     enum AVPixelFormat format = hwfc->sw_format;
     const VkFormat *img_fmts = av_vkfmt_from_pixfmt(format);
     const int planes = av_pix_fmt_count_planes(format);
 
     VkExportSemaphoreCreateInfo ext_sem_info = {
         .sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
         .handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
     };
 
     VkSemaphoreCreateInfo sem_spawn = {
         .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
         .pNext = p->extensions & EXT_EXTERNAL_FD_SEM ? &ext_sem_info : NULL,
     };
 
     AVVkFrame *f = av_vk_frame_alloc();
     if (!f) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         return AVERROR(ENOMEM);
     }
 
     /* Create the images */
     for (int i = 0; i < planes; i++) {
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = create_pnext,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = img_fmts[i],
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
             .tiling                = tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED,
             .usage                 = usage,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      format, hwfc->width, hwfc->height, i);
 
-        ret = vkCreateImage(hwctx->act_dev, &create_info,
-                            hwctx->alloc, &f->img[i]);
+        ret = vk->CreateImage(hwctx->act_dev, &create_info,
+                              hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         /* Create semaphore */
-        ret = vkCreateSemaphore(hwctx->act_dev, &sem_spawn,
-                                hwctx->alloc, &f->sem[i]);
+        ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
+                                  hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
     }
 
     f->flags     = 0x0;
     f->tiling    = tiling;
 
     *frame = f;
     return 0;
 
commit 2ece70090d61ccc1aea8000ba57d2fd759f204f7
Date:   Sat Nov 13 20:00:50 2021 +0100

    avutil/hwcontext_vulkan: add support for exporting memory via Win32 Handles

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1933,51 +1958,58 @@
 static AVBufferRef *vulkan_pool_alloc(void *opaque, size_t size)
 {
     int err;
     AVVkFrame *f;
     AVBufferRef *avbuf = NULL;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanFramesContext *hwctx = hwfc->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     VkExportMemoryAllocateInfo eminfo[AV_NUM_DATA_POINTERS];
     VkExternalMemoryHandleTypeFlags e = 0x0;
 
     VkExternalMemoryImageCreateInfo eiinfo = {
         .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
         .pNext       = hwctx->create_pnext,
     };
 
+#ifdef _WIN32
+    if (p->extensions & FF_VK_EXT_EXTERNAL_WIN32_MEMORY)
+        try_export_flags(hwfc, &eiinfo.handleTypes, &e, IsWindows8OrGreater()
+                             ? VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT
+                             : VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT);
+#else
     if (p->extensions & FF_VK_EXT_EXTERNAL_FD_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT);
 
     if (p->extensions & (FF_VK_EXT_EXTERNAL_DMABUF_MEMORY | FF_VK_EXT_DRM_MODIFIER_FLAGS))
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
+#endif
 
     for (int i = 0; i < av_pix_fmt_count_planes(hwfc->sw_format); i++) {
         eminfo[i].sType       = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
         eminfo[i].pNext       = hwctx->alloc_pnext[i];
         eminfo[i].handleTypes = e;
     }
 
     err = create_frame(hwfc, &f, hwctx->tiling, hwctx->usage,
                        eiinfo.handleTypes ? &eiinfo : NULL);
     if (err)
         return NULL;
 
     err = alloc_bind_mem(hwfc, f, eminfo, sizeof(*eminfo));
     if (err)
         goto fail;
 
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_WRITE);
     if (err)
         goto fail;
 
     avbuf = av_buffer_create((uint8_t *)f, sizeof(AVVkFrame),
                              vulkan_frame_free, hwfc, 0);
     if (!avbuf)
         goto fail;
 
     return avbuf;
 

commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2086,51 +1927,51 @@
 static AVBufferRef *vulkan_pool_alloc(void *opaque, size_t size)
 {
     int err;
     AVVkFrame *f;
     AVBufferRef *avbuf = NULL;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanFramesContext *hwctx = hwfc->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     VkExportMemoryAllocateInfo eminfo[AV_NUM_DATA_POINTERS];
     VkExternalMemoryHandleTypeFlags e = 0x0;
 
     VkExternalMemoryImageCreateInfo eiinfo = {
         .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
         .pNext       = hwctx->create_pnext,
     };
 
-    if (p->extensions & EXT_EXTERNAL_FD_MEMORY)
+    if (p->extensions & FF_VK_EXT_EXTERNAL_FD_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT);
 
-    if (p->extensions & (EXT_EXTERNAL_DMABUF_MEMORY | EXT_DRM_MODIFIER_FLAGS))
+    if (p->extensions & (FF_VK_EXT_EXTERNAL_DMABUF_MEMORY | FF_VK_EXT_DRM_MODIFIER_FLAGS))
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
 
     for (int i = 0; i < av_pix_fmt_count_planes(hwfc->sw_format); i++) {
         eminfo[i].sType       = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
         eminfo[i].pNext       = hwctx->alloc_pnext[i];
         eminfo[i].handleTypes = e;
     }
 
     err = create_frame(hwfc, &f, hwctx->tiling, hwctx->usage,
                        eiinfo.handleTypes ? &eiinfo : NULL);
     if (err)
         return NULL;
 
     err = alloc_bind_mem(hwfc, f, eminfo, sizeof(*eminfo));
     if (err)
         goto fail;
 
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_WRITE);
     if (err)
         goto fail;
 
     avbuf = av_buffer_create((uint8_t *)f, sizeof(AVVkFrame),
                              vulkan_frame_free, hwfc, 0);
     if (!avbuf)
         goto fail;
 
     return avbuf;
 

[func] **new** commit 0370a580dc9210450bf24d71e34966fabcda8747
Date:   Fri Nov 5 06:55:42 2021 +0100

    hwcontext_vulkan: fix mapping from/to DRM/VAAPI frames

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1993,51 +1993,51 @@
 static AVBufferRef *vulkan_pool_alloc(void *opaque, size_t size)
 {
     int err;
     AVVkFrame *f;
     AVBufferRef *avbuf = NULL;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanFramesContext *hwctx = hwfc->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     VkExportMemoryAllocateInfo eminfo[AV_NUM_DATA_POINTERS];
     VkExternalMemoryHandleTypeFlags e = 0x0;
 
     VkExternalMemoryImageCreateInfo eiinfo = {
         .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
         .pNext       = hwctx->create_pnext,
     };
 
     if (p->extensions & EXT_EXTERNAL_FD_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT);
 
-    if (p->extensions & EXT_EXTERNAL_DMABUF_MEMORY)
+    if (p->extensions & (EXT_EXTERNAL_DMABUF_MEMORY | EXT_DRM_MODIFIER_FLAGS))
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
 
     for (int i = 0; i < av_pix_fmt_count_planes(hwfc->sw_format); i++) {
         eminfo[i].sType       = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
         eminfo[i].pNext       = hwctx->alloc_pnext[i];
         eminfo[i].handleTypes = e;
     }
 
     err = create_frame(hwfc, &f, hwctx->tiling, hwctx->usage,
                        eiinfo.handleTypes ? &eiinfo : NULL);
     if (err)
         return NULL;
 
     err = alloc_bind_mem(hwfc, f, eminfo, sizeof(*eminfo));
     if (err)
         goto fail;
 
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_WRITE);
     if (err)
         goto fail;
 
     avbuf = av_buffer_create((uint8_t *)f, sizeof(AVVkFrame),
                              vulkan_frame_free, hwfc, 0);
     if (!avbuf)
         goto fail;
 
     return avbuf;
 

commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1696,51 +1696,51 @@
-static AVBufferRef *vulkan_pool_alloc(void *opaque, buffer_size_t size)
+static AVBufferRef *vulkan_pool_alloc(void *opaque, size_t size)
 {
     int err;
     AVVkFrame *f;
     AVBufferRef *avbuf = NULL;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanFramesContext *hwctx = hwfc->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     VkExportMemoryAllocateInfo eminfo[AV_NUM_DATA_POINTERS];
     VkExternalMemoryHandleTypeFlags e = 0x0;
 
     VkExternalMemoryImageCreateInfo eiinfo = {
         .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
         .pNext       = hwctx->create_pnext,
     };
 
     if (p->extensions & EXT_EXTERNAL_FD_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT);
 
     if (p->extensions & EXT_EXTERNAL_DMABUF_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
 
     for (int i = 0; i < av_pix_fmt_count_planes(hwfc->sw_format); i++) {
         eminfo[i].sType       = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
         eminfo[i].pNext       = hwctx->alloc_pnext[i];
         eminfo[i].handleTypes = e;
     }
 
     err = create_frame(hwfc, &f, hwctx->tiling, hwctx->usage,
                        eiinfo.handleTypes ? &eiinfo : NULL);
     if (err)
         return NULL;
 
     err = alloc_bind_mem(hwfc, f, eminfo, sizeof(*eminfo));
     if (err)
         goto fail;
 
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_WRITE);
     if (err)
         goto fail;
 
     avbuf = av_buffer_create((uint8_t *)f, sizeof(AVVkFrame),
                              vulkan_frame_free, hwfc, 0);
     if (!avbuf)
         goto fail;
 
     return avbuf;
 

commit e36eb940484b8b8ef5f3e7542d12240e24839fcf
Date:   Sat Mar 6 13:58:26 2021 -0300

    avutil: use the buffer_size_t typedef where required
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1696,51 +1696,51 @@
-static AVBufferRef *vulkan_pool_alloc(void *opaque, int size)
+static AVBufferRef *vulkan_pool_alloc(void *opaque, buffer_size_t size)
 {
     int err;
     AVVkFrame *f;
     AVBufferRef *avbuf = NULL;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanFramesContext *hwctx = hwfc->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     VkExportMemoryAllocateInfo eminfo[AV_NUM_DATA_POINTERS];
     VkExternalMemoryHandleTypeFlags e = 0x0;
 
     VkExternalMemoryImageCreateInfo eiinfo = {
         .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
         .pNext       = hwctx->create_pnext,
     };
 
     if (p->extensions & EXT_EXTERNAL_FD_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT);
 
     if (p->extensions & EXT_EXTERNAL_DMABUF_MEMORY)
         try_export_flags(hwfc, &eiinfo.handleTypes, &e,
                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
 
     for (int i = 0; i < av_pix_fmt_count_planes(hwfc->sw_format); i++) {
         eminfo[i].sType       = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
         eminfo[i].pNext       = hwctx->alloc_pnext[i];
         eminfo[i].handleTypes = e;
     }
 
     err = create_frame(hwfc, &f, hwctx->tiling, hwctx->usage,
                        eiinfo.handleTypes ? &eiinfo : NULL);
     if (err)
         return NULL;
 
     err = alloc_bind_mem(hwfc, f, eminfo, sizeof(*eminfo));
     if (err)
         goto fail;
 
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_WRITE);
     if (err)
         goto fail;
 
     avbuf = av_buffer_create((uint8_t *)f, sizeof(AVVkFrame),
                              vulkan_frame_free, hwfc, 0);
     if (!avbuf)
         goto fail;
 
     return avbuf;
 
[func] **new** commit c96d1ee401189188de881f6cd005f9ab45b65834
Date:   Sat Nov 13 11:11:47 2021 +0100

    hwcontext_vulkan: fix DMABUF import format check call
    
    VkExternalImageFormatProperties is required to be present in the .pNext
    chain of VkImageFormatProperties2, or some drivers crash (RADV).

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2252,256 +2252,260 @@
 static int vulkan_map_from_drm_frame_desc(AVHWFramesContext *hwfc, AVVkFrame **frame,
                                           const AVFrame *src)
 {
     int err = 0;
     VkResult ret;
     AVVkFrame *f;
     int bind_counts = 0;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
     FFVulkanFunctions *vk = &p->vkfn;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
     VkBindImageMemoryInfo bind_info[AV_DRM_MAX_PLANES];
     VkBindImagePlaneMemoryInfo plane_info[AV_DRM_MAX_PLANES];
 
     for (int i = 0; i < desc->nb_layers; i++) {
         if (drm_to_vulkan_fmt(desc->layers[i].format) == VK_FORMAT_UNDEFINED) {
             av_log(ctx, AV_LOG_ERROR, "Unsupported DMABUF layer format %#08x!\n",
                    desc->layers[i].format);
             return AVERROR(EINVAL);
         }
     }
 
     if (!(f = av_vk_frame_alloc())) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     f->tiling = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
 
         /* Semaphore */
         VkSemaphoreTypeCreateInfo sem_type_info = {
             .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
             .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
             .initialValue  = 0,
         };
         VkSemaphoreCreateInfo sem_spawn = {
             .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
             .pNext = &sem_type_info,
         };
 
         /* Image creation */
         VkSubresourceLayout ext_img_layouts[AV_DRM_MAX_PLANES];
         VkImageDrmFormatModifierExplicitCreateInfoEXT ext_img_mod_spec = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
             .drmFormatModifier = desc->objects[0].format_modifier,
             .drmFormatModifierPlaneCount = planes,
             .pPlaneLayouts = (const VkSubresourceLayout *)&ext_img_layouts,
         };
         VkExternalMemoryImageCreateInfo ext_img_spec = {
             .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
             .pNext       = &ext_img_mod_spec,
             .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = &ext_img_spec,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = drm_to_vulkan_fmt(desc->layers[i].format),
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = 0x0, /* ALIAS flag is implicit for imported images */
             .tiling                = f->tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED, /* specs say so */
             .usage                 = VK_IMAGE_USAGE_SAMPLED_BIT |
                                      VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         /* Image format verification */
+        VkExternalImageFormatProperties ext_props = {
+            .sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR,
+        };
         VkImageFormatProperties2 props_ret = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
+            .pNext = &ext_props,
         };
         VkPhysicalDeviceImageDrmFormatModifierInfoEXT props_drm_mod = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
             .drmFormatModifier = ext_img_mod_spec.drmFormatModifier,
             .pQueueFamilyIndices = create_info.pQueueFamilyIndices,
             .queueFamilyIndexCount = create_info.queueFamilyIndexCount,
             .sharingMode = create_info.sharingMode,
         };
         VkPhysicalDeviceExternalImageFormatInfo props_ext = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
             .pNext = &props_drm_mod,
             .handleType = ext_img_spec.handleTypes,
         };
         VkPhysicalDeviceImageFormatInfo2 fmt_props = {
             .sType  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
             .pNext  = &props_ext,
             .format = create_info.format,
             .type   = create_info.imageType,
             .tiling = create_info.tiling,
             .usage  = create_info.usage,
             .flags  = create_info.flags,
         };
 
         /* Check if importing is possible for this combination of parameters */
         ret = vk->GetPhysicalDeviceImageFormatProperties2(hwctx->phys_dev,
                                                           &fmt_props, &props_ret);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Cannot map DRM frame to Vulkan: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
 
         /* Set the image width/height */
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      hwfc->sw_format, src->width, src->height, i);
 
         /* Set the subresource layout based on the layer properties */
         for (int j = 0; j < planes; j++) {
             ext_img_layouts[j].offset     = desc->layers[i].planes[j].offset;
             ext_img_layouts[j].rowPitch   = desc->layers[i].planes[j].pitch;
             ext_img_layouts[j].size       = 0; /* The specs say so for all 3 */
             ext_img_layouts[j].arrayPitch = 0;
             ext_img_layouts[j].depthPitch = 0;
         }
 
         /* Create image */
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         /* We'd import a semaphore onto the one we created using
          * vkImportSemaphoreFdKHR but unfortunately neither DRM nor VAAPI
          * offer us anything we could import and sync with, so instead
          * just signal the semaphore we created. */
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
         f->sem_value[i] = 0;
     }
 
     for (int i = 0; i < desc->nb_objects; i++) {
         /* Memory requirements */
         VkImageMemoryRequirementsInfo2 req_desc = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
             .image = f->img[i],
         };
         VkMemoryDedicatedRequirements ded_req = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
         };
         VkMemoryRequirements2 req2 = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
             .pNext = &ded_req,
         };
 
         /* Allocation/importing */
         VkMemoryFdPropertiesKHR fdmp = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
         };
         VkImportMemoryFdInfoKHR idesc = {
             .sType      = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
             .fd         = dup(desc->objects[i].fd),
             .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkMemoryDedicatedAllocateInfo ded_alloc = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
             .pNext = &idesc,
             .image = req_desc.image,
         };
 
         /* Get object properties */
         ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev,
                                            VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
                                            idesc.fd, &fdmp);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to get FD properties: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             close(idesc.fd);
             goto fail;
         }
 
         vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
 
         /* Only a single bit must be set, not a range, and it must match */
         req2.memoryRequirements.memoryTypeBits = fdmp.memoryTypeBits;
 
         err = alloc_mem(ctx, &req2.memoryRequirements,
                         VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                         (ded_req.prefersDedicatedAllocation ||
                          ded_req.requiresDedicatedAllocation) ?
                             &ded_alloc : ded_alloc.pNext,
                         &f->flags, &f->mem[i]);
         if (err) {
             close(idesc.fd);
             return err;
         }
 
         f->size[i] = req2.memoryRequirements.size;
     }
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         for (int j = 0; j < planes; j++) {
             VkImageAspectFlagBits aspect = j == 0 ? VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT :
                                            j == 1 ? VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT :
                                                     VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
 
             plane_info[bind_counts].sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
             plane_info[bind_counts].pNext = NULL;
             plane_info[bind_counts].planeAspect = aspect;
 
             bind_info[bind_counts].sType  = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
             bind_info[bind_counts].pNext  = planes > 1 ? &plane_info[bind_counts] : NULL;
             bind_info[bind_counts].image  = f->img[i];
             bind_info[bind_counts].memory = f->mem[desc->layers[i].planes[j].object_index];
 
             /* Offset is already signalled via pPlaneLayouts above */
             bind_info[bind_counts].memoryOffset = 0;
 
             bind_counts++;
         }
     }
 
     /* Bind the allocated memory to the images */
     ret = vk->BindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_EXTERNAL_IMPORT);
     if (err)
         goto fail;
 
     *frame = f;
 
     return 0;
 

[func] **new** commit fa28c1b2f9d6fa9e3c0e89c27ad9a55add3a620f
Date:   Fri Nov 12 23:54:36 2021 +0100

    hwcontext_vulkan: properly migrate queue families with DRM import/export

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2259,259 +2252,256 @@
 static int vulkan_map_from_drm_frame_desc(AVHWFramesContext *hwfc, AVVkFrame **frame,
                                           const AVFrame *src)
 {
     int err = 0;
     VkResult ret;
     AVVkFrame *f;
     int bind_counts = 0;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
     FFVulkanFunctions *vk = &p->vkfn;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
     VkBindImageMemoryInfo bind_info[AV_DRM_MAX_PLANES];
     VkBindImagePlaneMemoryInfo plane_info[AV_DRM_MAX_PLANES];
 
     for (int i = 0; i < desc->nb_layers; i++) {
         if (drm_to_vulkan_fmt(desc->layers[i].format) == VK_FORMAT_UNDEFINED) {
             av_log(ctx, AV_LOG_ERROR, "Unsupported DMABUF layer format %#08x!\n",
                    desc->layers[i].format);
             return AVERROR(EINVAL);
         }
     }
 
     if (!(f = av_vk_frame_alloc())) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     f->tiling = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
 
         /* Semaphore */
         VkSemaphoreTypeCreateInfo sem_type_info = {
             .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
             .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
             .initialValue  = 0,
         };
         VkSemaphoreCreateInfo sem_spawn = {
             .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
             .pNext = &sem_type_info,
         };
 
         /* Image creation */
         VkSubresourceLayout ext_img_layouts[AV_DRM_MAX_PLANES];
         VkImageDrmFormatModifierExplicitCreateInfoEXT ext_img_mod_spec = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
             .drmFormatModifier = desc->objects[0].format_modifier,
             .drmFormatModifierPlaneCount = planes,
             .pPlaneLayouts = (const VkSubresourceLayout *)&ext_img_layouts,
         };
         VkExternalMemoryImageCreateInfo ext_img_spec = {
             .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
             .pNext       = &ext_img_mod_spec,
             .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = &ext_img_spec,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = drm_to_vulkan_fmt(desc->layers[i].format),
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = 0x0, /* ALIAS flag is implicit for imported images */
             .tiling                = f->tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED, /* specs say so */
             .usage                 = VK_IMAGE_USAGE_SAMPLED_BIT |
                                      VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         /* Image format verification */
         VkImageFormatProperties2 props_ret = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
         };
         VkPhysicalDeviceImageDrmFormatModifierInfoEXT props_drm_mod = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
             .drmFormatModifier = ext_img_mod_spec.drmFormatModifier,
             .pQueueFamilyIndices = create_info.pQueueFamilyIndices,
             .queueFamilyIndexCount = create_info.queueFamilyIndexCount,
             .sharingMode = create_info.sharingMode,
         };
         VkPhysicalDeviceExternalImageFormatInfo props_ext = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
             .pNext = &props_drm_mod,
             .handleType = ext_img_spec.handleTypes,
         };
         VkPhysicalDeviceImageFormatInfo2 fmt_props = {
             .sType  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
             .pNext  = &props_ext,
             .format = create_info.format,
             .type   = create_info.imageType,
             .tiling = create_info.tiling,
             .usage  = create_info.usage,
             .flags  = create_info.flags,
         };
 
         /* Check if importing is possible for this combination of parameters */
         ret = vk->GetPhysicalDeviceImageFormatProperties2(hwctx->phys_dev,
                                                           &fmt_props, &props_ret);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Cannot map DRM frame to Vulkan: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
 
         /* Set the image width/height */
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      hwfc->sw_format, src->width, src->height, i);
 
         /* Set the subresource layout based on the layer properties */
         for (int j = 0; j < planes; j++) {
             ext_img_layouts[j].offset     = desc->layers[i].planes[j].offset;
             ext_img_layouts[j].rowPitch   = desc->layers[i].planes[j].pitch;
             ext_img_layouts[j].size       = 0; /* The specs say so for all 3 */
             ext_img_layouts[j].arrayPitch = 0;
             ext_img_layouts[j].depthPitch = 0;
         }
 
         /* Create image */
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         /* We'd import a semaphore onto the one we created using
          * vkImportSemaphoreFdKHR but unfortunately neither DRM nor VAAPI
          * offer us anything we could import and sync with, so instead
          * just signal the semaphore we created. */
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
         f->sem_value[i] = 0;
     }
 
     for (int i = 0; i < desc->nb_objects; i++) {
         /* Memory requirements */
         VkImageMemoryRequirementsInfo2 req_desc = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
             .image = f->img[i],
         };
         VkMemoryDedicatedRequirements ded_req = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
         };
         VkMemoryRequirements2 req2 = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
             .pNext = &ded_req,
         };
 
         /* Allocation/importing */
         VkMemoryFdPropertiesKHR fdmp = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
         };
         VkImportMemoryFdInfoKHR idesc = {
             .sType      = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
             .fd         = dup(desc->objects[i].fd),
             .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkMemoryDedicatedAllocateInfo ded_alloc = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
             .pNext = &idesc,
             .image = req_desc.image,
         };
 
         /* Get object properties */
         ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev,
                                            VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
                                            idesc.fd, &fdmp);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to get FD properties: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             close(idesc.fd);
             goto fail;
         }
 
         vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
 
         /* Only a single bit must be set, not a range, and it must match */
         req2.memoryRequirements.memoryTypeBits = fdmp.memoryTypeBits;
 
         err = alloc_mem(ctx, &req2.memoryRequirements,
                         VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                         (ded_req.prefersDedicatedAllocation ||
                          ded_req.requiresDedicatedAllocation) ?
                             &ded_alloc : ded_alloc.pNext,
                         &f->flags, &f->mem[i]);
         if (err) {
             close(idesc.fd);
             return err;
         }
 
         f->size[i] = req2.memoryRequirements.size;
     }
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         for (int j = 0; j < planes; j++) {
             VkImageAspectFlagBits aspect = j == 0 ? VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT :
                                            j == 1 ? VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT :
                                                     VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
 
             plane_info[bind_counts].sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
             plane_info[bind_counts].pNext = NULL;
             plane_info[bind_counts].planeAspect = aspect;
 
             bind_info[bind_counts].sType  = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
             bind_info[bind_counts].pNext  = planes > 1 ? &plane_info[bind_counts] : NULL;
             bind_info[bind_counts].image  = f->img[i];
             bind_info[bind_counts].memory = f->mem[desc->layers[i].planes[j].object_index];
 
             /* Offset is already signalled via pPlaneLayouts above */
             bind_info[bind_counts].memoryOffset = 0;
 
             bind_counts++;
         }
     }
 
     /* Bind the allocated memory to the images */
     ret = vk->BindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
-    /* NOTE: This is completely uneccesary and unneeded once we can import
-     * semaphores from DRM. Otherwise we have to activate the semaphores.
-     * We're reusing the exec context that's also used for uploads/downloads. */
-    err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_RO_SHADER);
+    err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_EXTERNAL_IMPORT);
     if (err)
         goto fail;
 
     *frame = f;
 
     return 0;
 

commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2407,259 +2248,259 @@
 static int vulkan_map_from_drm_frame_desc(AVHWFramesContext *hwfc, AVVkFrame **frame,
                                           const AVFrame *src)
 {
     int err = 0;
     VkResult ret;
     AVVkFrame *f;
     int bind_counts = 0;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
     VkBindImageMemoryInfo bind_info[AV_DRM_MAX_PLANES];
     VkBindImagePlaneMemoryInfo plane_info[AV_DRM_MAX_PLANES];
 
     for (int i = 0; i < desc->nb_layers; i++) {
         if (drm_to_vulkan_fmt(desc->layers[i].format) == VK_FORMAT_UNDEFINED) {
             av_log(ctx, AV_LOG_ERROR, "Unsupported DMABUF layer format %#08x!\n",
                    desc->layers[i].format);
             return AVERROR(EINVAL);
         }
     }
 
     if (!(f = av_vk_frame_alloc())) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     f->tiling = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
 
         /* Semaphore */
         VkSemaphoreTypeCreateInfo sem_type_info = {
             .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
             .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
             .initialValue  = 0,
         };
         VkSemaphoreCreateInfo sem_spawn = {
             .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
             .pNext = &sem_type_info,
         };
 
         /* Image creation */
         VkSubresourceLayout ext_img_layouts[AV_DRM_MAX_PLANES];
         VkImageDrmFormatModifierExplicitCreateInfoEXT ext_img_mod_spec = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
             .drmFormatModifier = desc->objects[0].format_modifier,
             .drmFormatModifierPlaneCount = planes,
             .pPlaneLayouts = (const VkSubresourceLayout *)&ext_img_layouts,
         };
         VkExternalMemoryImageCreateInfo ext_img_spec = {
             .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
             .pNext       = &ext_img_mod_spec,
             .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = &ext_img_spec,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = drm_to_vulkan_fmt(desc->layers[i].format),
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = 0x0, /* ALIAS flag is implicit for imported images */
             .tiling                = f->tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED, /* specs say so */
             .usage                 = VK_IMAGE_USAGE_SAMPLED_BIT |
                                      VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         /* Image format verification */
         VkImageFormatProperties2 props_ret = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
         };
         VkPhysicalDeviceImageDrmFormatModifierInfoEXT props_drm_mod = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
             .drmFormatModifier = ext_img_mod_spec.drmFormatModifier,
             .pQueueFamilyIndices = create_info.pQueueFamilyIndices,
             .queueFamilyIndexCount = create_info.queueFamilyIndexCount,
             .sharingMode = create_info.sharingMode,
         };
         VkPhysicalDeviceExternalImageFormatInfo props_ext = {
             .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
             .pNext = &props_drm_mod,
             .handleType = ext_img_spec.handleTypes,
         };
         VkPhysicalDeviceImageFormatInfo2 fmt_props = {
             .sType  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
             .pNext  = &props_ext,
             .format = create_info.format,
             .type   = create_info.imageType,
             .tiling = create_info.tiling,
             .usage  = create_info.usage,
             .flags  = create_info.flags,
         };
 
         /* Check if importing is possible for this combination of parameters */
         ret = vk->GetPhysicalDeviceImageFormatProperties2(hwctx->phys_dev,
                                                           &fmt_props, &props_ret);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Cannot map DRM frame to Vulkan: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
 
         /* Set the image width/height */
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      hwfc->sw_format, src->width, src->height, i);
 
         /* Set the subresource layout based on the layer properties */
         for (int j = 0; j < planes; j++) {
             ext_img_layouts[j].offset     = desc->layers[i].planes[j].offset;
             ext_img_layouts[j].rowPitch   = desc->layers[i].planes[j].pitch;
             ext_img_layouts[j].size       = 0; /* The specs say so for all 3 */
             ext_img_layouts[j].arrayPitch = 0;
             ext_img_layouts[j].depthPitch = 0;
         }
 
         /* Create image */
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         /* We'd import a semaphore onto the one we created using
          * vkImportSemaphoreFdKHR but unfortunately neither DRM nor VAAPI
          * offer us anything we could import and sync with, so instead
          * just signal the semaphore we created. */
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
         f->sem_value[i] = 0;
     }
 
     for (int i = 0; i < desc->nb_objects; i++) {
         /* Memory requirements */
         VkImageMemoryRequirementsInfo2 req_desc = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
             .image = f->img[i],
         };
         VkMemoryDedicatedRequirements ded_req = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
         };
         VkMemoryRequirements2 req2 = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
             .pNext = &ded_req,
         };
 
         /* Allocation/importing */
         VkMemoryFdPropertiesKHR fdmp = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
         };
         VkImportMemoryFdInfoKHR idesc = {
             .sType      = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
             .fd         = dup(desc->objects[i].fd),
             .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkMemoryDedicatedAllocateInfo ded_alloc = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
             .pNext = &idesc,
             .image = req_desc.image,
         };
 
         /* Get object properties */
         ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev,
                                            VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
                                            idesc.fd, &fdmp);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to get FD properties: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             close(idesc.fd);
             goto fail;
         }
 
         vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
 
         /* Only a single bit must be set, not a range, and it must match */
         req2.memoryRequirements.memoryTypeBits = fdmp.memoryTypeBits;
 
         err = alloc_mem(ctx, &req2.memoryRequirements,
                         VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                         (ded_req.prefersDedicatedAllocation ||
                          ded_req.requiresDedicatedAllocation) ?
                             &ded_alloc : ded_alloc.pNext,
                         &f->flags, &f->mem[i]);
         if (err) {
             close(idesc.fd);
             return err;
         }
 
         f->size[i] = req2.memoryRequirements.size;
     }
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         for (int j = 0; j < planes; j++) {
             VkImageAspectFlagBits aspect = j == 0 ? VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT :
                                            j == 1 ? VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT :
                                                     VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
 
             plane_info[bind_counts].sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
             plane_info[bind_counts].pNext = NULL;
             plane_info[bind_counts].planeAspect = aspect;
 
             bind_info[bind_counts].sType  = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
             bind_info[bind_counts].pNext  = planes > 1 ? &plane_info[bind_counts] : NULL;
             bind_info[bind_counts].image  = f->img[i];
             bind_info[bind_counts].memory = f->mem[desc->layers[i].planes[j].object_index];
 
             /* Offset is already signalled via pPlaneLayouts above */
             bind_info[bind_counts].memoryOffset = 0;
 
             bind_counts++;
         }
     }
 
     /* Bind the allocated memory to the images */
     ret = vk->BindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
     /* NOTE: This is completely uneccesary and unneeded once we can import
      * semaphores from DRM. Otherwise we have to activate the semaphores.
      * We're reusing the exec context that's also used for uploads/downloads. */
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_RO_SHADER);
     if (err)
         goto fail;
 
     *frame = f;
 
     return 0;
 

commit 0370a580dc9210450bf24d71e34966fabcda8747
Date:   Fri Nov 5 06:55:42 2021 +0100

    hwcontext_vulkan: fix mapping from/to DRM/VAAPI frames

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2314,226 +2314,259 @@
 static int vulkan_map_from_drm_frame_desc(AVHWFramesContext *hwfc, AVVkFrame **frame,
                                           const AVFrame *src)
 {
     int err = 0;
     VkResult ret;
     AVVkFrame *f;
     int bind_counts = 0;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
     VulkanFunctions *vk = &p->vkfn;
     VulkanFramesPriv *fp = hwfc->internal->priv;
-    AVVulkanFramesContext *frames_hwctx = hwfc->hwctx;
     const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
-    const int has_modifiers = !!(p->extensions & EXT_DRM_MODIFIER_FLAGS);
-    VkSubresourceLayout plane_data[AV_NUM_DATA_POINTERS] = { 0 };
-    VkBindImageMemoryInfo bind_info[AV_NUM_DATA_POINTERS] = { 0 };
-    VkBindImagePlaneMemoryInfo plane_info[AV_NUM_DATA_POINTERS] = { 0 };
-    VkExternalMemoryHandleTypeFlagBits htype = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
+    VkBindImageMemoryInfo bind_info[AV_DRM_MAX_PLANES];
+    VkBindImagePlaneMemoryInfo plane_info[AV_DRM_MAX_PLANES];
 
     for (int i = 0; i < desc->nb_layers; i++) {
         if (drm_to_vulkan_fmt(desc->layers[i].format) == VK_FORMAT_UNDEFINED) {
             av_log(ctx, AV_LOG_ERROR, "Unsupported DMABUF layer format %#08x!\n",
                    desc->layers[i].format);
             return AVERROR(EINVAL);
         }
     }
 
     if (!(f = av_vk_frame_alloc())) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
-    f->tiling = has_modifiers ? VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT :
-                desc->objects[0].format_modifier == DRM_FORMAT_MOD_LINEAR ?
-                VK_IMAGE_TILING_LINEAR : VK_IMAGE_TILING_OPTIMAL;
+    f->tiling = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
-        VkImageDrmFormatModifierExplicitCreateInfoEXT drm_info = {
-            .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
-            .drmFormatModifier = desc->objects[0].format_modifier,
-            .drmFormatModifierPlaneCount = planes,
-            .pPlaneLayouts = (const VkSubresourceLayout *)&plane_data,
-        };
-
-        VkExternalMemoryImageCreateInfo einfo = {
-            .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
-            .pNext       = has_modifiers ? &drm_info : NULL,
-            .handleTypes = htype,
-        };
 
+        /* Semaphore */
         VkSemaphoreTypeCreateInfo sem_type_info = {
             .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
             .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
-            .initialValue  = 1,
+            .initialValue  = 0,
         };
-
         VkSemaphoreCreateInfo sem_spawn = {
             .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
             .pNext = &sem_type_info,
         };
 
+        /* Image creation */
+        VkSubresourceLayout ext_img_layouts[AV_DRM_MAX_PLANES];
+        VkImageDrmFormatModifierExplicitCreateInfoEXT ext_img_mod_spec = {
+            .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
+            .drmFormatModifier = desc->objects[0].format_modifier,
+            .drmFormatModifierPlaneCount = planes,
+            .pPlaneLayouts = (const VkSubresourceLayout *)&ext_img_layouts,
+        };
+        VkExternalMemoryImageCreateInfo ext_img_spec = {
+            .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
+            .pNext       = &ext_img_mod_spec,
+            .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
+        };
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
-            .pNext                 = &einfo,
+            .pNext                 = &ext_img_spec,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = drm_to_vulkan_fmt(desc->layers[i].format),
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
-            .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
+            .flags                 = 0x0, /* ALIAS flag is implicit for imported images */
             .tiling                = f->tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED, /* specs say so */
-            .usage                 = frames_hwctx->usage,
+            .usage                 = VK_IMAGE_USAGE_SAMPLED_BIT |
+                                     VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
+        /* Image format verification */
+        VkImageFormatProperties2 props_ret = {
+            .sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
+        };
+        VkPhysicalDeviceImageDrmFormatModifierInfoEXT props_drm_mod = {
+            .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
+            .drmFormatModifier = ext_img_mod_spec.drmFormatModifier,
+            .pQueueFamilyIndices = create_info.pQueueFamilyIndices,
+            .queueFamilyIndexCount = create_info.queueFamilyIndexCount,
+            .sharingMode = create_info.sharingMode,
+        };
+        VkPhysicalDeviceExternalImageFormatInfo props_ext = {
+            .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
+            .pNext = &props_drm_mod,
+            .handleType = ext_img_spec.handleTypes,
+        };
+        VkPhysicalDeviceImageFormatInfo2 fmt_props = {
+            .sType  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
+            .pNext  = &props_ext,
+            .format = create_info.format,
+            .type   = create_info.imageType,
+            .tiling = create_info.tiling,
+            .usage  = create_info.usage,
+            .flags  = create_info.flags,
+        };
+
+        /* Check if importing is possible for this combination of parameters */
+        ret = vk->GetPhysicalDeviceImageFormatProperties2(hwctx->phys_dev,
+                                                          &fmt_props, &props_ret);
+        if (ret != VK_SUCCESS) {
+            av_log(ctx, AV_LOG_ERROR, "Cannot map DRM frame to Vulkan: %s\n",
+                   vk_ret2str(ret));
+            err = AVERROR_EXTERNAL;
+            goto fail;
+        }
+
+        /* Set the image width/height */
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      hwfc->sw_format, src->width, src->height, i);
 
+        /* Set the subresource layout based on the layer properties */
         for (int j = 0; j < planes; j++) {
-            plane_data[j].offset     = desc->layers[i].planes[j].offset;
-            plane_data[j].rowPitch   = desc->layers[i].planes[j].pitch;
-            plane_data[j].size       = 0; /* The specs say so for all 3 */
-            plane_data[j].arrayPitch = 0;
-            plane_data[j].depthPitch = 0;
+            ext_img_layouts[j].offset     = desc->layers[i].planes[j].offset;
+            ext_img_layouts[j].rowPitch   = desc->layers[i].planes[j].pitch;
+            ext_img_layouts[j].size       = 0; /* The specs say so for all 3 */
+            ext_img_layouts[j].arrayPitch = 0;
+            ext_img_layouts[j].depthPitch = 0;
         }
 
         /* Create image */
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         /* We'd import a semaphore onto the one we created using
          * vkImportSemaphoreFdKHR but unfortunately neither DRM nor VAAPI
          * offer us anything we could import and sync with, so instead
          * just signal the semaphore we created. */
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
         f->sem_value[i] = 0;
     }
 
     for (int i = 0; i < desc->nb_objects; i++) {
-        int use_ded_mem = 0;
+        /* Memory requirements */
+        VkImageMemoryRequirementsInfo2 req_desc = {
+            .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
+            .image = f->img[i],
+        };
+        VkMemoryDedicatedRequirements ded_req = {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
+        };
+        VkMemoryRequirements2 req2 = {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
+            .pNext = &ded_req,
+        };
+
+        /* Allocation/importing */
         VkMemoryFdPropertiesKHR fdmp = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
         };
-        VkMemoryRequirements req = {
-            .size = desc->objects[i].size,
-        };
         VkImportMemoryFdInfoKHR idesc = {
             .sType      = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
-            .handleType = htype,
             .fd         = dup(desc->objects[i].fd),
+            .handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
         };
         VkMemoryDedicatedAllocateInfo ded_alloc = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
             .pNext = &idesc,
+            .image = req_desc.image,
         };
 
-        ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev, htype,
+        /* Get object properties */
+        ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev,
+                                           VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
                                            idesc.fd, &fdmp);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to get FD properties: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             close(idesc.fd);
             goto fail;
         }
 
-        req.memoryTypeBits = fdmp.memoryTypeBits;
-
-        /* Dedicated allocation only makes sense if there's a one to one mapping
-         * between images and the memory backing them, so only check in this
-         * case. */
-        if (desc->nb_layers == desc->nb_objects) {
-            VkImageMemoryRequirementsInfo2 req_desc = {
-                .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
-                .image = f->img[i],
-            };
-            VkMemoryDedicatedRequirements ded_req = {
-                .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
-            };
-            VkMemoryRequirements2 req2 = {
-                .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
-                .pNext = &ded_req,
-            };
-
-            vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
+        vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
 
-            use_ded_mem = ded_req.prefersDedicatedAllocation |
-                          ded_req.requiresDedicatedAllocation;
-            if (use_ded_mem)
-                ded_alloc.image = f->img[i];
-        }
+        /* Only a single bit must be set, not a range, and it must match */
+        req2.memoryRequirements.memoryTypeBits = fdmp.memoryTypeBits;
 
-        err = alloc_mem(ctx, &req, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
-                        use_ded_mem ? &ded_alloc : ded_alloc.pNext,
+        err = alloc_mem(ctx, &req2.memoryRequirements,
+                        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
+                        (ded_req.prefersDedicatedAllocation ||
+                         ded_req.requiresDedicatedAllocation) ?
+                            &ded_alloc : ded_alloc.pNext,
                         &f->flags, &f->mem[i]);
         if (err) {
             close(idesc.fd);
             return err;
         }
 
-        f->size[i] = desc->objects[i].size;
+        f->size[i] = req2.memoryRequirements.size;
     }
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
-        const int signal_p = has_modifiers && (planes > 1);
         for (int j = 0; j < planes; j++) {
             VkImageAspectFlagBits aspect = j == 0 ? VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT :
                                            j == 1 ? VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT :
                                                     VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
 
             plane_info[bind_counts].sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
+            plane_info[bind_counts].pNext = NULL;
             plane_info[bind_counts].planeAspect = aspect;
 
             bind_info[bind_counts].sType  = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
-            bind_info[bind_counts].pNext  = signal_p ? &plane_info[bind_counts] : NULL;
+            bind_info[bind_counts].pNext  = planes > 1 ? &plane_info[bind_counts] : NULL;
             bind_info[bind_counts].image  = f->img[i];
             bind_info[bind_counts].memory = f->mem[desc->layers[i].planes[j].object_index];
-            bind_info[bind_counts].memoryOffset = desc->layers[i].planes[j].offset;
+
+            /* Offset is already signalled via pPlaneLayouts above */
+            bind_info[bind_counts].memoryOffset = 0;
+
             bind_counts++;
         }
     }
 
     /* Bind the allocated memory to the images */
     ret = vk->BindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory: %s\n",
                vk_ret2str(ret));
-        return AVERROR_EXTERNAL;
+        err = AVERROR_EXTERNAL;
+        goto fail;
     }
 
     /* NOTE: This is completely uneccesary and unneeded once we can import
      * semaphores from DRM. Otherwise we have to activate the semaphores.
      * We're reusing the exec context that's also used for uploads/downloads. */
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_RO_SHADER);
     if (err)
         goto fail;
 
     *frame = f;
 
     return 0;
 

commit 00ef53c3eabb0e99fd9b62dfd30992824de27e23
Date:   Thu Nov 4 12:17:06 2021 +0100

    hwcontext_vulkan: switch to using timeline semaphores

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2265,218 +2314,226 @@
 static int vulkan_map_from_drm_frame_desc(AVHWFramesContext *hwfc, AVVkFrame **frame,
                                           const AVFrame *src)
 {
     int err = 0;
     VkResult ret;
     AVVkFrame *f;
     int bind_counts = 0;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
     VulkanFunctions *vk = &p->vkfn;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     AVVulkanFramesContext *frames_hwctx = hwfc->hwctx;
     const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
     const int has_modifiers = !!(p->extensions & EXT_DRM_MODIFIER_FLAGS);
     VkSubresourceLayout plane_data[AV_NUM_DATA_POINTERS] = { 0 };
     VkBindImageMemoryInfo bind_info[AV_NUM_DATA_POINTERS] = { 0 };
     VkBindImagePlaneMemoryInfo plane_info[AV_NUM_DATA_POINTERS] = { 0 };
     VkExternalMemoryHandleTypeFlagBits htype = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         if (drm_to_vulkan_fmt(desc->layers[i].format) == VK_FORMAT_UNDEFINED) {
             av_log(ctx, AV_LOG_ERROR, "Unsupported DMABUF layer format %#08x!\n",
                    desc->layers[i].format);
             return AVERROR(EINVAL);
         }
     }
 
     if (!(f = av_vk_frame_alloc())) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     f->tiling = has_modifiers ? VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT :
                 desc->objects[0].format_modifier == DRM_FORMAT_MOD_LINEAR ?
                 VK_IMAGE_TILING_LINEAR : VK_IMAGE_TILING_OPTIMAL;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         VkImageDrmFormatModifierExplicitCreateInfoEXT drm_info = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
             .drmFormatModifier = desc->objects[0].format_modifier,
             .drmFormatModifierPlaneCount = planes,
             .pPlaneLayouts = (const VkSubresourceLayout *)&plane_data,
         };
 
         VkExternalMemoryImageCreateInfo einfo = {
             .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
             .pNext       = has_modifiers ? &drm_info : NULL,
             .handleTypes = htype,
         };
 
+        VkSemaphoreTypeCreateInfo sem_type_info = {
+            .sType         = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
+            .semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE,
+            .initialValue  = 1,
+        };
+
         VkSemaphoreCreateInfo sem_spawn = {
             .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
+            .pNext = &sem_type_info,
         };
 
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = &einfo,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = drm_to_vulkan_fmt(desc->layers[i].format),
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
             .tiling                = f->tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED, /* specs say so */
             .usage                 = frames_hwctx->usage,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      hwfc->sw_format, src->width, src->height, i);
 
         for (int j = 0; j < planes; j++) {
             plane_data[j].offset     = desc->layers[i].planes[j].offset;
             plane_data[j].rowPitch   = desc->layers[i].planes[j].pitch;
             plane_data[j].size       = 0; /* The specs say so for all 3 */
             plane_data[j].arrayPitch = 0;
             plane_data[j].depthPitch = 0;
         }
 
         /* Create image */
         ret = vk->CreateImage(hwctx->act_dev, &create_info,
                               hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
         ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
                                   hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         /* We'd import a semaphore onto the one we created using
          * vkImportSemaphoreFdKHR but unfortunately neither DRM nor VAAPI
          * offer us anything we could import and sync with, so instead
          * just signal the semaphore we created. */
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
+        f->sem_value[i] = 0;
     }
 
     for (int i = 0; i < desc->nb_objects; i++) {
         int use_ded_mem = 0;
         VkMemoryFdPropertiesKHR fdmp = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
         };
         VkMemoryRequirements req = {
             .size = desc->objects[i].size,
         };
         VkImportMemoryFdInfoKHR idesc = {
             .sType      = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
             .handleType = htype,
             .fd         = dup(desc->objects[i].fd),
         };
         VkMemoryDedicatedAllocateInfo ded_alloc = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
             .pNext = &idesc,
         };
 
         ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev, htype,
                                            idesc.fd, &fdmp);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to get FD properties: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             close(idesc.fd);
             goto fail;
         }
 
         req.memoryTypeBits = fdmp.memoryTypeBits;
 
         /* Dedicated allocation only makes sense if there's a one to one mapping
          * between images and the memory backing them, so only check in this
          * case. */
         if (desc->nb_layers == desc->nb_objects) {
             VkImageMemoryRequirementsInfo2 req_desc = {
                 .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
                 .image = f->img[i],
             };
             VkMemoryDedicatedRequirements ded_req = {
                 .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
             };
             VkMemoryRequirements2 req2 = {
                 .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                 .pNext = &ded_req,
             };
 
             vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
 
             use_ded_mem = ded_req.prefersDedicatedAllocation |
                           ded_req.requiresDedicatedAllocation;
             if (use_ded_mem)
                 ded_alloc.image = f->img[i];
         }
 
         err = alloc_mem(ctx, &req, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                         use_ded_mem ? &ded_alloc : ded_alloc.pNext,
                         &f->flags, &f->mem[i]);
         if (err) {
             close(idesc.fd);
             return err;
         }
 
         f->size[i] = desc->objects[i].size;
     }
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         const int signal_p = has_modifiers && (planes > 1);
         for (int j = 0; j < planes; j++) {
             VkImageAspectFlagBits aspect = j == 0 ? VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT :
                                            j == 1 ? VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT :
                                                     VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
 
             plane_info[bind_counts].sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
             plane_info[bind_counts].planeAspect = aspect;
 
             bind_info[bind_counts].sType  = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
             bind_info[bind_counts].pNext  = signal_p ? &plane_info[bind_counts] : NULL;
             bind_info[bind_counts].image  = f->img[i];
             bind_info[bind_counts].memory = f->mem[desc->layers[i].planes[j].object_index];
             bind_info[bind_counts].memoryOffset = desc->layers[i].planes[j].offset;
             bind_counts++;
         }
     }
 
     /* Bind the allocated memory to the images */
     ret = vk->BindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory: %s\n",
                vk_ret2str(ret));
         return AVERROR_EXTERNAL;
     }
 
     /* NOTE: This is completely uneccesary and unneeded once we can import
      * semaphores from DRM. Otherwise we have to activate the semaphores.
      * We're reusing the exec context that's also used for uploads/downloads. */
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_RO_SHADER);
     if (err)
         goto fail;
 
     *frame = f;
 
     return 0;
 

commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2011,219 +2222,218 @@
 static int vulkan_map_from_drm_frame_desc(AVHWFramesContext *hwfc, AVVkFrame **frame,
                                           const AVFrame *src)
 {
     int err = 0;
     VkResult ret;
     AVVkFrame *f;
     int bind_counts = 0;
     AVHWDeviceContext *ctx = hwfc->device_ctx;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
     VulkanFramesPriv *fp = hwfc->internal->priv;
     AVVulkanFramesContext *frames_hwctx = hwfc->hwctx;
     const AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)src->data[0];
     const int has_modifiers = !!(p->extensions & EXT_DRM_MODIFIER_FLAGS);
     VkSubresourceLayout plane_data[AV_NUM_DATA_POINTERS] = { 0 };
     VkBindImageMemoryInfo bind_info[AV_NUM_DATA_POINTERS] = { 0 };
     VkBindImagePlaneMemoryInfo plane_info[AV_NUM_DATA_POINTERS] = { 0 };
     VkExternalMemoryHandleTypeFlagBits htype = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
 
-    VK_LOAD_PFN(hwctx->inst, vkGetMemoryFdPropertiesKHR);
-
     for (int i = 0; i < desc->nb_layers; i++) {
         if (drm_to_vulkan_fmt(desc->layers[i].format) == VK_FORMAT_UNDEFINED) {
             av_log(ctx, AV_LOG_ERROR, "Unsupported DMABUF layer format %#08x!\n",
                    desc->layers[i].format);
             return AVERROR(EINVAL);
         }
     }
 
     if (!(f = av_vk_frame_alloc())) {
         av_log(ctx, AV_LOG_ERROR, "Unable to allocate memory for AVVkFrame!\n");
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     f->tiling = has_modifiers ? VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT :
                 desc->objects[0].format_modifier == DRM_FORMAT_MOD_LINEAR ?
                 VK_IMAGE_TILING_LINEAR : VK_IMAGE_TILING_OPTIMAL;
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         VkImageDrmFormatModifierExplicitCreateInfoEXT drm_info = {
             .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
             .drmFormatModifier = desc->objects[0].format_modifier,
             .drmFormatModifierPlaneCount = planes,
             .pPlaneLayouts = (const VkSubresourceLayout *)&plane_data,
         };
 
         VkExternalMemoryImageCreateInfo einfo = {
             .sType       = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
             .pNext       = has_modifiers ? &drm_info : NULL,
             .handleTypes = htype,
         };
 
         VkSemaphoreCreateInfo sem_spawn = {
             .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
         };
 
         VkImageCreateInfo create_info = {
             .sType                 = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
             .pNext                 = &einfo,
             .imageType             = VK_IMAGE_TYPE_2D,
             .format                = drm_to_vulkan_fmt(desc->layers[i].format),
             .extent.depth          = 1,
             .mipLevels             = 1,
             .arrayLayers           = 1,
             .flags                 = VK_IMAGE_CREATE_ALIAS_BIT,
             .tiling                = f->tiling,
             .initialLayout         = VK_IMAGE_LAYOUT_UNDEFINED, /* specs say so */
             .usage                 = frames_hwctx->usage,
             .samples               = VK_SAMPLE_COUNT_1_BIT,
             .pQueueFamilyIndices   = p->qfs,
             .queueFamilyIndexCount = p->num_qfs,
             .sharingMode           = p->num_qfs > 1 ? VK_SHARING_MODE_CONCURRENT :
                                                       VK_SHARING_MODE_EXCLUSIVE,
         };
 
         get_plane_wh(&create_info.extent.width, &create_info.extent.height,
                      hwfc->sw_format, src->width, src->height, i);
 
         for (int j = 0; j < planes; j++) {
             plane_data[j].offset     = desc->layers[i].planes[j].offset;
             plane_data[j].rowPitch   = desc->layers[i].planes[j].pitch;
             plane_data[j].size       = 0; /* The specs say so for all 3 */
             plane_data[j].arrayPitch = 0;
             plane_data[j].depthPitch = 0;
         }
 
         /* Create image */
-        ret = vkCreateImage(hwctx->act_dev, &create_info,
-                            hwctx->alloc, &f->img[i]);
+        ret = vk->CreateImage(hwctx->act_dev, &create_info,
+                              hwctx->alloc, &f->img[i]);
         if (ret != VK_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Image creation failure: %s\n",
                    vk_ret2str(ret));
             err = AVERROR(EINVAL);
             goto fail;
         }
 
-        ret = vkCreateSemaphore(hwctx->act_dev, &sem_spawn,
-                                hwctx->alloc, &f->sem[i]);
+        ret = vk->CreateSemaphore(hwctx->act_dev, &sem_spawn,
+                                  hwctx->alloc, &f->sem[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwctx, AV_LOG_ERROR, "Failed to create semaphore: %s\n",
                    vk_ret2str(ret));
             return AVERROR_EXTERNAL;
         }
 
         /* We'd import a semaphore onto the one we created using
          * vkImportSemaphoreFdKHR but unfortunately neither DRM nor VAAPI
          * offer us anything we could import and sync with, so instead
          * just signal the semaphore we created. */
 
         f->layout[i] = create_info.initialLayout;
         f->access[i] = 0x0;
     }
 
     for (int i = 0; i < desc->nb_objects; i++) {
         int use_ded_mem = 0;
         VkMemoryFdPropertiesKHR fdmp = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
         };
         VkMemoryRequirements req = {
             .size = desc->objects[i].size,
         };
         VkImportMemoryFdInfoKHR idesc = {
             .sType      = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
             .handleType = htype,
             .fd         = dup(desc->objects[i].fd),
         };
         VkMemoryDedicatedAllocateInfo ded_alloc = {
             .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
             .pNext = &idesc,
         };
 
-        ret = pfn_vkGetMemoryFdPropertiesKHR(hwctx->act_dev, htype,
-                                             idesc.fd, &fdmp);
+        ret = vk->GetMemoryFdPropertiesKHR(hwctx->act_dev, htype,
+                                           idesc.fd, &fdmp);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to get FD properties: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             close(idesc.fd);
             goto fail;
         }
 
         req.memoryTypeBits = fdmp.memoryTypeBits;
 
         /* Dedicated allocation only makes sense if there's a one to one mapping
          * between images and the memory backing them, so only check in this
          * case. */
         if (desc->nb_layers == desc->nb_objects) {
             VkImageMemoryRequirementsInfo2 req_desc = {
                 .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
                 .image = f->img[i],
             };
             VkMemoryDedicatedRequirements ded_req = {
                 .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
             };
             VkMemoryRequirements2 req2 = {
                 .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
                 .pNext = &ded_req,
             };
 
-            vkGetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
+            vk->GetImageMemoryRequirements2(hwctx->act_dev, &req_desc, &req2);
 
             use_ded_mem = ded_req.prefersDedicatedAllocation |
                           ded_req.requiresDedicatedAllocation;
             if (use_ded_mem)
                 ded_alloc.image = f->img[i];
         }
 
         err = alloc_mem(ctx, &req, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                         use_ded_mem ? &ded_alloc : ded_alloc.pNext,
                         &f->flags, &f->mem[i]);
         if (err) {
             close(idesc.fd);
             return err;
         }
 
         f->size[i] = desc->objects[i].size;
     }
 
     for (int i = 0; i < desc->nb_layers; i++) {
         const int planes = desc->layers[i].nb_planes;
         const int signal_p = has_modifiers && (planes > 1);
         for (int j = 0; j < planes; j++) {
             VkImageAspectFlagBits aspect = j == 0 ? VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT :
                                            j == 1 ? VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT :
                                                     VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
 
             plane_info[bind_counts].sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
             plane_info[bind_counts].planeAspect = aspect;
 
             bind_info[bind_counts].sType  = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
             bind_info[bind_counts].pNext  = signal_p ? &plane_info[bind_counts] : NULL;
             bind_info[bind_counts].image  = f->img[i];
             bind_info[bind_counts].memory = f->mem[desc->layers[i].planes[j].object_index];
             bind_info[bind_counts].memoryOffset = desc->layers[i].planes[j].offset;
             bind_counts++;
         }
     }
 
     /* Bind the allocated memory to the images */
-    ret = vkBindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
+    ret = vk->BindImageMemory2(hwctx->act_dev, bind_counts, bind_info);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory: %s\n",
                vk_ret2str(ret));
         return AVERROR_EXTERNAL;
     }
 
     /* NOTE: This is completely uneccesary and unneeded once we can import
      * semaphores from DRM. Otherwise we have to activate the semaphores.
      * We're reusing the exec context that's also used for uploads/downloads. */
     err = prepare_frame(hwfc, &fp->conv_ctx, f, PREP_MODE_RO_SHADER);
     if (err)
         goto fail;
 
     *frame = f;
 
     return 0;
 
[func] **new** commit 0d524b170ec4bf762e11c49743d813de650d409a
Date:   Tue Dec 7 17:05:52 2021 +0800

    hwcontext_vulkan: add support for mapping frames with planes in a single VkDeviceMemory
    
    Add support to map vulkan frames to software frames when
    using contiguous_planes flag.
    
    Signed-off-by: Wenbin Chen <wenbin.chen@intel.com>
    Further-modifications-by: Lynne <dev@lynne.ee>

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2331,84 +2331,91 @@
 static int vulkan_map_frame_to_mem(AVHWFramesContext *hwfc, AVFrame *dst,
                                    const AVFrame *src, int flags)
 {
     VkResult ret;
-    int err, mapped_mem_count = 0;
+    int err, mapped_mem_count = 0, mem_planes = 0;
     AVVkFrame *f = (AVVkFrame *)src->data[0];
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVVulkanFramesContext *hwfctx = hwfc->hwctx;
     const int planes = av_pix_fmt_count_planes(hwfc->sw_format);
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     FFVulkanFunctions *vk = &p->vkfn;
 
     VulkanMapping *map = av_mallocz(sizeof(VulkanMapping));
     if (!map)
         return AVERROR(EINVAL);
 
     if (src->format != AV_PIX_FMT_VULKAN) {
         av_log(hwfc, AV_LOG_ERROR, "Cannot map from pixel format %s!\n",
                av_get_pix_fmt_name(src->format));
         err = AVERROR(EINVAL);
         goto fail;
     }
 
     if (!(f->flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) ||
         !(f->tiling == VK_IMAGE_TILING_LINEAR)) {
         av_log(hwfc, AV_LOG_ERROR, "Unable to map frame, not host visible "
                "and linear!\n");
         err = AVERROR(EINVAL);
         goto fail;
     }
 
     dst->width  = src->width;
     dst->height = src->height;
 
-    for (int i = 0; i < planes; i++) {
+    mem_planes = hwfctx->flags & AV_VK_FRAME_FLAG_CONTIGUOUS_MEMORY ? 1 : planes;
+    for (int i = 0; i < mem_planes; i++) {
         ret = vk->MapMemory(hwctx->act_dev, f->mem[i], 0,
                             VK_WHOLE_SIZE, 0, (void **)&dst->data[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to map image memory: %s\n",
                 vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
         mapped_mem_count++;
     }
 
+    if (hwfctx->flags & AV_VK_FRAME_FLAG_CONTIGUOUS_MEMORY) {
+        for (int i = 0; i < planes; i++)
+            dst->data[i] = dst->data[0] + f->offset[i];
+    }
+
     /* Check if the memory contents matter */
     if (((flags & AV_HWFRAME_MAP_READ) || !(flags & AV_HWFRAME_MAP_OVERWRITE)) &&
         !(f->flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
         VkMappedMemoryRange map_mem_ranges[AV_NUM_DATA_POINTERS] = { { 0 } };
         for (int i = 0; i < planes; i++) {
             map_mem_ranges[i].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
             map_mem_ranges[i].size = VK_WHOLE_SIZE;
             map_mem_ranges[i].memory = f->mem[i];
         }
 
         ret = vk->InvalidateMappedMemoryRanges(hwctx->act_dev, planes,
                                                map_mem_ranges);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to invalidate memory: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
     }
 
     for (int i = 0; i < planes; i++) {
         VkImageSubresource sub = {
             .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
         };
         VkSubresourceLayout layout;
         vk->GetImageSubresourceLayout(hwctx->act_dev, f->img[i], &sub, &layout);
         dst->linesize[i] = layout.rowPitch;
     }
 
     map->frame = f;
     map->flags = flags;
 
     err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,
                                 &vulkan_unmap_frame, map);
     if (err < 0)
         goto fail;
 
     return 0;
 

commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2273,84 +2114,84 @@
 static int vulkan_map_frame_to_mem(AVHWFramesContext *hwfc, AVFrame *dst,
                                    const AVFrame *src, int flags)
 {
     VkResult ret;
     int err, mapped_mem_count = 0;
     AVVkFrame *f = (AVVkFrame *)src->data[0];
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     const int planes = av_pix_fmt_count_planes(hwfc->sw_format);
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
 
     VulkanMapping *map = av_mallocz(sizeof(VulkanMapping));
     if (!map)
         return AVERROR(EINVAL);
 
     if (src->format != AV_PIX_FMT_VULKAN) {
         av_log(hwfc, AV_LOG_ERROR, "Cannot map from pixel format %s!\n",
                av_get_pix_fmt_name(src->format));
         err = AVERROR(EINVAL);
         goto fail;
     }
 
     if (!(f->flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) ||
         !(f->tiling == VK_IMAGE_TILING_LINEAR)) {
         av_log(hwfc, AV_LOG_ERROR, "Unable to map frame, not host visible "
                "and linear!\n");
         err = AVERROR(EINVAL);
         goto fail;
     }
 
     dst->width  = src->width;
     dst->height = src->height;
 
     for (int i = 0; i < planes; i++) {
         ret = vk->MapMemory(hwctx->act_dev, f->mem[i], 0,
                             VK_WHOLE_SIZE, 0, (void **)&dst->data[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to map image memory: %s\n",
                 vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
         mapped_mem_count++;
     }
 
     /* Check if the memory contents matter */
     if (((flags & AV_HWFRAME_MAP_READ) || !(flags & AV_HWFRAME_MAP_OVERWRITE)) &&
         !(f->flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
         VkMappedMemoryRange map_mem_ranges[AV_NUM_DATA_POINTERS] = { { 0 } };
         for (int i = 0; i < planes; i++) {
             map_mem_ranges[i].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
             map_mem_ranges[i].size = VK_WHOLE_SIZE;
             map_mem_ranges[i].memory = f->mem[i];
         }
 
         ret = vk->InvalidateMappedMemoryRanges(hwctx->act_dev, planes,
                                                map_mem_ranges);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to invalidate memory: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
     }
 
     for (int i = 0; i < planes; i++) {
         VkImageSubresource sub = {
             .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
         };
         VkSubresourceLayout layout;
         vk->GetImageSubresourceLayout(hwctx->act_dev, f->img[i], &sub, &layout);
         dst->linesize[i] = layout.rowPitch;
     }
 
     map->frame = f;
     map->flags = flags;
 
     err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,
                                 &vulkan_unmap_frame, map);
     if (err < 0)
         goto fail;
 
     return 0;
 

commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1881,82 +2088,84 @@
 static int vulkan_map_frame_to_mem(AVHWFramesContext *hwfc, AVFrame *dst,
                                    const AVFrame *src, int flags)
 {
     VkResult ret;
     int err, mapped_mem_count = 0;
     AVVkFrame *f = (AVVkFrame *)src->data[0];
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     const int planes = av_pix_fmt_count_planes(hwfc->sw_format);
+    VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
 
     VulkanMapping *map = av_mallocz(sizeof(VulkanMapping));
     if (!map)
         return AVERROR(EINVAL);
 
     if (src->format != AV_PIX_FMT_VULKAN) {
         av_log(hwfc, AV_LOG_ERROR, "Cannot map from pixel format %s!\n",
                av_get_pix_fmt_name(src->format));
         err = AVERROR(EINVAL);
         goto fail;
     }
 
     if (!(f->flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) ||
         !(f->tiling == VK_IMAGE_TILING_LINEAR)) {
         av_log(hwfc, AV_LOG_ERROR, "Unable to map frame, not host visible "
                "and linear!\n");
         err = AVERROR(EINVAL);
         goto fail;
     }
 
     dst->width  = src->width;
     dst->height = src->height;
 
     for (int i = 0; i < planes; i++) {
-        ret = vkMapMemory(hwctx->act_dev, f->mem[i], 0,
-                          VK_WHOLE_SIZE, 0, (void **)&dst->data[i]);
+        ret = vk->MapMemory(hwctx->act_dev, f->mem[i], 0,
+                            VK_WHOLE_SIZE, 0, (void **)&dst->data[i]);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to map image memory: %s\n",
                 vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
         mapped_mem_count++;
     }
 
     /* Check if the memory contents matter */
     if (((flags & AV_HWFRAME_MAP_READ) || !(flags & AV_HWFRAME_MAP_OVERWRITE)) &&
         !(f->flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
         VkMappedMemoryRange map_mem_ranges[AV_NUM_DATA_POINTERS] = { { 0 } };
         for (int i = 0; i < planes; i++) {
             map_mem_ranges[i].sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
             map_mem_ranges[i].size = VK_WHOLE_SIZE;
             map_mem_ranges[i].memory = f->mem[i];
         }
 
-        ret = vkInvalidateMappedMemoryRanges(hwctx->act_dev, planes,
-                                             map_mem_ranges);
+        ret = vk->InvalidateMappedMemoryRanges(hwctx->act_dev, planes,
+                                               map_mem_ranges);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to invalidate memory: %s\n",
                    vk_ret2str(ret));
             err = AVERROR_EXTERNAL;
             goto fail;
         }
     }
 
     for (int i = 0; i < planes; i++) {
         VkImageSubresource sub = {
             .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
         };
         VkSubresourceLayout layout;
-        vkGetImageSubresourceLayout(hwctx->act_dev, f->img[i], &sub, &layout);
+        vk->GetImageSubresourceLayout(hwctx->act_dev, f->img[i], &sub, &layout);
         dst->linesize[i] = layout.rowPitch;
     }
 
     map->frame = f;
     map->flags = flags;
 
     err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,
                                 &vulkan_unmap_frame, map);
     if (err < 0)
         goto fail;
 
     return 0;
 
commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -3208,85 +3049,85 @@
 static int create_buf(AVHWDeviceContext *ctx, AVBufferRef **buf,
                       VkBufferUsageFlags usage, VkMemoryPropertyFlagBits flags,
                       size_t size, uint32_t req_memory_bits, int host_mapped,
                       void *create_pnext, void *alloc_pnext)
 {
     int err;
     VkResult ret;
     int use_ded_mem;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
 
     VkBufferCreateInfo buf_spawn = {
         .sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
         .pNext       = create_pnext,
         .usage       = usage,
         .size        = size,
         .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
     };
 
     VkBufferMemoryRequirementsInfo2 req_desc = {
         .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
     };
     VkMemoryDedicatedAllocateInfo ded_alloc = {
         .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
         .pNext = alloc_pnext,
     };
     VkMemoryDedicatedRequirements ded_req = {
         .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
     };
     VkMemoryRequirements2 req = {
         .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
         .pNext = &ded_req,
     };
 
     ImageBuffer *vkbuf = av_mallocz(sizeof(*vkbuf));
     if (!vkbuf)
         return AVERROR(ENOMEM);
 
     vkbuf->mapped_mem = host_mapped;
 
     ret = vk->CreateBuffer(hwctx->act_dev, &buf_spawn, NULL, &vkbuf->buf);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to create buffer: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
     req_desc.buffer = vkbuf->buf;
 
     vk->GetBufferMemoryRequirements2(hwctx->act_dev, &req_desc, &req);
 
     /* In case the implementation prefers/requires dedicated allocation */
     use_ded_mem = ded_req.prefersDedicatedAllocation |
                   ded_req.requiresDedicatedAllocation;
     if (use_ded_mem)
         ded_alloc.buffer = vkbuf->buf;
 
     /* Additional requirements imposed on us */
     if (req_memory_bits)
         req.memoryRequirements.memoryTypeBits &= req_memory_bits;
 
     err = alloc_mem(ctx, &req.memoryRequirements, flags,
                     use_ded_mem ? &ded_alloc : (void *)ded_alloc.pNext,
                     &vkbuf->flags, &vkbuf->mem);
     if (err)
         goto fail;
 
     ret = vk->BindBufferMemory(hwctx->act_dev, vkbuf->buf, vkbuf->mem, 0);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory to buffer: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
     *buf = av_buffer_create((uint8_t *)vkbuf, sizeof(*vkbuf), free_buf, ctx, 0);
     if (!(*buf)) {
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     return 0;
 

commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2756,83 +2967,85 @@
 static int create_buf(AVHWDeviceContext *ctx, AVBufferRef **buf,
                       VkBufferUsageFlags usage, VkMemoryPropertyFlagBits flags,
                       size_t size, uint32_t req_memory_bits, int host_mapped,
                       void *create_pnext, void *alloc_pnext)
 {
     int err;
     VkResult ret;
     int use_ded_mem;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
+    VulkanDevicePriv *p = ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
 
     VkBufferCreateInfo buf_spawn = {
         .sType       = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
         .pNext       = create_pnext,
         .usage       = usage,
         .size        = size,
         .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
     };
 
     VkBufferMemoryRequirementsInfo2 req_desc = {
         .sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
     };
     VkMemoryDedicatedAllocateInfo ded_alloc = {
         .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
         .pNext = alloc_pnext,
     };
     VkMemoryDedicatedRequirements ded_req = {
         .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
     };
     VkMemoryRequirements2 req = {
         .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
         .pNext = &ded_req,
     };
 
     ImageBuffer *vkbuf = av_mallocz(sizeof(*vkbuf));
     if (!vkbuf)
         return AVERROR(ENOMEM);
 
     vkbuf->mapped_mem = host_mapped;
 
-    ret = vkCreateBuffer(hwctx->act_dev, &buf_spawn, NULL, &vkbuf->buf);
+    ret = vk->CreateBuffer(hwctx->act_dev, &buf_spawn, NULL, &vkbuf->buf);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to create buffer: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
     req_desc.buffer = vkbuf->buf;
 
-    vkGetBufferMemoryRequirements2(hwctx->act_dev, &req_desc, &req);
+    vk->GetBufferMemoryRequirements2(hwctx->act_dev, &req_desc, &req);
 
     /* In case the implementation prefers/requires dedicated allocation */
     use_ded_mem = ded_req.prefersDedicatedAllocation |
                   ded_req.requiresDedicatedAllocation;
     if (use_ded_mem)
         ded_alloc.buffer = vkbuf->buf;
 
     /* Additional requirements imposed on us */
     if (req_memory_bits)
         req.memoryRequirements.memoryTypeBits &= req_memory_bits;
 
     err = alloc_mem(ctx, &req.memoryRequirements, flags,
                     use_ded_mem ? &ded_alloc : (void *)ded_alloc.pNext,
                     &vkbuf->flags, &vkbuf->mem);
     if (err)
         goto fail;
 
-    ret = vkBindBufferMemory(hwctx->act_dev, vkbuf->buf, vkbuf->mem, 0);
+    ret = vk->BindBufferMemory(hwctx->act_dev, vkbuf->buf, vkbuf->mem, 0);
     if (ret != VK_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Failed to bind memory to buffer: %s\n",
                vk_ret2str(ret));
         err = AVERROR_EXTERNAL;
         goto fail;
     }
 
     *buf = av_buffer_create((uint8_t *)vkbuf, sizeof(*vkbuf), free_buf, ctx, 0);
     if (!(*buf)) {
         err = AVERROR(ENOMEM);
         goto fail;
     }
 
     return 0;
 
[func] **new** commit f74ceb358c3042a7d3c6b61fc0149d0caafd4158
Date:   Sat Nov 13 04:14:04 2021 +0100

    hwcontext_vulkan: improve CUDA error handling

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1583,24 +1585,24 @@
 static void vulkan_frame_free(void *opaque, uint8_t *data)
 {
     AVVkFrame *f = (AVVkFrame *)data;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     FFVulkanFunctions *vk = &p->vkfn;
     int planes = av_pix_fmt_count_planes(hwfc->sw_format);
 
     /* We could use vkWaitSemaphores, but the validation layer seems to have
      * issues tracking command buffer execution state on uninit. */
     vk->DeviceWaitIdle(hwctx->act_dev);
 
-    vulkan_free_internal(f->internal);
+    vulkan_free_internal(f);
 
     for (int i = 0; i < planes; i++) {
         vk->DestroyImage(hwctx->act_dev, f->img[i], hwctx->alloc);
         vk->FreeMemory(hwctx->act_dev, f->mem[i], hwctx->alloc);
         vk->DestroySemaphore(hwctx->act_dev, f->sem[i], hwctx->alloc);
     }
 
     av_free(f);
 }
 

[func] **new** commit 57e11321ea378a57a909d817c2fcf2ebcaf8c123
Date:   Fri Nov 12 13:05:42 2021 +0100

    hwcontext_vulkan: use vkDeviceWaitIdle instead of vkWaitSemaphores on uninit
    
    To silence a possible validation layer bug, switch the function. It only gets
    triggered by vf_libplacebo, which is odd.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1583,30 +1583,24 @@
 static void vulkan_frame_free(void *opaque, uint8_t *data)
 {
     AVVkFrame *f = (AVVkFrame *)data;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     FFVulkanFunctions *vk = &p->vkfn;
     int planes = av_pix_fmt_count_planes(hwfc->sw_format);
 
-    VkSemaphoreWaitInfo wait_info = {
-        .sType          = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
-        .flags          = 0x0,
-        .pSemaphores    = f->sem,
-        .pValues        = f->sem_value,
-        .semaphoreCount = planes,
-    };
-
-    vk->WaitSemaphores(hwctx->act_dev, &wait_info, UINT64_MAX);
+    /* We could use vkWaitSemaphores, but the validation layer seems to have
+     * issues tracking command buffer execution state on uninit. */
+    vk->DeviceWaitIdle(hwctx->act_dev);
 
     vulkan_free_internal(f->internal);
 
     for (int i = 0; i < planes; i++) {
         vk->DestroyImage(hwctx->act_dev, f->img[i], hwctx->alloc);
         vk->FreeMemory(hwctx->act_dev, f->mem[i], hwctx->alloc);
         vk->DestroySemaphore(hwctx->act_dev, f->sem[i], hwctx->alloc);
     }
 
     av_free(f);
 }
 

commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1742,30 +1583,30 @@
 static void vulkan_frame_free(void *opaque, uint8_t *data)
 {
     AVVkFrame *f = (AVVkFrame *)data;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
     int planes = av_pix_fmt_count_planes(hwfc->sw_format);
 
     VkSemaphoreWaitInfo wait_info = {
         .sType          = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
         .flags          = 0x0,
         .pSemaphores    = f->sem,
         .pValues        = f->sem_value,
         .semaphoreCount = planes,
     };
 
     vk->WaitSemaphores(hwctx->act_dev, &wait_info, UINT64_MAX);
 
     vulkan_free_internal(f->internal);
 
     for (int i = 0; i < planes; i++) {
         vk->DestroyImage(hwctx->act_dev, f->img[i], hwctx->alloc);
         vk->FreeMemory(hwctx->act_dev, f->mem[i], hwctx->alloc);
         vk->DestroySemaphore(hwctx->act_dev, f->sem[i], hwctx->alloc);
     }
 
     av_free(f);
 }
 

[func] **new** commit bde1fc5386282142697dbaf91fe57744ba63fec1
Date:   Sun Nov 7 08:44:46 2021 +0100

    hwcontext_vulkan: host wait on semaphores before freeing frame

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1731,20 +1732,30 @@
 static void vulkan_frame_free(void *opaque, uint8_t *data)
 {
     AVVkFrame *f = (AVVkFrame *)data;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
     VulkanFunctions *vk = &p->vkfn;
     int planes = av_pix_fmt_count_planes(hwfc->sw_format);
 
+    VkSemaphoreWaitInfo wait_info = {
+        .sType          = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO,
+        .flags          = 0x0,
+        .pSemaphores    = f->sem,
+        .pValues        = f->sem_value,
+        .semaphoreCount = planes,
+    };
+
+    vk->WaitSemaphores(hwctx->act_dev, &wait_info, UINT64_MAX);
+
     vulkan_free_internal(f->internal);
 
     for (int i = 0; i < planes; i++) {
         vk->DestroyImage(hwctx->act_dev, f->img[i], hwctx->alloc);
         vk->FreeMemory(hwctx->act_dev, f->mem[i], hwctx->alloc);
         vk->DestroySemaphore(hwctx->act_dev, f->sem[i], hwctx->alloc);
     }
 
     av_free(f);
 }
 

commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1390,18 +1587,20 @@
 static void vulkan_frame_free(void *opaque, uint8_t *data)
 {
     AVVkFrame *f = (AVVkFrame *)data;
     AVHWFramesContext *hwfc = opaque;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
     int planes = av_pix_fmt_count_planes(hwfc->sw_format);
 
     vulkan_free_internal(f->internal);
 
     for (int i = 0; i < planes; i++) {
-        vkDestroyImage(hwctx->act_dev, f->img[i], hwctx->alloc);
-        vkFreeMemory(hwctx->act_dev, f->mem[i], hwctx->alloc);
-        vkDestroySemaphore(hwctx->act_dev, f->sem[i], hwctx->alloc);
+        vk->DestroyImage(hwctx->act_dev, f->img[i], hwctx->alloc);
+        vk->FreeMemory(hwctx->act_dev, f->mem[i], hwctx->alloc);
+        vk->DestroySemaphore(hwctx->act_dev, f->sem[i], hwctx->alloc);
     }
 
     av_free(f);
 }
 
commit 2ece70090d61ccc1aea8000ba57d2fd759f204f7
Date:   Sat Nov 13 20:00:50 2021 +0100

    avutil/hwcontext_vulkan: add support for exporting memory via Win32 Handles

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1555,32 +1564,38 @@
 static void vulkan_free_internal(AVVkFrame *f)
 {
     AVVkFrameInternal *internal = f->internal;
 
     if (!internal)
         return;
 
 #if CONFIG_CUDA
     if (internal->cuda_fc_ref) {
         AVHWFramesContext *cuda_fc = (AVHWFramesContext *)internal->cuda_fc_ref->data;
         int planes = av_pix_fmt_count_planes(cuda_fc->sw_format);
         AVHWDeviceContext *cuda_cu = cuda_fc->device_ctx;
         AVCUDADeviceContext *cuda_dev = cuda_cu->hwctx;
         AVCUDADeviceContextInternal *cu_internal = cuda_dev->internal;
         CudaFunctions *cu = cu_internal->cuda_dl;
 
         for (int i = 0; i < planes; i++) {
             if (internal->cu_sem[i])
                 CHECK_CU(cu->cuDestroyExternalSemaphore(internal->cu_sem[i]));
             if (internal->cu_mma[i])
                 CHECK_CU(cu->cuMipmappedArrayDestroy(internal->cu_mma[i]));
             if (internal->ext_mem[i])
                 CHECK_CU(cu->cuDestroyExternalMemory(internal->ext_mem[i]));
+#ifdef _WIN32
+            if (internal->ext_sem_handle[i])
+                CloseHandle(internal->ext_sem_handle[i]);
+            if (internal->ext_mem_handle[i])
+                CloseHandle(internal->ext_mem_handle[i]);
+#endif
         }
 
         av_buffer_unref(&internal->cuda_fc_ref);
     }
 #endif
 
     av_freep(&f->internal);
 }
 

commit f74ceb358c3042a7d3c6b61fc0149d0caafd4158
Date:   Sat Nov 13 04:14:04 2021 +0100

    hwcontext_vulkan: improve CUDA error handling

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1553,30 +1553,32 @@
-static void vulkan_free_internal(AVVkFrameInternal *internal)
+static void vulkan_free_internal(AVVkFrame *f)
 {
+    AVVkFrameInternal *internal = f->internal;
+
     if (!internal)
         return;
 
 #if CONFIG_CUDA
     if (internal->cuda_fc_ref) {
         AVHWFramesContext *cuda_fc = (AVHWFramesContext *)internal->cuda_fc_ref->data;
         int planes = av_pix_fmt_count_planes(cuda_fc->sw_format);
         AVHWDeviceContext *cuda_cu = cuda_fc->device_ctx;
         AVCUDADeviceContext *cuda_dev = cuda_cu->hwctx;
         AVCUDADeviceContextInternal *cu_internal = cuda_dev->internal;
         CudaFunctions *cu = cu_internal->cuda_dl;
 
         for (int i = 0; i < planes; i++) {
             if (internal->cu_sem[i])
                 CHECK_CU(cu->cuDestroyExternalSemaphore(internal->cu_sem[i]));
             if (internal->cu_mma[i])
                 CHECK_CU(cu->cuMipmappedArrayDestroy(internal->cu_mma[i]));
             if (internal->ext_mem[i])
                 CHECK_CU(cu->cuDestroyExternalMemory(internal->ext_mem[i]));
         }
 
         av_buffer_unref(&internal->cuda_fc_ref);
     }
 #endif
 
-    av_free(internal);
+    av_freep(&f->internal);
 }
 

[func] **new** commit 015b487777cc3bd540f7d77e7ce902a3ab4a7239
Date:   Sat Nov 13 00:14:10 2021 +0100

    hwcontext_vulkan: do not dup() semaphore FDs for CUDA

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1554,31 +1553,30 @@
 static void vulkan_free_internal(AVVkFrameInternal *internal)
 {
     if (!internal)
         return;
 
 #if CONFIG_CUDA
     if (internal->cuda_fc_ref) {
         AVHWFramesContext *cuda_fc = (AVHWFramesContext *)internal->cuda_fc_ref->data;
         int planes = av_pix_fmt_count_planes(cuda_fc->sw_format);
         AVHWDeviceContext *cuda_cu = cuda_fc->device_ctx;
         AVCUDADeviceContext *cuda_dev = cuda_cu->hwctx;
         AVCUDADeviceContextInternal *cu_internal = cuda_dev->internal;
         CudaFunctions *cu = cu_internal->cuda_dl;
 
         for (int i = 0; i < planes; i++) {
             if (internal->cu_sem[i])
                 CHECK_CU(cu->cuDestroyExternalSemaphore(internal->cu_sem[i]));
             if (internal->cu_mma[i])
                 CHECK_CU(cu->cuMipmappedArrayDestroy(internal->cu_mma[i]));
             if (internal->ext_mem[i])
                 CHECK_CU(cu->cuDestroyExternalMemory(internal->ext_mem[i]));
-            close(internal->exp_sem[i]);
         }
 
         av_buffer_unref(&internal->cuda_fc_ref);
     }
 #endif
 
     av_free(internal);
 }
 

[func] **new** commit 09e4687b5b8e0ad690f7e101e539c0605768d1d7
Date:   Fri Nov 5 13:50:32 2021 +0100

    hwcontext_vulkan: port CUDA interop to use timeline semaphores

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1629,30 +1631,31 @@
 static void vulkan_free_internal(AVVkFrameInternal *internal)
 {
     if (!internal)
         return;
 
 #if CONFIG_CUDA
     if (internal->cuda_fc_ref) {
         AVHWFramesContext *cuda_fc = (AVHWFramesContext *)internal->cuda_fc_ref->data;
         int planes = av_pix_fmt_count_planes(cuda_fc->sw_format);
         AVHWDeviceContext *cuda_cu = cuda_fc->device_ctx;
         AVCUDADeviceContext *cuda_dev = cuda_cu->hwctx;
         AVCUDADeviceContextInternal *cu_internal = cuda_dev->internal;
         CudaFunctions *cu = cu_internal->cuda_dl;
 
         for (int i = 0; i < planes; i++) {
             if (internal->cu_sem[i])
                 CHECK_CU(cu->cuDestroyExternalSemaphore(internal->cu_sem[i]));
             if (internal->cu_mma[i])
                 CHECK_CU(cu->cuMipmappedArrayDestroy(internal->cu_mma[i]));
             if (internal->ext_mem[i])
                 CHECK_CU(cu->cuDestroyExternalMemory(internal->ext_mem[i]));
+            close(internal->exp_sem[i]);
         }
 
         av_buffer_unref(&internal->cuda_fc_ref);
     }
 #endif
 
     av_free(internal);
 }
 
commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2239,34 +2080,34 @@
 static void vulkan_unmap_frame(AVHWFramesContext *hwfc, HWMapDescriptor *hwmap)
 {
     VulkanMapping *map = hwmap->priv;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     const int planes = av_pix_fmt_count_planes(hwfc->sw_format);
     VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
 
     /* Check if buffer needs flushing */
     if ((map->flags & AV_HWFRAME_MAP_WRITE) &&
         !(map->frame->flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
         VkResult ret;
         VkMappedMemoryRange flush_ranges[AV_NUM_DATA_POINTERS] = { { 0 } };
 
         for (int i = 0; i < planes; i++) {
             flush_ranges[i].sType  = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
             flush_ranges[i].memory = map->frame->mem[i];
             flush_ranges[i].size   = VK_WHOLE_SIZE;
         }
 
         ret = vk->FlushMappedMemoryRanges(hwctx->act_dev, planes,
                                           flush_ranges);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to flush memory: %s\n",
                    vk_ret2str(ret));
         }
     }
 
     for (int i = 0; i < planes; i++)
         vk->UnmapMemory(hwctx->act_dev, map->frame->mem[i]);
 
     av_free(map);
 }
 

commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -1849,32 +2054,34 @@
 static void vulkan_unmap_frame(AVHWFramesContext *hwfc, HWMapDescriptor *hwmap)
 {
     VulkanMapping *map = hwmap->priv;
     AVVulkanDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     const int planes = av_pix_fmt_count_planes(hwfc->sw_format);
+    VulkanDevicePriv *p = hwfc->device_ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
 
     /* Check if buffer needs flushing */
     if ((map->flags & AV_HWFRAME_MAP_WRITE) &&
         !(map->frame->flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)) {
         VkResult ret;
         VkMappedMemoryRange flush_ranges[AV_NUM_DATA_POINTERS] = { { 0 } };
 
         for (int i = 0; i < planes; i++) {
             flush_ranges[i].sType  = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
             flush_ranges[i].memory = map->frame->mem[i];
             flush_ranges[i].size   = VK_WHOLE_SIZE;
         }
 
-        ret = vkFlushMappedMemoryRanges(hwctx->act_dev, planes,
-                                        flush_ranges);
+        ret = vk->FlushMappedMemoryRanges(hwctx->act_dev, planes,
+                                          flush_ranges);
         if (ret != VK_SUCCESS) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to flush memory: %s\n",
                    vk_ret2str(ret));
         }
     }
 
     for (int i = 0; i < planes; i++)
-        vkUnmapMemory(hwctx->act_dev, map->frame->mem[i]);
+        vk->UnmapMemory(hwctx->act_dev, map->frame->mem[i]);
 
     av_free(map);
 }
 
commit d05a18cdc7ea245843a1c785e1e3d7fdf980a130
Date:   Sun Nov 7 15:57:35 2021 +0100

    lavu: move hwcontext_vulkan's function loader into separate files
    
    This allows for the loader to be shared with libavcodec and libavfilter.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -3183,16 +3024,16 @@
 static void free_buf(void *opaque, uint8_t *data)
 {
     AVHWDeviceContext *ctx = opaque;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
     VulkanDevicePriv *p = ctx->internal->priv;
-    VulkanFunctions *vk = &p->vkfn;
+    FFVulkanFunctions *vk = &p->vkfn;
     ImageBuffer *vkbuf = (ImageBuffer *)data;
 
     if (vkbuf->buf)
         vk->DestroyBuffer(hwctx->act_dev, vkbuf->buf, hwctx->alloc);
     if (vkbuf->mem)
         vk->FreeMemory(hwctx->act_dev, vkbuf->mem, hwctx->alloc);
 
     av_free(data);
 }
 

commit 4a6581e968d38f009140e055e29be9953279cc7b
Date:   Thu Apr 29 02:44:41 2021 +0200

    hwcontext_vulkan: dynamically load functions
    
    This patch allows for alternative loader implementations.

diff --git a/libavutil/hwcontext_vulkan.c b/libavutil/hwcontext_vulkan.c
--- a/libavutil/hwcontext_vulkan.c
+++ b/libavutil/hwcontext_vulkan.c
@@ -2733,14 +2942,16 @@
 static void free_buf(void *opaque, uint8_t *data)
 {
     AVHWDeviceContext *ctx = opaque;
     AVVulkanDeviceContext *hwctx = ctx->hwctx;
+    VulkanDevicePriv *p = ctx->internal->priv;
+    VulkanFunctions *vk = &p->vkfn;
     ImageBuffer *vkbuf = (ImageBuffer *)data;
 
     if (vkbuf->buf)
-        vkDestroyBuffer(hwctx->act_dev, vkbuf->buf, hwctx->alloc);
+        vk->DestroyBuffer(hwctx->act_dev, vkbuf->buf, hwctx->alloc);
     if (vkbuf->mem)
-        vkFreeMemory(hwctx->act_dev, vkbuf->mem, hwctx->alloc);
+        vk->FreeMemory(hwctx->act_dev, vkbuf->mem, hwctx->alloc);
 
     av_free(data);
 }
 
commit 7c6f9b9d638a9ae6020c8a388d5a6f2a89620663
Date:   Wed Jan 5 11:52:07 2022 +0800

    Revert "avutils/hwcontext: When deriving a hwdevice, search for existing device in both directions"
    
    This reverts commit a4289497755386435783774a4f520eb7fc23cbc9.
    There were objections on ML (see
    https://ffmpeg.org/pipermail/ffmpeg-devel/2021-December/290530.html)
    
    Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>

diff --git a/libavutil/hwcontext.c b/libavutil/hwcontext.c
--- a/libavutil/hwcontext.c
+++ b/libavutil/hwcontext.c
@@ -122,23 +122,20 @@
 static void hwdevice_ctx_free(void *opaque, uint8_t *data)
 {
     AVHWDeviceContext *ctx = (AVHWDeviceContext*)data;
-    int i;
 
     /* uninit might still want access the hw context and the user
      * free() callback might destroy it, so uninit has to be called first */
     if (ctx->internal->hw_type->device_uninit)
         ctx->internal->hw_type->device_uninit(ctx);
 
     if (ctx->free)
         ctx->free(ctx);
 
     av_buffer_unref(&ctx->internal->source_device);
-    for (i = 0; i < AV_HWDEVICE_TYPE_NB; i++)
-        av_buffer_unref(&ctx->internal->derived_devices[i]);
 
     av_freep(&ctx->hwctx);
     av_freep(&ctx->internal->priv);
     av_freep(&ctx->internal);
     av_freep(&ctx);
 }
 

commit a4289497755386435783774a4f520eb7fc23cbc9
Date:   Thu Nov 25 02:41:32 2021 +0000

    avutils/hwcontext: When deriving a hwdevice, search for existing device in both directions
    
    The test /libavutil/tests/hwdevice checks that when deriving a device
    from a source device and then deriving back to the type of the source
    device, the result is matching the original source device, i.e. the
    derivation mechanism doesn't create a new device in this case.
    
    Previously, this test was usually passed, but only due to two different
    kind of flaws:
    
    1. The test covers only a single level of derivation (and back)
    
    It derives device Y from device X and then Y back to the type of X and
    checks whether the result matches X.
    
    What it doesn't check for, are longer chains of derivation like:
    
    CUDA1 > OpenCL2 > CUDA3 and then back to OpenCL4
    
    In that case, the second derivation returns the first device (CUDA3 ==
    CUDA1), but when deriving OpenCL4, hwcontext.c was creating a new
    OpenCL4 context instead of returning OpenCL2, because there was no link
    from CUDA1 to OpenCL2 (only backwards from OpenCL2 to CUDA1)
    
    If the test would check for two levels of derivation, it would have
    failed.
    
    This patch fixes those (yet untested) cases by introducing forward
    references (derived_device) in addition to the existing back references
    (source_device).
    
    2. hwcontext_qsv didn't properly set the source_device
    
    In case of QSV, hwcontext_qsv creates a source context internally
    (vaapi, dxva2 or d3d11va) without calling av_hwdevice_ctx_create_derived
    and without setting source_device.
    
    This way, the hwcontext test ran successful, but what practically
    happened, was that - for example - deriving vaapi from qsv didn't return
    the original underlying vaapi device and a new one was created instead:
    Exactly what the test is intended to detect and prevent. It just
    couldn't do so, because the original device was hidden (= not set as the
    source_device of the QSV device).
    
    This patch properly makes these setting and fixes all derivation
    scenarios.
    
    (at a later stage, /libavutil/tests/hwdevice should be extended to check
    longer derivation chains as well)
    
    Reviewed-by: Lynne <dev@lynne.ee>
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Tested-by: Wenbin Chen <wenbin.chen@intel.com>
    Signed-off-by: softworkz <softworkz@hotmail.com>
    Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>

diff --git a/libavutil/hwcontext.c b/libavutil/hwcontext.c
--- a/libavutil/hwcontext.c
+++ b/libavutil/hwcontext.c
@@ -122,20 +122,23 @@
 static void hwdevice_ctx_free(void *opaque, uint8_t *data)
 {
     AVHWDeviceContext *ctx = (AVHWDeviceContext*)data;
+    int i;
 
     /* uninit might still want access the hw context and the user
      * free() callback might destroy it, so uninit has to be called first */
     if (ctx->internal->hw_type->device_uninit)
         ctx->internal->hw_type->device_uninit(ctx);
 
     if (ctx->free)
         ctx->free(ctx);
 
     av_buffer_unref(&ctx->internal->source_device);
+    for (i = 0; i < AV_HWDEVICE_TYPE_NB; i++)
+        av_buffer_unref(&ctx->internal->derived_devices[i]);
 
     av_freep(&ctx->hwctx);
     av_freep(&ctx->internal->priv);
     av_freep(&ctx->internal);
     av_freep(&ctx);
 }
 
commit 985c0dac674846721ec8ff23344c16ac7d1c9a1e
Date:   Wed Apr 14 01:46:26 2021 +0200

    avutil/pixdesc: Remove deprecated AV_PIX_FMT_FLAG_PSEUDOPAL
    
    Deprecated in d6fc031caf64eed921bbdef86d79d56bfc2633b0.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/imgutils.c b/libavutil/imgutils.c
--- a/libavutil/imgutils.c
+++ b/libavutil/imgutils.c
@@ -216,57 +215,56 @@
 int av_image_alloc(uint8_t *pointers[4], int linesizes[4],
                    int w, int h, enum AVPixelFormat pix_fmt, int align)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
     int i, ret;
     ptrdiff_t linesizes1[4];
     size_t total_size, sizes[4];
     uint8_t *buf;
 
     if (!desc)
         return AVERROR(EINVAL);
 
     if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)
         return ret;
     if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, align>7 ? FFALIGN(w, 8) : w)) < 0)
         return ret;
 
     for (i = 0; i < 4; i++) {
         linesizes[i] = FFALIGN(linesizes[i], align);
         linesizes1[i] = linesizes[i];
     }
 
     if ((ret = av_image_fill_plane_sizes(sizes, pix_fmt, h, linesizes1)) < 0)
         return ret;
     total_size = align;
     for (i = 0; i < 4; i++) {
         if (total_size > SIZE_MAX - sizes[i])
             return AVERROR(EINVAL);
         total_size += sizes[i];
     }
     buf = av_malloc(total_size);
     if (!buf)
         return AVERROR(ENOMEM);
     if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {
         av_free(buf);
         return ret;
     }
-    if (desc->flags & AV_PIX_FMT_FLAG_PAL || (desc->flags & FF_PSEUDOPAL && pointers[1])) {
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL) {
         avpriv_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
         if (align < 4) {
             av_log(NULL, AV_LOG_ERROR, "Formats with a palette require a minimum alignment of 4\n");
             av_free(buf);
             return AVERROR(EINVAL);
         }
     }
 
-    if ((desc->flags & AV_PIX_FMT_FLAG_PAL ||
-         desc->flags & FF_PSEUDOPAL) && pointers[1] &&
+    if (desc->flags & AV_PIX_FMT_FLAG_PAL && pointers[1] &&
         pointers[1] - pointers[0] > linesizes[0] * h) {
         /* zero-initialize the padding before the palette */
         memset(pointers[0] + linesizes[0] * h, 0,
                pointers[1] - pointers[0] - linesizes[0] * h);
     }
 
     return ret;
 }
 
[func] **new** commit be96f4b616878c6245acd626e26cdd65a491b68d
Date:   Sat May 22 18:03:10 2021 -0300

    avutil/mem: make max_alloc_size an atomic type
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -77,57 +78,57 @@
 void *av_malloc(size_t size)
 {
     void *ptr = NULL;
 
-    if (size > max_alloc_size)
+    if (size > atomic_load_explicit(&max_alloc_size, memory_order_relaxed))
         return NULL;
 
 #if HAVE_POSIX_MEMALIGN
     if (size) //OS X on SDK 10.6 has a broken posix_memalign implementation
     if (posix_memalign(&ptr, ALIGN, size))
         ptr = NULL;
 #elif HAVE_ALIGNED_MALLOC
     ptr = _aligned_malloc(size, ALIGN);
 #elif HAVE_MEMALIGN
 #ifndef __DJGPP__
     ptr = memalign(ALIGN, size);
 #else
     ptr = memalign(size, ALIGN);
 #endif
     /* Why 64?
      * Indeed, we should align it:
      *   on  4 for 386
      *   on 16 for 486
      *   on 32 for 586, PPro - K6-III
      *   on 64 for K7 (maybe for P3 too).
      * Because L1 and L2 caches are aligned on those values.
      * But I don't want to code such logic here!
      */
     /* Why 32?
      * For AVX ASM. SSE / NEON needs only 16.
      * Why not larger? Because I did not see a difference in benchmarks ...
      */
     /* benchmarks with P3
      * memalign(64) + 1          3071, 3051, 3032
      * memalign(64) + 2          3051, 3032, 3041
      * memalign(64) + 4          2911, 2896, 2915
      * memalign(64) + 8          2545, 2554, 2550
      * memalign(64) + 16         2543, 2572, 2563
      * memalign(64) + 32         2546, 2545, 2571
      * memalign(64) + 64         2570, 2533, 2558
      *
      * BTW, malloc seems to do 8-byte alignment by default here.
      */
 #else
     ptr = malloc(size);
 #endif
     if(!ptr && !size) {
         size = 1;
         ptr= av_malloc(1);
     }
 #if CONFIG_MEMORY_POISONING
     if (ptr)
         memset(ptr, FF_MEMORY_POISON, size);
 #endif
     return ptr;
 }
 
[func] **new** commit 8d5de914d31ca95ab36e6b66177be435e5cebb3d
Date:   Tue Sep 14 23:32:37 2021 +0200

    avutil/mem: Deprecate av_mallocz_array()
    
    It does the same as av_calloc(), so one of them should be removed.
    Given that av_calloc() has the shorter name, it is retained.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -214,8 +215,9 @@
 void *av_mallocz_array(size_t nmemb, size_t size)
 {
     size_t result;
     if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_mallocz(result);
 }
+#endif
 

[func] **new** commit f9126b62b6f62f5373a5e5cfff64fb2ff2b19cd1
Date:   Tue Aug 10 19:40:02 2021 +0200

    avutil/mem: Reinline av_size_mult() internally
    
    Since 580e168a945b65100ec2c25433f33bfacfe9f7be, av_size_mult() is no
    longer inlined; on systems where interposing is a thing, this also
    inhibits the compiler from inlining said function into the internal
    callers of said function, although inlining such a small function is
    typically beneficial: With GCC 10.3 on Ubuntu x64 and -O3 this decreases
    the size of av_realloc_array from 91B to 23B, from 129B to 81B for
    av_realloc_f and from 77B to 23B for each of av_malloc_array,
    av_mallocz_array and av_calloc.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -196,8 +214,8 @@
 void *av_mallocz_array(size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_mallocz(result);
 }
 
commit f9126b62b6f62f5373a5e5cfff64fb2ff2b19cd1
Date:   Tue Aug 10 19:40:02 2021 +0200

    avutil/mem: Reinline av_size_mult() internally
    
    Since 580e168a945b65100ec2c25433f33bfacfe9f7be, av_size_mult() is no
    longer inlined; on systems where interposing is a thing, this also
    inhibits the compiler from inlining said function into the internal
    callers of said function, although inlining such a small function is
    typically beneficial: With GCC 10.3 on Ubuntu x64 and -O3 this decreases
    the size of av_realloc_array from 91B to 23B, from 129B to 81B for
    av_realloc_f and from 77B to 23B for each of av_malloc_array,
    av_mallocz_array and av_calloc.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -251,8 +269,8 @@
 void *av_calloc(size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_mallocz(result);
 }
 
commit be96f4b616878c6245acd626e26cdd65a491b68d
Date:   Sat May 22 18:03:10 2021 -0300

    avutil/mem: make max_alloc_size an atomic type
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -134,18 +135,18 @@
 void *av_realloc(void *ptr, size_t size)
 {
     void *ret;
-    if (size > max_alloc_size)
+    if (size > atomic_load_explicit(&max_alloc_size, memory_order_relaxed))
         return NULL;
 
 #if HAVE_ALIGNED_MALLOC
     ret = _aligned_realloc(ptr, size + !size, ALIGN);
 #else
     ret = realloc(ptr, size + !size);
 #endif
 #if CONFIG_MEMORY_POISONING
     if (ret && !ptr)
         memset(ret, FF_MEMORY_POISON, size);
 #endif
     return ret;
 }
 

[func] **new** commit 8b83a4a885e3b92bd09354d6cb182fca47f80973
Date:   Mon Apr 26 18:34:31 2021 +0200

    avutil/mem: Also poison new av_realloc-allocated blocks
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -134,12 +134,18 @@
 void *av_realloc(void *ptr, size_t size)
 {
+    void *ret;
     if (size > max_alloc_size)
         return NULL;
 
 #if HAVE_ALIGNED_MALLOC
-    return _aligned_realloc(ptr, size + !size, ALIGN);
+    ret = _aligned_realloc(ptr, size + !size, ALIGN);
 #else
-    return realloc(ptr, size + !size);
+    ret = realloc(ptr, size + !size);
 #endif
+#if CONFIG_MEMORY_POISONING
+    if (ret && !ptr)
+        memset(ret, FF_MEMORY_POISON, size);
+#endif
+    return ret;
 }
 
commit f9126b62b6f62f5373a5e5cfff64fb2ff2b19cd1
Date:   Tue Aug 10 19:40:02 2021 +0200

    avutil/mem: Reinline av_size_mult() internally
    
    Since 580e168a945b65100ec2c25433f33bfacfe9f7be, av_size_mult() is no
    longer inlined; on systems where interposing is a thing, this also
    inhibits the compiler from inlining said function into the internal
    callers of said function, although inlining such a small function is
    typically beneficial: With GCC 10.3 on Ubuntu x64 and -O3 this decreases
    the size of av_realloc_array from 91B to 23B, from 129B to 81B for
    av_realloc_f and from 77B to 23B for each of av_malloc_array,
    av_mallocz_array and av_calloc.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -152,15 +170,15 @@
 void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
 {
     size_t size;
     void *r;
 
-    if (av_size_mult(elsize, nelem, &size)) {
+    if (size_mult(elsize, nelem, &size)) {
         av_free(ptr);
         return NULL;
     }
     r = av_realloc(ptr, size);
     if (!r)
         av_free(ptr);
     return r;
 }
 
commit 8d5de914d31ca95ab36e6b66177be435e5cebb3d
Date:   Tue Sep 14 23:32:37 2021 +0200

    avutil/mem: Deprecate av_mallocz_array()
    
    It does the same as av_calloc(), so one of them should be removed.
    Given that av_calloc() has the shorter name, it is retained.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -206,8 +206,9 @@
 void *av_malloc_array(size_t nmemb, size_t size)
 {
     size_t result;
     if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_malloc(result);
 }
 
+#if FF_API_AV_MALLOCZ_ARRAY

commit f9126b62b6f62f5373a5e5cfff64fb2ff2b19cd1
Date:   Tue Aug 10 19:40:02 2021 +0200

    avutil/mem: Reinline av_size_mult() internally
    
    Since 580e168a945b65100ec2c25433f33bfacfe9f7be, av_size_mult() is no
    longer inlined; on systems where interposing is a thing, this also
    inhibits the compiler from inlining said function into the internal
    callers of said function, although inlining such a small function is
    typically beneficial: With GCC 10.3 on Ubuntu x64 and -O3 this decreases
    the size of av_realloc_array from 91B to 23B, from 129B to 81B for
    av_realloc_f and from 77B to 23B for each of av_malloc_array,
    av_mallocz_array and av_calloc.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -188,8 +206,8 @@
 void *av_malloc_array(size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_malloc(result);
 }
 
commit 8d5de914d31ca95ab36e6b66177be435e5cebb3d
Date:   Tue Sep 14 23:32:37 2021 +0200

    avutil/mem: Deprecate av_mallocz_array()
    
    It does the same as av_calloc(), so one of them should be removed.
    Given that av_calloc() has the shorter name, it is retained.
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -214,8 +215,9 @@
 void *av_mallocz_array(size_t nmemb, size_t size)
 {
     size_t result;
     if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_mallocz(result);
 }
+#endif
 

commit f9126b62b6f62f5373a5e5cfff64fb2ff2b19cd1
Date:   Tue Aug 10 19:40:02 2021 +0200

    avutil/mem: Reinline av_size_mult() internally
    
    Since 580e168a945b65100ec2c25433f33bfacfe9f7be, av_size_mult() is no
    longer inlined; on systems where interposing is a thing, this also
    inhibits the compiler from inlining said function into the internal
    callers of said function, although inlining such a small function is
    typically beneficial: With GCC 10.3 on Ubuntu x64 and -O3 this decreases
    the size of av_realloc_array from 91B to 23B, from 129B to 81B for
    av_realloc_f and from 77B to 23B for each of av_malloc_array,
    av_mallocz_array and av_calloc.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -196,8 +214,8 @@
 void *av_mallocz_array(size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_mallocz(result);
 }
 
commit f9126b62b6f62f5373a5e5cfff64fb2ff2b19cd1
Date:   Tue Aug 10 19:40:02 2021 +0200

    avutil/mem: Reinline av_size_mult() internally
    
    Since 580e168a945b65100ec2c25433f33bfacfe9f7be, av_size_mult() is no
    longer inlined; on systems where interposing is a thing, this also
    inhibits the compiler from inlining said function into the internal
    callers of said function, although inlining such a small function is
    typically beneficial: With GCC 10.3 on Ubuntu x64 and -O3 this decreases
    the size of av_realloc_array from 91B to 23B, from 129B to 81B for
    av_realloc_f and from 77B to 23B for each of av_malloc_array,
    av_mallocz_array and av_calloc.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -204,8 +222,8 @@
 void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
 {
     size_t result;
-    if (av_size_mult(nmemb, size, &result) < 0)
+    if (size_mult(nmemb, size, &result) < 0)
         return NULL;
     return av_realloc(ptr, result);
 }
 
[safe] **new** commit aca09ed7d4832520cf10fb93faed4249726348c0
Date:   Tue Jul 5 21:31:19 2022 +0200

    avutil/mem: Handle fast allocations near UINT_MAX properly
    
    av_fast_realloc and av_fast_mallocz? store the size of
    the objects they allocate in an unsigned. Yet they overallocate
    and currently they can allocate more than UINT_MAX bytes
    in case a user has requested a size of about UINT_MAX * 16 / 17
    or more if SIZE_MAX > UINT_MAX (and if the user increased
    max_alloc_size via av_max_alloc). In this case it is impossible
    to store the true size of the buffer via the unsigned*;
    future requests are likely to use the (re)allocation codepath
    even if the buffer is actually large enough because of
    the incorrect size.
    
    Fix this by ensuring that the actually allocated size
    always fits into an unsigned. (This entails erroring out
    in case the user requested more than UINT_MAX.)
    
    Reviewed-by: Tomas Härdin <tjoppen@acc.umu.se>
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -533,28 +535,30 @@
 static inline void fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)
 {
     size_t max_size;
     void *val;
 
     memcpy(&val, ptr, sizeof(val));
     if (min_size <= *size) {
         av_assert0(val || !min_size);
         return;
     }
 
     max_size = atomic_load_explicit(&max_alloc_size, memory_order_relaxed);
+    /* *size is an unsigned, so the real maximum is <= UINT_MAX. */
+    max_size = FFMIN(max_size, UINT_MAX);
 
     if (min_size > max_size) {
         av_freep(ptr);
         *size = 0;
         return;
     }
     min_size = FFMIN(max_size, FFMAX(min_size + min_size / 16 + 32, min_size));
     av_freep(ptr);
     val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);
     memcpy(ptr, &val, sizeof(val));
     if (!val)
         min_size = 0;
     *size = min_size;
     return;
 }
 

[safe] **new** commit 918fc9a0ed4e9202341ffb3e7e4b72b4387dfe0a
Date:   Sun May 23 11:29:04 2021 -0300

    avutil/mem: check for max_alloc_size in av_fast_malloc()
    
    This puts av_fast_malloc*() in line with av_fast_realloc().
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -513,19 +513,28 @@
 static inline void fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)
 {
+    size_t max_size;
     void *val;
 
     memcpy(&val, ptr, sizeof(val));
     if (min_size <= *size) {
         av_assert0(val || !min_size);
         return;
     }
-    min_size = FFMAX(min_size + min_size / 16 + 32, min_size);
+
+    max_size = atomic_load_explicit(&max_alloc_size, memory_order_relaxed);
+
+    if (min_size > max_size) {
+        av_freep(ptr);
+        *size = 0;
+        return;
+    }
+    min_size = FFMIN(max_size, FFMAX(min_size + min_size / 16 + 32, min_size));
     av_freep(ptr);
     val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);
     memcpy(ptr, &val, sizeof(val));
     if (!val)
         min_size = 0;
     *size = min_size;
     return;
 }
 

[func] **new** commit 786be70e28fe739b8e49893fa13ae4652a68d1ea
Date:   Sun May 23 11:24:17 2021 -0300

    avutil/mem: make ff_fast_malloc() internal to mem.c
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -513,0 +513,19 @@
+static inline void fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)
+{
+    void *val;
+
+    memcpy(&val, ptr, sizeof(val));
+    if (min_size <= *size) {
+        av_assert0(val || !min_size);
+        return;
+    }
+    min_size = FFMAX(min_size + min_size / 16 + 32, min_size);
+    av_freep(ptr);
+    val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);
+    memcpy(ptr, &val, sizeof(val));
+    if (!val)
+        min_size = 0;
+    *size = min_size;
+    return;
+}
+
commit 786be70e28fe739b8e49893fa13ae4652a68d1ea
Date:   Sun May 23 11:24:17 2021 -0300

    avutil/mem: make ff_fast_malloc() internal to mem.c
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -513,5 +532,5 @@
 void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
 {
-    ff_fast_malloc(ptr, size, min_size, 0);
+    fast_malloc(ptr, size, min_size, 0);
 }
 
[func] **new** commit 580e168a945b65100ec2c25433f33bfacfe9f7be
Date:   Mon May 31 11:25:26 2021 +0200

    lavu/mem: un-inline av_size_mult()
    
    There seems to be no compelling reason for it to be inline.

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -546,4 +546,5 @@
 void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
 {
     fast_malloc(ptr, size, min_size, 1);
 }
+

commit 786be70e28fe739b8e49893fa13ae4652a68d1ea
Date:   Sun May 23 11:24:17 2021 -0300

    avutil/mem: make ff_fast_malloc() internal to mem.c
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -518,4 +537,4 @@
 void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
 {
-    ff_fast_malloc(ptr, size, min_size, 1);
+    fast_malloc(ptr, size, min_size, 1);
 }
commit aca09ed7d4832520cf10fb93faed4249726348c0
Date:   Tue Jul 5 21:31:19 2022 +0200

    avutil/mem: Handle fast allocations near UINT_MAX properly
    
    av_fast_realloc and av_fast_mallocz? store the size of
    the objects they allocate in an unsigned. Yet they overallocate
    and currently they can allocate more than UINT_MAX bytes
    in case a user has requested a size of about UINT_MAX * 16 / 17
    or more if SIZE_MAX > UINT_MAX (and if the user increased
    max_alloc_size via av_max_alloc). In this case it is impossible
    to store the true size of the buffer via the unsigned*;
    future requests are likely to use the (re)allocation codepath
    even if the buffer is actually large enough because of
    the incorrect size.
    
    Fix this by ensuring that the actually allocated size
    always fits into an unsigned. (This entails erroring out
    in case the user requested more than UINT_MAX.)
    
    Reviewed-by: Tomas Härdin <tjoppen@acc.umu.se>
    Reviewed-by: Anton Khirnov <anton@khirnov.net>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -505,28 +505,30 @@
 void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
 {
     size_t max_size;
 
     if (min_size <= *size)
         return ptr;
 
     max_size = atomic_load_explicit(&max_alloc_size, memory_order_relaxed);
+    /* *size is an unsigned, so the real maximum is <= UINT_MAX. */
+    max_size = FFMIN(max_size, UINT_MAX);
 
     if (min_size > max_size) {
         *size = 0;
         return NULL;
     }
 
     min_size = FFMIN(max_size, FFMAX(min_size + min_size / 16 + 32, min_size));
 
     ptr = av_realloc(ptr, min_size);
     /* we could set this to the unmodified min_size but this is safer
      * if the user lost the ptr and uses NULL now
      */
     if (!ptr)
         min_size = 0;
 
     *size = min_size;
 
     return ptr;
 }
 

commit be96f4b616878c6245acd626e26cdd65a491b68d
Date:   Sat May 22 18:03:10 2021 -0300

    avutil/mem: make max_alloc_size an atomic type
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/mem.c b/libavutil/mem.c
--- a/libavutil/mem.c
+++ b/libavutil/mem.c
@@ -484,24 +485,28 @@
 void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
 {
+    size_t max_size;
+
     if (min_size <= *size)
         return ptr;
 
-    if (min_size > max_alloc_size) {
+    max_size = atomic_load_explicit(&max_alloc_size, memory_order_relaxed);
+
+    if (min_size > max_size) {
         *size = 0;
         return NULL;
     }
 
-    min_size = FFMIN(max_alloc_size, FFMAX(min_size + min_size / 16 + 32, min_size));
+    min_size = FFMIN(max_size, FFMAX(min_size + min_size / 16 + 32, min_size));
 
     ptr = av_realloc(ptr, min_size);
     /* we could set this to the unmodified min_size but this is safer
      * if the user lost the ptr and uses NULL now
      */
     if (!ptr)
         min_size = 0;
 
     *size = min_size;
 
     return ptr;
 }
 
[safe] **new** commit 327efa66331ebdc0087c6b656059a8df2f404019
Date:   Fri Mar 18 18:46:40 2022 -0300

    avutil/opt: add missing case for AV_OPT_TYPE_CHLAYOUT in av_opt_free()
    
    Fixes potential memleaks for existing options of this type.
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/opt.c b/libavutil/opt.c
--- a/libavutil/opt.c
+++ b/libavutil/opt.c
@@ -1718,20 +1718,24 @@
 void av_opt_free(void *obj)
 {
     const AVOption *o = NULL;
     while ((o = av_opt_next(obj, o))) {
         switch (o->type) {
         case AV_OPT_TYPE_STRING:
         case AV_OPT_TYPE_BINARY:
             av_freep((uint8_t *)obj + o->offset);
             break;
 
         case AV_OPT_TYPE_DICT:
             av_dict_free((AVDictionary **)(((uint8_t *)obj) + o->offset));
             break;
 
+        case AV_OPT_TYPE_CHLAYOUT:
+            av_channel_layout_uninit((AVChannelLayout *)(((uint8_t *)obj) + o->offset));
+            break;
+
         default:
             break;
         }
     }
 }
 
[safe] **new** commit da5f7799a03aa53d0ffd25572aa9c65ba8279e57
Date:   Mon Sep 5 15:17:56 2022 +0300

    slicethread: Limit the automatic number of threads to 16
    
    This matches a similar cap on the number of automatic threads
    in libavcodec/pthread_slice.c.
    
    On systems with lots of cores, this fixes a couple fate failures
    in 32 bit mode on such machines (where spawning a huge number of
    threads runs out of address space).
    
    Signed-off-by: Martin Storsjö <martin@martin.st>

diff --git a/libavutil/slicethread.c b/libavutil/slicethread.c
--- a/libavutil/slicethread.c
+++ b/libavutil/slicethread.c
@@ -96,70 +98,70 @@
 int avpriv_slicethread_create(AVSliceThread **pctx, void *priv,
                               void (*worker_func)(void *priv, int jobnr, int threadnr, int nb_jobs, int nb_threads),
                               void (*main_func)(void *priv),
                               int nb_threads)
 {
     AVSliceThread *ctx;
     int nb_workers, i;
 
     av_assert0(nb_threads >= 0);
     if (!nb_threads) {
         int nb_cpus = av_cpu_count();
         if (nb_cpus > 1)
-            nb_threads = nb_cpus + 1;
+            nb_threads = FFMIN(nb_cpus + 1, MAX_AUTO_THREADS);
         else
             nb_threads = 1;
     }
 
     nb_workers = nb_threads;
     if (!main_func)
         nb_workers--;
 
     *pctx = ctx = av_mallocz(sizeof(*ctx));
     if (!ctx)
         return AVERROR(ENOMEM);
 
     if (nb_workers && !(ctx->workers = av_calloc(nb_workers, sizeof(*ctx->workers)))) {
         av_freep(pctx);
         return AVERROR(ENOMEM);
     }
 
     ctx->priv        = priv;
     ctx->worker_func = worker_func;
     ctx->main_func   = main_func;
     ctx->nb_threads  = nb_threads;
     ctx->nb_active_threads = 0;
     ctx->nb_jobs     = 0;
     ctx->finished    = 0;
 
     atomic_init(&ctx->first_job, 0);
     atomic_init(&ctx->current_job, 0);
     pthread_mutex_init(&ctx->done_mutex, NULL);
     pthread_cond_init(&ctx->done_cond, NULL);
     ctx->done        = 0;
 
     for (i = 0; i < nb_workers; i++) {
         WorkerContext *w = &ctx->workers[i];
         int ret;
         w->ctx = ctx;
         pthread_mutex_init(&w->mutex, NULL);
         pthread_cond_init(&w->cond, NULL);
         pthread_mutex_lock(&w->mutex);
         w->done = 0;
 
         if (ret = pthread_create(&w->thread, NULL, thread_worker, w)) {
             ctx->nb_threads = main_func ? i : i + 1;
             pthread_mutex_unlock(&w->mutex);
             pthread_cond_destroy(&w->cond);
             pthread_mutex_destroy(&w->mutex);
             avpriv_slicethread_free(pctx);
             return AVERROR(ret);
         }
 
         while (!w->done)
             pthread_cond_wait(&w->cond, &w->mutex);
         pthread_mutex_unlock(&w->mutex);
     }
 
     return nb_threads;
 }
 
[func] **new** commit 90eef1c3de7b575091b9299bc396b6ebb86ca8e8
Date:   Fri Jan 7 11:41:42 2022 +0100

    lavu/threadmessage: switch to new FIFO API

diff --git a/libavutil/threadmessage.c b/libavutil/threadmessage.c
--- a/libavutil/threadmessage.c
+++ b/libavutil/threadmessage.c
@@ -40,43 +40,43 @@
 int av_thread_message_queue_alloc(AVThreadMessageQueue **mq,
                                   unsigned nelem,
                                   unsigned elsize)
 {
 #if HAVE_THREADS
     AVThreadMessageQueue *rmq;
     int ret = 0;
 
     if (nelem > INT_MAX / elsize)
         return AVERROR(EINVAL);
     if (!(rmq = av_mallocz(sizeof(*rmq))))
         return AVERROR(ENOMEM);
     if ((ret = pthread_mutex_init(&rmq->lock, NULL))) {
         av_free(rmq);
         return AVERROR(ret);
     }
     if ((ret = pthread_cond_init(&rmq->cond_recv, NULL))) {
         pthread_mutex_destroy(&rmq->lock);
         av_free(rmq);
         return AVERROR(ret);
     }
     if ((ret = pthread_cond_init(&rmq->cond_send, NULL))) {
         pthread_cond_destroy(&rmq->cond_recv);
         pthread_mutex_destroy(&rmq->lock);
         av_free(rmq);
         return AVERROR(ret);
     }
-    if (!(rmq->fifo = av_fifo_alloc(elsize * nelem))) {
+    if (!(rmq->fifo = av_fifo_alloc2(nelem, elsize, 0))) {
         pthread_cond_destroy(&rmq->cond_send);
         pthread_cond_destroy(&rmq->cond_recv);
         pthread_mutex_destroy(&rmq->lock);
         av_free(rmq);
         return AVERROR(ENOMEM);
     }
     rmq->elsize = elsize;
     *mq = rmq;
     return 0;
 #else
     *mq = NULL;
     return AVERROR(ENOSYS);
 #endif /* HAVE_THREADS */
 }
 
commit 90eef1c3de7b575091b9299bc396b6ebb86ca8e8
Date:   Fri Jan 7 11:41:42 2022 +0100

    lavu/threadmessage: switch to new FIFO API

diff --git a/libavutil/threadmessage.c b/libavutil/threadmessage.c
--- a/libavutil/threadmessage.c
+++ b/libavutil/threadmessage.c
@@ -91,14 +91,14 @@
 void av_thread_message_queue_free(AVThreadMessageQueue **mq)
 {
 #if HAVE_THREADS
     if (*mq) {
         av_thread_message_flush(*mq);
-        av_fifo_freep(&(*mq)->fifo);
+        av_fifo_freep2(&(*mq)->fifo);
         pthread_cond_destroy(&(*mq)->cond_send);
         pthread_cond_destroy(&(*mq)->cond_recv);
         pthread_mutex_destroy(&(*mq)->lock);
         av_freep(mq);
     }
 #endif
 }
 
[func] **new** commit c8778606b3811da6bd58ca6b73d2446bd430013e
Date:   Thu Apr 8 11:16:06 2021 +0200

    lavu/video_enc_params: make sure blocks are properly aligned

diff --git a/libavutil/video_enc_params.c b/libavutil/video_enc_params.c
--- a/libavutil/video_enc_params.c
+++ b/libavutil/video_enc_params.c
@@ -29,26 +29,30 @@
 AVVideoEncParams *av_video_enc_params_alloc(enum AVVideoEncParamsType type,
                                             unsigned int nb_blocks, size_t *out_size)
 {
+    const size_t blocks_offset = offsetof(
+        struct {
+            AVVideoEncParams   p;
+            AVVideoBlockParams b;
+        }, b);
+    size_t size = blocks_offset;
     AVVideoEncParams *par;
-    size_t size;
 
-    size = sizeof(*par);
     if (nb_blocks > (SIZE_MAX - size) / sizeof(AVVideoBlockParams))
         return NULL;
     size += sizeof(AVVideoBlockParams) * nb_blocks;
 
     par = av_mallocz(size);
     if (!par)
         return NULL;
 
     par->type          = type;
     par->nb_blocks     = nb_blocks;
     par->block_size    = sizeof(AVVideoBlockParams);
-    par->blocks_offset = sizeof(*par);
+    par->blocks_offset = blocks_offset;
 
     if (out_size)
         *out_size = size;
 
     return par;
 }
 

[safe] **new** commit 39df279c741928c6adf223890ff19b457f96b9bf
Date:   Sun Feb 14 19:43:56 2021 +0100

    avutil/video_enc_params: Combine overflow checks
    
    This patch also fixes a -Wtautological-constant-out-of-range-compare
    warning from Clang and a -Wtype-limits warning from GCC on systems
    where size_t is 64bits and unsigned 32bits. The reason for this seems
    to be that variable (whose value derives from sizeof() and can therefore
    be known at compile-time) is used instead of using sizeof() directly in
    the comparison.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>

diff --git a/libavutil/video_enc_params.c b/libavutil/video_enc_params.c
--- a/libavutil/video_enc_params.c
+++ b/libavutil/video_enc_params.c
@@ -29,27 +29,26 @@
 AVVideoEncParams *av_video_enc_params_alloc(enum AVVideoEncParamsType type,
                                             unsigned int nb_blocks, size_t *out_size)
 {
     AVVideoEncParams *par;
     size_t size;
 
     size = sizeof(*par);
-    if (nb_blocks > SIZE_MAX / sizeof(AVVideoBlockParams) ||
-        nb_blocks * sizeof(AVVideoBlockParams) > SIZE_MAX - size)
+    if (nb_blocks > (SIZE_MAX - size) / sizeof(AVVideoBlockParams))
         return NULL;
     size += sizeof(AVVideoBlockParams) * nb_blocks;
 
     par = av_mallocz(size);
     if (!par)
         return NULL;
 
     par->type          = type;
     par->nb_blocks     = nb_blocks;
     par->block_size    = sizeof(AVVideoBlockParams);
     par->blocks_offset = sizeof(*par);
 
     if (out_size)
         *out_size = size;
 
     return par;
 }
 
commit ef6a9e5e311f09fa8032974fa4d0c1e166a959bb
Date:   Wed Apr 14 14:59:32 2021 +0200

    avutil/buffer: Switch AVBuffer API to size_t
    
    Announced in 14040a1d913794d9a3fd6406a6d8c2f0e37e0062.
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libavutil/video_enc_params.c b/libavutil/video_enc_params.c
--- a/libavutil/video_enc_params.c
+++ b/libavutil/video_enc_params.c
@@ -56,27 +56,23 @@
 av_video_enc_params_create_side_data(AVFrame *frame, enum AVVideoEncParamsType type,
                                      unsigned int nb_blocks)
 {
     AVBufferRef      *buf;
     AVVideoEncParams *par;
     size_t size;
 
     par = av_video_enc_params_alloc(type, nb_blocks, &size);
     if (!par)
         return NULL;
-    if (size > INT_MAX) {
-        av_free(par);
-        return NULL;
-    }
     buf = av_buffer_create((uint8_t *)par, size, NULL, NULL, 0);
     if (!buf) {
         av_freep(&par);
         return NULL;
     }
 
     if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_VIDEO_ENC_PARAMS, buf)) {
         av_buffer_unref(&buf);
         return NULL;
     }
 
     return par;
 }

[safe] **new** commit c9d9c6074689ec11b0ba12dd8c895d3564b06ed7
Date:   Sun Feb 14 19:47:45 2021 +0100

    avutil/video_enc_params: Check for truncation before creating buffer
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>

diff --git a/libavutil/video_enc_params.c b/libavutil/video_enc_params.c
--- a/libavutil/video_enc_params.c
+++ b/libavutil/video_enc_params.c
@@ -56,23 +56,27 @@
 av_video_enc_params_create_side_data(AVFrame *frame, enum AVVideoEncParamsType type,
                                      unsigned int nb_blocks)
 {
     AVBufferRef      *buf;
     AVVideoEncParams *par;
     size_t size;
 
     par = av_video_enc_params_alloc(type, nb_blocks, &size);
     if (!par)
         return NULL;
+    if (size > INT_MAX) {
+        av_free(par);
+        return NULL;
+    }
     buf = av_buffer_create((uint8_t *)par, size, NULL, NULL, 0);
     if (!buf) {
         av_freep(&par);
         return NULL;
     }
 
     if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_VIDEO_ENC_PARAMS, buf)) {
         av_buffer_unref(&buf);
         return NULL;
     }
 
     return par;
 }
[func] **new** commit b2aec70bd6bbf4620d363dfdc7d9e54f2f32f9ee
Date:   Fri Nov 19 12:07:10 2021 +0100

    lavu/vulkan: add option to switch between shader compilers and cleanup glslang

diff --git a/libavutil/vulkan_glslang.c b/libavutil/vulkan_glslang.c
--- a/libavutil/vulkan_glslang.c
+++ b/libavutil/vulkan_glslang.c
@@ -250,7 +260,21 @@
-void ff_vk_glslang_uninit(void)
+static FFVkSPIRVCompiler *ff_vk_glslang_init(void)
 {
-    pthread_mutex_lock(&glslang_mutex);
-    if (glslang_refcount && (--glslang_refcount == 0))
-        glslang_finalize_process();
-    pthread_mutex_unlock(&glslang_mutex);
+    FFVkSPIRVCompiler *ret = av_mallocz(sizeof(*ret));
+    if (!ret)
+        return NULL;
+
+    ret->compile_shader = glslc_shader_compile;
+    ret->free_shader    = glslc_shader_free;
+    ret->uninit         = glslc_uninit;
+
+    pthread_mutex_lock(&glslc_mutex);
+    if (!glslc_refcount++) {
+        if (!glslang_initialize_process()) {
+            av_freep(&ret);
+            glslc_refcount--;
+        }
+    }
+    pthread_mutex_unlock(&glslc_mutex);
+
+    return ret;
 }

[func] **new** commit d1133e8c44f457f0698c48f2efcedbd8626b3cee
Date:   Fri Nov 19 07:46:15 2021 +0100

    lavu/vulkan: move common Vulkan code from libavfilter to libavutil

diff --git a/libavutil/vulkan_glslang.c b/libavutil/vulkan_glslang.c
--- /dev/null
+++ b/libavutil/vulkan_glslang.c
@@ -0,0 +250,7 @@
+void ff_vk_glslang_uninit(void)
+{
+    pthread_mutex_lock(&glslang_mutex);
+    if (glslang_refcount && (--glslang_refcount == 0))
+        glslang_finalize_process();
+    pthread_mutex_unlock(&glslang_mutex);
+}
[func] **new** commit da72aca7b02503cdcdacd915dcf11929d29eecd1
Date:   Fri Nov 19 13:45:21 2021 +0100

    lavu/vulkan: add support for using libshaderc as a GLSL compiler
    
    It's got a much better API that's actually maintained, it eliminates
    race conditions, it comes with a pkg-config file by default, and
    unfortunately isn't currently packaged by Debian or other large
    distributions.

diff --git a/libavutil/vulkan_shaderc.c b/libavutil/vulkan_shaderc.c
--- /dev/null
+++ b/libavutil/vulkan_shaderc.c
@@ -0,0 +107,16 @@
+static FFVkSPIRVCompiler *ff_vk_shaderc_init(void)
+{
+    FFVkSPIRVCompiler *ret = av_mallocz(sizeof(*ret));
+    if (!ret)
+        return NULL;
+
+    ret->compile_shader = shdc_shader_compile;
+    ret->free_shader    = shdc_shader_free;
+    ret->uninit         = shdc_uninit;
+
+    ret->priv           = (void *)shaderc_compiler_initialize();
+    if (!ret->priv)
+        av_freep(&ret);
+
+    return ret;
+}
commit da72aca7b02503cdcdacd915dcf11929d29eecd1
Date:   Fri Nov 19 13:45:21 2021 +0100

    lavu/vulkan: add support for using libshaderc as a GLSL compiler
    
    It's got a much better API that's actually maintained, it eliminates
    race conditions, it comes with a pkg-config file by default, and
    unfortunately isn't currently packaged by Debian or other large
    distributions.

diff --git a/libavutil/vulkan_shaderc.c b/libavutil/vulkan_shaderc.c
--- /dev/null
+++ b/libavutil/vulkan_shaderc.c
@@ -0,0 +94,13 @@
+static void shdc_uninit(FFVkSPIRVCompiler **ctx)
+{
+    FFVkSPIRVCompiler *s;
+
+    if (!ctx || !*ctx)
+        return;
+
+    s = *ctx;
+
+    shaderc_compiler_release((shaderc_compiler_t)s->priv);
+    av_freep(ctx);
+}
+
commit d1133e8c44f457f0698c48f2efcedbd8626b3cee
Date:   Fri Nov 19 07:46:15 2021 +0100

    lavu/vulkan: move common Vulkan code from libavfilter to libavutil

diff --git a/libavutil/vulkan.c b/libavutil/vulkan.c
--- /dev/null
+++ b/libavutil/vulkan.c
@@ -0,0 +737,52 @@
+int ff_vk_create_imageview(FFVulkanContext *s, FFVkExecContext *e,
+                           VkImageView *v, VkImage img, VkFormat fmt,
+                           const VkComponentMapping map)
+{
+    int err;
+    AVBufferRef *buf;
+    FFVulkanFunctions *vk = &s->vkfn;
+
+    VkImageViewCreateInfo imgview_spawn = {
+        .sType      = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
+        .pNext      = NULL,
+        .image      = img,
+        .viewType   = VK_IMAGE_VIEW_TYPE_2D,
+        .format     = fmt,
+        .components = map,
+        .subresourceRange = {
+            .aspectMask     = VK_IMAGE_ASPECT_COLOR_BIT,
+            .baseMipLevel   = 0,
+            .levelCount     = 1,
+            .baseArrayLayer = 0,
+            .layerCount     = 1,
+        },
+    };
+
+    ImageViewCtx *iv = av_mallocz(sizeof(*iv));
+
+    VkResult ret = vk->CreateImageView(s->hwctx->act_dev, &imgview_spawn,
+                                       s->hwctx->alloc, &iv->view);
+    if (ret != VK_SUCCESS) {
+        av_log(s, AV_LOG_ERROR, "Failed to create imageview: %s\n",
+               ff_vk_ret2str(ret));
+        return AVERROR_EXTERNAL;
+    }
+
+    buf = av_buffer_create((uint8_t *)iv, sizeof(*iv), destroy_imageview, s, 0);
+    if (!buf) {
+        destroy_imageview(s, (uint8_t *)iv);
+        return AVERROR(ENOMEM);
+    }
+
+    /* Add to queue dependencies */
+    err = ff_vk_add_dep_exec_ctx(s, e, &buf, 1);
+    if (err) {
+        av_buffer_unref(&buf);
+        return err;
+    }
+
+    *v = iv->view;
+
+    return 0;
+}
+
commit d1133e8c44f457f0698c48f2efcedbd8626b3cee
Date:   Fri Nov 19 07:46:15 2021 +0100

    lavu/vulkan: move common Vulkan code from libavfilter to libavutil

diff --git a/libavutil/vulkan.c b/libavutil/vulkan.c
--- /dev/null
+++ b/libavutil/vulkan.c
@@ -0,0 +380,62 @@
+int ff_vk_create_exec_ctx(FFVulkanContext *s, FFVkExecContext **ctx,
+                          FFVkQueueFamilyCtx *qf)
+{
+    VkResult ret;
+    FFVkExecContext *e;
+    FFVulkanFunctions *vk = &s->vkfn;
+
+    VkCommandPoolCreateInfo cqueue_create = {
+        .sType              = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
+        .flags              = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
+        .queueFamilyIndex   = qf->queue_family,
+    };
+    VkCommandBufferAllocateInfo cbuf_create = {
+        .sType              = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
+        .level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
+        .commandBufferCount = qf->nb_queues,
+    };
+
+    e = create_exec_ctx(s);
+    if (!e)
+        return AVERROR(ENOMEM);
+
+    e->qf = qf;
+
+    e->queues = av_mallocz(qf->nb_queues * sizeof(*e->queues));
+    if (!e->queues)
+        return AVERROR(ENOMEM);
+
+    e->bufs = av_mallocz(qf->nb_queues * sizeof(*e->bufs));
+    if (!e->bufs)
+        return AVERROR(ENOMEM);
+
+    /* Create command pool */
+    ret = vk->CreateCommandPool(s->hwctx->act_dev, &cqueue_create,
+                              s->hwctx->alloc, &e->pool);
+    if (ret != VK_SUCCESS) {
+        av_log(s, AV_LOG_ERROR, "Command pool creation failure: %s\n",
+               ff_vk_ret2str(ret));
+        return AVERROR_EXTERNAL;
+    }
+
+    cbuf_create.commandPool = e->pool;
+
+    /* Allocate command buffer */
+    ret = vk->AllocateCommandBuffers(s->hwctx->act_dev, &cbuf_create, e->bufs);
+    if (ret != VK_SUCCESS) {
+        av_log(s, AV_LOG_ERROR, "Command buffer alloc failure: %s\n",
+               ff_vk_ret2str(ret));
+        return AVERROR_EXTERNAL;
+    }
+
+    for (int i = 0; i < qf->nb_queues; i++) {
+        FFVkQueueCtx *q = &e->queues[i];
+        vk->GetDeviceQueue(s->hwctx->act_dev, qf->queue_family,
+                           i % qf->actual_queues, &q->queue);
+    }
+
+    *ctx = e;
+
+    return 0;
+}
+
commit d1133e8c44f457f0698c48f2efcedbd8626b3cee
Date:   Fri Nov 19 07:46:15 2021 +0100

    lavu/vulkan: move common Vulkan code from libavfilter to libavutil

diff --git a/libavutil/vulkan.c b/libavutil/vulkan.c
--- /dev/null
+++ b/libavutil/vulkan.c
@@ -0,0 +727,10 @@
+static void destroy_imageview(void *opaque, uint8_t *data)
+{
+    FFVulkanContext *s = opaque;
+    FFVulkanFunctions *vk = &s->vkfn;
+    ImageViewCtx *iv = (ImageViewCtx *)data;
+
+    vk->DestroyImageView(s->hwctx->act_dev, iv->view, s->hwctx->alloc);
+    av_free(iv);
+}
+
commit d1133e8c44f457f0698c48f2efcedbd8626b3cee
Date:   Fri Nov 19 07:46:15 2021 +0100

    lavu/vulkan: move common Vulkan code from libavfilter to libavutil

diff --git a/libavutil/vulkan.c b/libavutil/vulkan.c
--- /dev/null
+++ b/libavutil/vulkan.c
@@ -0,0 +1314,52 @@
+static void free_pipeline(FFVulkanContext *s, FFVulkanPipeline *pl)
+{
+    FFVulkanFunctions *vk = &s->vkfn;
+
+    for (int i = 0; i < pl->shaders_num; i++) {
+        FFVkSPIRVShader *shd = pl->shaders[i];
+        av_bprint_finalize(&shd->src, NULL);
+        vk->DestroyShaderModule(s->hwctx->act_dev, shd->shader.module,
+                                s->hwctx->alloc);
+        av_free(shd);
+    }
+
+    vk->DestroyPipeline(s->hwctx->act_dev, pl->pipeline, s->hwctx->alloc);
+    vk->DestroyPipelineLayout(s->hwctx->act_dev, pl->pipeline_layout,
+                              s->hwctx->alloc);
+
+    for (int i = 0; i < pl->desc_layout_num; i++) {
+        if (pl->desc_template && pl->desc_template[i])
+            vk->DestroyDescriptorUpdateTemplate(s->hwctx->act_dev, pl->desc_template[i],
+                                                s->hwctx->alloc);
+        if (pl->desc_layout && pl->desc_layout[i])
+            vk->DestroyDescriptorSetLayout(s->hwctx->act_dev, pl->desc_layout[i],
+                                           s->hwctx->alloc);
+    }
+
+    /* Also frees the descriptor sets */
+    if (pl->desc_pool)
+        vk->DestroyDescriptorPool(s->hwctx->act_dev, pl->desc_pool,
+                                  s->hwctx->alloc);
+
+    av_freep(&pl->desc_staging);
+    av_freep(&pl->desc_set);
+    av_freep(&pl->shaders);
+    av_freep(&pl->desc_layout);
+    av_freep(&pl->desc_template);
+    av_freep(&pl->desc_set_initialized);
+    av_freep(&pl->push_consts);
+    pl->push_consts_num = 0;
+
+    /* Only freed in case of failure */
+    av_freep(&pl->pool_size_desc);
+    if (pl->desc_template_info) {
+        for (int i = 0; i < pl->total_descriptor_sets; i += pl->qf->nb_queues) {
+            VkDescriptorUpdateTemplateCreateInfo *dt = &pl->desc_template_info[i];
+            av_free((void *)dt->pDescriptorUpdateEntries);
+        }
+        av_freep(&pl->desc_template_info);
+    }
+
+    av_free(pl);
+}
+
commit d1133e8c44f457f0698c48f2efcedbd8626b3cee
Date:   Fri Nov 19 07:46:15 2021 +0100

    lavu/vulkan: move common Vulkan code from libavfilter to libavutil

diff --git a/libavutil/vulkan.c b/libavutil/vulkan.c
--- /dev/null
+++ b/libavutil/vulkan.c
@@ -0,0 +1270,44 @@
+static void free_exec_ctx(FFVulkanContext *s, FFVkExecContext *e)
+{
+    FFVulkanFunctions *vk = &s->vkfn;
+
+    /* Make sure all queues have finished executing */
+    for (int i = 0; i < e->qf->nb_queues; i++) {
+        FFVkQueueCtx *q = &e->queues[i];
+
+        if (q->fence) {
+            vk->WaitForFences(s->hwctx->act_dev, 1, &q->fence, VK_TRUE, UINT64_MAX);
+            vk->ResetFences(s->hwctx->act_dev, 1, &q->fence);
+        }
+
+        /* Free the fence */
+        if (q->fence)
+            vk->DestroyFence(s->hwctx->act_dev, q->fence, s->hwctx->alloc);
+
+        /* Free buffer dependencies */
+        for (int j = 0; j < q->nb_buf_deps; j++)
+            av_buffer_unref(&q->buf_deps[j]);
+        av_free(q->buf_deps);
+
+        /* Free frame dependencies */
+        for (int j = 0; j < q->nb_frame_deps; j++)
+            av_frame_free(&q->frame_deps[j]);
+        av_free(q->frame_deps);
+    }
+
+    if (e->bufs)
+        vk->FreeCommandBuffers(s->hwctx->act_dev, e->pool, e->qf->nb_queues, e->bufs);
+    if (e->pool)
+        vk->DestroyCommandPool(s->hwctx->act_dev, e->pool, s->hwctx->alloc);
+
+    av_freep(&e->bufs);
+    av_freep(&e->queues);
+    av_freep(&e->sem_sig);
+    av_freep(&e->sem_sig_val);
+    av_freep(&e->sem_sig_val_dst);
+    av_freep(&e->sem_wait);
+    av_freep(&e->sem_wait_dst);
+    av_freep(&e->sem_wait_val);
+    av_free(e);
+}
+
[func] **new** commit 1f0948272a0fcd0e4947f629b600983f3338c02f
Date:   Thu Nov 3 18:45:37 2022 +0100

    postproc/postprocess: Remove obsolete MMX(EXT)/3Dnow functions
    
    postprocess.c currently has C, MMX, MMXEXT, 3DNow as well as
    SSE2 versions of its internal functions. But given that only
    ancient 32-bit x86 CPUs don't support SSE2, the MMX, MMXEXT
    and 3DNow versions are obsolete and are therefore removed by
    this commit. This saves about 56KB here.
    
    (The SSE2 version in particular is not really complete,
    so that it often falls back to MMXEXT (which means that
    there were some identical (apart from the name) MMXEXT
    and SSE2 functions; this duplication no longer exists
    with this commit.)
    
    Reviewed-by: Paul B Mahol <onemda@gmail.com>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libpostproc/postprocess.c b/libpostproc/postprocess.c
--- a/libpostproc/postprocess.c
+++ b/libpostproc/postprocess.c
@@ -860,33 +834,30 @@
 av_cold pp_context *pp_get_context(int width, int height, int cpuCaps){
     PPContext *c= av_mallocz(sizeof(PPContext));
     int stride= FFALIGN(width, 16);  //assumed / will realloc if needed
     int qpStride= (width+15)/16 + 2; //assumed / will realloc if needed
 
     if (!c)
         return NULL;
 
     c->av_class = &av_codec_context_class;
     if(cpuCaps&PP_FORMAT){
         c->hChromaSubSample= cpuCaps&0x3;
         c->vChromaSubSample= (cpuCaps>>4)&0x3;
     }else{
         c->hChromaSubSample= 1;
         c->vChromaSubSample= 1;
     }
     if (cpuCaps & PP_CPU_CAPS_AUTO) {
         c->cpuCaps = av_get_cpu_flags();
     } else {
         c->cpuCaps = 0;
-        if (cpuCaps & PP_CPU_CAPS_MMX)      c->cpuCaps |= AV_CPU_FLAG_MMX;
-        if (cpuCaps & PP_CPU_CAPS_MMX2)     c->cpuCaps |= AV_CPU_FLAG_MMXEXT;
-        if (cpuCaps & PP_CPU_CAPS_3DNOW)    c->cpuCaps |= AV_CPU_FLAG_3DNOW;
         if (cpuCaps & PP_CPU_CAPS_ALTIVEC)  c->cpuCaps |= AV_CPU_FLAG_ALTIVEC;
     }
 
     reallocBuffers(c, width, height, stride, qpStride);
 
     c->frameNum=-1;
 
     return c;
 }
 
commit 40e6575aa3eed64cd32bf28c00ae57edc5acb25a
Date:   Sun Jun 12 05:51:12 2022 +0200

    all: Replace if (ARCH_FOO) checks by #if ARCH_FOO
    
    This is more spec-compliant because it does not rely
    on dead-code elimination by the compiler. Especially
    MSVC has problems with this, as can be seen in
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/296373.html
    or
    https://ffmpeg.org/pipermail/ffmpeg-devel/2022-May/297022.html
    
    This commit does not eliminate every instance where we rely
    on dead code elimination: It only tackles branching to
    the initialization of arch-specific dsp code, not e.g. all
    uses of CONFIG_ and HAVE_ checks. But maybe it is already
    enough to compile FFmpeg with MSVC with whole-programm-optimizations
    enabled (if one does not disable too many components).
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libswresample/audioconvert.c b/libswresample/audioconvert.c
--- a/libswresample/audioconvert.c
+++ b/libswresample/audioconvert.c
@@ -145,41 +145,45 @@
 AudioConvert *swri_audio_convert_alloc(enum AVSampleFormat out_fmt,
                                        enum AVSampleFormat in_fmt,
                                        int channels, const int *ch_map,
                                        int flags)
 {
     AudioConvert *ctx;
     conv_func_type *f = fmt_pair_to_conv_functions[av_get_packed_sample_fmt(out_fmt) + AV_SAMPLE_FMT_NB*av_get_packed_sample_fmt(in_fmt)];
 
     if (!f)
         return NULL;
     ctx = av_mallocz(sizeof(*ctx));
     if (!ctx)
         return NULL;
 
     if(channels == 1){
          in_fmt = av_get_planar_sample_fmt( in_fmt);
         out_fmt = av_get_planar_sample_fmt(out_fmt);
     }
 
     ctx->channels = channels;
     ctx->conv_f   = f;
     ctx->ch_map   = ch_map;
     if (in_fmt == AV_SAMPLE_FMT_U8 || in_fmt == AV_SAMPLE_FMT_U8P)
         memset(ctx->silence, 0x80, sizeof(ctx->silence));
 
     if(out_fmt == in_fmt && !ch_map) {
         switch(av_get_bytes_per_sample(in_fmt)){
             case 1:ctx->simd_f = cpy1; break;
             case 2:ctx->simd_f = cpy2; break;
             case 4:ctx->simd_f = cpy4; break;
             case 8:ctx->simd_f = cpy8; break;
         }
     }
 
-    if(HAVE_X86ASM && HAVE_MMX) swri_audio_convert_init_x86(ctx, out_fmt, in_fmt, channels);
-    if(ARCH_ARM)              swri_audio_convert_init_arm(ctx, out_fmt, in_fmt, channels);
-    if(ARCH_AARCH64)          swri_audio_convert_init_aarch64(ctx, out_fmt, in_fmt, channels);
+#if ARCH_X86 && HAVE_X86ASM && HAVE_MMX
+    swri_audio_convert_init_x86(ctx, out_fmt, in_fmt, channels);
+#elif ARCH_ARM
+    swri_audio_convert_init_arm(ctx, out_fmt, in_fmt, channels);
+#elif ARCH_AARCH64
+    swri_audio_convert_init_aarch64(ctx, out_fmt, in_fmt, channels);
+#endif
 
     return ctx;
 }
 
[func] **new** commit 9546b3a1cbcd94e9107f85c8f1d2175efc6cf083
Date:   Fri Aug 5 15:57:31 2022 -0500

    lswr: take const AVChannelLayout* in swr_alloc_set_opts2()
    
    This is fully backwards-compatible in both ABI and API,
    so it's only a minor bump.

diff --git a/libswresample/swresample.c b/libswresample/swresample.c
--- a/libswresample/swresample.c
+++ b/libswresample/swresample.c
@@ -85,44 +85,44 @@
 int swr_alloc_set_opts2(struct SwrContext **ps,
-                        AVChannelLayout *out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
-                        AVChannelLayout *in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
+                        const AVChannelLayout *out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
+                        const AVChannelLayout *in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
                         int log_offset, void *log_ctx) {
     struct SwrContext *s = *ps;
     int ret;
 
     if (!s) s = swr_alloc();
     if (!s) return AVERROR(ENOMEM);
 
     *ps = s;
 
     s->log_level_offset = log_offset;
     s->log_ctx = log_ctx;
 
     if ((ret = av_opt_set_chlayout(s, "ochl", out_ch_layout, 0)) < 0)
         goto fail;
 
     if ((ret = av_opt_set_int(s, "osf", out_sample_fmt, 0)) < 0)
         goto fail;
 
     if ((ret = av_opt_set_int(s, "osr", out_sample_rate, 0)) < 0)
         goto fail;
 
     if ((ret = av_opt_set_chlayout(s, "ichl", in_ch_layout, 0)) < 0)
         goto fail;
 
     if ((ret = av_opt_set_int(s, "isf", in_sample_fmt, 0)) < 0)
         goto fail;
 
     if ((ret = av_opt_set_int(s, "isr", in_sample_rate, 0)) < 0)
         goto fail;
 
     av_opt_set_int(s, "uch", 0, 0);
 
 #if FF_API_OLD_CHANNEL_LAYOUT
     // Clear old API values so they don't take precedence in swr_init()
     av_opt_set_int(s, "icl", 0, 0);
     av_opt_set_int(s, "ocl", 0, 0);
     av_opt_set_int(s, "ich", 0, 0);
     av_opt_set_int(s, "och", 0, 0);
 #endif
 
     return 0;

[func] **new** commit 8a5896ec1f635ccf0d726f7ba7a06649ebeebf25
Date:   Fri Aug 27 00:37:53 2021 -0300

    swresample: convert to new channel layout API
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libswresample/swresample.c b/libswresample/swresample.c
--- a/libswresample/swresample.c
+++ b/libswresample/swresample.c
@@ -100,0 +105,44 @@
+int swr_alloc_set_opts2(struct SwrContext **ps,
+                        AVChannelLayout *out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
+                        AVChannelLayout *in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
+                        int log_offset, void *log_ctx) {
+    struct SwrContext *s = *ps;
+    int ret;
+
+    if (!s) s = swr_alloc();
+    if (!s) return AVERROR(ENOMEM);
+
+    *ps = s;
+
+    s->log_level_offset = log_offset;
+    s->log_ctx = log_ctx;
+
+    if ((ret = av_opt_set_chlayout(s, "ochl", out_ch_layout, 0)) < 0)
+        goto fail;
+
+    if ((ret = av_opt_set_int(s, "osf", out_sample_fmt, 0)) < 0)
+        goto fail;
+
+    if ((ret = av_opt_set_int(s, "osr", out_sample_rate, 0)) < 0)
+        goto fail;
+
+    if ((ret = av_opt_set_chlayout(s, "ichl", in_ch_layout, 0)) < 0)
+        goto fail;
+
+    if ((ret = av_opt_set_int(s, "isf", in_sample_fmt, 0)) < 0)
+        goto fail;
+
+    if ((ret = av_opt_set_int(s, "isr", in_sample_rate, 0)) < 0)
+        goto fail;
+
+    av_opt_set_int(s, "uch", 0, 0);
+
+#if FF_API_OLD_CHANNEL_LAYOUT
+    // Clear old API values so they don't take precedence in swr_init()
+    av_opt_set_int(s, "icl", 0, 0);
+    av_opt_set_int(s, "ocl", 0, 0);
+    av_opt_set_int(s, "ich", 0, 0);
+    av_opt_set_int(s, "och", 0, 0);
+#endif
+
+    return 0;
commit 8a5896ec1f635ccf0d726f7ba7a06649ebeebf25
Date:   Fri Aug 27 00:37:53 2021 -0300

    swresample: convert to new channel layout API
    
    Signed-off-by: James Almer <jamrial@gmail.com>

diff --git a/libswresample/swresample.c b/libswresample/swresample.c
--- a/libswresample/swresample.c
+++ b/libswresample/swresample.c
@@ -137,11 +193,14 @@
 av_cold void swr_free(SwrContext **ss){
     SwrContext *s= *ss;
     if(s){
         clear_context(s);
+        av_channel_layout_uninit(&s->user_in_chlayout);
+        av_channel_layout_uninit(&s->user_out_chlayout);
+
         if (s->resampler)
             s->resampler->free(&s->resample);
     }
 
     av_freep(ss);
 }
 
[safe] **new** commit f440c422b70ce76f225a34ebf168215a432e8d88
Date:   Sat Sep 18 05:11:57 2021 +0200

    swscale/swscale: Fix races when using unaligned strides/data
    
    In this case the current code tries to warn once; to do so, it uses
    ordinary static ints to store whether the warning has already been
    emitted. This is both a data race (and therefore undefined behaviour)
    as well as a race condition, because it is really possible for multiple
    threads to be the one thread to emit the warning. This is actually
    common since the introduction of the new multithreaded scaling API.
    
    This commit fixes this by using atomic integers for the state;
    furthermore, these are not static anymore, but rather contained
    in the user-facing SwsContext (i.e. the parent SwsContext in case
    of slice-threading).
    
    Given that these atomic variables are not intended for synchronization
    at all (but only for atomicity, i.e. only to output the warning once),
    the atomic operations use memory_order_relaxed.
    
    This affected the nv12, nv21, yuv420, yuv420p10, yuv422, yuv422p10 and
    yuv444 filter-overlay FATE-tests.
    
    Reviewed-by: Michael Niedermayer <michael@niedermayer.cc>
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libswscale/utils.c b/libswscale/utils.c
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -1106,14 +1106,16 @@
 SwsContext *sws_alloc_context(void)
 {
     SwsContext *c = av_mallocz(sizeof(SwsContext));
 
     av_assert0(offsetof(SwsContext, redDither) + DITHER32_INT == offsetof(SwsContext, dither32));
 
     if (c) {
         c->av_class = &ff_sws_context_class;
         av_opt_set_defaults(c);
+        atomic_init(&c->stride_unaligned_warned, 0);
+        atomic_init(&c->data_unaligned_warned,   0);
     }
 
     return c;
 }
 
[func] **new** commit ff39dcb129806477e9a05c30dfdefb96f7fb0a25
Date:   Sat Nov 19 05:58:59 2022 +0100

    swscale/utils: Move functions to avoid forward declarations
    
    Signed-off-by: Andreas Rheinhardt <andreas.rheinhardt@outlook.com>

diff --git a/libswscale/utils.c b/libswscale/utils.c
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -2420,0 +2330,74 @@
+SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur,
+                                float lumaSharpen, float chromaSharpen,
+                                float chromaHShift, float chromaVShift,
+                                int verbose)
+{
+    SwsFilter *filter = av_malloc(sizeof(SwsFilter));
+    if (!filter)
+        return NULL;
+
+    if (lumaGBlur != 0.0) {
+        filter->lumH = sws_getGaussianVec(lumaGBlur, 3.0);
+        filter->lumV = sws_getGaussianVec(lumaGBlur, 3.0);
+    } else {
+        filter->lumH = sws_getIdentityVec();
+        filter->lumV = sws_getIdentityVec();
+    }
+
+    if (chromaGBlur != 0.0) {
+        filter->chrH = sws_getGaussianVec(chromaGBlur, 3.0);
+        filter->chrV = sws_getGaussianVec(chromaGBlur, 3.0);
+    } else {
+        filter->chrH = sws_getIdentityVec();
+        filter->chrV = sws_getIdentityVec();
+    }
+
+    if (!filter->lumH || !filter->lumV || !filter->chrH || !filter->chrV)
+        goto fail;
+
+    if (chromaSharpen != 0.0) {
+        SwsVector *id = sws_getIdentityVec();
+        if (!id)
+            goto fail;
+        sws_scaleVec(filter->chrH, -chromaSharpen);
+        sws_scaleVec(filter->chrV, -chromaSharpen);
+        sws_addVec(filter->chrH, id);
+        sws_addVec(filter->chrV, id);
+        sws_freeVec(id);
+    }
+
+    if (lumaSharpen != 0.0) {
+        SwsVector *id = sws_getIdentityVec();
+        if (!id)
+            goto fail;
+        sws_scaleVec(filter->lumH, -lumaSharpen);
+        sws_scaleVec(filter->lumV, -lumaSharpen);
+        sws_addVec(filter->lumH, id);
+        sws_addVec(filter->lumV, id);
+        sws_freeVec(id);
+    }
+
+    if (chromaHShift != 0.0)
+        sws_shiftVec(filter->chrH, (int)(chromaHShift + 0.5));
+
+    if (chromaVShift != 0.0)
+        sws_shiftVec(filter->chrV, (int)(chromaVShift + 0.5));
+
+    sws_normalizeVec(filter->chrH, 1.0);
+    sws_normalizeVec(filter->chrV, 1.0);
+    sws_normalizeVec(filter->lumH, 1.0);
+    sws_normalizeVec(filter->lumV, 1.0);
+
+    if (isnan_vec(filter->chrH) ||
+        isnan_vec(filter->chrV) ||
+        isnan_vec(filter->lumH) ||
+        isnan_vec(filter->lumV))
+        goto fail;
+
+    if (verbose)
+        sws_printVec2(filter->chrH, NULL, AV_LOG_DEBUG);
+    if (verbose)
+        sws_printVec2(filter->lumH, NULL, AV_LOG_DEBUG);
+
+    return filter;
+
[func] **new** commit d6fdc78e9164c8e6bf7bfc7766932c467b874aa2
Date:   Mon Jul 12 12:31:14 2021 +0200

    sws: implement slice threading

diff --git a/libswscale/utils.c b/libswscale/utils.c
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -2251,68 +2329,75 @@
 void sws_freeContext(SwsContext *c)
 {
     int i;
     if (!c)
         return;
 
+    for (i = 0; i < c->nb_slice_ctx; i++)
+        sws_freeContext(c->slice_ctx[i]);
+    av_freep(&c->slice_ctx);
+    av_freep(&c->slice_err);
+
+    avpriv_slicethread_free(&c->slicethread);
+
     for (i = 0; i < 4; i++)
         av_freep(&c->dither_error[i]);
 
     av_frame_free(&c->frame_src);
     av_frame_free(&c->frame_dst);
 
     av_freep(&c->src_ranges.ranges);
 
     av_freep(&c->vLumFilter);
     av_freep(&c->vChrFilter);
     av_freep(&c->hLumFilter);
     av_freep(&c->hChrFilter);
 #if HAVE_ALTIVEC
     av_freep(&c->vYCoeffsBank);
     av_freep(&c->vCCoeffsBank);
 #endif
 
     av_freep(&c->vLumFilterPos);
     av_freep(&c->vChrFilterPos);
     av_freep(&c->hLumFilterPos);
     av_freep(&c->hChrFilterPos);
 
 #if HAVE_MMX_INLINE
 #if USE_MMAP
     if (c->lumMmxextFilterCode)
         munmap(c->lumMmxextFilterCode, c->lumMmxextFilterCodeSize);
     if (c->chrMmxextFilterCode)
         munmap(c->chrMmxextFilterCode, c->chrMmxextFilterCodeSize);
 #elif HAVE_VIRTUALALLOC
     if (c->lumMmxextFilterCode)
         VirtualFree(c->lumMmxextFilterCode, 0, MEM_RELEASE);
     if (c->chrMmxextFilterCode)
         VirtualFree(c->chrMmxextFilterCode, 0, MEM_RELEASE);
 #else
     av_free(c->lumMmxextFilterCode);
     av_free(c->chrMmxextFilterCode);
 #endif
     c->lumMmxextFilterCode = NULL;
     c->chrMmxextFilterCode = NULL;
 #endif /* HAVE_MMX_INLINE */
 
     av_freep(&c->yuvTable);
     av_freep(&c->formatConvBuffer);
 
     sws_freeContext(c->cascaded_context[0]);
     sws_freeContext(c->cascaded_context[1]);
     sws_freeContext(c->cascaded_context[2]);
     memset(c->cascaded_context, 0, sizeof(c->cascaded_context));
     av_freep(&c->cascaded_tmp[0]);
     av_freep(&c->cascaded1_tmp[0]);
 
     av_freep(&c->gamma);
     av_freep(&c->inv_gamma);
 
     av_freep(&c->rgb0_scratch);
     av_freep(&c->xyz_scratch);
 
     ff_free_filters(c);
 
     av_free(c);
 }
 

[func] **new** commit 42cd64c1826d74ce523eb07c7f0910e8f0ade084
Date:   Thu Jun 24 13:11:34 2021 +0200

    sws: add a new scaling API

diff --git a/libswscale/utils.c b/libswscale/utils.c
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -2244,63 +2251,68 @@
 void sws_freeContext(SwsContext *c)
 {
     int i;
     if (!c)
         return;
 
     for (i = 0; i < 4; i++)
         av_freep(&c->dither_error[i]);
 
+    av_frame_free(&c->frame_src);
+    av_frame_free(&c->frame_dst);
+
+    av_freep(&c->src_ranges.ranges);
+
     av_freep(&c->vLumFilter);
     av_freep(&c->vChrFilter);
     av_freep(&c->hLumFilter);
     av_freep(&c->hChrFilter);
 #if HAVE_ALTIVEC
     av_freep(&c->vYCoeffsBank);
     av_freep(&c->vCCoeffsBank);
 #endif
 
     av_freep(&c->vLumFilterPos);
     av_freep(&c->vChrFilterPos);
     av_freep(&c->hLumFilterPos);
     av_freep(&c->hChrFilterPos);
 
 #if HAVE_MMX_INLINE
 #if USE_MMAP
     if (c->lumMmxextFilterCode)
         munmap(c->lumMmxextFilterCode, c->lumMmxextFilterCodeSize);
     if (c->chrMmxextFilterCode)
         munmap(c->chrMmxextFilterCode, c->chrMmxextFilterCodeSize);
 #elif HAVE_VIRTUALALLOC
     if (c->lumMmxextFilterCode)
         VirtualFree(c->lumMmxextFilterCode, 0, MEM_RELEASE);
     if (c->chrMmxextFilterCode)
         VirtualFree(c->chrMmxextFilterCode, 0, MEM_RELEASE);
 #else
     av_free(c->lumMmxextFilterCode);
     av_free(c->chrMmxextFilterCode);
 #endif
     c->lumMmxextFilterCode = NULL;
     c->chrMmxextFilterCode = NULL;
 #endif /* HAVE_MMX_INLINE */
 
     av_freep(&c->yuvTable);
     av_freep(&c->formatConvBuffer);
 
     sws_freeContext(c->cascaded_context[0]);
     sws_freeContext(c->cascaded_context[1]);
     sws_freeContext(c->cascaded_context[2]);
     memset(c->cascaded_context, 0, sizeof(c->cascaded_context));
     av_freep(&c->cascaded_tmp[0]);
     av_freep(&c->cascaded1_tmp[0]);
 
     av_freep(&c->gamma);
     av_freep(&c->inv_gamma);
 
     av_freep(&c->rgb0_scratch);
     av_freep(&c->xyz_scratch);
 
     ff_free_filters(c);
 
     av_free(c);
 }
 

[perf] **new** commit 0f8e0957d23038f80c8c6193b4f940cfd0b42c9c
Date:   Wed May 19 14:45:34 2021 +0200

    sws: do not reallocate scratch buffers for each slice

diff --git a/libswscale/utils.c b/libswscale/utils.c
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -2243,60 +2243,63 @@
 void sws_freeContext(SwsContext *c)
 {
     int i;
     if (!c)
         return;
 
     for (i = 0; i < 4; i++)
         av_freep(&c->dither_error[i]);
 
     av_freep(&c->vLumFilter);
     av_freep(&c->vChrFilter);
     av_freep(&c->hLumFilter);
     av_freep(&c->hChrFilter);
 #if HAVE_ALTIVEC
     av_freep(&c->vYCoeffsBank);
     av_freep(&c->vCCoeffsBank);
 #endif
 
     av_freep(&c->vLumFilterPos);
     av_freep(&c->vChrFilterPos);
     av_freep(&c->hLumFilterPos);
     av_freep(&c->hChrFilterPos);
 
 #if HAVE_MMX_INLINE
 #if USE_MMAP
     if (c->lumMmxextFilterCode)
         munmap(c->lumMmxextFilterCode, c->lumMmxextFilterCodeSize);
     if (c->chrMmxextFilterCode)
         munmap(c->chrMmxextFilterCode, c->chrMmxextFilterCodeSize);
 #elif HAVE_VIRTUALALLOC
     if (c->lumMmxextFilterCode)
         VirtualFree(c->lumMmxextFilterCode, 0, MEM_RELEASE);
     if (c->chrMmxextFilterCode)
         VirtualFree(c->chrMmxextFilterCode, 0, MEM_RELEASE);
 #else
     av_free(c->lumMmxextFilterCode);
     av_free(c->chrMmxextFilterCode);
 #endif
     c->lumMmxextFilterCode = NULL;
     c->chrMmxextFilterCode = NULL;
 #endif /* HAVE_MMX_INLINE */
 
     av_freep(&c->yuvTable);
     av_freep(&c->formatConvBuffer);
 
     sws_freeContext(c->cascaded_context[0]);
     sws_freeContext(c->cascaded_context[1]);
     sws_freeContext(c->cascaded_context[2]);
     memset(c->cascaded_context, 0, sizeof(c->cascaded_context));
     av_freep(&c->cascaded_tmp[0]);
     av_freep(&c->cascaded1_tmp[0]);
 
     av_freep(&c->gamma);
     av_freep(&c->inv_gamma);
 
+    av_freep(&c->rgb0_scratch);
+    av_freep(&c->xyz_scratch);
+
     ff_free_filters(c);
 
     av_free(c);
 }
 
