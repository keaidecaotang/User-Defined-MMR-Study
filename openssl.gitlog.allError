[ML] commit 20c7febc860ae8e67f52912ee205d2e324e7beed
Author: Matt Caswell <matt@openssl.org>
Date:   Mon Nov 7 15:13:35 2022 +0000

    Fix memory leak when freeing the DTLS record layer
    
    We need to check whether the sent_messages has actually buffered any
    messages in it. If not we won't free the old record layer later when we
    clear out the old buffered messages and a memory leak will result.
    
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19586)

diff --git a/ssl/record/methods/dtls_meth.c b/ssl/record/methods/dtls_meth.c
index 7cd3d51976..858417d965 100644
--- a/ssl/record/methods/dtls_meth.c
+++ b/ssl/record/methods/dtls_meth.c
@@ -684,7 +684,7 @@ dtls_new_record_layer(OSSL_LIB_CTX *libctx, const char *propq, int vers,
 
  err:
     if (ret != OSSL_RECORD_RETURN_SUCCESS) {
-        OPENSSL_free(*retrl);
+        dtls_free(*retrl);
         *retrl = NULL;
     }
     return ret;
diff --git a/ssl/record/rec_layer_s3.c b/ssl/record/rec_layer_s3.c
index 9a4cd85389..dc0b8b3d9e 100644
--- a/ssl/record/rec_layer_s3.c
+++ b/ssl/record/rec_layer_s3.c
@@ -1356,11 +1356,14 @@ int ssl_set_new_record_layer(SSL_CONNECTION *s, int version,
 
     /*
      * Free the old record layer if we have one except in the case of DTLS when
-     * writing. In that case the record layer is still referenced by buffered
-     * messages for potential retransmit. Only when those buffered messages get
-     * freed do we free the record layer object (see dtls1_hm_fragment_free)
+     * writing and there are still buffered sent messages in our queue. In that
+     * case the record layer is still referenced by those buffered messages for
+     * potential retransmit. Only when those buffered messages get freed do we
+     * free the record layer object (see dtls1_hm_fragment_free)
      */
-    if (!SSL_CONNECTION_IS_DTLS(s) || direction == OSSL_RECORD_DIRECTION_READ) {
+    if (!SSL_CONNECTION_IS_DTLS(s)
+            || direction == OSSL_RECORD_DIRECTION_READ
+            || pqueue_peek(s->d1->sent_messages) == NULL) {
         if (*thismethod != NULL && !(*thismethod)->free(*thisrl)) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             return 0;

[ML] commit 608aca8ed2becccfe9c238846834ea2b162fc98b
Author: Milan Broz <gmazyland@gmail.com>
Date:   Sat Oct 29 11:46:34 2022 +0200

    pem: fix a memory leak in PEM_write_bio_PrivateKey_traditional
    
    The copy of PKEY should be released on the error path.
    Easily reproduced with "ED448" context.
    
    Signed-off-by: Milan Broz <gmazyland@gmail.com>
    
    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19536)

diff --git a/crypto/pem/pem_pkey.c b/crypto/pem/pem_pkey.c
index f9346486dd..53367c03db 100644
--- a/crypto/pem/pem_pkey.c
+++ b/crypto/pem/pem_pkey.c
@@ -343,6 +343,7 @@ int PEM_write_bio_PrivateKey_traditional(BIO *bp, const EVP_PKEY *x,
 
     if (x->ameth == NULL || x->ameth->old_priv_encode == NULL) {
         ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+        EVP_PKEY_free(copy);
         return 0;
     }
     BIO_snprintf(pem_str, 80, "%s PRIVATE KEY", x->ameth->pem_str);

[ML] commit cd6e89b6b6ebe204cc442da9b563213bd67eb27f
Author: Matt Caswell <matt@openssl.org>
Date:   Tue Oct 18 12:23:40 2022 +0100

    Move freeing of BIOs as late as possible
    
    Calling SSL_free() will call BIO_free_all() on the rbio and wbio. We
    keep references to the rbio and wbio inside the record layer object.
    References to that object are held directly, as well as in fragment
    retransmission queues. We need to ensure all record layer objects are
    cleaned up before we call BIO_free_all() on rbio/wbio - otherwise the
    "top" BIO may not have its reference count drop to 0 when BIO_free_all()
    is called. This means that the rest of the BIOs in the chain don't get
    freed and a memory leak can occur.
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19424)

diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 5b71d6dc0a..b2a68c9f34 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -1355,11 +1355,6 @@ void ossl_ssl_connection_free(SSL *ssl)
 
     RECORD_LAYER_clear(&s->rlayer);
 
-    BIO_free_all(s->wbio);
-    s->wbio = NULL;
-    BIO_free_all(s->rbio);
-    s->rbio = NULL;
-
     BUF_MEM_free(s->init_buf);
 
     /* add extra stuff */
@@ -1422,6 +1417,17 @@ void ossl_ssl_connection_free(SSL *ssl)
 #ifndef OPENSSL_NO_SRTP
     sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);
 #endif
+
+    /*
+     * We do this late. We want to ensure that any other references we held to
+     * these BIOs are freed first *before* we call BIO_free_all(), because
+     * BIO_free_all() will only free each BIO in the chain if the number of
+     * references to the first BIO have dropped to 0
+     */
+    BIO_free_all(s->wbio);
+    s->wbio = NULL;
+    BIO_free_all(s->rbio);
+    s->rbio = NULL;
 }
 
 void SSL_set0_rbio(SSL *s, BIO *rbio)

[ML] commit c5d061290baa9466182b6d1a5b88aa9e5a4b2386
Author: Tianjia Zhang <tianjia.zhang@linux.alibaba.com>
Date:   Tue Sep 28 23:23:44 2021 +0800

    test: Fix memory leak of asynctest
    
    ASYNC_init_thread() will be called automatically by ASYNC_start_job(),
    so ASYNC_cleanup_thread() must be called at last, otherwise it will
    cause memory leak.
    
    Signed-off-by: Tianjia Zhang <tianjia.zhang@linux.alibaba.com>
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16703)

diff --git a/test/asynctest.c b/test/asynctest.c
index 39600bbfb0..a441d09ad4 100644
--- a/test/asynctest.c
+++ b/test/asynctest.c
@@ -411,6 +411,7 @@ static int test_ASYNC_start_job_ex(void)
     ret = 1;
  err:
     ASYNC_WAIT_CTX_free(waitctx);
+    ASYNC_cleanup_thread();
     OSSL_LIB_CTX_free(libctx);
     return ret;
 }

[ML] commit 6b5c7ef7713d913002f94068a3ef1f41b22eafdb
Author: Juergen Christ <jchrist@linux.ibm.com>
Date:   Fri Aug 19 17:10:29 2022 +0200

    Fix memory leak with TLS1.2 compression
    
    Leak sanitizer reports following leak for ssl-test-new subtest
    4-tlsv1_2-both-compress:
    
    ==335733==ERROR: LeakSanitizer: detected memory leaks
    Direct leak of 17728 byte(s) in 1 object(s) allocated from:
        #0 0x3ff9fbba251 in malloc (/usr/lib64/libasan.so.8+0xba251)
        #1 0x3ff9f71744f in tls_do_uncompress ssl/record/methods/tls_common.c:868
        #2 0x3ff9f7175bd in tls_default_post_process_record ssl/record/methods/tls_common.c:896
        #3 0x3ff9f715ee7 in tls_get_more_records ssl/record/methods/tls_common.c:773
        #4 0x3ff9f712209 in tls_read_record ssl/record/methods/tls_common.c:958
        #5 0x3ff9f6ef73f in ssl3_read_bytes ssl/record/rec_layer_s3.c:1235
        #6 0x3ff9f776165 in tls_get_message_header ssl/statem/statem_lib.c:1198
        #7 0x3ff9f74709b in read_state_machine ssl/statem/statem.c:624
        #8 0x3ff9f74709b in state_machine ssl/statem/statem.c:478
        #9 0x3ff9f662e61 in SSL_do_handshake ssl/ssl_lib.c:4430
        #10 0x100c55d in do_handshake_step test/helpers/handshake.c:775
        #11 0x100c55d in do_connect_step test/helpers/handshake.c:1134
        #12 0x100e85b in do_handshake_internal test/helpers/handshake.c:1544
        #13 0x1011715 in do_handshake test/helpers/handshake.c:1738
        #14 0x101d1a7 in test_handshake test/ssl_test.c:543
        #15 0x1027875 in run_tests test/testutil/driver.c:370
        #16 0x1008393 in main test/testutil/main.c:30
        #17 0x3ff9cc2b871 in __libc_start_call_main (/usr/lib64/libc.so.6+0x2b871)
        #18 0x3ff9cc2b94f in __libc_start_main_alias_2 (/usr/lib64/libc.so.6+0x2b94f)
        #19 0x100864f  (/code/openssl/test/ssl_test+0x100864f)
    Direct leak of 17728 byte(s) in 1 object(s) allocated from:
        #0 0x3ff9fbba251 in malloc (/usr/lib64/libasan.so.8+0xba251)
        #1 0x3ff9f71744f in tls_do_uncompress ssl/record/methods/tls_common.c:868
        #2 0x3ff9f7175bd in tls_default_post_process_record ssl/record/methods/tls_common.c:896
        #3 0x3ff9f715ee7 in tls_get_more_records ssl/record/methods/tls_common.c:773
        #4 0x3ff9f712209 in tls_read_record ssl/record/methods/tls_common.c:958
        #5 0x3ff9f6ef73f in ssl3_read_bytes ssl/record/rec_layer_s3.c:1235
        #6 0x3ff9f776165 in tls_get_message_header ssl/statem/statem_lib.c:1198
        #7 0x3ff9f74709b in read_state_machine ssl/statem/statem.c:624
        #8 0x3ff9f74709b in state_machine ssl/statem/statem.c:478
        #9 0x3ff9f662e61 in SSL_do_handshake ssl/ssl_lib.c:4430
        #10 0x100c55d in do_handshake_step test/helpers/handshake.c:775
        #11 0x100c55d in do_connect_step test/helpers/handshake.c:1134
        #12 0x1010b09 in do_handshake_internal test/helpers/handshake.c:1550
        #13 0x1011715 in do_handshake test/helpers/handshake.c:1738
        #14 0x101d1a7 in test_handshake test/ssl_test.c:543
        #15 0x1027875 in run_tests test/testutil/driver.c:370
        #16 0x1008393 in main test/testutil/main.c:30
        #17 0x3ff9cc2b871 in __libc_start_call_main (/usr/lib64/libc.so.6+0x2b871)
        #18 0x3ff9cc2b94f in __libc_start_main_alias_2 (/usr/lib64/libc.so.6+0x2b94f)
        #19 0x100864f  (/code/openssl/test/ssl_test+0x100864f)
    SUMMARY: AddressSanitizer: 35456 byte(s) leaked in 2 allocation(s).
    
    Fix this by freeing the SSL3_RECORD structure inside the OSSL_RECORD_LAYER.
    
    Signed-off-by: Juergen Christ <jchrist@linux.ibm.com>
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19030)

diff --git a/ssl/record/methods/tls_common.c b/ssl/record/methods/tls_common.c
index 35d7d0dcf8..8e1810d042 100644
--- a/ssl/record/methods/tls_common.c
+++ b/ssl/record/methods/tls_common.c
@@ -1232,6 +1232,8 @@ static void tls_int_free(OSSL_RECORD_LAYER *rl)
     if (rl->version == SSL3_VERSION)
         OPENSSL_cleanse(rl->mac_secret, sizeof(rl->mac_secret));
 
+    SSL3_RECORD_release(rl->rrec, SSL_MAX_PIPELINES);
+
     OPENSSL_free(rl);
 }
 

[DF] commit efc84eacb7a500306c7cb55e4e2d707dfd9d1ac1
Author: Matt Caswell <matt@openssl.org>
Date:   Wed Jul 27 14:52:13 2022 +0100

    Ensure the rrl object is set to NULL after it is freed
    
    Once we free the rrl object we should NULL it to prevent a dangling ref
    to it. Otherwise we could get a double free.
    
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18132)

diff --git a/ssl/record/rec_layer_s3.c b/ssl/record/rec_layer_s3.c
index 807cc43c15..c187141ee9 100644
--- a/ssl/record/rec_layer_s3.c
+++ b/ssl/record/rec_layer_s3.c
@@ -1774,6 +1774,7 @@ int ssl_set_new_record_layer(SSL_CONNECTION *s, int version,
         return 0;
     }
 
+    s->rlayer.rrl = NULL;
     if (meth != NULL)
         s->rlayer.rrlmethod = meth;
 

[ML] commit 70f589ae41928edda18470ba1c3df82af02a92b3
Author: valdaarhun <icegambit91@gmail.com>
Date:   Thu Aug 11 00:48:05 2022 +0530

    Fix memory leak in BN_rand_range()
    
    The patch enables BN_rand_range() to exit immediately
    if BIGNUM *rnd is NULL.
    
    CLA: trivial
    
    Fixes: #18951
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18982)

diff --git a/crypto/bn/bn_rand.c b/crypto/bn/bn_rand.c
index 1b49596990..fd17e7a601 100644
--- a/crypto/bn/bn_rand.c
+++ b/crypto/bn/bn_rand.c
@@ -136,6 +136,11 @@ static int bnrand_range(BNRAND_FLAG flag, BIGNUM *r, const BIGNUM *range,
     int n;
     int count = 100;
 
+    if (r == NULL) {
+        ERR_raise(ERR_LIB_BN, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
     if (range->neg || BN_is_zero(range)) {
         ERR_raise(ERR_LIB_BN, BN_R_INVALID_RANGE);
         return 0;

[ML] commit d272ef5372a16924a5804b74a76491b1bc8529b5
Author: Juergen Christ <jchrist@linux.ibm.com>
Date:   Wed Aug 10 18:02:49 2022 +0200

    Fix asan finding in bio_tfo_test
    
    Running bio_tfo_test under asan yields
    ==172342==ERROR: LeakSanitizer: detected memory leaks
    Direct leak of 380 byte(s) in 5 object(s) allocated from:
        #0 0x3ff89bba251 in malloc (/lib64/libasan.so.8+0xba251)
        #1 0x3ff88cf9fd5 in gaih_inet.constprop.0 (/lib64/libc.so.6+0xf9fd5)
        #2 0x3ff88cfaf6f in getaddrinfo (/lib64/libc.so.6+0xfaf6f)
        #3 0x3ff89ba52a9 in __interceptor_getaddrinfo.part.0 (/lib64/libasan.so.8+0xa52a9)
        #4 0x1004909 in test_fd_tfo test/bio_tfo_test.c:241
    [...]
    
    and fails the test.
    
    Fix this by freeing the return addrinfo on exit.
    
    Signed-off-by: Juergen Christ <jchrist@linux.ibm.com>
    
    Reviewed-by: Todd Short <todd.short@me.com>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18979)

diff --git a/test/bio_tfo_test.c b/test/bio_tfo_test.c
index e91c32bd32..43057e0133 100644
--- a/test/bio_tfo_test.c
+++ b/test/bio_tfo_test.c
@@ -400,6 +400,8 @@ err:
         if (errstr != NULL)
             BIO_printf(bio_err, "last errno: %d=%s\n", sockerr, errstr);
     }
+    if (ai != NULL)
+        freeaddrinfo(ai);
     BIO_ADDR_free(baddr);
     BIO_closesocket(cfd);
     BIO_closesocket(sfd);

[ML] commit 4e9a4997c540e64647d4e1708a1dbda51fb59a68
Author: slontis <shane.lontis@oracle.com>
Date:   Thu Jul 7 15:03:08 2022 +1000

    Fix memory leak in EVP_PKEY_get1_encoded_public_key.
    
    Occurs if a failure happens after the malloc call in the second call to
    EVP_PKEY_get_octet_string_param().
    
    Detected by PR #18355
    
    Some calling code assumes that nothing is allocated in the returned
    pointer if there was a failure. Other calling code always trys freeing.
    The third case is in ecdh_cms_encrypt() where it does not check the
    return value. I am assuming this change is ok since the legacy path in
    EVP_PKEY_get1_encoded_public_key() also does not return the pointer on
    failure.
    
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18739)

diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 8d2eee11f1..aef63128f9 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -1389,6 +1389,7 @@ size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub)
 
     if (pkey != NULL && evp_pkey_is_provided(pkey)) {
         size_t return_size = OSSL_PARAM_UNMODIFIED;
+        unsigned char *buf;
 
         /*
          * We know that this is going to fail, but it will give us a size
@@ -1400,14 +1401,18 @@ size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub)
         if (return_size == OSSL_PARAM_UNMODIFIED)
             return 0;
 
-        *ppub = OPENSSL_malloc(return_size);
-        if (*ppub == NULL)
+        *ppub = NULL;
+        buf = OPENSSL_malloc(return_size);
+        if (buf == NULL)
             return 0;
 
         if (!EVP_PKEY_get_octet_string_param(pkey,
                                              OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
-                                             *ppub, return_size, NULL))
+                                             buf, return_size, NULL)) {
+            OPENSSL_free(buf);
             return 0;
+        }
+        *ppub = buf;
         return return_size;
     }
 

[ML] commit 4798e0680b112993815098ca21d7d68ff31ebc6e
Author: Allan <allanchang96@gmail.com>
Date:   Thu Jul 7 16:04:09 2022 -0700

    Fix memory leak in X509V3_add1_i2d when flag is X509V3_ADD_DELETE
    
    Fixes #18677
    
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18698)

diff --git a/crypto/x509/v3_lib.c b/crypto/x509/v3_lib.c
index 42b6ff1527..5c05b56d9c 100644
--- a/crypto/x509/v3_lib.c
+++ b/crypto/x509/v3_lib.c
@@ -242,8 +242,10 @@ int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
         }
         /* If delete, just delete it */
         if (ext_op == X509V3_ADD_DELETE) {
-            if (!sk_X509_EXTENSION_delete(*x, extidx))
+            extmp = sk_X509_EXTENSION_delete(*x, extidx);
+            if (extmp == NULL)
                 return -1;
+            X509_EXTENSION_free(extmp);
             return 1;
         }
     } else {

[ML] commit 74c929d00dce3a4755164859c600aabb3838a87b
Author: slontis <shane.lontis@oracle.com>
Date:   Tue Jun 28 09:49:17 2022 +1000

    Fix memory leak in cmp_calc_protection()
    
    Triggered by a  memory allocation failure.
    Detected by PR #18355
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/18670)

diff --git a/crypto/cmp/cmp_protect.c b/crypto/cmp/cmp_protect.c
index 93976a7eea..937b713c23 100644
--- a/crypto/cmp/cmp_protect.c
+++ b/crypto/cmp/cmp_protect.c
@@ -91,7 +91,7 @@ ASN1_BIT_STRING *ossl_cmp_calc_protection(const OSSL_CMP_CTX *ctx,
             goto end;
 
         if ((prot = ASN1_BIT_STRING_new()) == NULL)
-            return NULL;
+            goto end;
         /* OpenSSL defaults all bit strings to be encoded as ASN.1 NamedBitList */
         prot->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
         prot->flags |= ASN1_STRING_FLAG_BITS_LEFT;

[ML] commit 28adea95975c3ea53fc590efda35dee13efd4767
Author: slontis <shane.lontis@oracle.com>
Date:   Fri Jun 24 14:01:07 2022 +1000

    Fix memory leak in ossl_rsa_fromdata.
    
    Occurs if a malloc failure happens inside collect_numbers()
    
    Reported via #18365
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18646)

diff --git a/crypto/rsa/rsa_backend.c b/crypto/rsa/rsa_backend.c
index b69c94fc11..bc658d9d30 100644
--- a/crypto/rsa/rsa_backend.c
+++ b/crypto/rsa/rsa_backend.c
@@ -49,9 +49,12 @@ static int collect_numbers(STACK_OF(BIGNUM) *numbers,
         if (p != NULL) {
             BIGNUM *tmp = NULL;
 
-            if (!OSSL_PARAM_get_BN(p, &tmp)
-                || sk_BIGNUM_push(numbers, tmp) == 0)
+            if (!OSSL_PARAM_get_BN(p, &tmp))
                 return 0;
+            if (sk_BIGNUM_push(numbers, tmp) == 0) {
+                BN_clear_free(tmp);
+                return 0;
+            }
         }
     }
 

[ML] commit be50862e72d96e599f1111bbb69f41b5af651c97
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Jun 22 17:05:55 2022 +0200

    Fix a memory leak in EC_GROUP_new_from_ecparameters
    
    This can be reproduced with my error injection patch.
    
    The test vector has been validated on the 1.1.1 branch
    but the issue is of course identical in all branches.
    
    $ ERROR_INJECT=1656112173 ../util/shlib_wrap.sh ./x509-test ./corpora/x509/fe543a8d7e09109a9a08114323eefec802ad79e2
        #0 0x7fb61945eeba in __sanitizer_print_stack_trace ../../../../gcc-trunk/libsanitizer/asan/asan_stack.cpp:87
        #1 0x402f84 in my_malloc fuzz/test-corpus.c:114
        #2 0x7fb619092430 in CRYPTO_zalloc crypto/mem.c:230
        #3 0x7fb618ef7561 in bn_expand_internal crypto/bn/bn_lib.c:280
        #4 0x7fb618ef7561 in bn_expand2 crypto/bn/bn_lib.c:304
        #5 0x7fb618ef819d in BN_bin2bn crypto/bn/bn_lib.c:454
        #6 0x7fb618e7aa13 in asn1_string_to_bn crypto/asn1/a_int.c:503
        #7 0x7fb618e7aa13 in ASN1_INTEGER_to_BN crypto/asn1/a_int.c:559
        #8 0x7fb618fd8e79 in EC_GROUP_new_from_ecparameters crypto/ec/ec_asn1.c:814
        #9 0x7fb618fd98e8 in EC_GROUP_new_from_ecpkparameters crypto/ec/ec_asn1.c:935
        #10 0x7fb618fd9aec in d2i_ECPKParameters crypto/ec/ec_asn1.c:966
        #11 0x7fb618fdace9 in d2i_ECParameters crypto/ec/ec_asn1.c:1184
        #12 0x7fb618fd1fc7 in eckey_type2param crypto/ec/ec_ameth.c:119
        #13 0x7fb618fd57b4 in eckey_pub_decode crypto/ec/ec_ameth.c:165
        #14 0x7fb6191a9c62 in x509_pubkey_decode crypto/x509/x_pubkey.c:124
        #15 0x7fb6191a9e42 in pubkey_cb crypto/x509/x_pubkey.c:46
        #16 0x7fb618eac032 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:432
        #17 0x7fb618eacaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #18 0x7fb618ead288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #19 0x7fb618eab9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #20 0x7fb618eacaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #21 0x7fb618ead288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #22 0x7fb618eab9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #23 0x7fb618eadd1f in ASN1_item_ex_d2i crypto/asn1/tasn_dec.c:124
        #24 0x7fb618eade35 in ASN1_item_d2i crypto/asn1/tasn_dec.c:114
        #25 0x40310c in FuzzerTestOneInput fuzz/x509.c:33
        #26 0x402afb in testfile fuzz/test-corpus.c:182
        #27 0x402656 in main fuzz/test-corpus.c:226
        #28 0x7fb618551f44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
        #29 0x402756  (/home/ed/OPC/openssl/fuzz/x509-test+0x402756)
    
    =================================================================
    ==12221==ERROR: LeakSanitizer: detected memory leaks
    
    Direct leak of 24 byte(s) in 1 object(s) allocated from:
        #0 0x7fb61945309f in __interceptor_malloc ../../../../gcc-trunk/libsanitizer/asan/asan_malloc_linux.cpp:69
        #1 0x7fb619092430 in CRYPTO_zalloc crypto/mem.c:230
        #2 0x7fb618ef5f11 in BN_new crypto/bn/bn_lib.c:246
        #3 0x7fb618ef82f4 in BN_bin2bn crypto/bn/bn_lib.c:440
        #4 0x7fb618fd8933 in EC_GROUP_new_from_ecparameters crypto/ec/ec_asn1.c:618
        #5 0x7fb618fd98e8 in EC_GROUP_new_from_ecpkparameters crypto/ec/ec_asn1.c:935
        #6 0x7fb618fd9aec in d2i_ECPKParameters crypto/ec/ec_asn1.c:966
        #7 0x7fb618fdace9 in d2i_ECParameters crypto/ec/ec_asn1.c:1184
        #8 0x7fb618fd1fc7 in eckey_type2param crypto/ec/ec_ameth.c:119
        #9 0x7fb618fd57b4 in eckey_pub_decode crypto/ec/ec_ameth.c:165
        #10 0x7fb6191a9c62 in x509_pubkey_decode crypto/x509/x_pubkey.c:124
        #11 0x7fb6191a9e42 in pubkey_cb crypto/x509/x_pubkey.c:46
        #12 0x7fb618eac032 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:432
        #13 0x7fb618eacaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #14 0x7fb618ead288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #15 0x7fb618eab9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #16 0x7fb618eacaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #17 0x7fb618ead288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #18 0x7fb618eab9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #19 0x7fb618eadd1f in ASN1_item_ex_d2i crypto/asn1/tasn_dec.c:124
        #20 0x7fb618eade35 in ASN1_item_d2i crypto/asn1/tasn_dec.c:114
        #21 0x40310c in FuzzerTestOneInput fuzz/x509.c:33
        #22 0x402afb in testfile fuzz/test-corpus.c:182
        #23 0x402656 in main fuzz/test-corpus.c:226
        #24 0x7fb618551f44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
    
    Indirect leak of 56 byte(s) in 1 object(s) allocated from:
        #0 0x7fb61945309f in __interceptor_malloc ../../../../gcc-trunk/libsanitizer/asan/asan_malloc_linux.cpp:69
        #1 0x7fb619092430 in CRYPTO_zalloc crypto/mem.c:230
        #2 0x7fb618ef7561 in bn_expand_internal crypto/bn/bn_lib.c:280
        #3 0x7fb618ef7561 in bn_expand2 crypto/bn/bn_lib.c:304
        #4 0x7fb618ef819d in BN_bin2bn crypto/bn/bn_lib.c:454
        #5 0x7fb618fd8933 in EC_GROUP_new_from_ecparameters crypto/ec/ec_asn1.c:618
        #6 0x7fb618fd98e8 in EC_GROUP_new_from_ecpkparameters crypto/ec/ec_asn1.c:935
        #7 0x7fb618fd9aec in d2i_ECPKParameters crypto/ec/ec_asn1.c:966
        #8 0x7fb618fdace9 in d2i_ECParameters crypto/ec/ec_asn1.c:1184
        #9 0x7fb618fd1fc7 in eckey_type2param crypto/ec/ec_ameth.c:119
        #10 0x7fb618fd57b4 in eckey_pub_decode crypto/ec/ec_ameth.c:165
        #11 0x7fb6191a9c62 in x509_pubkey_decode crypto/x509/x_pubkey.c:124
        #12 0x7fb6191a9e42 in pubkey_cb crypto/x509/x_pubkey.c:46
        #13 0x7fb618eac032 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:432
        #14 0x7fb618eacaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #15 0x7fb618ead288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #16 0x7fb618eab9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #17 0x7fb618eacaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #18 0x7fb618ead288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #19 0x7fb618eab9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #20 0x7fb618eadd1f in ASN1_item_ex_d2i crypto/asn1/tasn_dec.c:124
        #21 0x7fb618eade35 in ASN1_item_d2i crypto/asn1/tasn_dec.c:114
        #22 0x40310c in FuzzerTestOneInput fuzz/x509.c:33
        #23 0x402afb in testfile fuzz/test-corpus.c:182
        #24 0x402656 in main fuzz/test-corpus.c:226
        #25 0x7fb618551f44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
    
    SUMMARY: AddressSanitizer: 80 byte(s) leaked in 2 allocation(s).
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Kurt Roeckx <kurt@roeckx.be>
    (Merged from https://github.com/openssl/openssl/pull/18633)

diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index 60550c7539..e1b6f88d44 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -730,7 +730,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     }
 
     /* extract the order */
-    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {
+    if (ASN1_INTEGER_to_BN(params->order, a) == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
         goto err;
     }
@@ -747,7 +747,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     if (params->cofactor == NULL) {
         BN_free(b);
         b = NULL;
-    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {
+    } else if (ASN1_INTEGER_to_BN(params->cofactor, b) == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
         goto err;
     }

[UAF] commit 926c698c6f0a197e0322d4617db0ecd0d40f6e06
Author: Tomas Mraz <tomas@openssl.org>
Date:   Wed Jun 8 17:48:39 2022 +0200

    sm2_dupctx: Avoid potential use after free of the md
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18494)

diff --git a/providers/implementations/asymciphers/sm2_enc.c b/providers/implementations/asymciphers/sm2_enc.c
index 9577d16e83..ddb2cfc14a 100644
--- a/providers/implementations/asymciphers/sm2_enc.c
+++ b/providers/implementations/asymciphers/sm2_enc.c
@@ -138,6 +138,8 @@ static void *sm2_dupctx(void *vpsm2ctx)
         return NULL;
 
     *dstctx = *srcctx;
+    memset(&dstctx->md, 0, sizeof(dstctx->md));
+
     if (dstctx->key != NULL && !EC_KEY_up_ref(dstctx->key)) {
         OPENSSL_free(dstctx);
         return NULL;

[UAF] commit cec1699f1f54ba8b87f055776dc77b48dd37d5fa
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Jun 8 17:36:52 2022 +0200

    Fix a use after free in error handling of hmac_dup
    
    dst->digest needs to be zeroized in case HMAC_CTX_copy
    or ossl_prov_digest_copy return failure.
    
    Fixes #18493
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18502)

diff --git a/providers/implementations/macs/hmac_prov.c b/providers/implementations/macs/hmac_prov.c
index 2d6087b2c6..52ebb08b8f 100644
--- a/providers/implementations/macs/hmac_prov.c
+++ b/providers/implementations/macs/hmac_prov.c
@@ -115,6 +115,7 @@ static void *hmac_dup(void *vsrc)
     *dst = *src;
     dst->ctx = ctx;
     dst->key = NULL;
+    memset(&dst->digest, 0, sizeof(dst->digest));
 
     if (!HMAC_CTX_copy(dst->ctx, src->ctx)
         || !ossl_prov_digest_copy(&dst->digest, &src->digest)) {

[ML] commit fed8dbea27b7e01ee934951b25c6ffd40ad1d5c3
Author: Matt Caswell <matt@openssl.org>
Date:   Thu Jun 2 11:14:32 2022 +0100

    Fix a memory leak in ossl_method_store_add()
    
    If the call to ossl_prop_defn_set() fails then the OSSL_PROPERTY_LIST
    we just created will leak.
    
    Found as a result of:
    https://github.com/openssl/openssl/pull/18355#issuecomment-1139499881
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Todd Short <todd.short@me.com>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18458)

diff --git a/crypto/property/property.c b/crypto/property/property.c
index d209f2c79d..fb48022a8f 100644
--- a/crypto/property/property.c
+++ b/crypto/property/property.c
@@ -304,7 +304,11 @@ int ossl_method_store_add(OSSL_METHOD_STORE *store, const OSSL_PROVIDER *prov,
         impl->properties = ossl_parse_property(store->ctx, properties);
         if (impl->properties == NULL)
             goto err;
-        ossl_prop_defn_set(store->ctx, properties, impl->properties);
+        if (!ossl_prop_defn_set(store->ctx, properties, impl->properties)) {
+            ossl_property_free(impl->properties);
+            impl->properties = NULL;
+            goto err;
+        }
     }
 
     alg = ossl_method_store_retrieve(store, nid);

[ML] commit b4be10dfcd370960cecfda9773e1bfcc568a7390
Author: Matt Caswell <matt@openssl.org>
Date:   Thu May 26 15:34:38 2022 +0100

    Fix a memory leak is ossl_provider_doall_activated
    
    If the callback fails then we don't correctly free providers that were
    already in our stack and that we up-refed earlier.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18413)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index 3e2738fb32..53f04400a0 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -1401,8 +1401,10 @@ int ossl_provider_doall_activated(OSSL_LIB_CTX *ctx,
     for (curr = 0; curr < max; curr++) {
         OSSL_PROVIDER *prov = sk_OSSL_PROVIDER_value(provs, curr);
 
-        if (!cb(prov, cbdata))
+        if (!cb(prov, cbdata)) {
+            curr = -1;
             goto finish;
+        }
     }
     curr = -1;
 

[ML] commit e9007e09792e3735d4973743634ff55d354fc7d8
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Sat May 21 07:50:46 2022 +0200

    Fix a memory leak in crl_set_issuers
    
    This can be reproduced with my error injection patch.
    
    The test vector has been validated on the 1.1.1 branch
    but the issue is of course identical in all branches.
    
    $ ERROR_INJECT=1653520461 ../util/shlib_wrap.sh ./cms-test ./corpora/cms/3eff1d2f1232bd66d5635db2c3f9e7f23830dfd1
    log file: cms-3eff1d2f1232bd66d5635db2c3f9e7f23830dfd1-32454-test.out
    ERROR_INJECT=1653520461
        #0 0x7fd5d8b8eeba in __sanitizer_print_stack_trace ../../../../gcc-trunk/libsanitizer/asan/asan_stack.cpp:87
        #1 0x402fc4 in my_realloc fuzz/test-corpus.c:129
        #2 0x7fd5d8893c49 in sk_reserve crypto/stack/stack.c:198
        #3 0x7fd5d8893c49 in OPENSSL_sk_insert crypto/stack/stack.c:242
        #4 0x7fd5d88d6d7f in sk_GENERAL_NAMES_push include/openssl/x509v3.h:168
        #5 0x7fd5d88d6d7f in crl_set_issuers crypto/x509/x_crl.c:111
        #6 0x7fd5d88d6d7f in crl_cb crypto/x509/x_crl.c:246
        #7 0x7fd5d85dc032 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:432
        #8 0x7fd5d85dcaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #9 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #10 0x7fd5d85db2b5 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:259
        #11 0x7fd5d85dc813 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:611
        #12 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #13 0x7fd5d85db9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #14 0x7fd5d85dca28 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:633
        #15 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #16 0x7fd5d85db9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #17 0x7fd5d85dcaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #18 0x7fd5d85dd7d3 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:494
        #19 0x7fd5d85db9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #20 0x7fd5d85ddd1f in ASN1_item_ex_d2i crypto/asn1/tasn_dec.c:124
        #21 0x7fd5d85dde35 in ASN1_item_d2i crypto/asn1/tasn_dec.c:114
        #22 0x7fd5d85a77e0 in ASN1_item_d2i_bio crypto/asn1/a_d2i_fp.c:69
        #23 0x402845 in FuzzerTestOneInput fuzz/cms.c:43
        #24 0x402bbb in testfile fuzz/test-corpus.c:182
        #25 0x402626 in main fuzz/test-corpus.c:226
        #26 0x7fd5d7c81f44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
        #27 0x402706  (/home/ed/OPC/openssl/fuzz/cms-test+0x402706)
    
    =================================================================
    ==29625==ERROR: LeakSanitizer: detected memory leaks
    
    Direct leak of 32 byte(s) in 1 object(s) allocated from:
        #0 0x7fd5d8b8309f in __interceptor_malloc ../../../../gcc-trunk/libsanitizer/asan/asan_malloc_linux.cpp:69
        #1 0x7fd5d87c2430 in CRYPTO_zalloc crypto/mem.c:230
        #2 0x7fd5d889501f in OPENSSL_sk_new_reserve crypto/stack/stack.c:209
        #3 0x7fd5d85dcbc3 in sk_ASN1_VALUE_new_null include/openssl/asn1t.h:928
        #4 0x7fd5d85dcbc3 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:577
        #5 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #6 0x7fd5d85db104 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:178
        #7 0x7fd5d85ddd1f in ASN1_item_ex_d2i crypto/asn1/tasn_dec.c:124
        #8 0x7fd5d85dde35 in ASN1_item_d2i crypto/asn1/tasn_dec.c:114
        #9 0x7fd5d88f86d9 in X509V3_EXT_d2i crypto/x509v3/v3_lib.c:142
        #10 0x7fd5d88d6d3c in crl_set_issuers crypto/x509/x_crl.c:97
        #11 0x7fd5d88d6d3c in crl_cb crypto/x509/x_crl.c:246
        #12 0x7fd5d85dc032 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:432
        #13 0x7fd5d85dcaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #14 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #15 0x7fd5d85db2b5 in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:259
        #16 0x7fd5d85dc813 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:611
        #17 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #18 0x7fd5d85db9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #19 0x7fd5d85dca28 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:633
        #20 0x7fd5d85dd288 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:518
        #21 0x7fd5d85db9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #22 0x7fd5d85dcaf5 in asn1_template_noexp_d2i crypto/asn1/tasn_dec.c:643
        #23 0x7fd5d85dd7d3 in asn1_template_ex_d2i crypto/asn1/tasn_dec.c:494
        #24 0x7fd5d85db9ce in asn1_item_embed_d2i crypto/asn1/tasn_dec.c:382
        #25 0x7fd5d85ddd1f in ASN1_item_ex_d2i crypto/asn1/tasn_dec.c:124
        #26 0x7fd5d85dde35 in ASN1_item_d2i crypto/asn1/tasn_dec.c:114
        #27 0x7fd5d85a77e0 in ASN1_item_d2i_bio crypto/asn1/a_d2i_fp.c:69
        #28 0x402845 in FuzzerTestOneInput fuzz/cms.c:43
        #29 0x402bbb in testfile fuzz/test-corpus.c:182
        #30 0x402626 in main fuzz/test-corpus.c:226
        #31 0x7fd5d7c81f44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
    
    SUMMARY: AddressSanitizer: 32 byte(s) leaked in 1 allocation(s).
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18391)

diff --git a/crypto/x509/x_crl.c b/crypto/x509/x_crl.c
index 1d8af92f04..4fb3096673 100644
--- a/crypto/x509/x_crl.c
+++ b/crypto/x509/x_crl.c
@@ -103,13 +103,17 @@ static int crl_set_issuers(X509_CRL *crl)
 
         if (gtmp) {
             gens = gtmp;
-            if (!crl->issuers) {
+            if (crl->issuers == NULL) {
                 crl->issuers = sk_GENERAL_NAMES_new_null();
-                if (!crl->issuers)
+                if (crl->issuers == NULL) {
+                    GENERAL_NAMES_free(gtmp);
                     return 0;
+                }
             }
-            if (!sk_GENERAL_NAMES_push(crl->issuers, gtmp))
+            if (!sk_GENERAL_NAMES_push(crl->issuers, gtmp)) {
+                GENERAL_NAMES_free(gtmp);
                 return 0;
+            }
         }
         rev->issuer = gens;
 

[ML] commit b7e28c0bb1cdc07e36c7dc2467083236b931de31
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Sat May 21 15:41:46 2022 +0200

    Fix a memory leak in X509_issuer_and_serial_hash
    
    This is reproducible with my error injection patch.
    
    The test vector has been validated on the 1.1.1 branch
    but the issue is of course identical in all branches.
    
    $ ERROR_INJECT=1653267699 ../util/shlib_wrap.sh ./x509-test ./corpora/x509/5f4034ae85d6587dcad4da3e812e80f3d312894d
    ERROR_INJECT=1653267699
        #0 0x7fd485a6ad4f in __sanitizer_print_stack_trace ../../../../src/libsanitizer/asan/asan_stack.cc:36
        #1 0x55c12d268724 in my_malloc fuzz/test-corpus.c:114
        #2 0x7fd484f51a75 in CRYPTO_zalloc crypto/mem.c:230
        #3 0x7fd484ed778d in EVP_DigestInit_ex crypto/evp/digest.c:139
        #4 0x7fd4850a9849 in X509_issuer_and_serial_hash crypto/x509/x509_cmp.c:44
        #5 0x55c12d268951 in FuzzerTestOneInput fuzz/x509.c:44
        #6 0x55c12d268239 in testfile fuzz/test-corpus.c:182
        #7 0x55c12d267c7f in main fuzz/test-corpus.c:226
        #8 0x7fd483a42082 in __libc_start_main ../csu/libc-start.c:308
        #9 0x55c12d267e5d in _start (/home/ed/OPCToolboxV5/Source/Core/OpenSSL/openssl/fuzz/x509-test+0x3e5d)
    
    =================================================================
    ==1058475==ERROR: LeakSanitizer: detected memory leaks
    
    Direct leak of 268 byte(s) in 1 object(s) allocated from:
        #0 0x7fd485a5dc3e in __interceptor_realloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:163
        #1 0x7fd484d2eb9b in BUF_MEM_grow crypto/buffer/buffer.c:97
        #2 0x7fd4850b2913 in X509_NAME_oneline crypto/x509/x509_obj.c:43
        #3 0x7fd4850a982f in X509_issuer_and_serial_hash crypto/x509/x509_cmp.c:41
        #4 0x55c12d268951 in FuzzerTestOneInput fuzz/x509.c:44
        #5 0x55c12d268239 in testfile fuzz/test-corpus.c:182
        #6 0x55c12d267c7f in main fuzz/test-corpus.c:226
        #7 0x7fd483a42082 in __libc_start_main ../csu/libc-start.c:308
    
    SUMMARY: AddressSanitizer: 268 byte(s) leaked in 1 allocation(s).
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18371)

diff --git a/crypto/x509/x509_cmp.c b/crypto/x509/x509_cmp.c
index f3d58cdfa6..9f5b9403f2 100644
--- a/crypto/x509/x509_cmp.c
+++ b/crypto/x509/x509_cmp.c
@@ -39,7 +39,7 @@ unsigned long X509_issuer_and_serial_hash(X509 *a)
     unsigned long ret = 0;
     EVP_MD_CTX *ctx = EVP_MD_CTX_new();
     unsigned char md[16];
-    char *f;
+    char *f = NULL;
     EVP_MD *digest = NULL;
 
     if (ctx == NULL)
@@ -55,7 +55,6 @@ unsigned long X509_issuer_and_serial_hash(X509 *a)
         goto err;
     if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f)))
         goto err;
-    OPENSSL_free(f);
     if (!EVP_DigestUpdate
         (ctx, (unsigned char *)a->cert_info.serialNumber.data,
          (unsigned long)a->cert_info.serialNumber.length))
@@ -66,6 +65,7 @@ unsigned long X509_issuer_and_serial_hash(X509 *a)
            ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)
         ) & 0xffffffffL;
  err:
+    OPENSSL_free(f);
     EVP_MD_free(digest);
     EVP_MD_CTX_free(ctx);
     return ret;

[ML] commit 22a96c6be41897d11a18455b2ab142422bc57f3f
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Fri May 20 16:15:44 2022 +0200

    Fix a memory leak in ec_key_simple_oct2priv
    
    This is reproducible with my error injection patch.
    
    The test vector has been validated on the 1.1.1 branch
    but the issue is of course identical in all branches.
    
    $ ERROR_INJECT=1652710284 ../util/shlib_wrap.sh ./server-test ./corpora/server/4e48da8aecce6b9b58e8e4dbbf0523e6d2dd56dc
    140587884632000:error:03078041:bignum routines:bn_expand_internal:malloc failure:crypto/bn/bn_lib.c:282:
    140587884632000:error:10103003:elliptic curve routines:ec_key_simple_oct2priv:BN lib:crypto/ec/ec_key.c:662:
    140587884632000:error:100DE08E:elliptic curve routines:old_ec_priv_decode:decode error:crypto/ec/ec_ameth.c:464:
    140587884632000:error:0D0680A8:asn1 encoding routines:asn1_check_tlen:wrong tag:crypto/asn1/tasn_dec.c:1149:
    140587884632000:error:0D07803A:asn1 encoding routines:asn1_item_embed_d2i:nested asn1 error:crypto/asn1/tasn_dec.c:309:Type=X509_ALGOR
    140587884632000:error:0D08303A:asn1 encoding routines:asn1_template_noexp_d2i:nested asn1 error:crypto/asn1/tasn_dec.c:646:Field=pkeyalg, Type=PKCS8_PRIV_KEY_INFO
    140587884632000:error:0907B00D:PEM routines:PEM_read_bio_PrivateKey:ASN1 lib:crypto/pem/pem_pkey.c:88:
    
    =================================================================
    ==19676==ERROR: LeakSanitizer: detected memory leaks
    
    Direct leak of 24 byte(s) in 1 object(s) allocated from:
        #0 0x7fdd2a6bb09f in __interceptor_malloc ../../../../gcc-trunk/libsanitizer/asan/asan_malloc_linux.cpp:69
        #1 0x7fdd2a2fa430 in CRYPTO_zalloc crypto/mem.c:230
        #2 0x7fdd2a15df11 in BN_new crypto/bn/bn_lib.c:246
        #3 0x7fdd2a15df88 in BN_secure_new crypto/bn/bn_lib.c:257
        #4 0x7fdd2a247390 in ec_key_simple_oct2priv crypto/ec/ec_key.c:655
        #5 0x7fdd2a241fc5 in d2i_ECPrivateKey crypto/ec/ec_asn1.c:1030
        #6 0x7fdd2a23dac5 in old_ec_priv_decode crypto/ec/ec_ameth.c:463
        #7 0x7fdd2a109db7 in d2i_PrivateKey crypto/asn1/d2i_pr.c:46
        #8 0x7fdd2a33ab16 in PEM_read_bio_PrivateKey crypto/pem/pem_pkey.c:84
        #9 0x7fdd2a3330b6 in PEM_read_bio_ECPrivateKey crypto/pem/pem_all.c:151
        #10 0x402dba in FuzzerTestOneInput fuzz/server.c:592
        #11 0x40370b in testfile fuzz/test-corpus.c:182
        #12 0x402846 in main fuzz/test-corpus.c:226
        #13 0x7fdd297b9f44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
    
    SUMMARY: AddressSanitizer: 24 byte(s) leaked in 1 allocation(s).
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18366)

diff --git a/crypto/ec/ec_key.c b/crypto/ec/ec_key.c
index eb14f4e409..0ae1c3f367 100644
--- a/crypto/ec/ec_key.c
+++ b/crypto/ec/ec_key.c
@@ -947,8 +947,7 @@ int ossl_ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf,
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
-    eckey->priv_key = BN_bin2bn(buf, len, eckey->priv_key);
-    if (eckey->priv_key == NULL) {
+    if (BN_bin2bn(buf, len, eckey->priv_key) == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         return 0;
     }

[UAF] commit 71b7f34978c7332562300487af497559b67f600a
Author: Pauli <pauli@openssl.org>
Date:   Fri Apr 1 12:20:26 2022 +1100

    Fix Coverity 1503325 use after free
    
    Another reference counting false positive, now negated.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/18014)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index c31503e770..a8f43b9b76 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -202,6 +202,8 @@ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,
             return 0;
         }
         EVP_CIPHER_free(ctx->fetched_cipher);
+        /* Coverity false positive, the reference counting is confusing it */
+        /* coverity[use_after_free] */
         ctx->fetched_cipher = (EVP_CIPHER *)cipher;
     }
     ctx->cipher = cipher;

commit 66cb4fcdc5039fe5b1476ed48a936137a307a58b
Author: Pauli <pauli@openssl.org>
Date:   Fri Apr 1 12:18:44 2022 +1100

    Fix Coverity 1503329 use after free
    
    Another false positive tagged as such
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/18014)

diff --git a/crypto/store/store_lib.c b/crypto/store/store_lib.c
index 696056e370..3d91f159b6 100644
--- a/crypto/store/store_lib.c
+++ b/crypto/store/store_lib.c
@@ -215,6 +215,8 @@ OSSL_STORE_open_ex(const char *uri, OSSL_LIB_CTX *libctx, const char *propq,
          */
         (void)ossl_store_close_it(&tmpctx);
     }
+    /* Coverity false positive, the reference counting is confusing it */
+    /* coverity[pass_freed_arg] */
     OSSL_STORE_LOADER_free(fetched_loader);
     OPENSSL_free(propq_copy);
     OPENSSL_free(ctx);

commit 588080cbf8e254ca2c033224146bc29fddea75a7
Author: Pauli <pauli@openssl.org>
Date:   Fri Apr 1 12:12:07 2022 +1100

    Fix coverity 1503330 use after free
    
    This is a false positive resulting from confusion over up_ref/free.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/18014)

diff --git a/test/acvp_test.c b/test/acvp_test.c
index bbc77d0ae6..90a97e2bf4 100644
--- a/test/acvp_test.c
+++ b/test/acvp_test.c
@@ -1381,6 +1381,8 @@ static int drbg_test(int id)
     res = 1;
 err:
     EVP_RAND_CTX_free(ctx);
+    /* Coverity is confused by the upref/free in EVP_RAND_CTX_new() subdue it */
+    /* coverity[pass_freed_arg] */
     EVP_RAND_CTX_free(parent);
     EVP_RAND_free(rand);
     return res;

[ML] commit 49d874e0b7514cb270e817103ff0e13d4689e1f0
Author: Richard Levitte <levitte@openssl.org>
Date:   Tue Apr 26 11:04:49 2022 +0200

    Fix memleak in test/provider_test.c
    
    This memory leak is triggered when configuring with 'no-legacy'
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
    (Merged from https://github.com/openssl/openssl/pull/18179)

diff --git a/test/provider_test.c b/test/provider_test.c
index 807b8fcf22..11b7ee44a0 100644
--- a/test/provider_test.c
+++ b/test/provider_test.c
@@ -191,12 +191,15 @@ static int test_builtin_provider_with_child(void)
          * In this case we assume we've been built with "no-legacy" and skip
          * this test (there is no OPENSSL_NO_LEGACY)
          */
+        OSSL_LIB_CTX_free(libctx);
         return 1;
     }
 
     if (!TEST_true(OSSL_PROVIDER_add_builtin(libctx, name,
-                                             PROVIDER_INIT_FUNCTION_NAME)))
+                                             PROVIDER_INIT_FUNCTION_NAME))) {
+        OSSL_LIB_CTX_free(libctx);
         return 0;
+    }
 
     /* test_provider will free libctx and unload legacy as part of the test */
     return test_provider(&libctx, name, legacy);

[ML] commit 175355923046921a689b500f7a72455f7095708f
Author: Dmitry Belyavskiy <beldmit@gmail.com>
Date:   Mon Mar 7 17:05:57 2022 +0100

    Avoid potential memory leak
    
    Resolves #17827
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17828)

diff --git a/crypto/x509/v3_utl.c b/crypto/x509/v3_utl.c
index ae53554e58..688c2ee722 100644
--- a/crypto/x509/v3_utl.c
+++ b/crypto/x509/v3_utl.c
@@ -539,8 +539,11 @@ static int append_ia5(STACK_OF(OPENSSL_STRING) **sk,
         return 0;
 
     emtmp = OPENSSL_strndup((char *)email->data, email->length);
-    if (emtmp == NULL)
+    if (emtmp == NULL) {
+        X509_email_free(*sk);
+        *sk = NULL;
         return 0;
+    }
 
     /* Don't add duplicates */
     if (sk_OPENSSL_STRING_find(*sk, emtmp) != -1) {

[ML] commit 9362a1b32b7330e24d3bca230b412557caea095b
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Mon Nov 22 21:50:04 2021 +0100

    Prevent crash with engine using different openssl runtime
    
    This problem happens usually because an application
    links libcrypto and/or libssl statically which
    installs an atexit handler, but later an engine using
    a shared instance of libcrypto is installed.
    The problem is in simple words that both instances
    of libcrypto have an atexit handler installed,
    but both are unable to coordinate with each other,
    which causes a crash, typically a use-after-free
    in the engine's destroy function.
    
    Work around that by preventing the engine's
    libcrypto to install the atexit handler.
    This may result in a small memory leak, but that
    memory is still reachable.
    
    Fixes #15898
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17112)

diff --git a/include/openssl/engine.h b/include/openssl/engine.h
index 25c3cf7c19..70c856a9cd 100644
--- a/include/openssl/engine.h
+++ b/include/openssl/engine.h
@@ -801,6 +801,7 @@ typedef int (*dynamic_bind_engine) (ENGINE *e, const char *id,
             CRYPTO_set_mem_functions(fns->mem_fns.malloc_fn, \
                                      fns->mem_fns.realloc_fn, \
                                      fns->mem_fns.free_fn); \
+            OPENSSL_init_crypto(OPENSSL_INIT_NO_ATEXIT, NULL); \
         skip_cbs: \
             if (!fn(e, id)) return 0; \
             return 1; }

[ML] commit b2f90e93a07d992515782511a5770aa7cf7dc28f
Author: Jiasheng Jiang <jiasheng@iscas.ac.cn>
Date:   Wed Feb 2 19:45:59 2022 +0800

    evp_test: Add the missing check after calling OPENSSL_strdup and sk_OPENSSL_STRING_new_null
    
    Since the memory allocation may fail, the 'mac_name' and 'controls'
    could be NULL.
    And the 'mac_name' will be printed in mac_test_run_mac() without check.
    Also the result of 'params_n +
    sk_OPENSSL_STRING_num(expected->controls)' in
    mac_test_run_mac() will be 'params_n - 1' if allocation fails , which
    does not make sense.
    Therefore, it should be better to check them in order to guarantee the
    complete success of initiation.
    If fails, we also need to free the 'mdat' to avoid the memory leak.
    
    Signed-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17628)

diff --git a/test/evp_test.c b/test/evp_test.c
index 6c4e64c159..a1b6bce8fa 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -1201,9 +1201,18 @@ static int mac_test_init(EVP_TEST *t, const char *alg)
         return 0;
 
     mdat->type = type;
-    mdat->mac_name = OPENSSL_strdup(alg);
+    if (!TEST_ptr(mdat->mac_name = OPENSSL_strdup(alg))) {
+        OPENSSL_free(mdat);
+        return 0;
+    }
+
     mdat->mac = mac;
-    mdat->controls = sk_OPENSSL_STRING_new_null();
+    if (!TEST_ptr(mdat->controls = sk_OPENSSL_STRING_new_null())) {
+        OPENSSL_free(mdat->mac_name);
+        OPENSSL_free(mdat);
+        return 0;
+    }
+
     mdat->output_size = mdat->block_size = -1;
     t->data = mdat;
     return 1;

commit 27f7f527652e403177335eb2e3ba1ff6df13f193
Author: Pauli <pauli@openssl.org>
Date:   Tue Dec 14 11:08:00 2021 +1100

    Add test case to verify that the use after free issue is fixed.
    
    Test case based on reproducer by Guido Vranken.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17263)

diff --git a/test/hmactest.c b/test/hmactest.c
index 63954a1183..8f5bf32f87 100644
--- a/test/hmactest.c
+++ b/test/hmactest.c
@@ -245,6 +245,36 @@ err:
     return ret;
 }
 
+static int test_hmac_copy_uninited(void)
+{
+    const unsigned char key[24] = {0};
+    const unsigned char ct[166] = {0};
+    EVP_PKEY *pkey = NULL;
+    EVP_MD_CTX *ctx = NULL;
+    EVP_MD_CTX *ctx_tmp = NULL;
+    int res = 0;
+
+    if (!TEST_ptr(ctx = EVP_MD_CTX_new())
+            || !TEST_ptr(pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL,
+                                                     key, sizeof(key)))
+            || !TEST_true(EVP_DigestSignInit(ctx, NULL, EVP_sha1(), NULL, pkey))
+            || !TEST_ptr(ctx_tmp = EVP_MD_CTX_new())
+            || !TEST_true(EVP_MD_CTX_copy(ctx_tmp, ctx)))
+        goto err;
+    EVP_MD_CTX_free(ctx);
+    ctx = ctx_tmp;
+    ctx_tmp = NULL;
+
+    if (!TEST_true(EVP_DigestSignUpdate(ctx, ct, sizeof(ct))))
+        goto err;
+    res = 1;
+ err:
+    EVP_MD_CTX_free(ctx);
+    EVP_MD_CTX_free(ctx_tmp);
+    EVP_PKEY_free(pkey);
+    return res;
+}
+
 # ifndef OPENSSL_NO_MD5
 static char *pt(unsigned char *md, unsigned int len)
 {
@@ -266,6 +296,7 @@ int setup_tests(void)
     ADD_TEST(test_hmac_bad);
     ADD_TEST(test_hmac_run);
     ADD_TEST(test_hmac_copy);
+    ADD_TEST(test_hmac_copy_uninited);
     return 1;
 }
 

[UAF] commit ad2fcee1632d3f21a37e8e108d4c0dcf9099686d
Author: Pauli <pauli@openssl.org>
Date:   Mon Dec 13 12:16:18 2021 +1100

    evp: address a use after free state when using HMAC and MD copy.
    
    Fixes #17261
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17263)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index 7ebb2e3235..322cfe7646 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -521,7 +521,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
         if (out->fetched_digest != NULL)
             EVP_MD_free(out->fetched_digest);
         *out = *in;
-        return 1;
+        goto clone_pkey;
     }
 
     if (in->digest->prov == NULL
@@ -552,6 +552,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
         }
     }
 
+ clone_pkey:
     /* copied EVP_MD_CTX should free the copied EVP_PKEY_CTX */
     EVP_MD_CTX_clear_flags(out, EVP_MD_CTX_FLAG_KEEP_PKEY_CTX);
 #ifndef FIPS_MODULE

[ML] commit c50bf14450f3cd242f2211ca7e500191053d8050
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Dec 8 14:14:48 2021 +0100

    Minor code cleanup in o_names_init
    
    This might result in a small memory leak.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17238)

diff --git a/crypto/objects/o_names.c b/crypto/objects/o_names.c
index 05aa8c44aa..92152eeb66 100644
--- a/crypto/objects/o_names.c
+++ b/crypto/objects/o_names.c
@@ -66,8 +66,14 @@ static int obj_name_cmp(const OBJ_NAME *a, const OBJ_NAME *b);
 static CRYPTO_ONCE init = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(o_names_init)
 {
-    names_lh = lh_OBJ_NAME_new(obj_name_hash, obj_name_cmp);
+    names_lh = NULL;
     obj_lock = CRYPTO_THREAD_lock_new();
+    if (obj_lock != NULL)
+        names_lh = lh_OBJ_NAME_new(obj_name_hash, obj_name_cmp);
+    if (names_lh == NULL) {
+        CRYPTO_THREAD_lock_free(obj_lock);
+        obj_lock = NULL;
+    }
     return names_lh != NULL && obj_lock != NULL;
 }
 

[ML] commit 3a069c1b0b4857b838186aeb55378195dfa50823
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Nov 3 09:19:39 2021 +0100

    Fix a memory leak in ssl_create_cipher_list
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16954)

diff --git a/ssl/ssl_ciph.c b/ssl/ssl_ciph.c
index b2a5fb077e..c396f69c3a 100644
--- a/ssl/ssl_ciph.c
+++ b/ssl/ssl_ciph.c
@@ -1643,6 +1643,7 @@ STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(SSL_CTX *ctx,
         }
 
         if (!sk_SSL_CIPHER_push(cipherstack, sslc)) {
+            OPENSSL_free(co_list);
             sk_SSL_CIPHER_free(cipherstack);
             return NULL;
         }

[ML] commit b3c34401c088dc247b8b54ea812e7cdde6caf361
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Nov 3 09:40:59 2021 +0100

    Fix a memory leak in tls_parse_stoc_key_share
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16956)

diff --git a/ssl/statem/extensions_clnt.c b/ssl/statem/extensions_clnt.c
index 78cc226064..b38c9ca684 100644
--- a/ssl/statem/extensions_clnt.c
+++ b/ssl/statem/extensions_clnt.c
@@ -1830,6 +1830,7 @@ int tls_parse_stoc_key_share(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
         skey = EVP_PKEY_new();
         if (skey == NULL || EVP_PKEY_copy_parameters(skey, ckey) <= 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_COPY_PARAMETERS_FAILED);
+            EVP_PKEY_free(skey);
             return 0;
         }
 

[ML] commit 19b30f1c596a8df2a522f9d6dfc1c1782790fc78
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Oct 13 06:37:46 2021 +0200

    Fix another memory leak reported in CIFuzz
    
    Direct leak of 2 byte(s) in 1 object(s) allocated from:
        #0 0x4a067d in __interceptor_malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:129:3
        #1 0x57acd9 in CRYPTO_malloc /src/openssl/crypto/mem.c:184:12
        #2 0x57e106 in CRYPTO_strdup /src/openssl/crypto/o_str.c:24:11
        #3 0x5c139f in def_load_bio /src/openssl/crypto/conf/conf_def.c:427:45
        #4 0x56adf5 in NCONF_load_bio /src/openssl/crypto/conf/conf_lib.c:282:12
        #5 0x4d96cf in FuzzerTestOneInput /src/openssl/fuzz/conf.c:38:5
        #6 0x4d9830 in LLVMFuzzerTestOneInput /src/openssl/fuzz/driver.c:28:12
        #7 0x510c23 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) cxa_noexception.cpp
        #8 0x4fc4d2 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:324:6
        #9 0x501f85 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) cxa_noexception.cpp
        #10 0x52ac82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
        #11 0x7f15336bf0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16813)

diff --git a/crypto/conf/conf_api.c b/crypto/conf/conf_api.c
index e4e305c714..7a4efe6dbb 100644
--- a/crypto/conf/conf_api.c
+++ b/crypto/conf/conf_api.c
@@ -135,7 +135,11 @@ IMPLEMENT_LHASH_DOALL_ARG_CONST(CONF_VALUE, LH_CONF_VALUE);
 
 void _CONF_free_data(CONF *conf)
 {
-    if (conf == NULL || conf->data == NULL)
+    if (conf == NULL)
+        return;
+
+    OPENSSL_free(conf->includedir);
+    if (conf->data == NULL)
         return;
 
     /* evil thing to make sure the 'OPENSSL_free()' works as expected */
@@ -147,7 +151,6 @@ void _CONF_free_data(CONF *conf)
      * with
      */
 
-    OPENSSL_free(conf->includedir);
     lh_CONF_VALUE_doall(conf->data, value_free_stack_doall);
     lh_CONF_VALUE_free(conf->data);
 }
diff --git a/crypto/conf/conf_def.c b/crypto/conf/conf_def.c
index 1832cf535f..c05c3c6b10 100644
--- a/crypto/conf/conf_def.c
+++ b/crypto/conf/conf_def.c
@@ -424,6 +424,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                     if (!parsebool(pval, &conf->flag_abspath))
                         goto err;
                 } else if (strcmp(p, "includedir") == 0) {
+                    OPENSSL_free(conf->includedir);
                     if ((conf->includedir = OPENSSL_strdup(pval)) == NULL) {
                         ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                         goto err;

[ML] commit 74b485848a608383d8d37c04480821ea7b613110
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Tue Oct 12 19:38:14 2021 +0200

    Fix a memory leak reported in CIFuzz
    
    Direct leak of 4 byte(s) in 1 object(s) allocated from:
         #0 0x4a067d in __interceptor_malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:129:3
         #1 0x57af0d in CRYPTO_malloc /src/openssl/crypto/mem.c:184:12
         #2 0x57af0d in CRYPTO_realloc /src/openssl/crypto/mem.c:207:16
         #3 0x569d17 in BUF_MEM_grow /src/openssl/crypto/buffer/buffer.c:97:15
         #4 0x5c3629 in str_copy /src/openssl/crypto/conf/conf_def.c:642:10
         #5 0x5c1cc1 in def_load_bio /src/openssl/crypto/conf/conf_def.c:452:22
         #6 0x56adf5 in NCONF_load_bio /src/openssl/crypto/conf/conf_lib.c:282:12
         #7 0x4d96cf in FuzzerTestOneInput /src/openssl/fuzz/conf.c:38:5
         #8 0x4d9830 in LLVMFuzzerTestOneInput /src/openssl/fuzz/driver.c:28:12
         #9 0x510c23 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) cxa_noexception.cpp
         #10 0x4fc4d2 in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:324:6
         #11 0x501f85 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) cxa_noexception.cpp
         #12 0x52ac82 in main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16813)

diff --git a/crypto/conf/conf_def.c b/crypto/conf/conf_def.c
index 7b67854c8b..1832cf535f 100644
--- a/crypto/conf/conf_def.c
+++ b/crypto/conf/conf_def.c
@@ -474,6 +474,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                 if (conf->flag_abspath
                         && !ossl_is_absolute_path(include_path)) {
                     ERR_raise(ERR_LIB_CONF, CONF_R_RELATIVE_PATH);
+                    OPENSSL_free(include_path);
                     goto err;
                 }
 

[ML] commit 6f6a5e0c7c41b6b3639e51f435cd98bb3ae061bc
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Mon Oct 4 19:45:19 2021 +0200

    Fix a memory leak in the afalg engine
    
    Fixes: #16743
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16744)

diff --git a/engines/e_afalg.c b/engines/e_afalg.c
index d8d3ef610c..2c08cbb28d 100644
--- a/engines/e_afalg.c
+++ b/engines/e_afalg.c
@@ -683,11 +683,8 @@ static int afalg_cipher_cleanup(EVP_CIPHER_CTX *ctx)
     }
 
     actx = (afalg_ctx *) EVP_CIPHER_CTX_get_cipher_data(ctx);
-    if (actx == NULL || actx->init_done != MAGIC_INIT_NUM) {
-        ALG_WARN("%s afalg ctx passed\n",
-                 ctx == NULL ? "NULL" : "Uninitialised");
-        return 0;
-    }
+    if (actx == NULL || actx->init_done != MAGIC_INIT_NUM)
+        return 1;
 
     close(actx->sfd);
     close(actx->bfd);
diff --git a/test/afalgtest.c b/test/afalgtest.c
index f0bdb26271..02947c1ed3 100644
--- a/test/afalgtest.c
+++ b/test/afalgtest.c
@@ -24,26 +24,7 @@
 
 #ifndef OPENSSL_NO_ENGINE
 static ENGINE *e;
-#endif
-
 
-#ifndef OPENSSL_NO_AFALGENG
-# include <linux/version.h>
-# define K_MAJ   4
-# define K_MIN1  1
-# define K_MIN2  0
-# if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2)
-/*
- * If we get here then it looks like there is a mismatch between the linux
- * headers and the actual kernel version, so we have tried to compile with
- * afalg support, but then skipped it in e_afalg.c. As far as this test is
- * concerned we behave as if we had been configured without support
- */
-#  define OPENSSL_NO_AFALGENG
-# endif
-#endif
-
-#ifndef OPENSSL_NO_AFALGENG
 static int test_afalg_aes_cbc(int keysize_idx)
 {
     EVP_CIPHER_CTX *ctx;
@@ -127,9 +108,25 @@ static int test_afalg_aes_cbc(int keysize_idx)
     EVP_CIPHER_CTX_free(ctx);
     return ret;
 }
-#endif
 
-#ifndef OPENSSL_NO_ENGINE
+static int test_pr16743(void)
+{
+    int ret = 0;
+    const EVP_CIPHER * cipher;
+    EVP_CIPHER_CTX *ctx;
+
+    if (!TEST_true(ENGINE_init(e)))
+        return 0;
+    cipher = ENGINE_get_cipher(e, NID_aes_128_cbc);
+    ctx = EVP_CIPHER_CTX_new();
+    if (cipher != NULL && ctx != NULL)
+        ret = EVP_EncryptInit_ex(ctx, cipher, e, NULL, NULL);
+    TEST_true(ret);
+    EVP_CIPHER_CTX_free(ctx);
+    ENGINE_finish(e);
+    return ret;
+}
+
 int global_init(void)
 {
     ENGINE_load_builtin_engines();
@@ -147,9 +144,8 @@ int setup_tests(void)
         /* Probably a platform env issue, not a test failure. */
         TEST_info("Can't load AFALG engine");
     } else {
-# ifndef OPENSSL_NO_AFALGENG
         ADD_ALL_TESTS(test_afalg_aes_cbc, 3);
-# endif
+        ADD_TEST(test_pr16743);
     }
 #endif
 

[DF] commit 85407b77543a2d4330dbb40f6b8520ea0894a716
Author: slontis <shane.lontis@oracle.com>
Date:   Thu Sep 2 16:39:21 2021 +1000

    Fix double free in EVP_PKEY_CTX_dup()
    
    If the internal operations dupctx() fails then a free is done (e.g. EVP_KEYEXCH_free()). If this is not set to NULL the EVP_PKEY_CTX_free() will do a double free.
    This was found by testing kdf_dupctx() in kdf_exch.c (Note this always
    fails since the internal KDF's do not have a dup method).
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16495)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 954166caae..1af1628823 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -500,6 +500,7 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
                 = pctx->op.kex.exchange->dupctx(pctx->op.kex.algctx);
             if (rctx->op.kex.algctx == NULL) {
                 EVP_KEYEXCH_free(rctx->op.kex.exchange);
+                rctx->op.kex.exchange = NULL;
                 goto err;
             }
             return rctx;
@@ -517,6 +518,7 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
                 = pctx->op.sig.signature->dupctx(pctx->op.sig.algctx);
             if (rctx->op.sig.algctx == NULL) {
                 EVP_SIGNATURE_free(rctx->op.sig.signature);
+                rctx->op.sig.signature = NULL;
                 goto err;
             }
             return rctx;
@@ -534,6 +536,7 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
                 = pctx->op.ciph.cipher->dupctx(pctx->op.ciph.algctx);
             if (rctx->op.ciph.algctx == NULL) {
                 EVP_ASYM_CIPHER_free(rctx->op.ciph.cipher);
+                rctx->op.ciph.cipher = NULL;
                 goto err;
             }
             return rctx;
@@ -551,6 +554,7 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
                 = pctx->op.encap.kem->dupctx(pctx->op.encap.algctx);
             if (rctx->op.encap.algctx == NULL) {
                 EVP_KEM_free(rctx->op.encap.kem);
+                rctx->op.encap.kem = NULL;
                 goto err;
             }
             return rctx;
diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c
index 593f7090eb..15c8ce77bb 100644
--- a/test/evp_pkey_provided_test.c
+++ b/test/evp_pkey_provided_test.c
@@ -14,6 +14,7 @@
 #include <openssl/provider.h>
 #include <openssl/param_build.h>
 #include <openssl/core_names.h>
+#include <openssl/sha.h>
 #include "crypto/ecx.h"
 #include "crypto/evp.h"          /* For the internal API */
 #include "crypto/bn_dh.h"        /* _bignum_ffdhe2048_p */
@@ -1622,6 +1623,52 @@ static int test_check_dsa(void)
 #endif /* OPENSSL_NO_DSA */
 
 
+static OSSL_PARAM *do_construct_hkdf_params(char *digest, char *key,
+                                            size_t keylen, char *salt)
+{
+    OSSL_PARAM *params = OPENSSL_malloc(sizeof(OSSL_PARAM) * 5);
+    OSSL_PARAM *p = params;
+
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST, digest, 0);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             salt, strlen(salt));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                             (unsigned char *)key, keylen);
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MODE,
+                                            "EXTRACT_ONLY", 0);
+    *p = OSSL_PARAM_construct_end();
+
+    return params;
+}
+
+/* Test that EVP_PKEY_CTX_dup() fails gracefully for a KDF */
+static int test_evp_pkey_ctx_dup_kdf_fail(void)
+{
+    int ret = 0;
+    size_t len = 0;
+    EVP_PKEY_CTX *pctx = NULL, *dctx = NULL;
+    OSSL_PARAM *params = NULL;
+
+    if (!TEST_ptr(params = do_construct_hkdf_params("sha256", "secret", 6,
+                                                    "salt")))
+        goto err;
+    if (!TEST_ptr(pctx = EVP_PKEY_CTX_new_from_name(NULL, "HKDF", NULL)))
+        goto err;
+    if (!TEST_int_eq(EVP_PKEY_derive_init_ex(pctx, params), 1))
+        goto err;
+    if (!TEST_int_eq(EVP_PKEY_derive(pctx, NULL, &len), 1)
+        || !TEST_size_t_eq(len, SHA256_DIGEST_LENGTH))
+        goto err;
+    if (!TEST_ptr_null(dctx = EVP_PKEY_CTX_dup(pctx)))
+        goto err;
+    ret = 1;
+err:
+    OPENSSL_free(params);
+    EVP_PKEY_CTX_free(dctx);
+    EVP_PKEY_CTX_free(pctx);
+    return ret;
+}
+
 int setup_tests(void)
 {
     if (!test_skip_common_options()) {
@@ -1632,6 +1679,7 @@ int setup_tests(void)
     if (!TEST_ptr(datadir = test_get_argument(0)))
         return 0;
 
+    ADD_TEST(test_evp_pkey_ctx_dup_kdf_fail);
     ADD_TEST(test_evp_pkey_get_bn_param_large);
     ADD_TEST(test_fromdata_rsa);
 #ifndef OPENSSL_NO_DH

[ML] commit 40184c96103a388209939c1c19920971c05bb78c
Author: Tomas Mraz <tomas@openssl.org>
Date:   Wed Jul 21 18:45:01 2021 +0200

    DSA/RSA_print(): Fix potential memory leak
    
    Fixes #10777
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16130)

diff --git a/crypto/dsa/dsa_prn.c b/crypto/dsa/dsa_prn.c
index c5ec7d5dfe..6f001a50f0 100644
--- a/crypto/dsa/dsa_prn.c
+++ b/crypto/dsa/dsa_prn.c
@@ -55,9 +55,11 @@ int DSA_print(BIO *bp, const DSA *x, int off)
     EVP_PKEY *pk;
     int ret;
     pk = EVP_PKEY_new();
-    if (pk == NULL || !EVP_PKEY_set1_DSA(pk, (DSA *)x))
+    if (pk == NULL)
         return 0;
-    ret = EVP_PKEY_print_private(bp, pk, off, NULL);
+    ret = EVP_PKEY_set1_DSA(pk, (DSA *)x);
+    if (ret)
+        ret = EVP_PKEY_print_private(bp, pk, off, NULL);
     EVP_PKEY_free(pk);
     return ret;
 }
@@ -67,9 +69,11 @@ int DSAparams_print(BIO *bp, const DSA *x)
     EVP_PKEY *pk;
     int ret;
     pk = EVP_PKEY_new();
-    if (pk == NULL || !EVP_PKEY_set1_DSA(pk, (DSA *)x))
+    if (pk == NULL)
         return 0;
-    ret = EVP_PKEY_print_params(bp, pk, 4, NULL);
+    ret = EVP_PKEY_set1_DSA(pk, (DSA *)x);
+    if (ret)
+        ret = EVP_PKEY_print_params(bp, pk, 4, NULL);
     EVP_PKEY_free(pk);
     return ret;
 }
diff --git a/crypto/rsa/rsa_prn.c b/crypto/rsa/rsa_prn.c
index 4a317dadc4..35723c87ae 100644
--- a/crypto/rsa/rsa_prn.c
+++ b/crypto/rsa/rsa_prn.c
@@ -40,9 +40,11 @@ int RSA_print(BIO *bp, const RSA *x, int off)
     EVP_PKEY *pk;
     int ret;
     pk = EVP_PKEY_new();
-    if (pk == NULL || !EVP_PKEY_set1_RSA(pk, (RSA *)x))
+    if (pk == NULL)
         return 0;
-    ret = EVP_PKEY_print_private(bp, pk, off, NULL);
+    ret = EVP_PKEY_set1_RSA(pk, (RSA *)x);
+    if (ret)
+        ret = EVP_PKEY_print_private(bp, pk, off, NULL);
     EVP_PKEY_free(pk);
     return ret;
 }

[ML] commit 981a5b7ce3bcdf4748162073c3dbd096c82d3c69
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Tue Jul 20 11:19:39 2021 +0200

    OSSL_HTTP_open(): Fix memory leak on TLS connect failure via proxy
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16119)

diff --git a/crypto/http/http_client.c b/crypto/http/http_client.c
index 779e4b7203..bb80836cd1 100644
--- a/crypto/http/http_client.c
+++ b/crypto/http/http_client.c
@@ -926,7 +926,8 @@ OSSL_HTTP_REQ_CTX *OSSL_HTTP_open(const char *server, const char *port,
 
         cbio = (*bio_update_fn)(cbio, arg, 1 /* connect */, use_ssl);
         if (cbio == NULL) {
-            cbio = orig_bio;
+            if (bio == NULL) /* cbio was not provided by caller */
+                BIO_free_all(orig_bio);
             goto end;
         }
     }

commit c74188e86c78c4fa47c4a658e1355c40524fadb4
Author: Pauli <pauli@openssl.org>
Date:   Wed Jul 21 19:25:22 2021 +1000

    ci: omit tests that consume too much memory
    
    The SSL API tests and the passwd command test trigger memory leakage in the
    address sanitizer.
    
    Fixes #16116
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16125)

diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index fa650e4d6c..a3a93b6602 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -123,7 +123,7 @@ jobs:
     - name: make
       run: make -s -j4
     - name: make test
-      run: make test HARNESS_JOBS=${HARNESS_JOBS:-4} OPENSSL_TEST_RAND_ORDER=0 TESTS="-test_fuzz* -test_ssl_* -test_evp -test_cmp_http -test_verify -test_cms -test_store -test_enc -[01][0-9]"
+      run: make test HARNESS_JOBS=${HARNESS_JOBS:-4} OPENSSL_TEST_RAND_ORDER=0 TESTS="-test_fuzz* -test_ssl_* -test_sslapi -test_passwd -test_evp -test_cmp_http -test_verify -test_cms -test_store -test_enc -[01][0-9]"
 
   address_ub_sanitizer:
     runs-on: ubuntu-latest

[ML] commit 9d300aa21b02f13d3429931417f4320350b9f891
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Fri Jul 2 14:26:07 2021 +1000

    Add HKDF negative tests
    
    Fix memory leak if legacy test is skipped.
    Using EVP_KDF_CTX_get_params() to get OSSL_KDF_PARAM_SIZE will now
    return 0 if the returned size is 0.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15977)

diff --git a/providers/implementations/kdfs/hkdf.c b/providers/implementations/kdfs/hkdf.c
index 83d9d1ecce..167b64f0b3 100644
--- a/providers/implementations/kdfs/hkdf.c
+++ b/providers/implementations/kdfs/hkdf.c
@@ -149,6 +149,7 @@ static int kdf_hkdf_derive(void *vctx, unsigned char *key, size_t keylen,
 
     switch (ctx->mode) {
     case EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND:
+    default:
         return HKDF(libctx, md, ctx->salt, ctx->salt_len,
                     ctx->key, ctx->key_len, ctx->info, ctx->info_len, key, keylen);
 
@@ -159,9 +160,6 @@ static int kdf_hkdf_derive(void *vctx, unsigned char *key, size_t keylen,
     case EVP_KDF_HKDF_MODE_EXPAND_ONLY:
         return HKDF_Expand(md, ctx->key, ctx->key_len, ctx->info,
                            ctx->info_len, key, keylen);
-
-    default:
-        return 0;
     }
 }
 
@@ -262,8 +260,13 @@ static int kdf_hkdf_get_ctx_params(void *vctx, OSSL_PARAM params[])
     KDF_HKDF *ctx = (KDF_HKDF *)vctx;
     OSSL_PARAM *p;
 
-    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
-        return OSSL_PARAM_set_size_t(p, kdf_hkdf_size(ctx));
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL) {
+        size_t sz = kdf_hkdf_size(ctx);
+
+        if (sz == 0)
+            return 0;
+        return OSSL_PARAM_set_size_t(p, sz);
+    }
     return -2;
 }
 
diff --git a/test/evp_kdf_test.c b/test/evp_kdf_test.c
index 94d2b0ac58..4b3df38b5f 100644
--- a/test/evp_kdf_test.c
+++ b/test/evp_kdf_test.c
@@ -199,14 +199,19 @@ static OSSL_PARAM *construct_hkdf_params(char *digest, char *key,
     if (params == NULL)
         return NULL;
 
-    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
-                                            digest, 0);
+    if (digest != NULL)
+        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                                digest, 0);
     *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
                                              salt, strlen(salt));
     *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
                                              (unsigned char *)key, keylen);
-    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
-                                             info, strlen(info));
+    if (info != NULL)
+        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                                 info, strlen(info));
+    else
+        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MODE,
+                                                "EXTRACT_ONLY", 0);
     *p = OSSL_PARAM_construct_end();
 
     return params;
@@ -234,6 +239,66 @@ static int test_kdf_hkdf(void)
     return ret;
 }
 
+static int do_kdf_hkdf_gettables(int expand_only, int has_digest)
+{
+    int ret = 0;
+    size_t sz = 0;
+    OSSL_PARAM *params;
+    OSSL_PARAM params_get[2];
+    const OSSL_PARAM *gettables, *p;
+    EVP_KDF_CTX *kctx = NULL;
+
+    if (!TEST_ptr(params = construct_hkdf_params(
+                                                 has_digest ? "sha256" : NULL,
+                                                 "secret", 6, "salt",
+                                                 expand_only ? NULL : "label"))
+        || !TEST_ptr(kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF))
+        || !TEST_true(EVP_KDF_CTX_set_params(kctx, params)))
+        goto err;
+
+    /* Check OSSL_KDF_PARAM_SIZE is gettable */
+    if (!TEST_ptr(gettables = EVP_KDF_CTX_gettable_params(kctx))
+        || !TEST_ptr(p = OSSL_PARAM_locate_const(gettables, OSSL_KDF_PARAM_SIZE)))
+        goto err;
+
+    /* Get OSSL_KDF_PARAM_SIZE as a size_t */
+    params_get[0] = OSSL_PARAM_construct_size_t(OSSL_KDF_PARAM_SIZE, &sz);
+    params_get[1] = OSSL_PARAM_construct_end();
+    if (has_digest) {
+        if (!TEST_int_eq(EVP_KDF_CTX_get_params(kctx, params_get), 1)
+            || !TEST_size_t_eq(sz, expand_only ? SHA256_DIGEST_LENGTH : SIZE_MAX))
+            goto err;
+    } else {
+        if (!TEST_int_eq(EVP_KDF_CTX_get_params(kctx, params_get), 0))
+            goto err;
+    }
+
+    /* Get params returns -2 if an unsupported parameter is requested */
+    params_get[0] = OSSL_PARAM_construct_end();
+    if (!TEST_int_eq(EVP_KDF_CTX_get_params(kctx, params_get), -2))
+        goto err;
+    ret = 1;
+err:
+    EVP_KDF_CTX_free(kctx);
+    OPENSSL_free(params);
+    return ret;
+}
+
+static int test_kdf_hkdf_gettables(void)
+{
+    return do_kdf_hkdf_gettables(0, 1);
+}
+
+static int test_kdf_hkdf_gettables_expandonly(void)
+{
+    return do_kdf_hkdf_gettables(1, 1);
+}
+
+static int test_kdf_hkdf_gettables_no_digest(void)
+{
+    return do_kdf_hkdf_gettables(1, 0);
+}
+
 static int test_kdf_hkdf_invalid_digest(void)
 {
     int ret;
@@ -251,6 +316,89 @@ static int test_kdf_hkdf_invalid_digest(void)
     return ret;
 }
 
+static int test_kdf_hkdf_derive_set_params_fail(void)
+{
+    int ret = 0, i = 0;
+    EVP_KDF_CTX *kctx = NULL;
+    OSSL_PARAM params[2];
+    unsigned char out[10];
+
+    if (!TEST_ptr(kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)))
+        goto end;
+    /*
+     * Set the wrong type for the digest so that it causes a failure
+     * inside kdf_hkdf_derive() when kdf_hkdf_set_ctx_params() is called
+     */
+    params[0] = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_DIGEST, &i);
+    params[1] = OSSL_PARAM_construct_end();
+    if (!TEST_int_eq(EVP_KDF_derive(kctx, out, sizeof(out), params), 0))
+        goto end;
+    ret = 1;
+end:
+    EVP_KDF_CTX_free(kctx);
+    return ret;
+}
+
+static int test_kdf_hkdf_set_invalid_mode(void)
+{
+    int ret = 0, bad_mode = 100;
+    EVP_KDF_CTX *kctx = NULL;
+    OSSL_PARAM params[2];
+
+    if (!TEST_ptr(kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)))
+        goto end;
+    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MODE,
+                                                 "BADMODE", 0);
+    params[1] = OSSL_PARAM_construct_end();
+    if (!TEST_int_eq(EVP_KDF_CTX_set_params(kctx, params), 0))
+        goto end;
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_MODE, &bad_mode);
+    if (!TEST_int_eq(EVP_KDF_CTX_set_params(kctx, params), 0))
+        goto end;
+
+    ret = 1;
+end:
+    EVP_KDF_CTX_free(kctx);
+    return ret;
+}
+
+static int do_kdf_hkdf_set_invalid_param(const char *key, int type)
+{
+    int ret = 0;
+    EVP_KDF_CTX *kctx = NULL;
+    OSSL_PARAM params[2];
+    unsigned char buf[2];
+
+    if (!TEST_ptr(kctx = get_kdfbyname(OSSL_KDF_NAME_HKDF)))
+        goto end;
+    /* Set the wrong type for the key so that it causes a failure */
+    if (type == OSSL_PARAM_UTF8_STRING)
+        params[0] = OSSL_PARAM_construct_utf8_string(key, "BAD", 0);
+    else
+        params[0] = OSSL_PARAM_construct_octet_string(key, buf, sizeof(buf));
+    params[1] = OSSL_PARAM_construct_end();
+    if (!TEST_int_eq(EVP_KDF_CTX_set_params(kctx, params), 0))
+        goto end;
+
+    ret = 1;
+end:
+    EVP_KDF_CTX_free(kctx);
+    return ret;
+}
+
+static int test_kdf_hkdf_set_ctx_param_fail(void)
+{
+    return do_kdf_hkdf_set_invalid_param(OSSL_KDF_PARAM_MODE,
+                                         OSSL_PARAM_OCTET_STRING)
+           && do_kdf_hkdf_set_invalid_param(OSSL_KDF_PARAM_KEY,
+                                            OSSL_PARAM_UTF8_STRING)
+           && do_kdf_hkdf_set_invalid_param(OSSL_KDF_PARAM_SALT,
+                                            OSSL_PARAM_UTF8_STRING)
+           && do_kdf_hkdf_set_invalid_param(OSSL_KDF_PARAM_INFO,
+                                            OSSL_PARAM_UTF8_STRING);
+}
+
 static int test_kdf_hkdf_zero_output_size(void)
 {
     int ret;
@@ -366,8 +514,10 @@ static int test_kdf_pbkdf1(void)
 
     /* PBKDF1 only available in the legacy provider */
     prov = OSSL_PROVIDER_load(libctx, "legacy");
-    if (prov == NULL)
+    if (prov == NULL) {
+        OSSL_LIB_CTX_free(libctx);
         return TEST_skip("PBKDF1 only available in legacy provider");
+    }
 
     params = construct_pbkdf1_params("passwordPASSWORDpassword", "sha256",
                                      "saltSALTsaltSALTsaltSALTsaltSALTsalt",
@@ -1495,6 +1645,12 @@ int setup_tests(void)
     ADD_TEST(test_kdf_hkdf_empty_key);
     ADD_TEST(test_kdf_hkdf_1byte_key);
     ADD_TEST(test_kdf_hkdf_empty_salt);
+    ADD_TEST(test_kdf_hkdf_gettables);
+    ADD_TEST(test_kdf_hkdf_gettables_expandonly);
+    ADD_TEST(test_kdf_hkdf_gettables_no_digest);
+    ADD_TEST(test_kdf_hkdf_derive_set_params_fail);
+    ADD_TEST(test_kdf_hkdf_set_invalid_mode);
+    ADD_TEST(test_kdf_hkdf_set_ctx_param_fail);
     ADD_TEST(test_kdf_pbkdf2);
     ADD_TEST(test_kdf_pbkdf2_small_output);
     ADD_TEST(test_kdf_pbkdf2_large_output);
diff --git a/test/recipes/30-test_evp_data/evpkdf_hkdf.txt b/test/recipes/30-test_evp_data/evpkdf_hkdf.txt
index 8d486c672a..c7f94cc644 100644
--- a/test/recipes/30-test_evp_data/evpkdf_hkdf.txt
+++ b/test/recipes/30-test_evp_data/evpkdf_hkdf.txt
@@ -193,3 +193,12 @@ Ctrl.digest = digest:SHA1
 Ctrl.IKM = hexkey:0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c
 Ctrl.salt = salt:
 Output = 2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5673a081d70cce7acfc48
+
+# The output key size should match the digest size for EXTRACT_ONLY mode
+KDF = HKDF
+Ctrl.mode = mode:EXTRACT_ONLY
+Ctrl.digest = digest:SHA1
+Ctrl.IKM = hexkey:0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b
+Ctrl.salt = salt:
+Output = da8c8a73
+Result = KDF_DERIVE_ERROR

[ML] commit 3a1d2b59522163ebb83bb68e13c896188dc222c6
Author: Oliver Mihatsch <oliver.mihatsch@virtual-solution.com>
Date:   Mon Apr 12 16:46:16 2021 +0200

    Fix memory leak in i2d_ASN1_bio_stream
    
    When creating a signed S/MIME message using SMIME_write_CMS()
    if the reading from the bio fails, the state is therefore
    still ASN1_STATE_START when BIO_flush() is called by i2d_ASN1_bio_stream().
    This results in calling asn1_bio_flush_ex cleanup but will only
    reset retry flags as the state is not ASN1_STATE_POST_COPY.
    Therefore 48 bytes (Linux x86_64) leaked since the
    ndef_prefix_free / ndef_suffix_free callbacks are not executed
    and the ndef_aux structure is not freed.
    
    By always calling free function callback in asn1_bio_free() the
    memory leak is fixed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14844)

diff --git a/crypto/asn1/bio_asn1.c b/crypto/asn1/bio_asn1.c
index fa81b3a28a..f792c08806 100644
--- a/crypto/asn1/bio_asn1.c
+++ b/crypto/asn1/bio_asn1.c
@@ -138,6 +138,11 @@ static int asn1_bio_free(BIO *b)
     if (ctx == NULL)
         return 0;
 
+    if (ctx->prefix_free != NULL)
+        ctx->prefix_free(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg);
+    if (ctx->suffix_free != NULL)
+        ctx->suffix_free(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg);
+
     OPENSSL_free(ctx->buf);
     OPENSSL_free(ctx);
     BIO_set_data(b, NULL);
diff --git a/crypto/asn1/bio_ndef.c b/crypto/asn1/bio_ndef.c
index df462d741a..d94e3a3644 100644
--- a/crypto/asn1/bio_ndef.c
+++ b/crypto/asn1/bio_ndef.c
@@ -143,6 +143,9 @@ static int ndef_prefix_free(BIO *b, unsigned char **pbuf, int *plen,
 
     ndef_aux = *(NDEF_SUPPORT **)parg;
 
+    if (ndef_aux == NULL)
+        return 0;
+
     OPENSSL_free(ndef_aux->derbuf);
 
     ndef_aux->derbuf = NULL;
diff --git a/test/bio_memleak_test.c b/test/bio_memleak_test.c
index cafc60e7b7..518e7dd982 100644
--- a/test/bio_memleak_test.c
+++ b/test/bio_memleak_test.c
@@ -35,7 +35,7 @@ static int test_bio_memleak(void)
         goto finish;
     ok = 1;
 
-finish:
+ finish:
     BIO_free(bio);
     return ok;
 }
@@ -62,7 +62,7 @@ static int test_bio_get_mem(void)
         goto finish;
     ok = 1;
 
-finish:
+ finish:
     BIO_free(bio);
     BUF_MEM_free(bufmem);
     return ok;
@@ -98,7 +98,7 @@ static int test_bio_new_mem_buf(void)
         goto finish;
     ok = 1;
 
-finish:
+ finish:
     BIO_free(bio);
     return ok;
 }
@@ -139,7 +139,7 @@ static int test_bio_rdonly_mem_buf(void)
         goto finish;
     ok = 1;
 
-finish:
+ finish:
     BIO_free(bio);
     BIO_free(bio2);
     return ok;
@@ -176,7 +176,7 @@ static int test_bio_rdwr_rdonly(void)
 
     ok = 1;
 
-finish:
+ finish:
     BIO_free(bio);
     return ok;
 }
@@ -216,11 +216,72 @@ static int test_bio_nonclear_rst(void)
 
     ok = 1;
 
-finish:
+ finish:
     BIO_free(bio);
     return ok;
 }
 
+static int error_callback_fired;
+static long BIO_error_callback(BIO *bio, int cmd, const char *argp,
+                               size_t len, int argi,
+                               long argl, int ret, size_t *processed)
+{
+    if ((cmd & (BIO_CB_READ | BIO_CB_RETURN)) != 0) {
+        error_callback_fired = 1;
+        ret = 0;  /* fail for read operations to simulate error in input BIO */
+    }
+    return ret;
+}
+
+/* Checks i2d_ASN1_bio_stream() is freeing all memory when input BIO ends unexpectedly. */
+static int test_bio_i2d_ASN1_mime(void)
+{
+    int ok = 0;
+    BIO *bio = NULL, *out = NULL;
+    BUF_MEM bufmem;
+    static const char str[] = "BIO mime test\n";
+    PKCS7 *p7 = NULL;
+
+    if (!TEST_ptr(bio = BIO_new(BIO_s_mem())))
+        goto finish;
+
+    bufmem.length = sizeof(str);
+    bufmem.data = (char *) str;
+    bufmem.max = bufmem.length;
+    BIO_set_mem_buf(bio, &bufmem, BIO_NOCLOSE);
+    BIO_set_flags(bio, BIO_FLAGS_MEM_RDONLY);
+    BIO_set_callback_ex(bio, BIO_error_callback);
+
+    if (!TEST_ptr(out = BIO_new(BIO_s_mem())))
+        goto finish;
+    if (!TEST_ptr(p7 = PKCS7_new()))
+        goto finish;
+    if (!TEST_true(PKCS7_set_type(p7, NID_pkcs7_data)))
+        goto finish;
+
+    error_callback_fired = 0;
+
+    /*
+     * The call succeeds even if the input stream ends unexpectedly as
+     * there is no handling for this case in SMIME_crlf_copy().
+     */
+    if (!TEST_true(i2d_ASN1_bio_stream(out, (ASN1_VALUE*) p7, bio,
+                                       SMIME_STREAM | SMIME_BINARY,
+                                       ASN1_ITEM_rptr(PKCS7))))
+        goto finish;
+
+    if (!TEST_int_eq(error_callback_fired, 1))
+        goto finish;
+
+    ok = 1;
+
+ finish:
+    BIO_free(bio);
+    BIO_free(out);
+    PKCS7_free(p7);
+    return ok;
+}
+
 int setup_tests(void)
 {
     ADD_TEST(test_bio_memleak);
@@ -229,5 +290,6 @@ int setup_tests(void)
     ADD_TEST(test_bio_rdonly_mem_buf);
     ADD_TEST(test_bio_rdwr_rdonly);
     ADD_TEST(test_bio_nonclear_rst);
+    ADD_TEST(test_bio_i2d_ASN1_mime);
     return 1;
 }

[ML] commit 711d5a2fc0d611d5574c6d81b9cc0aa1564d2d2a
Author: Pauli <pauli@openssl.org>
Date:   Fri Jun 25 12:57:37 2021 +1000

    test: avoid memory leaks on errors
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/15910)

diff --git a/test/conf_include_test.c b/test/conf_include_test.c
index 1c00c601e5..2481a2380b 100644
--- a/test/conf_include_test.c
+++ b/test/conf_include_test.c
@@ -42,7 +42,7 @@ static int change_path(const char *file)
     char *s = OPENSSL_strdup(file);
     char *p = s;
     char *last = NULL;
-    int ret;
+    int ret = 0;
 
     if (s == NULL)
         return -1;
@@ -51,11 +51,12 @@ static int change_path(const char *file)
         last = p++;
     }
     if (last == NULL)
-        return 0;
+        goto err;
     last[DIRSEP_PRESERVE] = 0;
 
     TEST_note("changing path to %s", s);
     ret = chdir(s);
+ err:
     OPENSSL_free(s);
     return ret;
 }
diff --git a/test/helpers/handshake.c b/test/helpers/handshake.c
index 0543634c73..d44aa4baaf 100644
--- a/test/helpers/handshake.c
+++ b/test/helpers/handshake.c
@@ -278,8 +278,10 @@ static int server_ocsp_cb(SSL *s, void *arg)
      * For the purposes of testing we just send back a dummy OCSP response
      */
     *resp = *(unsigned char *)arg;
-    if (!SSL_set_tlsext_status_ocsp_resp(s, resp, 1))
+    if (!SSL_set_tlsext_status_ocsp_resp(s, resp, 1)) {
+        OPENSSL_free(resp);
         return SSL_TLSEXT_ERR_ALERT_FATAL;
+    }
 
     return SSL_TLSEXT_ERR_OK;
 }
diff --git a/test/sslapitest.c b/test/sslapitest.c
index 850c941ac2..bbb1cf91f4 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -1644,7 +1644,11 @@ static int ocsp_server_cb(SSL *s, void *arg)
     if (!TEST_ptr(copy = OPENSSL_memdup(orespder, sizeof(orespder))))
         return SSL_TLSEXT_ERR_ALERT_FATAL;
 
-    SSL_set_tlsext_status_ocsp_resp(s, copy, sizeof(orespder));
+    if (!TEST_true(SSL_set_tlsext_status_ocsp_resp(s, copy,
+                                                   sizeof(orespder)))) {
+        OPENSSL_free(copy);
+        return SSL_TLSEXT_ERR_ALERT_FATAL;
+    }
     ocsp_server_called = 1;
     return SSL_TLSEXT_ERR_OK;
 }

[ML] commit a52d20c82a82a0c1d5ecf9f1337906c6783f0971
Author: Pauli <pauli@openssl.org>
Date:   Fri Jun 25 12:56:01 2021 +1000

    ui: address potential memory leak
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/15910)

diff --git a/crypto/ui/ui_lib.c b/crypto/ui/ui_lib.c
index fd03dc6cd0..7cb91add41 100644
--- a/crypto/ui/ui_lib.c
+++ b/crypto/ui/ui_lib.c
@@ -43,7 +43,7 @@ UI *UI_new_method(const UI_METHOD *method)
     ret->meth = method;
 
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_UI, ret, &ret->ex_data)) {
-        OPENSSL_free(ret);
+        UI_free(ret);
         return NULL;
     }
     return ret;

[ML] commit 1f3f8a3d016ac1c659f7201e152c291d03437b72
Author: Pauli <pauli@openssl.org>
Date:   Fri Jun 25 12:55:28 2021 +1000

    apps: address potential memory leaks
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/15910)

diff --git a/apps/s_server.c b/apps/s_server.c
index 9c0c467ed6..a112b01f1b 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -3016,6 +3016,7 @@ static int www_body(int s, int stype, int prot, unsigned char *context)
     /* No need to free |con| after this. Done by BIO_free(ssl_bio) */
     BIO_set_ssl(ssl_bio, con, BIO_CLOSE);
     BIO_push(io, ssl_bio);
+    ssl_bio = NULL;
 #ifdef CHARSET_EBCDIC
     io = BIO_push(BIO_new(BIO_f_ebcdic_filter()), io);
 #endif
@@ -3376,6 +3377,7 @@ static int www_body(int s, int stype, int prot, unsigned char *context)
 
  err:
     OPENSSL_free(buf);
+    BIO_free(ssl_bio);
     BIO_free_all(io);
     return ret;
 }
@@ -3420,6 +3422,7 @@ static int rev_body(int s, int stype, int prot, unsigned char *context)
     /* No need to free |con| after this. Done by BIO_free(ssl_bio) */
     BIO_set_ssl(ssl_bio, con, BIO_CLOSE);
     BIO_push(io, ssl_bio);
+    ssl_bio = NULL;
 #ifdef CHARSET_EBCDIC
     io = BIO_push(BIO_new(BIO_f_ebcdic_filter()), io);
 #endif
@@ -3517,6 +3520,7 @@ static int rev_body(int s, int stype, int prot, unsigned char *context)
  err:
 
     OPENSSL_free(buf);
+    BIO_free(ssl_bio);
     BIO_free_all(io);
     return ret;
 }

[ML] commit 150251904c2b4c2cffd7429af90cd0486e3682d7
Author: Pauli <pauli@openssl.org>
Date:   Fri Jun 25 12:54:43 2021 +1000

    x509: address NULL dereference and memory leaks
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/15910)

diff --git a/crypto/x509/x_pubkey.c b/crypto/x509/x_pubkey.c
index e669ae3574..b20b756e9a 100644
--- a/crypto/x509/x_pubkey.c
+++ b/crypto/x509/x_pubkey.c
@@ -84,14 +84,16 @@ void ossl_X509_PUBKEY_INTERNAL_free(X509_PUBKEY *xpub)
 
 static void x509_pubkey_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
 {
-    X509_PUBKEY *pubkey = (X509_PUBKEY *)*pval;
+    X509_PUBKEY *pubkey;
 
-    X509_ALGOR_free(pubkey->algor);
-    ASN1_BIT_STRING_free(pubkey->public_key);
-    EVP_PKEY_free(pubkey->pkey);
-    OPENSSL_free(pubkey->propq);
-    OPENSSL_free(pubkey);
-    *pval = NULL;
+    if (pval != NULL && (pubkey = (X509_PUBKEY *)*pval) != NULL) {
+        X509_ALGOR_free(pubkey->algor);
+        ASN1_BIT_STRING_free(pubkey->public_key);
+        EVP_PKEY_free(pubkey->pkey);
+        OPENSSL_free(pubkey->propq);
+        OPENSSL_free(pubkey);
+        *pval = NULL;
+    }
 }
 
 static int x509_pubkey_ex_populate(ASN1_VALUE **pval, const ASN1_ITEM *it)
diff --git a/crypto/x509/x_x509a.c b/crypto/x509/x_x509a.c
index ef93db26d8..c88a58aa9f 100644
--- a/crypto/x509/x_x509a.c
+++ b/crypto/x509/x_x509a.c
@@ -125,6 +125,8 @@ int X509_add1_reject_object(X509 *x, const ASN1_OBJECT *obj)
 {
     X509_CERT_AUX *aux;
     ASN1_OBJECT *objtmp;
+    int res = 0;
+
     if ((objtmp = OBJ_dup(obj)) == NULL)
         return 0;
     if ((aux = aux_get(x)) == NULL)
@@ -132,10 +134,13 @@ int X509_add1_reject_object(X509 *x, const ASN1_OBJECT *obj)
     if (aux->reject == NULL
         && (aux->reject = sk_ASN1_OBJECT_new_null()) == NULL)
         goto err;
-    return sk_ASN1_OBJECT_push(aux->reject, objtmp);
+    if (sk_ASN1_OBJECT_push(aux->reject, objtmp) > 0)
+        res = 1;
+
  err:
-    ASN1_OBJECT_free(objtmp);
-    return 0;
+    if (!res)
+        ASN1_OBJECT_free(objtmp);
+    return res;
 }
 
 void X509_trust_clear(X509 *x)

[ML] commit dfb0b8d63a1b627c5d796ba0174ee4693b330989
Author: Pauli <pauli@openssl.org>
Date:   Mon Jun 14 21:22:55 2021 +1000

    cms: free PKEY_CTX
    
    Preventing a memory leak.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/15731)

diff --git a/crypto/cms/cms_ec.c b/crypto/cms/cms_ec.c
index ca66d9fcf8..87ce88e743 100644
--- a/crypto/cms/cms_ec.c
+++ b/crypto/cms/cms_ec.c
@@ -38,6 +38,7 @@ static EVP_PKEY *pkey_type2param(int ptype, const void *pval,
             goto err;
         }    
         OSSL_DECODER_CTX_free(ctx);
+        return pkey;
     } else if (ptype == V_ASN1_OBJECT) {
         const ASN1_OBJECT *poid = pval;
         char groupname[OSSL_MAX_NAME_SIZE];
@@ -53,12 +54,12 @@ static EVP_PKEY *pkey_type2param(int ptype, const void *pval,
         }
         if (EVP_PKEY_paramgen(pctx, &pkey) <= 0)
             goto err;
-    } else {
-        ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);
-        goto err;
+        EVP_PKEY_CTX_free(pctx);
+        return pkey;
     }
 
-    return pkey;
+    ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);
+    return NULL;
 
  err:
     EVP_PKEY_free(pkey);

[UAF] commit de5a0198b22c36884fd36021d9e4f589b939674f
Author: Tomas Mraz <tomas@openssl.org>
Date:   Mon Jun 7 16:56:20 2021 +0200

    Fix use after free in OSSL_HTTP_REQ_CTX_set1_req()
    
    Fixes #15647
    
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15648)

diff --git a/crypto/http/http_client.c b/crypto/http/http_client.c
index e7e0183b59..79fe9ccd41 100644
--- a/crypto/http/http_client.c
+++ b/crypto/http/http_client.c
@@ -126,7 +126,8 @@ void OSSL_HTTP_REQ_CTX_free(OSSL_HTTP_REQ_CTX *rctx)
     if (rctx->free_wbio)
         BIO_free_all(rctx->wbio);
     /* do not free rctx->rbio */
-    BIO_free(rctx->mem); /* this may indirectly call ERR_clear_error() */
+    BIO_free(rctx->mem);
+    BIO_free(rctx->req);
     OPENSSL_free(rctx->buf);
     OPENSSL_free(rctx->proxy);
     OPENSSL_free(rctx->server);
@@ -260,8 +261,8 @@ int OSSL_HTTP_REQ_CTX_set_expected(OSSL_HTTP_REQ_CTX *rctx,
     return 1;
 }
 
-static int set_content(OSSL_HTTP_REQ_CTX *rctx,
-                       const char *content_type, BIO *req)
+static int set1_content(OSSL_HTTP_REQ_CTX *rctx,
+                        const char *content_type, BIO *req)
 {
     long req_len;
 
@@ -285,10 +286,16 @@ static int set_content(OSSL_HTTP_REQ_CTX *rctx,
             && BIO_printf(rctx->mem, "Content-Type: %s\r\n", content_type) <= 0)
         return 0;
 
-    rctx->req = req;
-    if ((req_len = BIO_ctrl(req, BIO_CTRL_INFO, 0, NULL)) <= 0)
-        return 1; /* streaming BIO may not support querying size */
-    return BIO_printf(rctx->mem, "Content-Length: %ld\r\n", req_len) > 0;
+    /* streaming BIO may not support querying size */
+    if ((req_len = BIO_ctrl(req, BIO_CTRL_INFO, 0, NULL)) <= 0
+        || BIO_printf(rctx->mem, "Content-Length: %ld\r\n", req_len) > 0) {
+        if (!BIO_up_ref(req))
+            return 0;
+        BIO_free(rctx->req);
+        rctx->req = req;
+        return 1;
+    }
+    return 0;
 }
 
 int OSSL_HTTP_REQ_CTX_set1_req(OSSL_HTTP_REQ_CTX *rctx, const char *content_type,
@@ -303,7 +310,7 @@ int OSSL_HTTP_REQ_CTX_set1_req(OSSL_HTTP_REQ_CTX *rctx, const char *content_type
     }
 
     res = (mem = ASN1_item_i2d_mem_bio(it, req)) != NULL
-        && set_content(rctx, content_type, mem);
+        && set1_content(rctx, content_type, mem);
     BIO_free(mem);
     return res;
 }
@@ -965,7 +972,7 @@ int OSSL_HTTP_set_request(OSSL_HTTP_REQ_CTX *rctx, const char *path,
         && add1_headers(rctx, headers, rctx->server)
         && OSSL_HTTP_REQ_CTX_set_expected(rctx, expected_content_type,
                                           expect_asn1, timeout, keep_alive)
-        && set_content(rctx, content_type, req);
+        && set1_content(rctx, content_type, req);
 }
 
 /*-

[DF] commit 43dbe3b72de0ba4ebd20e9e6a2c526ef747326ab
Author: Pauli <pauli@openssl.org>
Date:   Fri May 28 10:25:55 2021 +1000

    fips: set the library context and handle later
    
    They need to be set once the provider will definitely be loading.  If they
    are set earlier, a double free results on a failure.
    
    Fixes #15452
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15492)

diff --git a/providers/fips/fipsprov.c b/providers/fips/fipsprov.c
index 580eea574f..4155b64197 100644
--- a/providers/fips/fipsprov.c
+++ b/providers/fips/fipsprov.c
@@ -663,8 +663,6 @@ int OSSL_provider_init_int(const OSSL_CORE_HANDLE *handle,
         OSSL_LIB_CTX_free(libctx);
         goto err;
     }
-    ossl_prov_ctx_set0_libctx(*provctx, libctx);
-    ossl_prov_ctx_set0_handle(*provctx, handle);
 
     if ((fgbl = ossl_lib_ctx_get_data(libctx, OSSL_LIB_CTX_FIPS_PROV_INDEX,
                                       &fips_prov_ossl_ctx_method)) == NULL)
@@ -707,6 +705,9 @@ int OSSL_provider_init_int(const OSSL_CORE_HANDLE *handle,
         goto err;
     }
 
+    ossl_prov_ctx_set0_libctx(*provctx, libctx);
+    ossl_prov_ctx_set0_handle(*provctx, handle);
+
     *out = fips_dispatch_table;
     return 1;
  err:

[ML] commit 32075a17249636b3e2986a0ac422b1803663ccaa
Author: Petr Gotthard <petr.gotthard@centrum.cz>
Date:   Tue May 25 15:39:01 2021 +0200

    Fix memory leak in OSSL_CMP_CTX
    
    The ctx->propq is strdup'ed, so it must be free'd too.
    
    Reviewed-by: Ben Kaduk <kaduk@mit.edu>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15458)

diff --git a/crypto/cmp/cmp_ctx.c b/crypto/cmp/cmp_ctx.c
index a09432597b..d1f8f27e13 100644
--- a/crypto/cmp/cmp_ctx.c
+++ b/crypto/cmp/cmp_ctx.c
@@ -179,6 +179,7 @@ void OSSL_CMP_CTX_free(OSSL_CMP_CTX *ctx)
         (void)OSSL_HTTP_close(ctx->http_ctx, 1);
         ossl_cmp_debug(ctx, "disconnected from CMP server");
     }
+    OPENSSL_free(ctx->propq);
     OPENSSL_free(ctx->serverPath);
     OPENSSL_free(ctx->server);
     OPENSSL_free(ctx->proxy);
diff --git a/crypto/cmp/cmp_local.h b/crypto/cmp/cmp_local.h
index eee609937b..fec4916ed3 100644
--- a/crypto/cmp/cmp_local.h
+++ b/crypto/cmp/cmp_local.h
@@ -32,7 +32,7 @@
  */
 struct ossl_cmp_ctx_st {
     OSSL_LIB_CTX *libctx;
-    const char *propq;
+    char *propq;
     OSSL_CMP_log_cb_t log_cb; /* log callback for error/debug/etc. output */
     OSSL_CMP_severity log_verbosity; /* level of verbosity of log output */
 

[ML] commit c9732f095363251131e6e6a4cbbe45deea285ed0
Author: Matt Caswell <matt@openssl.org>
Date:   Thu May 20 11:52:56 2021 +0100

    Fix a memleak in the FIPS provider
    
    If the DRBG is used within the scope of the FIPS OSSL_provider_init
    function then it attempts to register a thread callback via c_thread_start.
    However the implementation of c_thread_start assumed that the provider's
    provctx was already present. However because OSSL_provider_init is still
    running it was actually NULL. This means the thread callback fail to work
    correctly and a memory leak resulted.
    
    Instead of having c_thread_start use the provctx as the callback argument
    we change the definition of c_thread_start to have an explicit callback
    argument to use.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15278)

diff --git a/crypto/initthread.c b/crypto/initthread.c
index 73f55c5cb8..d86e280fc1 100644
--- a/crypto/initthread.c
+++ b/crypto/initthread.c
@@ -237,12 +237,12 @@ void OPENSSL_thread_stop(void)
     }
 }
 
-void ossl_ctx_thread_stop(void *arg)
+void ossl_ctx_thread_stop(OSSL_LIB_CTX *ctx)
 {
     if (destructor_key.sane != -1) {
         THREAD_EVENT_HANDLER **hands
             = init_get_thread_local(&destructor_key.value, 0, 1);
-        init_thread_stop(arg, hands);
+        init_thread_stop(ctx, hands);
     }
 }
 
@@ -285,10 +285,14 @@ static const OSSL_LIB_CTX_METHOD thread_event_ossl_ctx_method = {
     thread_event_ossl_ctx_free,
 };
 
-void ossl_ctx_thread_stop(void *arg)
+static void ossl_arg_thread_stop(void *arg)
+{
+    ossl_ctx_thread_stop((OSSL_LIB_CTX *)arg);
+}
+
+void ossl_ctx_thread_stop(OSSL_LIB_CTX *ctx)
 {
     THREAD_EVENT_HANDLER **hands;
-    OSSL_LIB_CTX *ctx = PROV_LIBCTX_OF(arg);
     CRYPTO_THREAD_LOCAL *local
         = ossl_lib_ctx_get_data(ctx, OSSL_LIB_CTX_THREAD_EVENT_HANDLER_INDEX,
                                 &thread_event_ossl_ctx_method);
@@ -367,7 +371,8 @@ int ossl_init_thread_start(const void *index, void *arg,
          * libcrypto to tell us about later thread stop events. c_thread_start
          * is a callback to libcrypto defined in fipsprov.c
          */
-        if (!c_thread_start(FIPS_get_core_handle(ctx), ossl_ctx_thread_stop))
+        if (!c_thread_start(FIPS_get_core_handle(ctx), ossl_arg_thread_stop,
+                            ctx))
             return 0;
     }
 #endif
diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index 512a16ee66..ca2bfdb8fa 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -1603,7 +1603,8 @@ static OPENSSL_CORE_CTX *core_get_libctx(const OSSL_CORE_HANDLE *handle)
 }
 
 static int core_thread_start(const OSSL_CORE_HANDLE *handle,
-                             OSSL_thread_stop_handler_fn handfn)
+                             OSSL_thread_stop_handler_fn handfn,
+                             void *arg)
 {
     /*
      * We created this object originally and we know it is actually an
@@ -1611,7 +1612,7 @@ static int core_thread_start(const OSSL_CORE_HANDLE *handle,
      */
     OSSL_PROVIDER *prov = (OSSL_PROVIDER *)handle;
 
-    return ossl_init_thread_start(prov, prov->provctx, handfn);
+    return ossl_init_thread_start(prov, arg, handfn);
 }
 
 /*
diff --git a/include/crypto/cryptlib.h b/include/crypto/cryptlib.h
index 1e58663b4f..39a956bfd3 100644
--- a/include/crypto/cryptlib.h
+++ b/include/crypto/cryptlib.h
@@ -21,7 +21,7 @@ int ossl_init_thread_start(const void *index, void *arg,
 int ossl_init_thread_deregister(void *index);
 int ossl_init_thread(void);
 void ossl_cleanup_thread(void);
-void ossl_ctx_thread_stop(void *arg);
+void ossl_ctx_thread_stop(OSSL_LIB_CTX *ctx);
 
 /*
  * OPENSSL_INIT flags. The primary list of these is in crypto.h. Flags below
diff --git a/include/openssl/core_dispatch.h b/include/openssl/core_dispatch.h
index 458cbb1c9e..2a46c10123 100644
--- a/include/openssl/core_dispatch.h
+++ b/include/openssl/core_dispatch.h
@@ -68,7 +68,8 @@ OSSL_CORE_MAKE_FUNC(int,core_get_params,(const OSSL_CORE_HANDLE *prov,
                                          OSSL_PARAM params[]))
 # define OSSL_FUNC_CORE_THREAD_START           3
 OSSL_CORE_MAKE_FUNC(int,core_thread_start,(const OSSL_CORE_HANDLE *prov,
-                                           OSSL_thread_stop_handler_fn handfn))
+                                           OSSL_thread_stop_handler_fn handfn,
+                                           void *arg))
 # define OSSL_FUNC_CORE_GET_LIBCTX             4
 OSSL_CORE_MAKE_FUNC(OPENSSL_CORE_CTX *,core_get_libctx,
                     (const OSSL_CORE_HANDLE *prov))

[ML] commit 558f2a014646bb057f3876b28e32b13d8178400e
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Thu Mar 4 21:17:31 2021 +0100

    X509 build_chain(): Fix two potential memory leaks on issuer variable
    
    This also removes an inadequate guard: if (num == ctx->num_untrusted)
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14422)

diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index 054dffc7dc..ddb3378eee 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -2965,10 +2965,10 @@ static int dane_verify(X509_STORE_CTX *ctx)
 }
 
 /*
- * Get issuer, without duplicate suppression
+ * Get trusted issuer, without duplicate suppression
  * Returns -1 on internal error.
  */
-static int get_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *cert)
+static int get1_trusted_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *cert)
 {
     STACK_OF(X509) *saved_chain = ctx->chain;
     int ok;
@@ -3090,8 +3090,8 @@ static int build_chain(X509_STORE_CTX *ctx)
             }
             curr = sk_X509_value(ctx->chain, i - 1);
 
-            /* Note: get_issuer() must be used even if curr is self-signed. */
-            ok = num > max_depth ? 0 : get_issuer(&issuer, ctx, curr);
+            /* Note: get1_trusted_issuer() must be used even if self-signed. */
+            ok = num > max_depth ? 0 : get1_trusted_issuer(&issuer, ctx, curr);
 
             if (ok < 0) {
                 trust = -1;
@@ -3102,8 +3102,10 @@ static int build_chain(X509_STORE_CTX *ctx)
             if (ok > 0) {
                 int self_signed = X509_self_signed(curr, 0);
 
-                if (self_signed < 0)
+                if (self_signed < 0) {
+                    X509_free(issuer);
                     goto int_err;
+                }
                 /*
                  * Alternative trusted issuer for a mid-chain untrusted cert?
                  * Pop the untrusted cert's successors and retry.  We might now
@@ -3150,7 +3152,7 @@ static int build_chain(X509_STORE_CTX *ctx)
                     }
                     if ((self_signed = X509_self_signed(issuer, 0)) < 0)
                         goto int_err;
-                } else if (num == ctx->num_untrusted) {
+                } else {
                     /*
                      * We have a self-signed certificate that has the same
                      * subject name (and perhaps keyid and/or serial number) as

[UR] [ML] commit 634da876e0d6d95a23c5d005b1ac4354a04310d2
Author: Pauli <pauli@openssl.org>
Date:   Mon May 17 09:33:10 2021 +1000

    provider: fix coverity 1484884: uninitialised lock use
    
    This actually fixes a more subtle problem that wasn't detected which could
    cause memory leaks.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/15300)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index b384f74fd2..9d5248de0d 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -306,7 +306,6 @@ static OSSL_PROVIDER *provider_new(const char *name,
 #ifndef HAVE_ATOMICS
         || (prov->refcnt_lock = CRYPTO_THREAD_lock_new()) == NULL
 #endif
-        || !ossl_provider_up_ref(prov) /* +1 One reference to be returned */
         || (prov->opbits_lock = CRYPTO_THREAD_lock_new()) == NULL
         || (prov->flag_lock = CRYPTO_THREAD_lock_new()) == NULL
         || (prov->name = OPENSSL_strdup(name)) == NULL) {
@@ -315,6 +314,7 @@ static OSSL_PROVIDER *provider_new(const char *name,
         return NULL;
     }
 
+    prov->refcnt = 1; /* 1 One reference to be returned */
     prov->init_function = init_function;
 #ifndef FIPS_MODULE
     prov->flag_couldbechild = 1;

[UAF] commit b1423d04cdcad9dbbe2da6e4751f0895112cc977
Author: Pauli <pauli@openssl.org>
Date:   Wed May 12 14:10:49 2021 +1000

    e_loader_attic: fix a use after free issue
    
    Fixes #15116
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15238)

diff --git a/engines/e_loader_attic.c b/engines/e_loader_attic.c
index 802b3d9067..4cb98280a5 100644
--- a/engines/e_loader_attic.c
+++ b/engines/e_loader_attic.c
@@ -199,6 +199,7 @@ static OSSL_STORE_INFO *new_EMBEDDED(const char *new_pem_name,
         return NULL;
     }
 
+    data->blob = embedded;
     data->pem_name =
         new_pem_name == NULL ? NULL : OPENSSL_strdup(new_pem_name);
 
@@ -207,7 +208,6 @@ static OSSL_STORE_INFO *new_EMBEDDED(const char *new_pem_name,
         store_info_free(info);
         info = NULL;
     }
-    data->blob = embedded;
 
     return info;
 }

[ML] commit 0a8a6afdfb71e42962921980b51942cea8632697
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Mon Mar 29 19:42:33 2021 +0200

    Add quick one-shot EVP_Q_mac() and deprecation compensation decls for MAC functions
    
    This helps compensating for deprecated functions such as HMAC()
    and reduces clutter in the crypto lib, apps, and tests.
    Also fixes memory leaks in generate_cookie_callback() of apps/lib/s_cb.c.
    and replaces 'B<...>' by 'I<...>' where appropriate in HMAC.pod
    
    Partially fixes #14628.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14664)

diff --git a/CHANGES.md b/CHANGES.md
index 29d28f91ab..a2ef2f6b3f 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1033,18 +1033,18 @@ OpenSSL 3.0
 
    *Paul Dale*
 
- * All of the low level HMAC functions have been deprecated including:
+ * All low level HMAC functions except for HMAC have been deprecated including:
 
-   HMAC, HMAC_size, HMAC_CTX_new, HMAC_CTX_reset, HMAC_CTX_free,
+   HMAC_size, HMAC_CTX_new, HMAC_CTX_reset, HMAC_CTX_free,
    HMAC_Init_ex, HMAC_Update, HMAC_Final, HMAC_CTX_copy, HMAC_CTX_set_flags
    and HMAC_CTX_get_md.
 
    Use of these low level functions has been informally discouraged for a long
    time.  Instead applications should use L<EVP_MAC_CTX_new(3)>,
    L<EVP_MAC_CTX_free(3)>, L<EVP_MAC_init(3)>, L<EVP_MAC_update(3)>
-   and L<EVP_MAC_final(3)>.
+   and L<EVP_MAC_final(3)> or the single-shot MAC function L<EVP_Q_mac(3)>.
 
-   *Paul Dale*
+   *Paul Dale and David von Oheimb*
 
  * Over two thousand fixes were made to the documentation, including:
    - Common options (such as -rand/-writerand, TLS version control, etc)
diff --git a/apps/lib/s_cb.c b/apps/lib/s_cb.c
index 0bb4b6c436..bdd5051ee6 100644
--- a/apps/lib/s_cb.c
+++ b/apps/lib/s_cb.c
@@ -739,10 +739,6 @@ int generate_cookie_callback(SSL *ssl, unsigned char *cookie,
     unsigned short port;
     BIO_ADDR *lpeer = NULL, *peer = NULL;
     int res = 0;
-    EVP_MAC *hmac = NULL;
-    EVP_MAC_CTX *ctx = NULL;
-    OSSL_PARAM params[2], *p = params;
-    size_t mac_len;
 
     /* Initialize a random secret */
     if (!cookie_initialized) {
@@ -780,32 +776,13 @@ int generate_cookie_callback(SSL *ssl, unsigned char *cookie,
     memcpy(buffer, &port, sizeof(port));
     BIO_ADDR_rawaddress(peer, buffer + sizeof(port), NULL);
 
-    /* Calculate HMAC of buffer using the secret */
-    hmac = EVP_MAC_fetch(NULL, "HMAC", NULL);
-    if (hmac == NULL) {
-            BIO_printf(bio_err, "HMAC not found\n");
-            goto end;
-    }
-    ctx = EVP_MAC_CTX_new(hmac);
-    if (ctx == NULL) {
-            BIO_printf(bio_err, "HMAC context allocation failed\n");
-            goto end;
-    }
-    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST, "SHA1", 0);
-    *p = OSSL_PARAM_construct_end();
-    if (!EVP_MAC_init(ctx, cookie_secret, COOKIE_SECRET_LENGTH, params)) {
-            BIO_printf(bio_err, "HMAC context initialisation failed\n");
-            goto end;
-    }
-    if (!EVP_MAC_update(ctx, buffer, length)) {
-            BIO_printf(bio_err, "HMAC context update failed\n");
-            goto end;
-    }
-    if (!EVP_MAC_final(ctx, cookie, &mac_len, DTLS1_COOKIE_LENGTH)) {
-            BIO_printf(bio_err, "HMAC context final failed\n");
-            goto end;
+    if (EVP_Q_mac(NULL, "HMAC", NULL, "SHA1", NULL,
+                  cookie_secret, COOKIE_SECRET_LENGTH, buffer, length,
+                  cookie, DTLS1_COOKIE_LENGTH, cookie_len) == NULL) {
+        BIO_printf(bio_err,
+                   "Error calculating HMAC-SHA1 of buffer with secret\n");
+        goto end;
     }
-    *cookie_len = (int)mac_len;
     res = 1;
 end:
     OPENSSL_free(buffer);
diff --git a/crypto/crmf/crmf_pbm.c b/crypto/crmf/crmf_pbm.c
index 40a41c28b2..cf483dcb9a 100644
--- a/crypto/crmf/crmf_pbm.c
+++ b/crypto/crmf/crmf_pbm.c
@@ -16,6 +16,7 @@
 
 #include <openssl/rand.h>
 #include <openssl/evp.h>
+#include <openssl/hmac.h>
 
 /* explicit #includes not strictly needed since implied by the above: */
 #include <openssl/asn1t.h>
@@ -120,8 +121,8 @@ OSSL_CRMF_PBMPARAMETER *OSSL_CRMF_pbmp_new(OSSL_LIB_CTX *libctx, size_t slen,
  * |msglen| length of the message
  * |sec| key to use
  * |seclen| length of the key
- * |mac| pointer to the computed mac, will be set on success
- * |maclen| if not NULL, will set variable to the length of the mac on success
+ * |out| pointer to the computed mac, will be set on success
+ * |outlen| if not NULL, will set variable to the length of the mac on success
  * returns 1 on success, 0 on error
  */
 /* TODO try to combine with other MAC calculations in the libray */
@@ -140,10 +141,8 @@ int OSSL_CRMF_pbm_new(OSSL_LIB_CTX *libctx, const char *propq,
     unsigned int bklen = EVP_MAX_MD_SIZE;
     int64_t iterations;
     unsigned char *mac_res = 0;
+    unsigned int maclen;
     int ok = 0;
-    EVP_MAC *mac = NULL;
-    EVP_MAC_CTX *mctx = NULL;
-    OSSL_PARAM macparams[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
     if (out == NULL || pbmp == NULL || pbmp->mac == NULL
             || pbmp->mac->algorithm == NULL || msg == NULL || sec == NULL) {
@@ -208,23 +207,16 @@ int OSSL_CRMF_pbm_new(OSSL_LIB_CTX *libctx, const char *propq,
         ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_ALGORITHM);
         goto err;
     }
-
-    macparams[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,
-                                                    (char *)hmac_mdname, 0);
-    if ((mac = EVP_MAC_fetch(libctx, "HMAC", propq)) == NULL
-            || (mctx = EVP_MAC_CTX_new(mac)) == NULL
-            || !EVP_MAC_CTX_set_params(mctx, macparams)
-            || !EVP_MAC_init(mctx, basekey, bklen, macparams)
-            || !EVP_MAC_update(mctx, msg, msglen)
-            || !EVP_MAC_final(mctx, mac_res, outlen, EVP_MAX_MD_SIZE))
+    /* TODO generalize to non-HMAC: */
+    if (EVP_Q_mac(libctx, "HMAC", propq, hmac_mdname, NULL, basekey, bklen,
+                  msg, msglen, mac_res, EVP_MAX_MD_SIZE, &maclen) == NULL)
         goto err;
 
+    *outlen = (size_t)maclen;
     ok = 1;
 
  err:
     OPENSSL_cleanse(basekey, bklen);
-    EVP_MAC_CTX_free(mctx);
-    EVP_MAC_free(mac);
     EVP_MD_free(owf);
     EVP_MD_CTX_free(ctx);
 
diff --git a/crypto/evp/mac_lib.c b/crypto/evp/mac_lib.c
index 6f97de94de..8a34df3757 100644
--- a/crypto/evp/mac_lib.c
+++ b/crypto/evp/mac_lib.c
@@ -222,3 +222,65 @@ int EVP_MAC_names_do_all(const EVP_MAC *mac,
 
     return 1;
 }
+
+unsigned char *EVP_Q_mac(OSSL_LIB_CTX *libctx, const char *name, const char *propq,
+                         const char *subalg, const OSSL_PARAM *params,
+                         const void *key, size_t keylen,
+                         const unsigned char *data, size_t datalen,
+                         unsigned char *out, size_t outsize, unsigned int *outlen)
+{
+    EVP_MAC *mac = EVP_MAC_fetch(libctx, name, propq);
+    OSSL_PARAM subalg_param[] = { OSSL_PARAM_END, OSSL_PARAM_END };
+    EVP_MAC_CTX *ctx  = NULL;
+    size_t len;
+    unsigned char *res = NULL;
+
+    if (outlen != NULL)
+        *outlen = 0;
+    if (mac == NULL)
+        return NULL;
+    if (subalg != NULL) {
+        const OSSL_PARAM *defined_params = EVP_MAC_settable_ctx_params(mac);
+        const char *param_name = OSSL_MAC_PARAM_DIGEST;
+
+        /*
+         * The underlying algorithm may be a cipher or a digest.
+         * We don't know which it is, but we can ask the MAC what it
+         * should be and bet on that.
+         */
+        if (OSSL_PARAM_locate_const(defined_params, param_name) == NULL) {
+            param_name = OSSL_MAC_PARAM_CIPHER;
+            if (OSSL_PARAM_locate_const(defined_params, param_name) == NULL) {
+                ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_INVALID_ARGUMENT);
+                goto err;
+            }
+        }
+        subalg_param[0] =
+            OSSL_PARAM_construct_utf8_string(param_name, (char *)subalg, 0);
+    }
+    /* Single-shot - on NULL key input, set dummy key value for EVP_MAC_Init. */
+    if (key == NULL && keylen == 0)
+        key = data;
+    if ((ctx = EVP_MAC_CTX_new(mac)) != NULL
+            && EVP_MAC_CTX_set_params(ctx, subalg_param)
+            && EVP_MAC_CTX_set_params(ctx, params)
+            && EVP_MAC_init(ctx, key, keylen, params)
+            && EVP_MAC_update(ctx, data, datalen)
+            && EVP_MAC_final(ctx, out, &len, outsize)) {
+        if (out == NULL) {
+            out = OPENSSL_malloc(len);
+            if (out != NULL && !EVP_MAC_final(ctx, out, NULL, len)) {
+                OPENSSL_free(out);
+                out = NULL;
+            }
+        }
+        res = out;
+        if (res != NULL && outlen != NULL)
+            *outlen = (unsigned int)len;
+    }
+
+ err:
+    EVP_MAC_CTX_free(ctx);
+    EVP_MAC_free(mac);
+    return res;
+}
diff --git a/crypto/hmac/hmac.c b/crypto/hmac/hmac.c
index 6c1a70e4bd..6d142f2cbb 100644
--- a/crypto/hmac/hmac.c
+++ b/crypto/hmac/hmac.c
@@ -17,8 +17,9 @@
 #include <stdlib.h>
 #include <string.h>
 #include "internal/cryptlib.h"
-#include <openssl/hmac.h>
 #include <openssl/opensslconf.h>
+#include <openssl/hmac.h>
+#include <openssl/core_names.h>
 #include "hmac_local.h"
 
 int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
@@ -34,13 +35,12 @@ int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
     if (md != NULL && md != ctx->md && (key == NULL || len < 0))
         return 0;
 
-    if (md != NULL) {
+    if (md != NULL)
         ctx->md = md;
-    } else if (ctx->md) {
+    else if (ctx->md != NULL)
         md = ctx->md;
-    } else {
+    else
         return 0;
-    }
 
     /*
      * The HMAC construction is not allowed to be used with the
@@ -217,34 +217,14 @@ int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx)
 }
 
 unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
-                    const unsigned char *d, size_t n, unsigned char *md,
-                    unsigned int *md_len)
+                    const unsigned char *data, size_t data_len,
+                    unsigned char *md, unsigned int *md_len)
 {
-    HMAC_CTX *c = NULL;
-    static unsigned char m[EVP_MAX_MD_SIZE];
-    static const unsigned char dummy_key[1] = {'\0'};
+    static unsigned char static_md[EVP_MAX_MD_SIZE];
 
-    if (md == NULL)
-        md = m;
-    if ((c = HMAC_CTX_new()) == NULL)
-        goto err;
-
-    /* For HMAC_Init_ex, NULL key signals reuse. */
-    if (key == NULL && key_len == 0) {
-        key = dummy_key;
-    }
-
-    if (!HMAC_Init_ex(c, key, key_len, evp_md, NULL))
-        goto err;
-    if (!HMAC_Update(c, d, n))
-        goto err;
-    if (!HMAC_Final(c, md, md_len))
-        goto err;
-    HMAC_CTX_free(c);
-    return md;
- err:
-    HMAC_CTX_free(c);
-    return NULL;
+    return EVP_Q_mac(NULL, "HMAC", NULL, EVP_MD_name(evp_md), NULL,
+                     key, key_len, data, data_len,
+                     md == NULL ? static_md : md, EVP_MD_size(evp_md), md_len);
 }
 
 void HMAC_CTX_set_flags(HMAC_CTX *ctx, unsigned long flags)
diff --git a/doc/man3/EVP_MAC.pod b/doc/man3/EVP_MAC.pod
index 27930eb89a..f4386f9daf 100644
--- a/doc/man3/EVP_MAC.pod
+++ b/doc/man3/EVP_MAC.pod
@@ -7,8 +7,9 @@ EVP_MAC_number, EVP_MAC_name, EVP_MAC_names_do_all, EVP_MAC_description,
 EVP_MAC_provider, EVP_MAC_get_params, EVP_MAC_gettable_params,
 EVP_MAC_CTX, EVP_MAC_CTX_new, EVP_MAC_CTX_free, EVP_MAC_CTX_dup,
 EVP_MAC_CTX_mac, EVP_MAC_CTX_get_params, EVP_MAC_CTX_set_params,
-EVP_MAC_CTX_get_mac_size, EVP_MAC_init, EVP_MAC_update, EVP_MAC_final,
-EVP_MAC_finalXOF, EVP_MAC_gettable_ctx_params, EVP_MAC_settable_ctx_params,
+EVP_MAC_CTX_get_mac_size, EVP_Q_mac,
+EVP_MAC_init, EVP_MAC_update, EVP_MAC_final, EVP_MAC_finalXOF,
+EVP_MAC_gettable_ctx_params, EVP_MAC_settable_ctx_params,
 EVP_MAC_CTX_gettable_params, EVP_MAC_CTX_settable_params,
 EVP_MAC_do_all_provided - EVP MAC routines
 
@@ -41,6 +42,11 @@ EVP_MAC_do_all_provided - EVP MAC routines
  int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[]);
 
  size_t EVP_MAC_CTX_get_mac_size(EVP_MAC_CTX *ctx);
+ unsigned char *EVP_Q_mac(OSSL_LIB_CTX *libctx, const char *name, const char *propq,
+                          const char *subalg, const OSSL_PARAM *params,
+                          const void *key, size_t keylen,
+                          const unsigned char *data, size_t datalen,
+                          unsigned char *out, size_t outsize, unsigned int *outlen);
  int EVP_MAC_init(EVP_MAC_CTX *ctx, const unsigned char *key, size_t keylen,
                   const OSSL_PARAM params[]);
  int EVP_MAC_update(EVP_MAC_CTX *ctx, const unsigned char *data, size_t datalen);
@@ -119,6 +125,19 @@ I<ctx>.
 
 =head2 Computing functions
 
+EVP_Q_mac() computes the message authentication code
+of I<data> with length I<datalen>
+using the MAC algorithm I<name> and the key I<key> with length I<keylen>.
+The MAC algorithm is fetched using any given I<libctx> and property query
+string I<propq>. It takes parameters I<subalg> and further I<params>,
+both of which may be NULL if not needed.
+If I<out> is not NULL, it places the result in the memory pointed at by I<out>,
+but only if I<outsize> is sufficient (otherwise no computation is made).
+If I<out> is NULL, it allocates and uses a buffer of suitable length,
+which will be returned on success and must be freed by the caller.
+In either case, also on error,
+it assigns the number of bytes written to I<*outlen> unless I<outlen> is NULL.
+
 EVP_MAC_init() sets up the underlying context I<ctx> with information given
 via the I<key> and I<params> arguments.  The MAC I<key> has a length of
 I<keylen> and the parameters in I<params> are processed before setting
@@ -162,6 +181,7 @@ EVP_MAC_CTX_set_params() passes chosen parameters to the underlying
 context, given a context I<ctx>.
 The set of parameters given with I<params> determine exactly what
 parameters are passed down.
+If I<params> are NULL, the unterlying context should do nothing and return 1.
 Note that a parameter that is unknown in the underlying context is
 simply ignored.
 Also, what happens when a needed parameter isn't passed down is
@@ -325,7 +345,7 @@ not be considered a breaking change to the API.
 
 =head1 RETURN VALUES
 
-EVP_MAC_fetch() returns a pointer to a newly fetched EVP_MAC, or
+EVP_MAC_fetch() returns a pointer to a newly fetched B<EVP_MAC>, or
 NULL if allocation failed.
 
 EVP_MAC_up_ref() returns 1 on success, 0 on error.
@@ -351,7 +371,9 @@ EVP_MAC_CTX_free() returns nothing at all.
 EVP_MAC_CTX_get_params() and EVP_MAC_CTX_set_params() return 1 on
 success, 0 on error.
 
-EVP_MAC_init(), EVP_MAC_update(), EVP_MAC_final() and  EVP_MAC_finalXOF()
+EVP_Q_mac() returns a pointer to the computed MAC value, or NULL on error.
+
+EVP_MAC_init(), EVP_MAC_update(), EVP_MAC_final(), and EVP_MAC_finalXOF()
 return 1 on success, 0 on error.
 
 EVP_MAC_CTX_get_mac_size() returns the expected output size, or 0 if it isn't set.
diff --git a/doc/man3/HMAC.pod b/doc/man3/HMAC.pod
index 816d6e325d..5057360253 100644
--- a/doc/man3/HMAC.pod
+++ b/doc/man3/HMAC.pod
@@ -20,14 +20,14 @@ HMAC_size
 
  #include <openssl/hmac.h>
 
+ unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
+                     const unsigned char *data, size_t data_len,
+                     unsigned char *md, unsigned int *md_len);
+
 Deprecated since OpenSSL 3.0, can be hidden entirely by defining
 B<OPENSSL_API_COMPAT> with a suitable version value, see
 L<openssl_user_macros(7)>:
 
- unsigned char *HMAC(const EVP_MD *evp_md, const void *key,
-                     int key_len, const unsigned char *d, size_t n,
-                     unsigned char *md, unsigned int *md_len);
-
  HMAC_CTX *HMAC_CTX_new(void);
  int HMAC_CTX_reset(HMAC_CTX *ctx);
 
@@ -53,28 +53,29 @@ L<openssl_user_macros(7)>:
 
 =head1 DESCRIPTION
 
-All of the functions described on this page are deprecated. Applications should
-instead use L<EVP_MAC_CTX_new(3)>, L<EVP_MAC_CTX_free(3)>, L<EVP_MAC_init(3)>,
-L<EVP_MAC_update(3)> and L<EVP_MAC_final(3)>.
-
 HMAC is a MAC (message authentication code), i.e. a keyed hash
 function used for message authentication, which is based on a hash
 function.
 
-HMAC() computes the message authentication code of the B<n> bytes at
-B<d> using the hash function B<evp_md> and the key B<key> which is
-B<key_len> bytes long.
+HMAC() computes the message authentication code of the I<data_len> bytes at
+I<data> using the hash function I<evp_md> and the key I<key> which is
+I<key_len> bytes long. The I<key> may also be NULL with I<key_len> being 0.
 
-It places the result in B<md> (which must have space for the output of
+It places the result in I<md> (which must have space for the output of
 the hash function, which is no more than B<EVP_MAX_MD_SIZE> bytes).
-If B<md> is NULL, the digest is placed in a static array.  The size of
-the output is placed in B<md_len>, unless it is B<NULL>. Note: passing a NULL
-value for B<md>  to use the static array is not thread safe.
+If I<md> is NULL, the digest is placed in a static array.  The size of
+the output is placed in I<md_len>, unless it is NULL. Note: passing a NULL
+value for I<md> to use the static array is not thread safe.
 
-B<evp_md> is a message digest such as EVP_sha1(), EVP_ripemd160() etc. HMAC does
-not support variable output length digests such as EVP_shake128() and
+I<evp_md> is a message digest such as EVP_sha1(), EVP_ripemd160() etc.
+HMAC does not support variable output length digests such as EVP_shake128() and
 EVP_shake256().
 
+All of the functions described below are deprecated.
+Applications should instead use L<EVP_MAC_CTX_new(3)>, L<EVP_MAC_CTX_free(3)>,
+L<EVP_MAC_init(3)>, L<EVP_MAC_update(3)> and L<EVP_MAC_final(3)>
+or the 'quick' single-shot MAC function L<EVP_Q_mac(3)>.
+
 HMAC_CTX_new() creates a new HMAC_CTX in heap memory.
 
 HMAC_CTX_reset() clears an existing B<HMAC_CTX> and associated
@@ -89,27 +90,27 @@ The following functions may be used if the message is not completely
 stored in memory:
 
 HMAC_Init_ex() initializes or reuses a B<HMAC_CTX> structure to use the hash
-function B<evp_md> and key B<key>. If both are NULL, or if B<key> is NULL
-and B<evp_md> is the same as the previous call, then the
+function I<evp_md> and key I<key>. If both are NULL, or if I<key> is NULL
+and I<evp_md> is the same as the previous call, then the
 existing key is
-reused. B<ctx> must have been created with HMAC_CTX_new() before the first use
+reused. I<ctx> must have been created with HMAC_CTX_new() before the first use
 of an B<HMAC_CTX> in this function.
 
-If HMAC_Init_ex() is called with B<key> NULL and B<evp_md> is not the
-same as the previous digest used by B<ctx> then an error is returned
+If HMAC_Init_ex() is called with I<key> NULL and I<evp_md> is not the
+same as the previous digest used by I<ctx> then an error is returned
 because reuse of an existing key with a different digest is not supported.
 
 HMAC_Init() initializes a B<HMAC_CTX> structure to use the hash
-function B<evp_md> and the key B<key> which is B<key_len> bytes
+function I<evp_md> and the key I<key> which is I<key_len> bytes
 long.
 
 HMAC_Update() can be called repeatedly with chunks of the message to
-be authenticated (B<len> bytes at B<data>).
+be authenticated (I<len> bytes at I<data>).
 
-HMAC_Final() places the message authentication code in B<md>, which
+HMAC_Final() places the message authentication code in I<md>, which
 must have space for the hash function output.
 
-HMAC_CTX_copy() copies all of the internal state from B<sctx> into B<dctx>.
+HMAC_CTX_copy() copies all of the internal state from I<sctx> into I<dctx>.
 
 HMAC_CTX_set_flags() applies the specified flags to the internal EVP_MD_CTXs.
 These flags have the same meaning as for L<EVP_MD_CTX_set_flags(3)>.
@@ -125,7 +126,7 @@ HMAC() returns a pointer to the message authentication code or NULL if
 an error occurred.
 
 HMAC_CTX_new() returns a pointer to a new B<HMAC_CTX> on success or
-B<NULL> if an error occurred.
+NULL if an error occurred.
 
 HMAC_CTX_reset(), HMAC_Init_ex(), HMAC_Update(), HMAC_Final() and
 HMAC_CTX_copy() return 1 for success or 0 if an error occurred.
@@ -142,11 +143,11 @@ RFC 2104
 
 =head1 SEE ALSO
 
-L<SHA1(3)>, L<evp(7)>
+L<SHA1(3)>, EVP_Q_mac(3), L<evp(7)>
 
 =head1 HISTORY
 
-All of these functions were deprecated in OpenSSL 3.0.
+All functions except for HMAC() were deprecated in OpenSSL 3.0.
 
 HMAC_CTX_init() was replaced with HMAC_CTX_reset() in OpenSSL 1.1.0.
 
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 91b84ebf6f..9374e86e66 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -1176,6 +1176,11 @@ int EVP_MAC_CTX_get_params(EVP_MAC_CTX *ctx, OSSL_PARAM params[]);
 int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[]);
 
 size_t EVP_MAC_CTX_get_mac_size(EVP_MAC_CTX *ctx);
+unsigned char *EVP_Q_mac(OSSL_LIB_CTX *libctx, const char *name, const char *propq,
+                         const char *subalg, const OSSL_PARAM *params,
+                         const void *key, size_t keylen,
+                         const unsigned char *data, size_t datalen,
+                         unsigned char *out, size_t outsize, unsigned int *outlen);
 int EVP_MAC_init(EVP_MAC_CTX *ctx, const unsigned char *key, size_t keylen,
                  const OSSL_PARAM params[]);
 int EVP_MAC_update(EVP_MAC_CTX *ctx, const unsigned char *data, size_t datalen);
diff --git a/include/openssl/hmac.h b/include/openssl/hmac.h
index f2f502ea5c..f9e1bff3f7 100644
--- a/include/openssl/hmac.h
+++ b/include/openssl/hmac.h
@@ -27,6 +27,7 @@
 # ifdef  __cplusplus
 extern "C" {
 # endif
+
 # ifndef OPENSSL_NO_DEPRECATED_3_0
 OSSL_DEPRECATEDIN_3_0 size_t HMAC_size(const HMAC_CTX *e);
 OSSL_DEPRECATEDIN_3_0 HMAC_CTX *HMAC_CTX_new(void);
@@ -45,15 +46,15 @@ OSSL_DEPRECATEDIN_3_0 int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data,
                                       size_t len);
 OSSL_DEPRECATEDIN_3_0 int HMAC_Final(HMAC_CTX *ctx, unsigned char *md,
                                      unsigned int *len);
-OSSL_DEPRECATEDIN_3_0 unsigned char *HMAC(const EVP_MD *evp_md, const void *key,
-                                          int key_len, const unsigned char *d,
-                                          size_t n, unsigned char *md,
-                                          unsigned int *md_len);
 OSSL_DEPRECATEDIN_3_0 __owur int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx);
 OSSL_DEPRECATEDIN_3_0 void HMAC_CTX_set_flags(HMAC_CTX *ctx, unsigned long flags);
 OSSL_DEPRECATEDIN_3_0 const EVP_MD *HMAC_CTX_get_md(const HMAC_CTX *ctx);
 # endif
 
+unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
+                    const unsigned char *data, size_t data_len,
+                    unsigned char *md, unsigned int *md_len);
+
 # ifdef  __cplusplus
 }
 # endif
diff --git a/providers/fips-sources.checksums b/providers/fips-sources.checksums
index e6d798648a..6175384c2d 100644
--- a/providers/fips-sources.checksums
+++ b/providers/fips-sources.checksums
@@ -180,7 +180,7 @@ c0f87865be8dab6ea909fd976e5a46e4e8343b18403090c4a59b2af90f9a1329  crypto/evp/evp
 2d657d8de8c2441693d54ef3730d83ca4b5d76c3b3405ece89bff9e46149d670  crypto/evp/keymgmt_lib.c
 56d3ed4313cb811a3c2d062ff8b2a0fd67c4b0d28fe0562a57555b3a95907535  crypto/evp/keymgmt_meth.c
 9fd78bfd59378fc4a9f56ce474310d8d2851aa42862c694ee0e47b175e836c51  crypto/evp/m_sigver.c
-0f5e0cd5c66712803a19774610f6bdfe572f5dda08c58cdf1b19d38a0693911c  crypto/evp/mac_lib.c
+ec959b00487bfc51f4cf33c21a60fd8a73087a622504f459ba4cfe48bb0a738c  crypto/evp/mac_lib.c
 5f4b933a479d7cd589c47388aebfd8d6ffa3943ec2883049fc929e6ca37e26b5  crypto/evp/mac_meth.c
 f5a18107256e00e2eed6a9b54eaf44ef1b99c0f29134e9f363a09daa2d35f1b5  crypto/evp/p_lib.c
 b7e9ce6e8a35e0fc5b4eb4c047cda1e811b757669dbfafa71e743d85e07817a4  crypto/evp/pmeth_check.c
@@ -195,7 +195,7 @@ ead786b4f5689ab69d6cca5d49e513e0f90cb558b67e6c5898255f2671f1393d  crypto/ffc/ffc
 a87945698684673832fbedb4d01e2f11df58f43f79605a9e6d7136bb15b02e52  crypto/ffc/ffc_params.c
 887357f0422954f2ecb855d468ad2456a76372dc401301ba284c0fd8c6b5092e  crypto/ffc/ffc_params_generate.c
 73dac805abab36cd9df53a421221c71d06a366a4ce479fa788be777f11b47159  crypto/ffc/ffc_params_validate.c
-84d8ae0141a79548ad65b31fe4673e8603930f942f21f3a7623e23f539799764  crypto/hmac/hmac.c
+c193773792bec29c791e84d150ffe5ef25f53cb02e23f0e12e9000234b4322e5  crypto/hmac/hmac.c
 7000ba81f54c1d516a536bc6e96ad3729e3b5b15740006c2e22f0b76606042d6  crypto/initthread.c
 c6c83f826eb6465f2a1b186ea692ff6fe32dbfb821d18d254625b69083d68fb0  crypto/lhash/lhash.c
 f866aafae928db1b439ac950dc90744a2397dfe222672fe68b3798396190c8b0  crypto/mem_clr.c
@@ -362,7 +362,7 @@ de342d04be6af69037922d5c97bdc40c0c27f6740636e72786a765d0d8ad9173  providers/impl
 427b9abee979f94371aa4aa99b48f08f1772965c93f9bce6f4531cc4cec136b6  providers/implementations/exchange/ecdh_exch.c
 9bf87b8429398a6465c7e9f749a33b84974303a458736b56f3359b30726d3969  providers/implementations/exchange/ecx_exch.c
 06ba83a8a8235bcdbda56f82b017cb19361469fe47c23cc6218a7e9b88ae6513  providers/implementations/exchange/kdf_exch.c
-4f8049771ff0cb57944e1ffc9599a96023e36b424138e51b1466f9a133f03943  providers/implementations/kdfs/hkdf.c
+9b9e7937be361de8e3c3fa9a2ef17edde8a0a4391bf55c72ff9785c1e4ee7dfc  providers/implementations/kdfs/hkdf.c
 115e13e152cfb7d729659cb26056414f719c5e7cb2a9b3df8b6ad0f232ce109a  providers/implementations/kdfs/kbkdf.c
 f93d3b32e7e3bc6bd4100559b15d392613797e1048010fdc70058ae9297a1125  providers/implementations/kdfs/pbkdf2.c
 abe2b0f3711eaa34846e155cffc9242e4051c45de896f747afd5ac9d87f637dc  providers/implementations/kdfs/pbkdf2_fips.c
diff --git a/providers/fips.checksum b/providers/fips.checksum
index 4ee2135be1..50a9c51b5c 100644
--- a/providers/fips.checksum
+++ b/providers/fips.checksum
@@ -1 +1 @@
-a1ce185646a78b5eb88229b77aec1455e6e361f7428bb884aebe45cb8fdc3703  providers/fips-sources.checksums
+4d501c5fb8a5646c618eb02511a7a1ffab71823f6adee558ee30df8bb4bd6f40  providers/fips-sources.checksums
diff --git a/providers/implementations/kdfs/hkdf.c b/providers/implementations/kdfs/hkdf.c
index 2d3c72f501..ce0c81c1d2 100644
--- a/providers/implementations/kdfs/hkdf.c
+++ b/providers/implementations/kdfs/hkdf.c
@@ -41,12 +41,12 @@ static OSSL_FUNC_kdf_set_ctx_params_fn kdf_hkdf_set_ctx_params;
 static OSSL_FUNC_kdf_gettable_ctx_params_fn kdf_hkdf_gettable_ctx_params;
 static OSSL_FUNC_kdf_get_ctx_params_fn kdf_hkdf_get_ctx_params;
 
-static int HKDF(const EVP_MD *evp_md,
+static int HKDF(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
                 const unsigned char *salt, size_t salt_len,
                 const unsigned char *key, size_t key_len,
                 const unsigned char *info, size_t info_len,
                 unsigned char *okm, size_t okm_len);
-static int HKDF_Extract(const EVP_MD *evp_md,
+static int HKDF_Extract(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
                         const unsigned char *salt, size_t salt_len,
                         const unsigned char *ikm, size_t ikm_len,
                         unsigned char *prk, size_t prk_len);
@@ -127,6 +127,7 @@ static int kdf_hkdf_derive(void *vctx, unsigned char *key, size_t keylen,
                            const OSSL_PARAM params[])
 {
     KDF_HKDF *ctx = (KDF_HKDF *)vctx;
+    OSSL_LIB_CTX *libctx = PROV_LIBCTX_OF(ctx->provctx);
     const EVP_MD *md;
 
     if (!ossl_prov_is_running() || !kdf_hkdf_set_ctx_params(ctx, params))
@@ -148,13 +149,12 @@ static int kdf_hkdf_derive(void *vctx, unsigned char *key, size_t keylen,
 
     switch (ctx->mode) {
     case EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND:
-        return HKDF(md, ctx->salt, ctx->salt_len, ctx->key,
-                    ctx->key_len, ctx->info, ctx->info_len, key,
-                    keylen);
+        return HKDF(libctx, md, ctx->salt, ctx->salt_len,
+                    ctx->key, ctx->key_len, ctx->info, ctx->info_len, key, keylen);
 
     case EVP_KDF_HKDF_MODE_EXTRACT_ONLY:
-        return HKDF_Extract(md, ctx->salt, ctx->salt_len, ctx->key,
-                            ctx->key_len, key, keylen);
+        return HKDF_Extract(libctx, md, ctx->salt, ctx->salt_len,
+                            ctx->key, ctx->key_len, key, keylen);
 
     case EVP_KDF_HKDF_MODE_EXPAND_ONLY:
         return HKDF_Expand(md, ctx->key, ctx->key_len, ctx->info,
@@ -169,13 +169,13 @@ static int kdf_hkdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
 {
     const OSSL_PARAM *p;
     KDF_HKDF *ctx = vctx;
-    OSSL_LIB_CTX *provctx = PROV_LIBCTX_OF(ctx->provctx);
+    OSSL_LIB_CTX *libctx = PROV_LIBCTX_OF(ctx->provctx);
     int n;
 
     if (params == NULL)
         return 1;
 
-    if (!ossl_prov_digest_load_from_params(&ctx->digest, params, provctx))
+    if (!ossl_prov_digest_load_from_params(&ctx->digest, params, libctx))
         return 0;
 
     if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_MODE)) != NULL) {
@@ -316,7 +316,7 @@ const OSSL_DISPATCH ossl_kdf_hkdf_functions[] = {
  *   2.3.  Step 2: Expand
  *     HKDF-Expand(PRK, info, L) -> OKM
  */
-static int HKDF(const EVP_MD *evp_md,
+static int HKDF(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
                 const unsigned char *salt, size_t salt_len,
                 const unsigned char *ikm, size_t ikm_len,
                 const unsigned char *info, size_t info_len,
@@ -332,7 +332,8 @@ static int HKDF(const EVP_MD *evp_md,
     prk_len = (size_t)sz;
 
     /* Step 1: HKDF-Extract(salt, IKM) -> PRK */
-    if (!HKDF_Extract(evp_md, salt, salt_len, ikm, ikm_len, prk, prk_len))
+    if (!HKDF_Extract(libctx, evp_md,
+                      salt, salt_len, ikm, ikm_len, prk, prk_len))
         return 0;
 
     /* Step 2: HKDF-Expand(PRK, info, L) -> OKM */
@@ -366,7 +367,7 @@ static int HKDF(const EVP_MD *evp_md,
  *
  *   PRK = HMAC-Hash(salt, IKM)
  */
-static int HKDF_Extract(const EVP_MD *evp_md,
+static int HKDF_Extract(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
                         const unsigned char *salt, size_t salt_len,
                         const unsigned char *ikm, size_t ikm_len,
                         unsigned char *prk, size_t prk_len)
@@ -380,7 +381,10 @@ static int HKDF_Extract(const EVP_MD *evp_md,
         return 0;
     }
     /* calc: PRK = HMAC-Hash(salt, IKM) */
-    return HMAC(evp_md, salt, salt_len, ikm, ikm_len, prk, NULL) != NULL;
+    return
+        EVP_Q_mac(libctx, "HMAC", NULL, EVP_MD_name(evp_md), NULL, salt,
+                  salt_len, ikm, ikm_len, prk, EVP_MD_size(evp_md), NULL)
+        != NULL;
 }
 
 /*
diff --git a/ssl/tls13_enc.c b/ssl/tls13_enc.c
index f88d59948d..dba1e5fb8c 100644
--- a/ssl/tls13_enc.c
+++ b/ssl/tls13_enc.c
@@ -306,22 +306,14 @@ size_t tls13_final_finish_mac(SSL *s, const char *str, size_t slen,
                              unsigned char *out)
 {
     const char *mdname = EVP_MD_name(ssl_handshake_md(s));
-    EVP_MAC *hmac = EVP_MAC_fetch(s->ctx->libctx, "HMAC", s->ctx->propq);
     unsigned char hash[EVP_MAX_MD_SIZE];
     unsigned char finsecret[EVP_MAX_MD_SIZE];
     unsigned char *key = NULL;
+    unsigned int len = 0;
     size_t hashlen, ret = 0;
-    EVP_MAC_CTX *ctx = NULL;
-    OSSL_PARAM params[3], *p = params;
-
-    if (hmac == NULL) {
-        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
-        goto err;
-    }
+    OSSL_PARAM params[2], *p = params;
 
     /* Safe to cast away const here since we're not "getting" any data */
-    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_DIGEST,
-                                            (char *)mdname, 0);
     if (s->ctx->propq != NULL)
         *p++ = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_PROPERTIES,
                                                 (char *)s->ctx->propq,
@@ -345,21 +337,17 @@ size_t tls13_final_finish_mac(SSL *s, const char *str, size_t slen,
         key = finsecret;
     }
 
-    ctx = EVP_MAC_CTX_new(hmac);
-    if (ctx == NULL
-            || !EVP_MAC_init(ctx, key, hashlen, params)
-            || !EVP_MAC_update(ctx, hash, hashlen)
-               /* outsize as per sizeof(peer_finish_md) */
-            || !EVP_MAC_final(ctx, out, &hashlen, EVP_MAX_MD_SIZE * 2)) {
+    if (!EVP_Q_mac(s->ctx->libctx, "HMAC", s->ctx->propq, mdname,
+                   params, key, hashlen, hash, hashlen,
+                   /* outsize as per sizeof(peer_finish_md) */
+                   out, EVP_MAX_MD_SIZE * 2, &len)) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
-    ret = hashlen;
+    ret = len;
  err:
     OPENSSL_cleanse(finsecret, sizeof(finsecret));
-    EVP_MAC_CTX_free(ctx);
-    EVP_MAC_free(hmac);
     return ret;
 }
 
diff --git a/test/hmactest.c b/test/hmactest.c
index babfb0e1a7..918ae0b005 100644
--- a/test/hmactest.c
+++ b/test/hmactest.c
@@ -100,10 +100,7 @@ static int test_hmac_md5(int idx)
                 test[idx].data, test[idx].data_len, NULL, NULL),
                 MD5_DIGEST_LENGTH);
 
-    if (!TEST_str_eq(p, test[idx].digest))
-      return 0;
-
-    return 1;
+    return TEST_ptr(p) && TEST_str_eq(p, test[idx].digest);
 }
 # endif
 
@@ -151,7 +148,7 @@ static int test_hmac_run(void)
         goto err;
 
     p = pt(buf, len);
-    if (!TEST_str_eq(p, test[4].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[4].digest))
         goto err;
 
     if (!TEST_false(HMAC_Init_ex(ctx, NULL, 0, EVP_sha256(), NULL)))
@@ -164,7 +161,7 @@ static int test_hmac_run(void)
         goto err;
 
     p = pt(buf, len);
-    if (!TEST_str_eq(p, test[5].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[5].digest))
         goto err;
 
     if (!TEST_true(HMAC_Init_ex(ctx, test[6].key, test[6].key_len, NULL, NULL))
@@ -172,7 +169,7 @@ static int test_hmac_run(void)
         || !TEST_true(HMAC_Final(ctx, buf, &len)))
         goto err;
     p = pt(buf, len);
-    if (!TEST_str_eq(p, test[6].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[6].digest))
         goto err;
 
     /* Test reusing a key */
@@ -181,7 +178,7 @@ static int test_hmac_run(void)
         || !TEST_true(HMAC_Final(ctx, buf, &len)))
         goto err;
     p = pt(buf, len);
-    if (!TEST_str_eq(p, test[6].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[6].digest))
         goto err;
 
     /*
@@ -193,7 +190,7 @@ static int test_hmac_run(void)
         || !TEST_true(HMAC_Final(ctx, buf, &len)))
         goto err;
     p = pt(buf, len);
-    if (!TEST_str_eq(p, test[6].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[6].digest))
         goto err;
 
     ret = 1;
@@ -207,10 +204,10 @@ static int test_hmac_single_shot(void)
 {
     char *p;
 
-    /* Test single-shot with an empty key. */
+    /* Test single-shot with NULL key. */
     p = pt(HMAC(EVP_sha1(), NULL, 0, test[4].data, test[4].data_len,
                 NULL, NULL), SHA_DIGEST_LENGTH);
-    if (!TEST_str_eq(p, test[4].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[4].digest))
         return 0;
 
     return 1;
@@ -237,7 +234,7 @@ static int test_hmac_copy(void)
         goto err;
 
     p = pt(buf, len);
-    if (!TEST_str_eq(p, test[7].digest))
+    if (!TEST_ptr(p) || !TEST_str_eq(p, test[7].digest))
         goto err;
 
     ret = 1;
@@ -253,6 +250,8 @@ static char *pt(unsigned char *md, unsigned int len)
     unsigned int i;
     static char buf[80];
 
+    if (md == NULL)
+        return NULL;
     for (i = 0; i < len; i++)
         sprintf(&(buf[i * 2]), "%02x", md[i]);
     return buf;
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 13ec6e26f7..2e89c5dd26 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -2028,7 +2028,7 @@ MDC2_Init                               2075	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 i2o_SCT                                 2076	3_0_0	EXIST::FUNCTION:CT
 d2i_TS_STATUS_INFO                      2077	3_0_0	EXIST::FUNCTION:TS
 ERR_error_string_n                      2078	3_0_0	EXIST::FUNCTION:
-HMAC                                    2079	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
+HMAC                                    2079	3_0_0	EXIST::FUNCTION:
 BN_mul                                  2080	3_0_0	EXIST::FUNCTION:
 BN_get0_nist_prime_384                  2081	3_0_0	EXIST::FUNCTION:
 X509_VERIFY_PARAM_set1_ip_asc           2082	3_0_0	EXIST::FUNCTION:
@@ -4408,6 +4408,7 @@ EVP_MAC_CTX_free                        ?	3_0_0	EXIST::FUNCTION:
 EVP_MAC_CTX_dup                         ?	3_0_0	EXIST::FUNCTION:
 EVP_MAC_CTX_mac                         ?	3_0_0	EXIST::FUNCTION:
 EVP_MAC_CTX_get_mac_size                ?	3_0_0	EXIST::FUNCTION:
+EVP_Q_mac                               ?	3_0_0	EXIST::FUNCTION:
 EVP_MAC_init                            ?	3_0_0	EXIST::FUNCTION:
 EVP_MAC_update                          ?	3_0_0	EXIST::FUNCTION:
 EVP_MAC_final                           ?	3_0_0	EXIST::FUNCTION:

[DF] commit bfe2fcc840e92df5a5875e55c6aed79891d2612f
Author: Tomas Mraz <tomas@openssl.org>
Date:   Tue May 4 15:38:48 2021 +0200

    evp_extra_test: Avoid potential double free of params
    
    Fixes #14916
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15135)

diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index f8fdc7287d..7fd45bc316 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -688,6 +688,7 @@ static int test_EC_priv_pub(void)
     if (!test_fromdata("EC", params))
         goto err;
     OSSL_PARAM_free(params);
+    params = NULL;
     OSSL_PARAM_BLD_free(bld);
 
     /* Test priv and !pub */
@@ -704,6 +705,7 @@ static int test_EC_priv_pub(void)
     if (!test_fromdata("EC", params))
         goto err;
     OSSL_PARAM_free(params);
+    params = NULL;
     OSSL_PARAM_BLD_free(bld);
 
     /* Test !priv and pub */
@@ -721,6 +723,7 @@ static int test_EC_priv_pub(void)
     if (!test_fromdata("EC", params))
         goto err;
     OSSL_PARAM_free(params);
+    params = NULL;
     OSSL_PARAM_BLD_free(bld);
 
     /* Test priv and pub */

[ML] commit 857c223bf73f6d3ec91567cf341c5267392a3e66
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Wed Apr 28 17:22:50 2021 +1000

    Fix memory leak in load_key_certs_crls() when using stdin.
    
    A newly created BIO object within this function calls
    OSSL_STORE_attach() which increases the ref count to 2.
    OSSL_STORE_close() then decrements the ref count by 1, so the BIO still
    remains.
    
    The following new test was picking up this leak using..
    > valgrind openssl crl -hash -noout < test/testcrl.pem
    
    Not quite sure why the existing tests were not picking this up
    since they appear to run through a similiar path.. such as
    > valgrind openssl pkey < test-runs/test_rsa/rsa-pkcs8-ff.dd
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15058)

diff --git a/apps/lib/apps.c b/apps/lib/apps.c
index 1ca6f6e096..d715e25ff1 100644
--- a/apps/lib/apps.c
+++ b/apps/lib/apps.c
@@ -924,9 +924,11 @@ int load_key_certs_crls(const char *uri, int maybe_stdin,
         uri = "<stdin>";
         unbuffer(stdin);
         bio = BIO_new_fp(stdin, 0);
-        if (bio != NULL)
+        if (bio != NULL) {
             ctx = OSSL_STORE_attach(bio, "file", libctx, propq,
                                     get_ui_method(), &uidata, NULL, NULL);
+            BIO_free(bio);
+        }
     } else {
         ctx = OSSL_STORE_open_ex(uri, libctx, propq, get_ui_method(), &uidata,
                                  NULL, NULL);

commit e466dc3646bc15fa928366a2c64ed987daab5b2c
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Wed Apr 21 13:49:29 2021 +1000

    Test that we don't have a memory leak in d2i_ASN1_OBJECT.
    
    Fixes #14667
    
    Reworked test supplied by @smcpeak into a unit test.
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14938)
    
    (cherry picked from commit 7c65179ad95d0f6f598ee82e763fce2567fe5802)

diff --git a/test/asn1_decode_test.c b/test/asn1_decode_test.c
index c6e1501fa1..3a3ad525ae 100644
--- a/test/asn1_decode_test.c
+++ b/test/asn1_decode_test.c
@@ -12,6 +12,7 @@
 
 #include <openssl/rand.h>
 #include <openssl/asn1t.h>
+#include <openssl/obj_mac.h>
 #include "internal/numbers.h"
 #include "testutil.h"
 
@@ -195,6 +196,30 @@ static int test_invalid_template(void)
     return 0;
 }
 
+static int test_reuse_asn1_object(void)
+{
+    static unsigned char cn_der[] = { 0x06, 0x03, 0x55, 0x04, 0x06 };
+    static unsigned char oid_der[] = {
+        0x06, 0x06, 0x2a, 0x03, 0x04, 0x05, 0x06, 0x07
+    };
+    int ret = 0;
+    ASN1_OBJECT *obj;
+    unsigned char const *p = oid_der;
+
+    /* Create an object that owns dynamically allocated 'sn' and 'ln' fields */
+
+    if (!TEST_ptr(obj = ASN1_OBJECT_create(NID_undef, cn_der, sizeof(cn_der),
+                                           "C", "countryName")))
+        goto err;
+    /* reuse obj - this should not leak sn and ln */
+    if (!TEST_ptr(d2i_ASN1_OBJECT(&obj, &p, sizeof(oid_der))))
+        goto err;
+    ret = 1;
+err:
+    ASN1_OBJECT_free(obj);
+    return ret;
+}
+
 int setup_tests(void)
 {
 #ifndef OPENSSL_NO_DEPRECATED_3_0
@@ -205,5 +230,6 @@ int setup_tests(void)
     ADD_TEST(test_int64);
     ADD_TEST(test_uint64);
     ADD_TEST(test_invalid_template);
+    ADD_TEST(test_reuse_asn1_object);
     return 1;
 }

[ML] commit 1727465471e800548694da96b8970743b7efa7ff
Author: Richard Levitte <levitte@openssl.org>
Date:   Tue Apr 20 08:43:30 2021 +0200

    ASN1: Ensure that d2i_ASN1_OBJECT() frees the strings on ASN1_OBJECT reuse
    
    The 'sn' and 'ln' strings may be dynamically allocated, and the
    ASN1_OBJECT flags have a bit set to say this.  If an ASN1_OBJECT with
    such strings is passed to d2i_ASN1_OBJECT() for reuse, the strings
    must be freed, or there is a memory leak.
    
    Fixes #14667
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14938)
    
    (cherry picked from commit 65b88a75921533ada8b465bc8d5c0817ad927947)

diff --git a/crypto/asn1/a_object.c b/crypto/asn1/a_object.c
index 3740f608c5..c96c36e730 100644
--- a/crypto/asn1/a_object.c
+++ b/crypto/asn1/a_object.c
@@ -291,16 +291,13 @@ ASN1_OBJECT *ossl_c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
         }
     }
 
-    /*
-     * only the ASN1_OBJECTs from the 'table' will have values for ->sn or
-     * ->ln
-     */
     if ((a == NULL) || ((*a) == NULL) ||
         !((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
         if ((ret = ASN1_OBJECT_new()) == NULL)
             return NULL;
-    } else
+    } else {
         ret = (*a);
+    }
 
     p = *pp;
     /* detach data from object */
@@ -318,6 +315,12 @@ ASN1_OBJECT *ossl_c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
         ret->flags |= ASN1_OBJECT_FLAG_DYNAMIC_DATA;
     }
     memcpy(data, p, length);
+    /* If there are dynamic strings, free them here, and clear the flag */
+    if ((ret->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) != 0) {
+        OPENSSL_free((char *)ret->sn);
+        OPENSSL_free((char *)ret->ln);
+        ret->flags &= ~ASN1_OBJECT_FLAG_DYNAMIC_STRINGS;
+    }
     /* reattach data to object, after which it remains const */
     ret->data = data;
     ret->length = length;

[ML] commit a2502862f679c82b794869ac88ed0d8ca7bc291c
Author: Petr Gotthard <petr.gotthard@centrum.cz>
Date:   Sat Apr 17 14:58:30 2021 +0200

    Fix memory leak in X509_REQ
    
    The propq is strdup'ed in X509_REQ_new_ex, but never freed.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14907)

diff --git a/crypto/x509/x_req.c b/crypto/x509/x_req.c
index edbe8cd72b..1b4e1587dd 100644
--- a/crypto/x509/x_req.c
+++ b/crypto/x509/x_req.c
@@ -60,6 +60,7 @@ static int req_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
 
     case ASN1_OP_FREE_POST:
         ASN1_OCTET_STRING_free(ret->distinguishing_id);
+        OPENSSL_free(ret->propq);
         break;
     case ASN1_OP_DUP_POST:
         {

[DF] commit 4e030ed45dbf56be2f09d86f76f697ae6a0c567f
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Mon Apr 19 16:03:53 2021 +0200

    apps/cmp.c: Fix double free on OSSL_CMP_CTX_set1_p10CSR() failure
    
    Fixes #14910
    Also slightly improve further error handling of setup_request_ctx().
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14929)

diff --git a/apps/cmp.c b/apps/cmp.c
index 644fb545d2..da28c3215e 100644
--- a/apps/cmp.c
+++ b/apps/cmp.c
@@ -1580,18 +1580,15 @@ static int setup_request_ctx(OSSL_CMP_CTX *ctx, ENGINE *engine)
         if (opt_cmd == CMP_GENM) {
             CMP_warn("-csr option is ignored for command 'genm'");
         } else {
-            csr = load_csr_autofmt(opt_csr, "PKCS#10 CSR");
-            if (csr == NULL)
+            if ((csr = load_csr_autofmt(opt_csr, "PKCS#10 CSR")) == NULL)
                 return 0;
-            if (!OSSL_CMP_CTX_set1_p10CSR(ctx, csr)) {
-                X509_REQ_free(csr);
+            if (!OSSL_CMP_CTX_set1_p10CSR(ctx, csr))
                 goto oom;
-            }
         }
     }
     if (opt_reqexts != NULL || opt_policies != NULL) {
         if ((exts = sk_X509_EXTENSION_new_null()) == NULL)
-            goto exts_err;
+            goto oom;
         X509V3_set_ctx(&ext_ctx, NULL, NULL, csr, NULL, X509V3_CTX_REPLACE);
         X509V3_set_nconf(&ext_ctx, conf);
         if (opt_reqexts != NULL
@@ -1607,15 +1604,14 @@ static int setup_request_ctx(OSSL_CMP_CTX *ctx, ENGINE *engine)
             goto exts_err;
         }
         OSSL_CMP_CTX_set0_reqExtensions(ctx, exts);
-        exts = NULL;
     }
     X509_REQ_free(csr);
-    csr = NULL;
+    /* After here, must not goto oom/exts_err */
+
     if (OSSL_CMP_CTX_reqExtensions_have_SAN(ctx) && opt_sans != NULL) {
         CMP_err("cannot have Subject Alternative Names both via -reqexts and via -sans");
         return 0;
     }
-
     if (!set_gennames(ctx, opt_sans, "Subject Alternative Name"))
         return 0;
 
@@ -1675,7 +1671,8 @@ static int setup_request_ctx(OSSL_CMP_CTX *ctx, ENGINE *engine)
                 return 0;
             if (!OSSL_CMP_CTX_set1_oldCert(ctx, oldcert)) {
                 X509_free(oldcert);
-                goto oom;
+                CMP_err("out of memory");
+                return 0;
             }
             X509_free(oldcert);
         }

[DF] commit 6bcbc3698557739da03495920a57be4ffe219fa4
Author: Pauli <pauli@openssl.org>
Date:   Mon Apr 19 08:59:37 2021 +1000

    test: fix double free problems.
    
    In function test_EVP_PKEY_ffc_priv_pub, params is freed via OSSL_PARAM_free() at line 577.
    If the condition at line 581 is true, the execution will goto err, and params will be freed again at line 630.
    
    The same problem also happens at line 593 and line 609, which causes two double free bugs.
    
    Bugs reported by @Yunlongs
    
    Fixes 14916
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14921)

diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index 6140e16e26..a290878a7d 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -575,6 +575,7 @@ static int test_EVP_PKEY_ffc_priv_pub(char *keytype)
     if (!test_fromdata(keytype, params))
         goto err;
     OSSL_PARAM_free(params);
+    params = NULL;
     OSSL_PARAM_BLD_free(bld);
 
     /* Test priv and !pub */
@@ -591,6 +592,7 @@ static int test_EVP_PKEY_ffc_priv_pub(char *keytype)
     if (!test_fromdata(keytype, params))
         goto err;
     OSSL_PARAM_free(params);
+    params = NULL;
     OSSL_PARAM_BLD_free(bld);
 
     /* Test !priv and pub */
@@ -607,6 +609,7 @@ static int test_EVP_PKEY_ffc_priv_pub(char *keytype)
     if (!test_fromdata(keytype, params))
         goto err;
     OSSL_PARAM_free(params);
+    params = NULL;
     OSSL_PARAM_BLD_free(bld);
 
     /* Test priv and pub */

[DF] commit efe8d69daa1a68be0a7f0f73220947c848e7ed1d
Author: Pauli <pauli@openssl.org>
Date:   Mon Apr 19 08:57:18 2021 +1000

    engine: fix double free on error path.
    
    In function try_decode_PKCS8Encrypted, p8 is freed via X509_SIG_free() at line 481.
    If function new_EMBEDDED() returns a null pointer at line 483, the execution will goto nop8.
    In the nop8 branch, p8 is freed again at line 491.
    
    Bug reported by @Yunlongs
    
    Fixes #14915
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14921)

diff --git a/engines/e_loader_attic.c b/engines/e_loader_attic.c
index 3ec31f8fc7..802b3d9067 100644
--- a/engines/e_loader_attic.c
+++ b/engines/e_loader_attic.c
@@ -479,6 +479,7 @@ static OSSL_STORE_INFO *try_decode_PKCS8Encrypted(const char *pem_name,
     mem->data = (char *)new_data;
     mem->max = mem->length = (size_t)new_data_len;
     X509_SIG_free(p8);
+    p8 = NULL;
 
     store_info = new_EMBEDDED(PEM_STRING_PKCS8INF, mem);
     if (store_info == NULL) {

[DF] commit db78c84eb2fa9c41124690bcc2ea50e05f5fc7b7
Author: Pauli <pauli@openssl.org>
Date:   Mon Apr 19 08:55:37 2021 +1000

    ts: fix double free on error path.
    
    In function int_ts_RESP_verify_token, if (flags & TS_VFY_DATA) is true, function ts_compute_imprint() will be called at line 299.
    In the implementation of ts_compute_imprint, it allocates md_alg at line 406.
    But after the allocation, if the execution goto err, then md_alg will be freed in the first time by X509_ALGOR_free at line 439.
    
    After that, ts_compute_imprint returns 0 and the execution goto err branch of int_ts_RESP_verify_token.
    In the err branch, md_alg will be freed in the second time at line 320.
    
    Bug reported by @Yunlongs
    
    Fixes #14914
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14921)

diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c
index 89428cdf54..f307e29fda 100644
--- a/crypto/ts/ts_rsp_verify.c
+++ b/crypto/ts/ts_rsp_verify.c
@@ -437,6 +437,7 @@ static int ts_compute_imprint(BIO *data, TS_TST_INFO *tst_info,
  err:
     EVP_MD_CTX_free(md_ctx);
     X509_ALGOR_free(*md_alg);
+    *md_alg = NULL;
     OPENSSL_free(*imprint);
     *imprint_len = 0;
     *imprint = 0;

[DF] commit b06450bcf763735a89b65ca3ec176600fe7fceed
Author: Pauli <pauli@openssl.org>
Date:   Mon Apr 19 08:51:38 2021 +1000

    srp: fix double free,
    
    In function SRP_create_verifier_ex, it calls SRP_create_verifier_BN_ex(..., &v, ..) at line 653.
    In the implementation of SRP_create_verifier_BN_ex(), *verify (which is the paremeter of v) is allocated a pointer via BN_new() at line 738.
    And *verify is freed via BN_clear_free() at line 743, and return 0.
    Then the execution continues up to goto err at line 655, and the freed v is freed again at line 687.
    
    Bug reported by @Yunlongs
    
    Fixes #14913
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14921)

diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c
index 0693a23be0..2c2ec11cd4 100644
--- a/crypto/srp/srp_vfy.c
+++ b/crypto/srp/srp_vfy.c
@@ -712,7 +712,7 @@ int SRP_create_verifier_BN_ex(const char *user, const char *pass, BIGNUM **salt,
     BIGNUM *x = NULL;
     BN_CTX *bn_ctx = BN_CTX_new_ex(libctx);
     unsigned char tmp2[MAX_LEN];
-    BIGNUM *salttmp = NULL;
+    BIGNUM *salttmp = NULL, *verif;
 
     if ((user == NULL) ||
         (pass == NULL) ||
@@ -735,17 +735,18 @@ int SRP_create_verifier_BN_ex(const char *user, const char *pass, BIGNUM **salt,
     if (x == NULL)
         goto err;
 
-    *verifier = BN_new();
-    if (*verifier == NULL)
+    verif = BN_new();
+    if (verif == NULL)
         goto err;
 
-    if (!BN_mod_exp(*verifier, g, x, N, bn_ctx)) {
-        BN_clear_free(*verifier);
+    if (!BN_mod_exp(verif, g, x, N, bn_ctx)) {
+        BN_clear_free(verif);
         goto err;
     }
 
     result = 1;
     *salt = salttmp;
+    *verifier = verif;
 
  err:
     if (salt != NULL && *salt != salttmp)

[DF] commit 493e78986f9677c2b321273da51c276b9a8182d8
Author: Nan Xiao <nan@chinadtrace.org>
Date:   Thu Apr 1 13:55:04 2021 +0800

    Fix potential double free in sslapitest.c
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14758)

diff --git a/test/sslapitest.c b/test/sslapitest.c
index 3e5d532bf4..31b36b23b1 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -2743,8 +2743,10 @@ static int execute_test_ssl_bio(int pop_ssl, bio_change_t change_bio)
 
     /* Verify changing the rbio/wbio directly does not cause leaks */
     if (change_bio != NO_BIO_CHANGE) {
-        if (!TEST_ptr(membio2 = BIO_new(BIO_s_mem())))
+        if (!TEST_ptr(membio2 = BIO_new(BIO_s_mem()))) {
+            ssl = NULL;
             goto end;
+        }
         if (change_bio == CHANGE_RBIO)
             SSL_set0_rbio(ssl, membio2);
         else

[UAF] commit 39f6bf33e5852be55b126c3fcc56e3ef5ab1a584
Author: Pauli <ppzgs1@gmail.com>
Date:   Thu Mar 18 14:08:06 2021 +1000

    test: fix Coverity 1454818: use after free
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14597)

diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c
index 380f0727fc..9739cb58c4 100644
--- a/test/cipherlist_test.c
+++ b/test/cipherlist_test.c
@@ -205,8 +205,10 @@ static int test_default_cipherlist_explicit(void)
 {
     SETUP_CIPHERLIST_TEST_FIXTURE();
     if (!TEST_true(SSL_CTX_set_cipher_list(fixture->server, "DEFAULT"))
-            || !TEST_true(SSL_CTX_set_cipher_list(fixture->client, "DEFAULT")))
+            || !TEST_true(SSL_CTX_set_cipher_list(fixture->client, "DEFAULT"))) {
         tear_down(fixture);
+        fixture = NULL;
+    }
     EXECUTE_CIPHERLIST_TEST();
     return result;
 }

[DF] commit bcb61b39b47419b9de1dbc37cd2f67b71eeb23ea
Author: zekeevans-mf <77804765+zekeevans-mf@users.noreply.github.com>
Date:   Thu Jan 21 12:24:51 2021 -0700

    Add deep copy of propq field in mac_dupctx to avoid double free
    
    mac_dupctx() should make a copy of the propq field. Currently it
    does a shallow copy which can result in a double free and crash.
    The double free occurs when using a provider property string.
    For example, passing in "fips=no" to SSL_CTX_new_ex() causes the
    propq field to get set to that value. When mac_dupctx() and
    mac_freectx() is called (ie: in SSL_write()) it ends up freeing
    the reference of the original object instead of a copy.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/13926)

diff --git a/providers/implementations/signature/mac_legacy.c b/providers/implementations/signature/mac_legacy.c
index 7d23e36f2b..2386583069 100644
--- a/providers/implementations/signature/mac_legacy.c
+++ b/providers/implementations/signature/mac_legacy.c
@@ -172,9 +172,13 @@ static void *mac_dupctx(void *vpmacctx)
         return NULL;
 
     *dstctx = *srcctx;
+    dstctx->propq = NULL;
     dstctx->key = NULL;
     dstctx->macctx = NULL;
 
+    if (srcctx->propq != NULL && (dstctx->propq = OPENSSL_strdup(srcctx->propq)) == NULL)
+        goto err;
+
     if (srcctx->key != NULL && !ossl_mac_key_up_ref(srcctx->key))
         goto err;
     dstctx->key = srcctx->key;

[ML] commit 604b86d8d360e36fc2fc0d1611d05bf38699d297
Author: Petr Gotthard <petr.gotthard@centrum.cz>
Date:   Sat Feb 6 21:47:20 2021 +0100

    Enhanced integer parsing in OSSL_PARAM_allocate_from_text
    
    Fixes #14041 and additional bugs discovered by the newly created
    tests.
    
    This patch:
     - Introduces support for 0x prefixed integers
     - Fixes parsing of negative integers (negative numbers were
       shifted by -2)
     - Fixes ability to parse maximal unsigned numbers ("too small
       buffer" error used to be reported incorrectly)
     - Fixes a memory leak when OSSL_PARAM_allocate_from_text fails
       leaving a temporary BN allocated
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14093)

diff --git a/crypto/params_from_text.c b/crypto/params_from_text.c
index ddc3c38aa4..b019744f9b 100644
--- a/crypto/params_from_text.c
+++ b/crypto/params_from_text.c
@@ -28,6 +28,7 @@ static int prepare_from_text(const OSSL_PARAM *paramdefs, const char *key,
                              size_t *buf_n, BIGNUM **tmpbn, int *found)
 {
     const OSSL_PARAM *p;
+    size_t buf_bits;
 
     /*
      * ishex is used to translate legacy style string controls in hex format
@@ -50,7 +51,7 @@ static int prepare_from_text(const OSSL_PARAM *paramdefs, const char *key,
         if (*ishex)
             BN_hex2bn(tmpbn, value);
         else
-            BN_dec2bn(tmpbn, value);
+            BN_asc2bn(tmpbn, value);
 
         if (*tmpbn == NULL)
             return 0;
@@ -62,20 +63,25 @@ static int prepare_from_text(const OSSL_PARAM *paramdefs, const char *key,
          * buffer, i.e. if it's negative, we need to deal with it.  We do
          * it by subtracting 1 here and inverting the bytes in
          * construct_from_text() below.
+         * To subtract 1 from an absolute value of a negative number we
+         * actually have to add 1: -3 - 1 = -4, |-3| = 3 + 1 = 4.
          */
         if (p->data_type == OSSL_PARAM_INTEGER && BN_is_negative(*tmpbn)
-            && !BN_sub_word(*tmpbn, 1)) {
+            && !BN_add_word(*tmpbn, 1)) {
             return 0;
         }
 
-        *buf_n = BN_num_bytes(*tmpbn);
+        buf_bits = (size_t)BN_num_bits(*tmpbn);
+        *buf_n = (buf_bits + 7) / 8;
 
         /*
          * TODO(v3.0) is this the right way to do this?  This code expects
          * a zero data size to simply mean "arbitrary size".
          */
         if (p->data_size > 0) {
-            if (*buf_n >= p->data_size) {
+            if (buf_bits > p->data_size * 8
+                || (p->data_type == OSSL_PARAM_INTEGER
+                    && buf_bits == p->data_size * 8)) {
                 ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_SMALL_BUFFER);
                 /* Since this is a different error, we don't break */
                 return 0;
@@ -184,11 +190,11 @@ int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
 
     if (!prepare_from_text(paramdefs, key, value, value_n,
                            &paramdef, &ishex, &buf_n, &tmpbn, found))
-        return 0;
+        goto err;
 
     if ((buf = OPENSSL_zalloc(buf_n > 0 ? buf_n : 1)) == NULL) {
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
-        return 0;
+        goto err;
     }
 
     ok = construct_from_text(to, paramdef, value, value_n, ishex,
@@ -197,4 +203,7 @@ int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
     if (!ok)
         OPENSSL_free(buf);
     return ok;
+ err:
+    BN_free(tmpbn);
+    return 0;
 }
diff --git a/doc/man3/OSSL_PARAM_allocate_from_text.pod b/doc/man3/OSSL_PARAM_allocate_from_text.pod
index ef68f0e10c..80ba555a8f 100644
--- a/doc/man3/OSSL_PARAM_allocate_from_text.pod
+++ b/doc/man3/OSSL_PARAM_allocate_from_text.pod
@@ -55,15 +55,16 @@ depending on that item's I<data_type>, as follows:
 
 =item B<OSSL_PARAM_INTEGER> and B<OSSL_PARAM_UNSIGNED_INTEGER>
 
-If I<key> started with "hex", I<value> is assumed to contain
-I<value_n> hexadecimal characters, which are decoded, and the
-resulting bytes become the number stored in the I<< to->data >>
-storage.
-
 If I<key> didn't start with "hex", I<value> is assumed to contain
 I<value_n> decimal characters, which are decoded, and the resulting
 bytes become the number stored in the I<< to->data >> storage.
 
+If I<value> starts with "0x", it is assumed to contain I<value_n>
+hexadecimal characters.
+
+If I<key> started with "hex", I<value> is assumed to contain
+I<value_n> hexadecimal characters without the "0x" prefix.
+
 If I<value> contains characters that couldn't be decoded as
 hexadecimal or decimal characters, OSSL_PARAM_allocate_from_text()
 considers that an error.
diff --git a/test/params_test.c b/test/params_test.c
index 8ee2e1594c..913df9eb8a 100644
--- a/test/params_test.c
+++ b/test/params_test.c
@@ -541,8 +541,81 @@ static int test_case(int i)
                                  test_cases[i].prov));
 }
 
+/*-
+ * OSSL_PARAM_allocate_from_text() tests
+ * =====================================
+ */
+
+static const OSSL_PARAM params_from_text[] = {
+    OSSL_PARAM_int32("int", NULL),
+    OSSL_PARAM_DEFN("short", OSSL_PARAM_INTEGER, NULL, sizeof(int16_t)),
+    OSSL_PARAM_DEFN("ushort", OSSL_PARAM_UNSIGNED_INTEGER, NULL, sizeof(uint16_t)),
+    OSSL_PARAM_END,
+};
+
+struct int_from_text_test_st {
+    const char *argname;
+    const char *strval;
+    long int intval;
+    int res;
+};
+
+static struct int_from_text_test_st int_from_text_test_cases[] = {
+    { "int",               "",          0, 0 },
+    { "int",              "0",          0, 1 },
+    { "int",            "101",        101, 1 },
+    { "int",           "-102",       -102, 1 },
+    { "int",            "12A",         12, 1 }, /* incomplete */
+    { "int",          "0x12B",      0x12B, 1 },
+    { "hexint",         "12C",      0x12C, 1 },
+    { "hexint",       "0x12D",          0, 1 }, /* zero */
+    /* test check of the target buffer size */
+    { "int",     "0x7fffffff",  INT32_MAX, 1 },
+    { "int",     "2147483647",  INT32_MAX, 1 },
+    { "int",     "2147483648",          0, 0 }, /* too small buffer */
+    { "int",    "-2147483648",  INT32_MIN, 1 },
+    { "int",    "-2147483649",          0, 0 }, /* too small buffer */
+    { "short",       "0x7fff",  INT16_MAX, 1 },
+    { "short",        "32767",  INT16_MAX, 1 },
+    { "short",        "32768",          0, 0 }, /* too small buffer */
+    { "ushort",      "0xffff", UINT16_MAX, 1 },
+    { "ushort",       "65535", UINT16_MAX, 1 },
+    { "ushort",       "65536",          0, 0 }, /* too small buffer */
+};
+
+static int check_int_from_text(const struct int_from_text_test_st a)
+{
+    OSSL_PARAM param;
+    long int val = 0;
+    int res;
+
+    if (!OSSL_PARAM_allocate_from_text(&param, params_from_text,
+                                       a.argname, a.strval, 0, NULL)) {
+        if (a.res)
+            TEST_error("errant %s param \"%s\"", a.argname, a.strval);
+        return !a.res;
+    }
+
+    res = OSSL_PARAM_get_long(&param, &val);
+    OPENSSL_free(param.data);
+
+    if (res ^ a.res || val != a.intval) {
+        TEST_error("errant %s \"%s\" %li != %li",
+                   a.argname, a.strval, a.intval, val);
+        return 0;
+    }
+
+    return a.res;
+}
+
+static int test_allocate_from_text(int i)
+{
+    return check_int_from_text(int_from_text_test_cases[i]);
+}
+
 int setup_tests(void)
 {
     ADD_ALL_TESTS(test_case, OSSL_NELEM(test_cases));
+    ADD_ALL_TESTS(test_allocate_from_text, OSSL_NELEM(int_from_text_test_cases));
     return 1;
 }

[ML] commit 64954e2f34b8839ca7ad1e9576a6efaf3e49e17c
Author: Pauli <ppzgs1@gmail.com>
Date:   Thu Feb 4 14:40:19 2021 +1000

    Fix race condition & allow operation cache to grow.
    
    This fixes a race condition where the index to the cache location was found
    under a read lock and a later write lock set the cache entry.  The issue being
    that two threads could get the same location index and then fight each other
    over writing the cache entry.  The most likely outcome is a memory leak,
    however it would be possible to set up an invalid cache entry.
    
    The operation cache was a fixed sized array, once full an assertion failed.
    The other fix here is to convert this to a stack.  The code is simplified and
    it avoids a cache overflow condition.
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14062)

diff --git a/crypto/evp/keymgmt_lib.c b/crypto/evp/keymgmt_lib.c
index 0112036263..85a39b3d89 100644
--- a/crypto/evp/keymgmt_lib.c
+++ b/crypto/evp/keymgmt_lib.c
@@ -87,7 +87,7 @@ int evp_keymgmt_util_export(const EVP_PKEY *pk, int selection,
 void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
 {
     struct evp_keymgmt_util_try_import_data_st import_data;
-    size_t i = 0;
+    OP_CACHE_ELEM *op;
 
     /* Export to where? */
     if (keymgmt == NULL)
@@ -104,15 +104,14 @@ void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
     CRYPTO_THREAD_read_lock(pk->lock);
     /*
      * If the provider native "origin" hasn't changed since last time, we
-     * try to find our keymgmt in the operation cache.  If it has changed,
-     * |i| remains zero, and we will clear the cache further down.
+     * try to find our keymgmt in the operation cache.  If it has changed
+     * and our keymgmt isn't found, we will clear the cache further down.
      */
     if (pk->dirty_cnt == pk->dirty_cnt_copy) {
         /* If this key is already exported to |keymgmt|, no more to do */
-        i = evp_keymgmt_util_find_operation_cache_index(pk, keymgmt);
-        if (i < OSSL_NELEM(pk->operation_cache)
-            && pk->operation_cache[i].keymgmt != NULL) {
-            void *ret = pk->operation_cache[i].keydata;
+        op = evp_keymgmt_util_find_operation_cache(pk, keymgmt);
+        if (op != NULL && op->keymgmt != NULL) {
+            void *ret = op->keydata;
 
             CRYPTO_THREAD_unlock(pk->lock);
             return ret;
@@ -128,15 +127,6 @@ void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
     if (pk->keymgmt->export == NULL)
         return NULL;
 
-    /* Check that we have found an empty slot in the export cache */
-    /*
-     * TODO(3.0) Right now, we assume we have ample space.  We will have to
-     * think about a cache aging scheme, though, if |i| indexes outside the
-     * array.
-     */
-    if (!ossl_assert(i < OSSL_NELEM(pk->operation_cache)))
-        return NULL;
-
     /*
      * Make sure that the type of the keymgmt to export to matches the type
      * of the "origin"
@@ -168,10 +158,9 @@ void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
 
     CRYPTO_THREAD_write_lock(pk->lock);
     /* Check to make sure some other thread didn't get there first */
-    i = evp_keymgmt_util_find_operation_cache_index(pk, keymgmt);
-    if (i < OSSL_NELEM(pk->operation_cache)
-        && pk->operation_cache[i].keymgmt != NULL) {
-        void *ret = pk->operation_cache[i].keydata;
+    op = evp_keymgmt_util_find_operation_cache(pk, keymgmt);
+    if (op != NULL && op->keydata != NULL) {
+        void *ret = op->keydata;
 
         CRYPTO_THREAD_unlock(pk->lock);
 
@@ -192,7 +181,7 @@ void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
         evp_keymgmt_util_clear_operation_cache(pk, 0);
 
     /* Add the new export to the operation cache */
-    if (!evp_keymgmt_util_cache_keydata(pk, i, keymgmt, import_data.keydata)) {
+    if (!evp_keymgmt_util_cache_keydata(pk, keymgmt, import_data.keydata)) {
         evp_keymgmt_freedata(keymgmt, import_data.keydata);
         return NULL;
     }
@@ -205,22 +194,20 @@ void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
     return import_data.keydata;
 }
 
-int evp_keymgmt_util_clear_operation_cache(EVP_PKEY *pk, int locking)
+static void op_cache_free(OP_CACHE_ELEM *e)
 {
-    size_t i, end = OSSL_NELEM(pk->operation_cache);
+    evp_keymgmt_freedata(e->keymgmt, e->keydata);
+    EVP_KEYMGMT_free(e->keymgmt);
+    OPENSSL_free(e);
+}
 
+int evp_keymgmt_util_clear_operation_cache(EVP_PKEY *pk, int locking)
+{
     if (pk != NULL) {
         if (locking && pk->lock != NULL && !CRYPTO_THREAD_write_lock(pk->lock))
             return 0;
-        for (i = 0; i < end && pk->operation_cache[i].keymgmt != NULL; i++) {
-            EVP_KEYMGMT *keymgmt = pk->operation_cache[i].keymgmt;
-            void *keydata = pk->operation_cache[i].keydata;
-
-            pk->operation_cache[i].keymgmt = NULL;
-            pk->operation_cache[i].keydata = NULL;
-            evp_keymgmt_freedata(keymgmt, keydata);
-            EVP_KEYMGMT_free(keymgmt);
-        }
+        sk_OP_CACHE_ELEM_pop_free(pk->operation_cache, op_cache_free);
+        pk->operation_cache = NULL;
         if (locking && pk->lock != NULL)
             CRYPTO_THREAD_unlock(pk->lock);
     }
@@ -228,28 +215,52 @@ int evp_keymgmt_util_clear_operation_cache(EVP_PKEY *pk, int locking)
     return 1;
 }
 
-size_t evp_keymgmt_util_find_operation_cache_index(EVP_PKEY *pk,
-                                                   EVP_KEYMGMT *keymgmt)
+OP_CACHE_ELEM *evp_keymgmt_util_find_operation_cache(EVP_PKEY *pk,
+                                                     EVP_KEYMGMT *keymgmt)
 {
-    size_t i, end = OSSL_NELEM(pk->operation_cache);
+    int i, end = sk_OP_CACHE_ELEM_num(pk->operation_cache);
+    OP_CACHE_ELEM *p;
 
-    for (i = 0; i < end && pk->operation_cache[i].keymgmt != NULL; i++) {
-        if (keymgmt == pk->operation_cache[i].keymgmt)
-            break;
+    /*
+     * A comparison and sk_P_CACHE_ELEM_find() are avoided to not cause
+     * problems when we've only a read lock.
+     */
+    for (i = 0; i < end; i++) {
+        p = sk_OP_CACHE_ELEM_value(pk->operation_cache, i);
+        if (keymgmt == p->keymgmt)
+            return p;
     }
-
-    return i;
+    return NULL;
 }
 
-int evp_keymgmt_util_cache_keydata(EVP_PKEY *pk, size_t index,
+int evp_keymgmt_util_cache_keydata(EVP_PKEY *pk,
                                    EVP_KEYMGMT *keymgmt, void *keydata)
 {
+    OP_CACHE_ELEM *p = NULL;
+
     if (keydata != NULL) {
-        if (!EVP_KEYMGMT_up_ref(keymgmt))
+        if (pk->operation_cache == NULL) {
+            pk->operation_cache = sk_OP_CACHE_ELEM_new_null();
+            if (pk->operation_cache == NULL)
+                return 0;
+        }
+
+        p = OPENSSL_malloc(sizeof(*p));
+        if (p == NULL)
             return 0;
+        p->keydata = keydata;
+        p->keymgmt = keymgmt;
 
-        pk->operation_cache[index].keydata = keydata;
-        pk->operation_cache[index].keymgmt = keymgmt;
+        if (!EVP_KEYMGMT_up_ref(keymgmt)) {
+            OPENSSL_free(p);
+            return 0;
+        }
+
+        if (!sk_OP_CACHE_ELEM_push(pk->operation_cache, p)) {
+            EVP_KEYMGMT_free(keymgmt);
+            OPENSSL_free(p);
+            return 0;
+        }
     }
     return 1;
 }
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 95cc15e9d7..fc0e5be7de 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -1629,6 +1629,7 @@ static void evp_pkey_free_it(EVP_PKEY *x)
     /* internal function; x is never NULL */
 
     evp_keymgmt_util_clear_operation_cache(x, 1);
+    sk_OP_CACHE_ELEM_free(x->operation_cache);
 #ifndef FIPS_MODULE
     evp_pkey_free_legacy(x);
 #endif
@@ -1734,7 +1735,7 @@ void *evp_pkey_export_to_provider(EVP_PKEY *pk, OSSL_LIB_CTX *libctx,
 
 #ifndef FIPS_MODULE
     if (pk->pkey.ptr != NULL) {
-        size_t i = 0;
+        OP_CACHE_ELEM *op;
 
         /*
          * If the legacy "origin" hasn't changed since last time, we try
@@ -1744,7 +1745,7 @@ void *evp_pkey_export_to_provider(EVP_PKEY *pk, OSSL_LIB_CTX *libctx,
         if (pk->ameth->dirty_cnt(pk) == pk->dirty_cnt_copy) {
             if (!CRYPTO_THREAD_read_lock(pk->lock))
                 goto end;
-            i = evp_keymgmt_util_find_operation_cache_index(pk, tmp_keymgmt);
+            op = evp_keymgmt_util_find_operation_cache(pk, tmp_keymgmt);
 
             /*
              * If |tmp_keymgmt| is present in the operation cache, it means
@@ -1752,23 +1753,14 @@ void *evp_pkey_export_to_provider(EVP_PKEY *pk, OSSL_LIB_CTX *libctx,
              * token copies of the cached pointers, to have token success
              * values to return.
              */
-            if (i < OSSL_NELEM(pk->operation_cache)
-                && pk->operation_cache[i].keymgmt != NULL) {
-                keydata = pk->operation_cache[i].keydata;
+            if (op != NULL && op->keymgmt != NULL) {
+                keydata = op->keydata;
                 CRYPTO_THREAD_unlock(pk->lock);
                 goto end;
             }
             CRYPTO_THREAD_unlock(pk->lock);
         }
 
-        /*
-         * TODO(3.0) Right now, we assume we have ample space.  We will have
-         * to think about a cache aging scheme, though, if |i| indexes outside
-         * the array.
-         */
-        if (!ossl_assert(i < OSSL_NELEM(pk->operation_cache)))
-            goto end;
-
         /* Make sure that the keymgmt key type matches the legacy NID */
         if (!ossl_assert(EVP_KEYMGMT_is_a(tmp_keymgmt, OBJ_nid2sn(pk->type))))
             goto end;
@@ -1806,8 +1798,19 @@ void *evp_pkey_export_to_provider(EVP_PKEY *pk, OSSL_LIB_CTX *libctx,
         }
         EVP_KEYMGMT_free(tmp_keymgmt); /* refcnt-- */
 
+        /* Check to make sure some other thread didn't get there first */
+        op = evp_keymgmt_util_find_operation_cache(pk, tmp_keymgmt);
+        if (op != NULL && op->keymgmt != NULL) {
+            void *tmp_keydata = op->keydata;
+
+            CRYPTO_THREAD_unlock(pk->lock);
+            evp_keymgmt_freedata(tmp_keymgmt, keydata);
+            keydata = tmp_keydata;
+            goto end;
+        }
+
         /* Add the new export to the operation cache */
-        if (!evp_keymgmt_util_cache_keydata(pk, i, tmp_keymgmt, keydata)) {
+        if (!evp_keymgmt_util_cache_keydata(pk, tmp_keymgmt, keydata)) {
             CRYPTO_THREAD_unlock(pk->lock);
             evp_keymgmt_freedata(tmp_keymgmt, keydata);
             keydata = NULL;
@@ -1972,7 +1975,7 @@ int evp_pkey_downgrade(EVP_PKEY *pk)
          * reference count, so we need to decrement it, or there will be a
          * leak.
          */
-        evp_keymgmt_util_cache_keydata(pk, 0, tmp_copy.keymgmt,
+        evp_keymgmt_util_cache_keydata(pk, tmp_copy.keymgmt,
                                        tmp_copy.keydata);
         EVP_KEYMGMT_free(tmp_copy.keymgmt);
 
diff --git a/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod b/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod
index 31f8b00e47..f55980376e 100644
--- a/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod
+++ b/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod
@@ -4,24 +4,27 @@
 
 evp_keymgmt_util_export,
 evp_keymgmt_util_export_to_provider,
-evp_keymgmt_util_find_operation_cache_index,
+evp_keymgmt_util_find_operation_cache,
 evp_keymgmt_util_clear_operation_cache,
 evp_keymgmt_util_cache_keydata,
 evp_keymgmt_util_cache_keyinfo,
-evp_keymgmt_util_fromdata
+evp_keymgmt_util_fromdata,
+OP_CACHE_ELEM
 - internal KEYMGMT utility functions
 
 =head1 SYNOPSIS
 
  #include "crypto/evp.h"
 
+ typedef struct OP_CACHE_ELEM;
+
  int evp_keymgmt_util_export(const EVP_PKEY *pk, int selection,
                              OSSL_CALLBACK *export_cb, void *export_cbarg);
  void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt);
- size_t evp_keymgmt_util_find_operation_cache_index(EVP_PKEY *pk,
-                                                    EVP_KEYMGMT *keymgmt);
+ OP_CACHE_ELEM *evp_keymgmt_util_find_operation_cache(EVP_PKEY *pk,
+                                                      EVP_KEYMGMT *keymgmt);
  int evp_keymgmt_util_clear_operation_cache(EVP_PKEY *pk, int locking);
- int evp_keymgmt_util_cache_keydata(EVP_PKEY *pk, size_t index,
+ int evp_keymgmt_util_cache_keydata(EVP_PKEY *pk,
                                     EVP_KEYMGMT *keymgmt, void *keydata);
  void evp_keymgmt_util_cache_keyinfo(EVP_PKEY *pk);
  void *evp_keymgmt_util_fromdata(EVP_PKEY *target, EVP_KEYMGMT *keymgmt,
@@ -41,20 +44,17 @@ of all provider side keys.
 To export a legacy key, use L<evp_pkey_export_to_provider(3)> instead,
 as this function ignores any legacy key data.
 
-evp_keymgmt_util_find_operation_cache_index() finds the location if
-I<keymgmt> in I<pk>'s cache of provided keys for operations.  If
-I<keymgmt> is NULL or couldn't be found in the cache, it finds the
-first empty slot instead if there is any. It should only be called while
-holding I<pk>'s lock (read or write).
+evp_keymgmt_util_find_operation_cache() finds
+I<keymgmt> in I<pk>'s cache of provided keys for operations.
+It should only be called while holding I<pk>'s lock (read or write).
 
 evp_keymgmt_util_clear_operation_cache() can be used to explicitly
 clear the cache of operation key references. If I<locking> is set to 1 then
 then I<pk>'s lock will be obtained while doing the clear. Otherwise it will be
 assumed that the lock has already been obtained or is not required.
 
-evp_keymgmt_util_cache_keydata() can be used to assign a provider key
-object to a specific cache slot in the given I<target>.
-I<Use extreme care>.
+evp_keymgmt_util_cache_keydata() can be used to add a provider key
+object to a B<PKEY>.
 
 evp_keymgmt_util_cache_keyinfo() can be used to get all kinds of
 information from the provvider "origin" and save it in I<pk>'s
@@ -70,10 +70,9 @@ evp_keymgmt_export_to_provider() and evp_keymgmt_util_fromdata()
 return a pointer to the appropriate provider side key (created or
 found again), or NULL on error.
 
-evp_keymgmt_util_find_operation_cache_index() returns the index of the
+evp_keymgmt_util_find_operation_cache() returns a pointer to the
 operation cache slot.  If I<keymgmt> is NULL, or if there is no slot
-with a match for I<keymgmt>, the index of the first empty slot is
-returned, or the maximum number of slots if there isn't an empty one.
+with a match for I<keymgmt>, NULL is returned.
 
 evp_keymgmt_util_cache_keydata() and evp_keymgmt_util_clear_operation_cache()
 return 1 on success or 0 otherwise.
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index 7b3c4bfd2f..60f07c7cf7 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -548,6 +548,23 @@ int evp_cipher_param_to_asn1_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
 int evp_cipher_asn1_to_param_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
                                 evp_cipher_aead_asn1_params *params);
 
+/*
+ * To support transparent execution of operation in backends other
+ * than the "origin" key, we support transparent export/import to
+ * those providers, and maintain a cache of the imported keydata,
+ * so we don't need to redo the export/import every time we perform
+ * the same operation in that same provider.
+ * This requires that the "origin" backend (whether it's a legacy or a
+ * provider "origin") implements exports, and that the target provider
+ * has an EVP_KEYMGMT that implements import.
+ */
+typedef struct {
+    EVP_KEYMGMT *keymgmt;
+    void *keydata;
+} OP_CACHE_ELEM;
+
+DEFINE_STACK_OF(OP_CACHE_ELEM)
+
 /*
  * An EVP_PKEY can have the following states:
  *
@@ -644,18 +661,9 @@ struct evp_pkey_st {
      * those providers, and maintain a cache of the imported keydata,
      * so we don't need to redo the export/import every time we perform
      * the same operation in that same provider.
-     * This requires that the "origin" backend (whether it's a legacy or a
-     * provider "origin") implements exports, and that the target provider
-     * has an EVP_KEYMGMT that implements import.
-     *
-     * The cache limit is set at 10 different providers using the same
-     * "origin".  It's probably over the top, but is preferable to too
-     * few.
      */
-    struct {
-        EVP_KEYMGMT *keymgmt;
-        void *keydata;
-    } operation_cache[10];
+    STACK_OF(OP_CACHE_ELEM) *operation_cache;
+
     /*
      * We keep a copy of that "origin"'s dirty count, so we know if the
      * operation cache needs flushing.
@@ -726,10 +734,10 @@ EVP_PKEY *evp_keymgmt_util_make_pkey(EVP_KEYMGMT *keymgmt, void *keydata);
 int evp_keymgmt_util_export(const EVP_PKEY *pk, int selection,
                             OSSL_CALLBACK *export_cb, void *export_cbarg);
 void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt);
-size_t evp_keymgmt_util_find_operation_cache_index(EVP_PKEY *pk,
-                                                   EVP_KEYMGMT *keymgmt);
+OP_CACHE_ELEM *evp_keymgmt_util_find_operation_cache(EVP_PKEY *pk,
+                                                     EVP_KEYMGMT *keymgmt);
 int evp_keymgmt_util_clear_operation_cache(EVP_PKEY *pk, int locking);
-int evp_keymgmt_util_cache_keydata(EVP_PKEY *pk, size_t index,
+int evp_keymgmt_util_cache_keydata(EVP_PKEY *pk,
                                    EVP_KEYMGMT *keymgmt, void *keydata);
 void evp_keymgmt_util_cache_keyinfo(EVP_PKEY *pk);
 void *evp_keymgmt_util_fromdata(EVP_PKEY *target, EVP_KEYMGMT *keymgmt,

[UAF] commit 8549b97214ce1b4ba61eae893c80d9b0ed7e35f0
Author: Pauli <ppzgs1@gmail.com>
Date:   Wed Feb 3 17:47:38 2021 +1000

    Fix a use after free issue when a provider context is being used and isn't cached
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14053)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index 46f4d201d9..e89b591978 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -25,12 +25,8 @@
 
 void evp_md_ctx_clear_digest(EVP_MD_CTX *ctx, int force)
 {
-    EVP_MD_free(ctx->fetched_digest);
-    ctx->fetched_digest = NULL;
-    ctx->reqdigest = NULL;
-
     if (ctx->provctx != NULL) {
-        if (ctx->digest->freectx != NULL)
+        if (ctx->digest != NULL && ctx->digest->freectx != NULL)
             ctx->digest->freectx(ctx->provctx);
         ctx->provctx = NULL;
         EVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);
@@ -55,6 +51,11 @@ void evp_md_ctx_clear_digest(EVP_MD_CTX *ctx, int force)
     ENGINE_finish(ctx->engine);
     ctx->engine = NULL;
 #endif
+
+    /* Non legacy code, this has to be later than the ctx->digest cleaning */
+    EVP_MD_free(ctx->fetched_digest);
+    ctx->fetched_digest = NULL;
+    ctx->reqdigest = NULL;
 }
 
 /* This call frees resources associated with the context */

[ML] commit 47b784a41b729d5df9ad47c99355db2f2026a709
Author: Kurt Roeckx <kurt@roeckx.be>
Date:   Thu Dec 17 22:28:17 2020 +0100

    Fix memory leak in mac_newctx() on error
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/13702)

diff --git a/providers/implementations/signature/mac_legacy.c b/providers/implementations/signature/mac_legacy.c
index b92dabde3c..79a5c911a3 100644
--- a/providers/implementations/signature/mac_legacy.c
+++ b/providers/implementations/signature/mac_legacy.c
@@ -74,6 +74,7 @@ static void *mac_newctx(void *provctx, const char *propq, const char *macname)
     return pmacctx;
 
  err:
+    OPENSSL_free(pmacctx->propq);
     OPENSSL_free(pmacctx);
     EVP_MAC_free(mac);
     return NULL;

[ML] commit 74cd923a78b490d46af9c3dc5c8dc7a741c5e576
Author: Richard Levitte <levitte@openssl.org>
Date:   Wed Dec 16 17:01:06 2020 +0100

    EVP: Fix memory leak in EVP_PKEY_CTX_dup()
    
    In most error cases, EVP_PKEY_CTX_dup() would only free the EVP_PKEY_CTX
    without freeing the duplicated contents.
    
    Fixes #13503
    
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/13661)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index f817173555..8fc309dc99 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -455,12 +455,6 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
 {
     EVP_PKEY_CTX *rctx;
 
-    if (((pctx->pmeth == NULL) || (pctx->pmeth->copy == NULL))
-            && ((EVP_PKEY_CTX_IS_DERIVE_OP(pctx)
-                 && pctx->op.kex.exchprovctx == NULL)
-                || (EVP_PKEY_CTX_IS_SIGNATURE_OP(pctx)
-                    && pctx->op.sig.sigprovctx == NULL)))
-        return NULL;
 # ifndef OPENSSL_NO_ENGINE
     /* Make sure it's safe to copy a pkey context using an ENGINE */
     if (pctx->engine && !ENGINE_init(pctx->engine)) {
@@ -483,10 +477,8 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
     rctx->propquery = NULL;
     if (pctx->propquery != NULL) {
         rctx->propquery = OPENSSL_strdup(pctx->propquery);
-        if (rctx->propquery == NULL) {
-            OPENSSL_free(rctx);
-            return NULL;
-        }
+        if (rctx->propquery == NULL)
+            goto err;
     }
     rctx->legacy_keytype = pctx->legacy_keytype;
 
@@ -494,16 +486,16 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
         if (pctx->op.kex.exchange != NULL) {
             rctx->op.kex.exchange = pctx->op.kex.exchange;
             if (!EVP_KEYEXCH_up_ref(rctx->op.kex.exchange))
-                goto end;
+                goto err;
         }
         if (pctx->op.kex.exchprovctx != NULL) {
             if (!ossl_assert(pctx->op.kex.exchange != NULL))
-                goto end;
+                goto err;
             rctx->op.kex.exchprovctx
                 = pctx->op.kex.exchange->dupctx(pctx->op.kex.exchprovctx);
             if (rctx->op.kex.exchprovctx == NULL) {
                 EVP_KEYEXCH_free(rctx->op.kex.exchange);
-                goto end;
+                goto err;
             }
             return rctx;
         }
@@ -511,16 +503,16 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
         if (pctx->op.sig.signature != NULL) {
             rctx->op.sig.signature = pctx->op.sig.signature;
             if (!EVP_SIGNATURE_up_ref(rctx->op.sig.signature))
-                goto end;
+                goto err;
         }
         if (pctx->op.sig.sigprovctx != NULL) {
             if (!ossl_assert(pctx->op.sig.signature != NULL))
-                goto end;
+                goto err;
             rctx->op.sig.sigprovctx
                 = pctx->op.sig.signature->dupctx(pctx->op.sig.sigprovctx);
             if (rctx->op.sig.sigprovctx == NULL) {
                 EVP_SIGNATURE_free(rctx->op.sig.signature);
-                goto end;
+                goto err;
             }
             return rctx;
         }
@@ -528,16 +520,16 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
         if (pctx->op.ciph.cipher != NULL) {
             rctx->op.ciph.cipher = pctx->op.ciph.cipher;
             if (!EVP_ASYM_CIPHER_up_ref(rctx->op.ciph.cipher))
-                goto end;
+                goto err;
         }
         if (pctx->op.ciph.ciphprovctx != NULL) {
             if (!ossl_assert(pctx->op.ciph.cipher != NULL))
-                goto end;
+                goto err;
             rctx->op.ciph.ciphprovctx
                 = pctx->op.ciph.cipher->dupctx(pctx->op.ciph.ciphprovctx);
             if (rctx->op.ciph.ciphprovctx == NULL) {
                 EVP_ASYM_CIPHER_free(rctx->op.ciph.cipher);
-                goto end;
+                goto err;
             }
             return rctx;
         }
@@ -545,22 +537,22 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
         if (pctx->op.encap.kem != NULL) {
             rctx->op.encap.kem = pctx->op.encap.kem;
             if (!EVP_KEM_up_ref(rctx->op.encap.kem))
-                goto end;
+                goto err;
         }
         if (pctx->op.encap.kemprovctx != NULL) {
             if (!ossl_assert(pctx->op.encap.kem != NULL))
-                goto end;
+                goto err;
             rctx->op.encap.kemprovctx
                 = pctx->op.encap.kem->dupctx(pctx->op.encap.kemprovctx);
             if (rctx->op.encap.kemprovctx == NULL) {
                 EVP_KEM_free(rctx->op.encap.kem);
-                goto end;
+                goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_GEN_OP(pctx)) {
         /* Not supported - This would need a gen_dupctx() to work */
-        goto end;
+        goto err;
     }
 
     rctx->pmeth = pctx->pmeth;
@@ -587,17 +579,13 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
             rctx->keymgmt = tmp_keymgmt;
             return rctx;
         }
-        goto err;
-    }
-    if (pctx->pmeth->copy(rctx, pctx) > 0)
+    } else if (pctx->pmeth->copy(rctx, pctx) > 0) {
         return rctx;
+    }
 err:
     rctx->pmeth = NULL;
     EVP_PKEY_CTX_free(rctx);
     return NULL;
-end:
-    OPENSSL_free(rctx);
-    return NULL;
 }
 
 int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth)

[ML] commit a21db568bf3d0ab4194fd3e0917ee982f1fc8bfd
Author: Benny Baumann <BenBE@geshi.org>
Date:   Fri Oct 2 01:06:12 2020 +0200

    Avoid memory leak of parent on allocation failure for child structure
    
    Reviewed-by: Ben Kaduk <kaduk@mit.edu>
    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/13055)

diff --git a/apps/cms.c b/apps/cms.c
index 9312c37fc2..91d951980d 100644
--- a/apps/cms.c
+++ b/apps/cms.c
@@ -647,9 +647,11 @@ int cms_main(int argc, char **argv)
             if (key_param == NULL || key_param->idx != keyidx) {
                 cms_key_param *nparam;
                 nparam = app_malloc(sizeof(*nparam), "key param buffer");
-                nparam->idx = keyidx;
-                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL)
+                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {
+                    OPENSSL_free(nparam);
                     goto end;
+                }
+                nparam->idx = keyidx;
                 nparam->next = NULL;
                 if (key_first == NULL)
                     key_first = nparam;

[ML] commit 7d80985e178d77226392f9c35c36f3f885b884d7
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Mon Sep 28 10:31:46 2020 +0200

    Fix memory leak in req_cb() of x_req.c - handle distinguishing_id also with NO_SM2
    
    Was detected via test_req_distinguishing_id() with config having no-ec but not no-sm2
    
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/13021)

diff --git a/crypto/x509/x_req.c b/crypto/x509/x_req.c
index 21215b4778..e821ffdb78 100644
--- a/crypto/x509/x_req.c
+++ b/crypto/x509/x_req.c
@@ -48,7 +48,6 @@ static int rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
 static int req_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
                   void *exarg)
 {
-#ifndef OPENSSL_NO_SM2
     X509_REQ *ret = (X509_REQ *)*pval;
 
     switch (operation) {
@@ -63,7 +62,6 @@ static int req_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
         ASN1_OCTET_STRING_free(ret->distinguishing_id);
         break;
     }
-#endif
 
     return 1;
 }

[ML] commit 4348995b0d818203f37ffa51c9bdf4488cf24bad
Author: luxinyou <luxinyou@uniontech.com>
Date:   Mon Sep 7 18:06:45 2020 +1000

    Fix memory leaks in conf_def.c
    
    Fixes #12471
    CLA: trivial
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/12533)

diff --git a/crypto/conf/conf_def.c b/crypto/conf/conf_def.c
index 1d34519d1a..5475429abd 100644
--- a/crypto/conf/conf_def.c
+++ b/crypto/conf/conf_def.c
@@ -442,11 +442,13 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                     if (biosk == NULL) {
                         if ((biosk = sk_BIO_new_null()) == NULL) {
                             CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                            BIO_free(next);
                             goto err;
                         }
                     }
                     if (!sk_BIO_push(biosk, in)) {
                         CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                        BIO_free(next);
                         goto err;
                     }
                     /* continue with reading from the included BIO */

[ML] commit 7a3068109568cefdb0d63be1d0c83251c621156e
Author: Richard Levitte <levitte@openssl.org>
Date:   Wed Aug 26 07:04:53 2020 +0200

    STORE: Fix potential memory leak
    
    When closing an OSSL_STORE_CTX, also clear the passphrase data.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/12587)

diff --git a/crypto/store/store_lib.c b/crypto/store/store_lib.c
index 978cb75af8..89efe691da 100644
--- a/crypto/store/store_lib.c
+++ b/crypto/store/store_lib.c
@@ -473,6 +473,7 @@ static int ossl_store_close_it(OSSL_STORE_CTX *ctx)
     sk_OSSL_STORE_INFO_pop_free(ctx->cached_info, OSSL_STORE_INFO_free);
     OSSL_STORE_LOADER_free(ctx->fetched_loader);
     OPENSSL_free(ctx->properties);
+    ossl_pw_clear_passphrase_data(&ctx->pwdata);
     return ret;
 }
 

[DF] commit 625679b6d79296e020bb0cad31d6ac24ad547a39
Author: Pauli <paul.dale@oracle.com>
Date:   Wed Aug 26 14:36:50 2020 +1000

    EVP: NULL pctx pointer after free.
    
    Not doing so can result in a double free.
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/12718)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index f9ba59ca63..c9b4e3fd6e 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -34,8 +34,10 @@ int EVP_MD_CTX_reset(EVP_MD_CTX *ctx)
      * pctx should be freed by the user of EVP_MD_CTX
      * if EVP_MD_CTX_FLAG_KEEP_PKEY_CTX is set
      */
-    if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_KEEP_PKEY_CTX))
+    if (!EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_KEEP_PKEY_CTX)) {
         EVP_PKEY_CTX_free(ctx->pctx);
+        ctx->pctx = NULL;
+    }
 #endif
 
     EVP_MD_free(ctx->fetched_digest);

[ML] commit c23add3676634ced6662929d60f266a9f5062e7b
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Sun Aug 9 17:26:39 2020 +1000

    Fix memory leak in drbgtest
    
    Reviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>
    (Merged from https://github.com/openssl/openssl/pull/12613)

diff --git a/test/drbgtest.c b/test/drbgtest.c
index c6c8438e98..fbe5c78c58 100644
--- a/test/drbgtest.c
+++ b/test/drbgtest.c
@@ -531,10 +531,10 @@ static EVP_RAND_CTX *new_drbg(EVP_RAND_CTX *parent)
     if (!TEST_ptr(rand = EVP_RAND_fetch(NULL, "CTR-DRBG", NULL))
             || !TEST_ptr(drbg = EVP_RAND_CTX_new(rand, parent))
             || !TEST_true(EVP_RAND_set_ctx_params(drbg, params))) {
-        EVP_RAND_CTX_rand(drbg);
-        EVP_RAND_free(rand);
+        EVP_RAND_CTX_free(drbg);
         drbg = NULL;
     }
+    EVP_RAND_free(rand);
     return drbg;
 }
 
@@ -627,13 +627,6 @@ err:
 
 int setup_tests(void)
 {
-    /*
-     * TODO(3.0): figure out why and fix.
-     * Create the primary DRBG here to avoid a memory leak if it is done in
-     * the test cases.
-     */
-    if (RAND_get0_primary(NULL) == NULL)
-        return 0;
     ADD_TEST(test_rand_drbg_reseed);
     ADD_TEST(test_rand_drbg_prediction_resistance);
 #if defined(OPENSSL_THREADS)

[ML] [NR] commit 64827f407b0b603f585d7fadfd7e61a60ed7a45b
Author: Pauli <paul.dale@oracle.com>
Date:   Thu Aug 6 11:11:44 2020 +1000

    drbgtest: avoid a memory leak
    
    Reviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>
    (Merged from https://github.com/openssl/openssl/pull/12509)

diff --git a/test/drbgtest.c b/test/drbgtest.c
index 2d72055cc7..c6c8438e98 100644
--- a/test/drbgtest.c
+++ b/test/drbgtest.c
@@ -627,6 +627,13 @@ err:
 
 int setup_tests(void)
 {
+    /*
+     * TODO(3.0): figure out why and fix.
+     * Create the primary DRBG here to avoid a memory leak if it is done in
+     * the test cases.
+     */
+    if (RAND_get0_primary(NULL) == NULL)
+        return 0;
     ADD_TEST(test_rand_drbg_reseed);
     ADD_TEST(test_rand_drbg_prediction_resistance);
 #if defined(OPENSSL_THREADS)

[ML] commit 90409da6a520812b0266fcb1303175406dea81fe
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Wed Jul 22 10:40:55 2020 +1000

    Fix provider cipher reinit issue
    
    Fixes #12405
    Fixes #12377
    
    Calling Init()/Update() and then Init()/Update() again gave a different result when using the same key and iv.
    Cipher modes that were using ctx->num were not resetting this value, this includes OFB, CFB & CTR.
    The fix is to reset this value during the ciphers einit() and dinit() methods.
    Most ciphers go thru a generic method so one line fixes most cases.
    
    Add test for calling EVP_EncryptInit()/EVP_EncryptUpdate() multiple times for all ciphers.
    Ciphers should return the same value for both updates.
    DES3-WRAP does not since it uses a random in the update.
    CCM modes currently also fail on the second update (This also happens in 1_1_1).
    
    Fix memory leak in AES_OCB cipher if EVP_EncryptInit is called multiple times.
    
    Fix AES_SIV cipher dup_ctx and init.
    Calling EVP_CIPHER_init multiple times resulted in a memory leak in the siv.
    Fixing this leak also showed that the dup ctx was not working for siv mode.
    Note: aes_siv_cleanup() can not be used by aes_siv_dupctx() as it clears data
    that is required for the decrypt (e.g the tag).
    
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/12413)

diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 05be21901d..c037090695 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -4061,7 +4061,7 @@ static int aes_siv_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 
     /* klen is the length of the underlying cipher, not the input key,
        which should be twice as long */
-    return CRYPTO_siv128_init(sctx, key, klen, cbc, ctr);
+    return CRYPTO_siv128_init(sctx, key, klen, cbc, ctr, NULL, NULL);
 }
 
 #define aesni_siv_cipher aes_siv_cipher
diff --git a/crypto/modes/siv128.c b/crypto/modes/siv128.c
index d3655674b4..27e29c3cc6 100644
--- a/crypto/modes/siv128.c
+++ b/crypto/modes/siv128.c
@@ -140,13 +140,15 @@ __owur static ossl_inline int siv128_do_encrypt(EVP_CIPHER_CTX *ctx, unsigned ch
 /*
  * Create a new SIV128_CONTEXT
  */
-SIV128_CONTEXT *CRYPTO_siv128_new(const unsigned char *key, int klen, EVP_CIPHER* cbc, EVP_CIPHER* ctr)
+SIV128_CONTEXT *CRYPTO_siv128_new(const unsigned char *key, int klen,
+                                  EVP_CIPHER *cbc, EVP_CIPHER *ctr,
+                                  OPENSSL_CTX *libctx, const char *propq)
 {
     SIV128_CONTEXT *ctx;
     int ret;
 
     if ((ctx = OPENSSL_malloc(sizeof(*ctx))) != NULL) {
-        ret = CRYPTO_siv128_init(ctx, key, klen, cbc, ctr);
+        ret = CRYPTO_siv128_init(ctx, key, klen, cbc, ctr, libctx, propq);
         if (ret)
             return ctx;
         OPENSSL_free(ctx);
@@ -159,7 +161,8 @@ SIV128_CONTEXT *CRYPTO_siv128_new(const unsigned char *key, int klen, EVP_CIPHER
  * Initialise an existing SIV128_CONTEXT
  */
 int CRYPTO_siv128_init(SIV128_CONTEXT *ctx, const unsigned char *key, int klen,
-                       const EVP_CIPHER* cbc, const EVP_CIPHER* ctr)
+                       const EVP_CIPHER *cbc, const EVP_CIPHER *ctr,
+                       OPENSSL_CTX *libctx, const char *propq)
 {
     static const unsigned char zero[SIV_LEN] = { 0 };
     size_t out_len = SIV_LEN;
@@ -174,14 +177,17 @@ int CRYPTO_siv128_init(SIV128_CONTEXT *ctx, const unsigned char *key, int klen,
     params[2] = OSSL_PARAM_construct_end();
 
     memset(&ctx->d, 0, sizeof(ctx->d));
+    EVP_CIPHER_CTX_free(ctx->cipher_ctx);
+    EVP_MAC_CTX_free(ctx->mac_ctx_init);
+    EVP_MAC_free(ctx->mac);
+    ctx->mac = NULL;
     ctx->cipher_ctx = NULL;
     ctx->mac_ctx_init = NULL;
 
     if (key == NULL || cbc == NULL || ctr == NULL
             || (ctx->cipher_ctx = EVP_CIPHER_CTX_new()) == NULL
-            /* TODO(3.0) library context */
             || (ctx->mac =
-                EVP_MAC_fetch(NULL, OSSL_MAC_NAME_CMAC, NULL)) == NULL
+                EVP_MAC_fetch(libctx, OSSL_MAC_NAME_CMAC, propq)) == NULL
             || (ctx->mac_ctx_init = EVP_MAC_CTX_new(ctx->mac)) == NULL
             || !EVP_MAC_CTX_set_params(ctx->mac_ctx_init, params)
             || !EVP_EncryptInit_ex(ctx->cipher_ctx, ctr, NULL, key + klen, NULL)
@@ -209,12 +215,20 @@ int CRYPTO_siv128_init(SIV128_CONTEXT *ctx, const unsigned char *key, int klen,
 int CRYPTO_siv128_copy_ctx(SIV128_CONTEXT *dest, SIV128_CONTEXT *src)
 {
     memcpy(&dest->d, &src->d, sizeof(src->d));
+    if (dest->cipher_ctx == NULL) {
+        dest->cipher_ctx = EVP_CIPHER_CTX_new();
+        if (dest->cipher_ctx == NULL)
+            return 0;
+    }
     if (!EVP_CIPHER_CTX_copy(dest->cipher_ctx, src->cipher_ctx))
         return 0;
     EVP_MAC_CTX_free(dest->mac_ctx_init);
     dest->mac_ctx_init = EVP_MAC_CTX_dup(src->mac_ctx_init);
     if (dest->mac_ctx_init == NULL)
         return 0;
+    dest->mac = src->mac;
+    if (dest->mac != NULL)
+        EVP_MAC_up_ref(dest->mac);
     return 1;
 }
 
diff --git a/include/crypto/siv.h b/include/crypto/siv.h
index 8a8ef6e15f..9ed8b1b121 100644
--- a/include/crypto/siv.h
+++ b/include/crypto/siv.h
@@ -12,9 +12,11 @@
 typedef struct siv128_context SIV128_CONTEXT;
 
 SIV128_CONTEXT *CRYPTO_siv128_new(const unsigned char *key, int klen,
-                                  EVP_CIPHER* cbc, EVP_CIPHER* ctr);
+                                  EVP_CIPHER *cbc, EVP_CIPHER *ctr,
+                                  OPENSSL_CTX *libctx, const char *propq);
 int CRYPTO_siv128_init(SIV128_CONTEXT *ctx, const unsigned char *key, int klen,
-                       const EVP_CIPHER* cbc, const EVP_CIPHER* ctr);
+                       const EVP_CIPHER *cbc, const EVP_CIPHER *ctr,
+                       OPENSSL_CTX *libctx, const char *propq);
 int CRYPTO_siv128_copy_ctx(SIV128_CONTEXT *dest, SIV128_CONTEXT *src);
 int CRYPTO_siv128_aad(SIV128_CONTEXT *ctx, const unsigned char *aad,
                       size_t len);
diff --git a/providers/implementations/ciphers/cipher_aes_ocb_hw.c b/providers/implementations/ciphers/cipher_aes_ocb_hw.c
index da82b66fa1..5caca0b1df 100644
--- a/providers/implementations/ciphers/cipher_aes_ocb_hw.c
+++ b/providers/implementations/ciphers/cipher_aes_ocb_hw.c
@@ -18,6 +18,7 @@
 #define OCB_SET_KEY_FN(fn_set_enc_key, fn_set_dec_key,                         \
                        fn_block_enc, fn_block_dec,                             \
                        fn_stream_enc, fn_stream_dec)                           \
+CRYPTO_ocb128_cleanup(&ctx->ocb);                                              \
 fn_set_enc_key(key, keylen * 8, &ctx->ksenc.ks);                               \
 fn_set_dec_key(key, keylen * 8, &ctx->ksdec.ks);                               \
 if (!CRYPTO_ocb128_init(&ctx->ocb, &ctx->ksenc.ks, &ctx->ksdec.ks,             \
diff --git a/providers/implementations/ciphers/cipher_aes_siv.c b/providers/implementations/ciphers/cipher_aes_siv.c
index 48bf01649a..84c078da82 100644
--- a/providers/implementations/ciphers/cipher_aes_siv.c
+++ b/providers/implementations/ciphers/cipher_aes_siv.c
@@ -19,6 +19,7 @@
 #include "prov/implementations.h"
 #include "prov/providercommonerr.h"
 #include "prov/ciphercommon_aead.h"
+#include "prov/provider_ctx.h"
 
 #define siv_stream_update siv_cipher
 #define SIV_FLAGS AEAD_FLAGS
@@ -34,6 +35,7 @@ static void *aes_siv_newctx(void *provctx, size_t keybits, unsigned int mode,
         ctx->flags = flags;
         ctx->keylen = keybits / 8;
         ctx->hw = PROV_CIPHER_HW_aes_siv(keybits);
+        ctx->libctx = PROV_LIBRARY_CONTEXT_OF(provctx);
     }
     return ctx;
 }
@@ -48,6 +50,22 @@ static void aes_siv_freectx(void *vctx)
     }
 }
 
+static void *siv_dupctx(void *vctx)
+{
+    PROV_AES_SIV_CTX *in = (PROV_AES_SIV_CTX *)vctx;
+    PROV_AES_SIV_CTX *ret = OPENSSL_malloc(sizeof(*ret));
+
+    if (ret == NULL) {
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    if (!in->hw->dupctx(in, ret)) {
+        OPENSSL_free(ret);
+        ret = NULL;
+    }
+    return ret;
+}
+
 static int siv_init(void *vctx, const unsigned char *key, size_t keylen,
                     const unsigned char *iv, size_t ivlen, int enc)
 {
@@ -219,6 +237,7 @@ static void * alg##kbits##lc##_newctx(void *provctx)                           \
 const OSSL_DISPATCH alg##kbits##lc##_functions[] = {                           \
     { OSSL_FUNC_CIPHER_NEWCTX, (void (*)(void))alg##kbits##lc##_newctx },      \
     { OSSL_FUNC_CIPHER_FREECTX, (void (*)(void))alg##_##lc##_freectx },        \
+    { OSSL_FUNC_CIPHER_DUPCTX, (void (*)(void)) lc##_dupctx },                 \
     { OSSL_FUNC_CIPHER_ENCRYPT_INIT, (void (*)(void)) lc##_einit },            \
     { OSSL_FUNC_CIPHER_DECRYPT_INIT, (void (*)(void)) lc##_dinit },            \
     { OSSL_FUNC_CIPHER_UPDATE, (void (*)(void)) lc##_stream_update },          \
diff --git a/providers/implementations/ciphers/cipher_aes_siv.h b/providers/implementations/ciphers/cipher_aes_siv.h
index 05411d7012..3179943f0e 100644
--- a/providers/implementations/ciphers/cipher_aes_siv.h
+++ b/providers/implementations/ciphers/cipher_aes_siv.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2019-2020 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -18,6 +18,7 @@ typedef struct prov_cipher_hw_aes_siv_st {
     void (*setspeed)(void *ctx, int speed);
     int (*settag)(void *ctx, const unsigned char *tag, size_t tagl);
     void (*cleanup)(void *ctx);
+    int (*dupctx)(void *src, void *dst);
 } PROV_CIPHER_HW_AES_SIV;
 
 typedef struct prov_siv_ctx_st {
@@ -30,6 +31,7 @@ typedef struct prov_siv_ctx_st {
     EVP_CIPHER *ctr;        /* These are fetched - so we need to free them */
     EVP_CIPHER *cbc;
     const PROV_CIPHER_HW_AES_SIV *hw;
+    OPENSSL_CTX *libctx;
 } PROV_AES_SIV_CTX;
 
 const PROV_CIPHER_HW_AES_SIV *PROV_CIPHER_HW_aes_siv(size_t keybits);
diff --git a/providers/implementations/ciphers/cipher_aes_siv_hw.c b/providers/implementations/ciphers/cipher_aes_siv_hw.c
index ef910dd6f8..547eb1a4c4 100644
--- a/providers/implementations/ciphers/cipher_aes_siv_hw.c
+++ b/providers/implementations/ciphers/cipher_aes_siv_hw.c
@@ -15,33 +15,63 @@
 
 #include "cipher_aes_siv.h"
 
+static void aes_siv_cleanup(void *vctx);
+
 static int aes_siv_initkey(void *vctx, const unsigned char *key, size_t keylen)
 {
     PROV_AES_SIV_CTX *ctx = (PROV_AES_SIV_CTX *)vctx;
     SIV128_CONTEXT *sctx = &ctx->siv;
     size_t klen  = keylen / 2;
+    OPENSSL_CTX *libctx = ctx->libctx;
+    const char *propq = NULL;
+
+    EVP_CIPHER_free(ctx->cbc);
+    EVP_CIPHER_free(ctx->ctr);
+    ctx->cbc = NULL;
+    ctx->ctr = NULL;
 
     switch (klen) {
     case 16:
-        ctx->cbc = EVP_CIPHER_fetch(NULL, "AES-128-CBC", "");
-        ctx->ctr = EVP_CIPHER_fetch(NULL, "AES-128-CTR", "");
+        ctx->cbc = EVP_CIPHER_fetch(libctx, "AES-128-CBC", propq);
+        ctx->ctr = EVP_CIPHER_fetch(libctx, "AES-128-CTR", propq);
         break;
     case 24:
-        ctx->cbc = EVP_CIPHER_fetch(NULL, "AES-192-CBC", "");
-        ctx->ctr = EVP_CIPHER_fetch(NULL, "AES-192-CTR", "");
+        ctx->cbc = EVP_CIPHER_fetch(libctx, "AES-192-CBC", propq);
+        ctx->ctr = EVP_CIPHER_fetch(libctx, "AES-192-CTR", propq);
         break;
     case 32:
-        ctx->cbc = EVP_CIPHER_fetch(NULL, "AES-256-CBC", "");
-        ctx->ctr = EVP_CIPHER_fetch(NULL, "AES-256-CTR", "");
+        ctx->cbc = EVP_CIPHER_fetch(libctx, "AES-256-CBC", propq);
+        ctx->ctr = EVP_CIPHER_fetch(libctx, "AES-256-CTR", propq);
         break;
     default:
-        return 0;
+        break;
     }
+    if (ctx->cbc == NULL || ctx->ctr == NULL)
+        return 0;
     /*
      * klen is the length of the underlying cipher, not the input key,
      * which should be twice as long
      */
-    return CRYPTO_siv128_init(sctx, key, klen, ctx->cbc, ctx->ctr);
+    return CRYPTO_siv128_init(sctx, key, klen, ctx->cbc, ctx->ctr, libctx,
+                              propq);
+}
+
+static int aes_siv_dupctx(void *in_vctx, void *out_vctx)
+{
+    PROV_AES_SIV_CTX *in = (PROV_AES_SIV_CTX *)in_vctx;
+    PROV_AES_SIV_CTX *out = (PROV_AES_SIV_CTX *)out_vctx;
+
+    *out = *in;
+    out->siv.cipher_ctx = NULL;
+    out->siv.mac_ctx_init = NULL;
+    out->siv.mac = NULL;
+    if (!CRYPTO_siv128_copy_ctx(&out->siv, &in->siv))
+        return 0;
+    if (out->cbc != NULL)
+        EVP_CIPHER_up_ref(out->cbc);
+    if (out->ctr != NULL)
+        EVP_CIPHER_up_ref(out->ctr);
+    return 1;
 }
 
 static int aes_siv_settag(void *vctx, const unsigned char *tag, size_t tagl)
@@ -96,7 +126,8 @@ static const PROV_CIPHER_HW_AES_SIV aes_siv_hw =
     aes_siv_cipher,
     aes_siv_setspeed,
     aes_siv_settag,
-    aes_siv_cleanup
+    aes_siv_cleanup,
+    aes_siv_dupctx,
 };
 
 const PROV_CIPHER_HW_AES_SIV *PROV_CIPHER_HW_aes_siv(size_t keybits)
diff --git a/providers/implementations/ciphers/cipher_des.c b/providers/implementations/ciphers/cipher_des.c
index 7a60e0501c..9a7c13902f 100644
--- a/providers/implementations/ciphers/cipher_des.c
+++ b/providers/implementations/ciphers/cipher_des.c
@@ -67,6 +67,7 @@ static int des_init(void *vctx, const unsigned char *key, size_t keylen,
 {
     PROV_CIPHER_CTX *ctx = (PROV_CIPHER_CTX *)vctx;
 
+    ctx->num = 0;
     ctx->enc = enc;
 
     if (iv != NULL) {
diff --git a/providers/implementations/ciphers/cipher_tdes_common.c b/providers/implementations/ciphers/cipher_tdes_common.c
index 6cdc88749c..d2379f741b 100644
--- a/providers/implementations/ciphers/cipher_tdes_common.c
+++ b/providers/implementations/ciphers/cipher_tdes_common.c
@@ -57,6 +57,7 @@ static int tdes_init(void *vctx, const unsigned char *key, size_t keylen,
 {
     PROV_CIPHER_CTX *ctx = (PROV_CIPHER_CTX *)vctx;
 
+    ctx->num = 0;
     ctx->enc = enc;
 
     if (iv != NULL) {
diff --git a/providers/implementations/ciphers/ciphercommon.c b/providers/implementations/ciphers/ciphercommon.c
index a8905d1242..a3ebd3f7e7 100644
--- a/providers/implementations/ciphers/ciphercommon.c
+++ b/providers/implementations/ciphers/ciphercommon.c
@@ -149,6 +149,8 @@ static int cipher_generic_init_internal(PROV_CIPHER_CTX *ctx,
                                         const unsigned char *iv, size_t ivlen,
                                         int enc)
 {
+    ctx->num = 0;
+    ctx->updated = 0;
     ctx->enc = enc ? 1 : 0;
 
     if (iv != NULL && ctx->mode != EVP_CIPH_ECB_MODE) {
diff --git a/test/evp_libctx_test.c b/test/evp_libctx_test.c
index 77054f93a2..a9f665842a 100644
--- a/test/evp_libctx_test.c
+++ b/test/evp_libctx_test.c
@@ -23,13 +23,18 @@
 #include <openssl/evp.h>
 #include <openssl/provider.h>
 #include <openssl/dsa.h>
+#include <openssl/safestack.h>
 #include "testutil.h"
 #include "internal/nelem.h"
-#include "crypto/bn_dh.h"        /* _bignum_ffdhe2048_p */
+#include "crypto/bn_dh.h"   /* _bignum_ffdhe2048_p */
+#include "../e_os.h"        /* strcasecmp */
+
+DEFINE_STACK_OF_CSTRING()
 
 static OPENSSL_CTX *libctx = NULL;
 static OSSL_PROVIDER *nullprov = NULL;
 static OSSL_PROVIDER *libprov = NULL;
+static STACK_OF(OPENSSL_CSTRING) *cipher_names = NULL;
 
 typedef enum OPTION_choice {
     OPT_ERR = -1,
@@ -193,9 +198,83 @@ static int test_dh_safeprime_param_keygen(int tstid)
     };
     return do_dh_param_keygen(tstid, bn);
 }
-
 #endif /* OPENSSL_NO_DH */
 
+static int test_cipher_reinit(int test_id)
+{
+    int ret = 0, out1_len = 0, out2_len = 0, diff, ccm;
+    EVP_CIPHER *cipher = NULL;
+    EVP_CIPHER_CTX *ctx = NULL;
+    unsigned char out1[256];
+    unsigned char out2[256];
+    unsigned char in[16] = {
+        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10
+    };
+    unsigned char key[64] = {
+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+        0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+        0x02, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+        0x03, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+    };
+    unsigned char iv[16] = {
+        0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08,
+        0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00
+    };
+    const char *name = sk_OPENSSL_CSTRING_value(cipher_names, test_id);
+
+    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))
+        goto err;
+
+    TEST_note("Fetching %s\n", name);
+    if (!TEST_ptr(cipher = EVP_CIPHER_fetch(libctx, name, NULL)))
+        goto err;
+
+    /* ccm fails on the second update - this matches OpenSSL 1_1_1 behaviour */
+    ccm = (EVP_CIPHER_mode(cipher) == EVP_CIPH_CCM_MODE);
+
+    /* DES3-WRAP uses random every update - so it will give a different value */
+    diff = EVP_CIPHER_is_a(cipher, "DES3-WRAP");
+
+    if (!TEST_true(EVP_EncryptInit_ex(ctx, cipher, NULL, key, iv))
+        || !TEST_true(EVP_EncryptUpdate(ctx, out1, &out1_len, in, sizeof(in)))
+        || !TEST_true(EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv))
+        || !TEST_int_eq(EVP_EncryptUpdate(ctx, out2, &out2_len, in, sizeof(in)),
+                        ccm ? 0 : 1))
+        goto err;
+
+    if (ccm == 0) {
+        if (diff) {
+            if (!TEST_mem_ne(out1, out1_len, out2, out2_len))
+                goto err;
+        } else {
+            if (!TEST_mem_eq(out1, out1_len, out2, out2_len))
+                goto err;
+        }
+    }
+    ret = 1;
+err:
+    EVP_CIPHER_free(cipher);
+    EVP_CIPHER_CTX_free(ctx);
+    return ret;
+}
+
+static int name_cmp(const char * const *a, const char * const *b)
+{
+    return strcasecmp(*a, *b);
+}
+
+static void collect_cipher_names(EVP_CIPHER *cipher, void *cipher_names_list)
+{
+    STACK_OF(OPENSSL_CSTRING) *names = cipher_names_list;
+
+    sk_OPENSSL_CSTRING_push(names, EVP_CIPHER_name(cipher));
+}
+
 int setup_tests(void)
 {
     const char *prov_name = "default";
@@ -242,11 +321,18 @@ int setup_tests(void)
 #ifndef OPENSSL_NO_DH
     ADD_ALL_TESTS(test_dh_safeprime_param_keygen, 3 * 3 * 3);
 #endif
+
+    if (!TEST_ptr(cipher_names = sk_OPENSSL_CSTRING_new(name_cmp)))
+        return 0;
+    EVP_CIPHER_do_all_provided(libctx, collect_cipher_names, cipher_names);
+
+    ADD_ALL_TESTS(test_cipher_reinit, sk_OPENSSL_CSTRING_num(cipher_names));
     return 1;
 }
 
 void cleanup_tests(void)
 {
+    sk_OPENSSL_CSTRING_free(cipher_names);
     OSSL_PROVIDER_unload(libprov);
     OPENSSL_CTX_free(libctx);
     OSSL_PROVIDER_unload(nullprov);
diff --git a/test/recipes/30-test_evp_libctx.t b/test/recipes/30-test_evp_libctx.t
index 0d0a762900..8c36a9e24e 100644
--- a/test/recipes/30-test_evp_libctx.t
+++ b/test/recipes/30-test_evp_libctx.t
@@ -27,7 +27,7 @@ my $infile = bldtop_file('providers', platform->dso('fips'));
 my @test_args = ( );
 
 plan tests =>
-    ($no_fips ? 0 : 1)          # FIPS install test
+    ($no_fips ? 0 : 2)          # FIPS install test
     + 1;
 
 unless ($no_fips) {
@@ -36,10 +36,11 @@ unless ($no_fips) {
 
     ok(run(app(['openssl', 'fipsinstall',
                '-out', bldtop_file('providers', 'fipsmodule.cnf'),
-               '-module', $infile,
-               '-provider_name', 'fips', '-mac_name', 'HMAC',
-               '-section_name', 'fips_sect'])),
+               '-module', $infile])),
        "fipsinstall");
+    ok(run(test(["evp_libctx_test", @test_args])), "running fips evp_libctx_test");
 }
 
-ok(run(test(["evp_libctx_test", @test_args])), "running evp_libctx_test");
+ok(run(test(["evp_libctx_test",
+             "-config", srctop_file("test","default-and-legacy.cnf"),])),
+   "running default-and-legacy evp_libctx_test");

[DF] commit 63794b048cbe46ac9abb883df4dd703f522e4643
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Thu Jul 9 13:43:10 2020 +1000

    Add multiple fixes for ffc key generation using invalid p,q,g parameters.
    
    Fixes #11864
    
    - The dsa keygen assumed valid p, q, g values were being passed. If this is not correct then it is
      possible that dsa keygen can either hang or segfault.
      The fix was to do a partial validation of p, q, and g inside the keygen.
    - Fixed a potential double free in the dsa keypair test in the case when in failed (It should never fail!).
      It freed internal object members without setting them to NULL.
    - Changed the FFC key validation to accept 1024 bit keys in non fips mode.
    - Added tests that use both the default provider & fips provider to test these cases.
    
    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
    (Merged from https://github.com/openssl/openssl/pull/12176)

diff --git a/crypto/dh/dh_key.c b/crypto/dh/dh_key.c
index 5d2acca25c..3b4da19cd2 100644
--- a/crypto/dh/dh_key.c
+++ b/crypto/dh/dh_key.c
@@ -287,6 +287,10 @@ static int generate_key(DH *dh)
             } else
 #endif
             {
+                /* Do a partial check for invalid p, q, g */
+                if (!ffc_params_simple_validate(dh->libctx, &dh->params,
+                                                FFC_PARAM_TYPE_DH))
+                    goto err;
                 /*
                  * For FFC FIPS 186-4 keygen
                  * security strength s = 112,
diff --git a/crypto/dsa/dsa_key.c b/crypto/dsa/dsa_key.c
index 7bd9c5ff2e..b537ec0b3c 100644
--- a/crypto/dsa/dsa_key.c
+++ b/crypto/dsa/dsa_key.c
@@ -74,6 +74,11 @@ static int dsa_keygen(DSA *dsa, int pairwise_test)
         priv_key = dsa->priv_key;
     }
 
+    /* Do a partial check for invalid p, q, g */
+    if (!ffc_params_simple_validate(dsa->libctx, &dsa->params,
+                                    FFC_PARAM_TYPE_DSA))
+        goto err;
+
     /*
      * For FFC FIPS 186-4 keygen
      * security strength s = 112,
@@ -110,6 +115,8 @@ static int dsa_keygen(DSA *dsa, int pairwise_test)
         if (!ok) {
             BN_free(dsa->pub_key);
             BN_clear_free(dsa->priv_key);
+            dsa->pub_key = NULL;
+            dsa->priv_key = NULL;
             BN_CTX_free(ctx);
             return ok;
         }
diff --git a/crypto/ffc/ffc_params_generate.c b/crypto/ffc/ffc_params_generate.c
index 325eb6768f..8a0b77e7f8 100644
--- a/crypto/ffc/ffc_params_generate.c
+++ b/crypto/ffc/ffc_params_generate.c
@@ -39,6 +39,11 @@
  */
 static int ffc_validate_LN(size_t L, size_t N, int type)
 {
+#ifndef FIPS_MODULE
+    if (L == 1024 && N == 160)
+        return 80;
+#endif
+
     if (type == FFC_PARAM_TYPE_DH) {
         /* Valid DH L,N parameters from SP800-56Ar3 5.5.1 Table 1 */
         if (L == 2048 && (N == 224 || N == 256))
@@ -498,6 +503,7 @@ int ffc_params_FIPS186_4_gen_verify(OPENSSL_CTX *libctx, FFC_PARAMS *params,
     EVP_MD *md = NULL;
     int verify = (mode == FFC_PARAM_MODE_VERIFY);
     unsigned int flags = verify ? params->flags : 0;
+    const char *def_name;
 
     *res = 0;
 
@@ -506,7 +512,10 @@ int ffc_params_FIPS186_4_gen_verify(OPENSSL_CTX *libctx, FFC_PARAMS *params,
     } else {
         if (N == 0)
             N = (L >= 2048 ? SHA256_DIGEST_LENGTH : SHA_DIGEST_LENGTH) * 8;
-        md = EVP_MD_fetch(libctx, default_mdname(N), NULL);
+        def_name = default_mdname(N);
+        if (def_name == NULL)
+            goto err;
+        md = EVP_MD_fetch(libctx, def_name, NULL);
     }
     if (md == NULL)
         goto err;
diff --git a/crypto/ffc/ffc_params_validate.c b/crypto/ffc/ffc_params_validate.c
index f3df0c2b39..821ff3e88a 100644
--- a/crypto/ffc/ffc_params_validate.c
+++ b/crypto/ffc/ffc_params_validate.c
@@ -78,3 +78,29 @@ int ffc_params_FIPS186_2_validate(OPENSSL_CTX *libctx, const FFC_PARAMS *params,
                                            FFC_PARAM_MODE_VERIFY, type,
                                            L, N, res, cb);
 }
+
+/*
+ * This does a simple check of L and N and partial g.
+ * It makes no attempt to do a full validation of p, q or g since these require
+ * extra parameters such as the digest and seed, which may not be available for
+ * this test.
+ */
+int ffc_params_simple_validate(OPENSSL_CTX *libctx, FFC_PARAMS *params, int type)
+{
+    int ret, res = 0;
+    int save_gindex;
+    unsigned int save_flags;
+
+    if (params == NULL)
+        return 0;
+
+    save_flags = params->flags;
+    save_gindex = params->gindex;
+    params->flags = FFC_PARAM_FLAG_VALIDATE_G;
+    params->gindex = FFC_UNVERIFIABLE_GINDEX;
+
+    ret = ffc_params_FIPS186_4_validate(libctx, params, type, &res, NULL);
+    params->flags = save_flags;
+    params->gindex = save_gindex;
+    return ret != FFC_PARAM_RET_STATUS_FAILED;
+}
diff --git a/include/internal/ffc.h b/include/internal/ffc.h
index 2ed5d72c5c..b352b8d345 100644
--- a/include/internal/ffc.h
+++ b/include/internal/ffc.h
@@ -155,6 +155,7 @@ int ffc_params_FIPS186_2_gen_verify(OPENSSL_CTX *libctx, FFC_PARAMS *params,
                                     int mode, int type, size_t L, size_t N,
                                     int *res, BN_GENCB *cb);
 
+int ffc_params_simple_validate(OPENSSL_CTX *libctx, FFC_PARAMS *params, int type);
 int ffc_params_FIPS186_4_validate(OPENSSL_CTX *libctx, const FFC_PARAMS *params,
                                   int type, int *res, BN_GENCB *cb);
 int ffc_params_FIPS186_2_validate(OPENSSL_CTX *libctx, const FFC_PARAMS *params,
diff --git a/test/build.info b/test/build.info
index 88b35d4d3c..ed547d1488 100644
--- a/test/build.info
+++ b/test/build.info
@@ -36,7 +36,7 @@ IF[{- !$disabled{tests} -}]
           destest mdc2test \
           enginetest exptest \
           evp_pkey_provided_test evp_test evp_extra_test evp_extra_test2 \
-          evp_fetch_prov_test acvp_test \
+          evp_fetch_prov_test acvp_test evp_libctx_test \
           v3nametest v3ext \
           evp_pkey_provided_test evp_test evp_extra_test evp_extra_test2 \
           evp_fetch_prov_test v3nametest v3ext \
@@ -141,6 +141,10 @@ IF[{- !$disabled{tests} -}]
   INCLUDE[evp_extra_test2]=../include ../apps/include
   DEPEND[evp_extra_test2]=../libcrypto libtestutil.a
 
+  SOURCE[evp_libctx_test]=evp_libctx_test.c
+  INCLUDE[evp_libctx_test]=../include ../apps/include
+  DEPEND[evp_libctx_test]=../libcrypto.a libtestutil.a
+
   SOURCE[evp_fetch_prov_test]=evp_fetch_prov_test.c
   INCLUDE[evp_fetch_prov_test]=../include ../apps/include
   DEPEND[evp_fetch_prov_test]=../libcrypto libtestutil.a
diff --git a/test/evp_libctx_test.c b/test/evp_libctx_test.c
new file mode 100644
index 0000000000..77054f93a2
--- /dev/null
+++ b/test/evp_libctx_test.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright 2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+/*
+
+ * These tests are setup to load null into the default library context.
+ * Any tests are expected to use the created 'libctx' to find algorithms.
+ * The framework runs the tests twice using the 'default' provider or
+ * 'fips' provider as inputs.
+ */
+
+/*
+ * DSA/DH low level APIs are deprecated for public use, but still ok for
+ * internal use.
+ */
+#include "internal/deprecated.h"
+#include <openssl/evp.h>
+#include <openssl/provider.h>
+#include <openssl/dsa.h>
+#include "testutil.h"
+#include "internal/nelem.h"
+#include "crypto/bn_dh.h"        /* _bignum_ffdhe2048_p */
+
+static OPENSSL_CTX *libctx = NULL;
+static OSSL_PROVIDER *nullprov = NULL;
+static OSSL_PROVIDER *libprov = NULL;
+
+typedef enum OPTION_choice {
+    OPT_ERR = -1,
+    OPT_EOF = 0,
+    OPT_CONFIG_FILE,
+    OPT_PROVIDER_NAME,
+    OPT_TEST_ENUM
+} OPTION_CHOICE;
+
+const OPTIONS *test_get_options(void)
+{
+    static const OPTIONS test_options[] = {
+        OPT_TEST_OPTIONS_DEFAULT_USAGE,
+        { "config", OPT_CONFIG_FILE, '<',
+          "The configuration file to use for the libctx" },
+        { "provider", OPT_PROVIDER_NAME, 's',
+          "The provider to load (The default value is 'default'" },
+        { NULL }
+    };
+    return test_options;
+}
+
+#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_DH)
+static const char *getname(int id)
+{
+    const char *name[] = {"p", "q", "g" };
+
+    if (id >= 0 && id < 3)
+        return name[id];
+    return "?";
+}
+#endif
+
+#ifndef OPENSSL_NO_DSA
+
+static int test_dsa_param_keygen(int tstid)
+{
+    int ret = 0;
+    int expected;
+    EVP_PKEY_CTX *gen_ctx = NULL;
+    EVP_PKEY *pkey_parm = NULL;
+    EVP_PKEY *pkey = NULL;
+    DSA *dsa = NULL;
+    int pind, qind, gind;
+    BIGNUM *p = NULL, *q = NULL, *g = NULL;
+
+    /*
+     * Just grab some fixed dh p, q, g values for testing,
+     * these 'safe primes' should not be used normally for dsa *.
+     */
+    static const BIGNUM *bn[] = {
+        &_bignum_dh2048_256_p,  &_bignum_dh2048_256_q, &_bignum_dh2048_256_g
+    };
+
+    /*
+     * These tests are using bad values for p, q, g by reusing the values.
+     * A value of 0 uses p, 1 uses q and 2 uses g.
+     * There are 27 different combinations, with only the 1 valid combination.
+     */
+    pind = tstid / 9;
+    qind = (tstid / 3) % 3;
+    gind = tstid % 3;
+    expected  = (pind == 0 && qind == 1 && gind == 2);
+
+    TEST_note("Testing with (p, q, g) = (%s, %s, %s)\n", getname(pind),
+              getname(qind), getname(gind));
+
+    if (!TEST_ptr(pkey_parm = EVP_PKEY_new())
+        || !TEST_ptr(dsa = DSA_new())
+        || !TEST_ptr(p = BN_dup(bn[pind]))
+        || !TEST_ptr(q = BN_dup(bn[qind]))
+        || !TEST_ptr(g = BN_dup(bn[gind]))
+        || !TEST_true(DSA_set0_pqg(dsa, p, q, g)))
+        goto err;
+    p = q = g = NULL;
+
+    if (!TEST_true(EVP_PKEY_assign_DSA(pkey_parm, dsa)))
+        goto err;
+    dsa = NULL;
+
+    if (!TEST_ptr(gen_ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey_parm, NULL))
+        || !TEST_int_gt(EVP_PKEY_keygen_init(gen_ctx), 0)
+        || !TEST_int_eq(EVP_PKEY_keygen(gen_ctx, &pkey), expected))
+        goto err;
+    ret = 1;
+err:
+    EVP_PKEY_free(pkey);
+    EVP_PKEY_CTX_free(gen_ctx);
+    EVP_PKEY_free(pkey_parm);
+    DSA_free(dsa);
+    BN_free(g);
+    BN_free(q);
+    BN_free(p);
+    return ret;
+}
+#endif /* OPENSSL_NO_DSA */
+
+#ifndef OPENSSL_NO_DH
+static int do_dh_param_keygen(int tstid, const BIGNUM **bn)
+{
+    int ret = 0;
+    int expected;
+    EVP_PKEY_CTX *gen_ctx = NULL;
+    EVP_PKEY *pkey_parm = NULL;
+    EVP_PKEY *pkey = NULL;
+    DH *dh = NULL;
+    int pind, qind, gind;
+    BIGNUM *p = NULL, *q = NULL, *g = NULL;
+
+    /*
+     * These tests are using bad values for p, q, g by reusing the values.
+     * A value of 0 uses p, 1 uses q and 2 uses g.
+     * There are 27 different combinations, with only the 1 valid combination.
+     */
+    pind = tstid / 9;
+    qind = (tstid / 3) % 3;
+    gind = tstid % 3;
+    expected  = (pind == 0 && qind == 1 && gind == 2);
+
+    TEST_note("Testing with (p, q, g) = (%s, %s, %s)", getname(pind),
+              getname(qind), getname(gind));
+
+    if (!TEST_ptr(pkey_parm = EVP_PKEY_new())
+        || !TEST_ptr(dh = DH_new())
+        || !TEST_ptr(p = BN_dup(bn[pind]))
+        || !TEST_ptr(q = BN_dup(bn[qind]))
+        || !TEST_ptr(g = BN_dup(bn[gind]))
+        || !TEST_true(DH_set0_pqg(dh, p, q, g)))
+        goto err;
+    p = q = g = NULL;
+
+    if (!TEST_true(EVP_PKEY_assign_DH(pkey_parm, dh)))
+        goto err;
+    dh = NULL;
+
+    if (!TEST_ptr(gen_ctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey_parm, NULL))
+        || !TEST_int_gt(EVP_PKEY_keygen_init(gen_ctx), 0)
+        || !TEST_int_eq(EVP_PKEY_keygen(gen_ctx, &pkey), expected))
+        goto err;
+    ret = 1;
+err:
+    EVP_PKEY_free(pkey);
+    EVP_PKEY_CTX_free(gen_ctx);
+    EVP_PKEY_free(pkey_parm);
+    DH_free(dh);
+    BN_free(g);
+    BN_free(q);
+    BN_free(p);
+    return ret;
+}
+
+/*
+ * Note that we get the fips186-4 path being run for most of these cases since
+ * the internal code will detect that the p, q, g does not match a safe prime
+ * group (Except for when tstid = 5, which sets the correct p, q, g)
+ */
+static int test_dh_safeprime_param_keygen(int tstid)
+{
+    static const BIGNUM *bn[] = {
+        &_bignum_ffdhe2048_p,  &_bignum_ffdhe2048_q, &_bignum_const_2
+    };
+    return do_dh_param_keygen(tstid, bn);
+}
+
+#endif /* OPENSSL_NO_DH */
+
+int setup_tests(void)
+{
+    const char *prov_name = "default";
+    char *config_file = NULL;
+    OPTION_CHOICE o;
+
+    while ((o = opt_next()) != OPT_EOF) {
+        switch (o) {
+        case OPT_PROVIDER_NAME:
+            prov_name = opt_arg();
+            break;
+        case OPT_CONFIG_FILE:
+            config_file = opt_arg();
+            break;
+        case OPT_TEST_CASES:
+           break;
+        default:
+        case OPT_ERR:
+            return 0;
+        }
+    }
+
+    nullprov = OSSL_PROVIDER_load(NULL, "null");
+    if (!TEST_ptr(nullprov))
+        return 0;
+
+    libctx = OPENSSL_CTX_new();
+
+    if (!TEST_ptr(libctx))
+        return 0;
+
+    if (config_file != NULL) {
+        if (!TEST_true(OPENSSL_CTX_load_config(libctx, config_file)))
+            return 0;
+    }
+
+    libprov = OSSL_PROVIDER_load(libctx, prov_name);
+    if (!TEST_ptr(libprov))
+        return 0;
+
+#ifndef OPENSSL_NO_DSA
+    ADD_ALL_TESTS(test_dsa_param_keygen, 3 * 3 * 3);
+#endif
+#ifndef OPENSSL_NO_DH
+    ADD_ALL_TESTS(test_dh_safeprime_param_keygen, 3 * 3 * 3);
+#endif
+    return 1;
+}
+
+void cleanup_tests(void)
+{
+    OSSL_PROVIDER_unload(libprov);
+    OPENSSL_CTX_free(libctx);
+    OSSL_PROVIDER_unload(nullprov);
+}
diff --git a/test/ffc_internal_test.c b/test/ffc_internal_test.c
index 632cead926..1acc342f6e 100644
--- a/test/ffc_internal_test.c
+++ b/test/ffc_internal_test.c
@@ -399,13 +399,6 @@ static int ffc_params_fips186_2_gen_validate_test(void)
                                                  FFC_PARAM_TYPE_DH,
                                                  &res, NULL)))
         goto err;
-    /* FIPS 186-4 L,N pair test will fail for DH */
-    if (!TEST_false(ffc_params_FIPS186_4_validate(NULL, &params,
-                                                  FFC_PARAM_TYPE_DH,
-                                                  &res, NULL)))
-        goto err;
-    if (!TEST_int_eq(res, FFC_CHECK_BAD_LN_PAIR))
-        goto err;
 
     /*
      * The fips186-2 generation should produce a different q compared to
diff --git a/test/recipes/30-test_evp_libctx.t b/test/recipes/30-test_evp_libctx.t
new file mode 100644
index 0000000000..8fcc71a1cd
--- /dev/null
+++ b/test/recipes/30-test_evp_libctx.t
@@ -0,0 +1,46 @@
+#! /usr/bin/env perl
+# Copyright 2020 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://www.openssl.org/source/license.html
+
+use strict;
+use warnings;
+
+use OpenSSL::Test qw(:DEFAULT bldtop_dir srctop_dir srctop_file bldtop_file);
+use OpenSSL::Test::Utils;
+
+BEGIN {
+    setup("test_evp_libctx");
+}
+
+my $no_fips = disabled('fips') || ($ENV{NO_FIPS} // 0);
+
+use lib srctop_dir('Configurations');
+use lib bldtop_dir('.');
+use platform;
+
+my $infile = bldtop_file('providers', platform->dso('fips'));
+# If no fips then run the test with no extra arguments.
+my @test_args = ( );
+
+plan tests =>
+    ($no_fips ? 0 : 1)          # FIPS install test
+    + 1;
+
+unless ($no_fips) {
+    @test_args = ("-config", srctop_file("test","fips.cnf"),
+                  "-provider", "fips");
+
+    ok(run(app(['openssl', 'fipsinstall',
+               '-out', bldtop_file('providers', 'fipsmodule.cnf'),
+               '-module', $infile,
+               '-provider_name', 'fips', '-mac_name', 'HMAC',
+               '-macopt', 'digest:SHA256', '-macopt', 'hexkey:00',
+               '-section_name', 'fips_sect'])),
+       "fipsinstall");
+}
+
+ok(run(test(["evp_libctx_test", @test_args])), "running evp_libctx_test");

[ML] commit 587e4e53f886cd4d7a8b0eb063b823409e2ed4b9
Author: Nicola Tuveri <nic.tuv@gmail.com>
Date:   Sun Jun 28 17:07:59 2020 +0300

    Fix memory leaks on OSSL_SERIALIZER_CTX_new_by_EVP_PKEY
    
    Fixes #12303
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/12304)

diff --git a/crypto/serializer/serializer_pkey.c b/crypto/serializer/serializer_pkey.c
index d612070240..1e7fc3eafb 100644
--- a/crypto/serializer/serializer_pkey.c
+++ b/crypto/serializer/serializer_pkey.c
@@ -292,8 +292,6 @@ OSSL_SERIALIZER_CTX *OSSL_SERIALIZER_CTX_new_by_EVP_PKEY(const EVP_PKEY *pkey,
         const OSSL_PROVIDER *desired_prov = EVP_KEYMGMT_provider(keymgmt);
         OPENSSL_CTX *libctx = ossl_provider_library_context(desired_prov);
         struct selected_serializer_st sel_data;
-        OSSL_PROPERTY_LIST *check = ossl_parse_query(libctx, "type=parameters");
-        OSSL_PROPERTY_LIST *current_props = NULL;
         OSSL_SERIALIZER *first = NULL;
         const char *name;
         int i;
@@ -347,6 +345,9 @@ OSSL_SERIALIZER_CTX *OSSL_SERIALIZER_CTX_new_by_EVP_PKEY(const EVP_PKEY *pkey,
             ser = first;
 
         if (ser != NULL) {
+            OSSL_PROPERTY_LIST *check = NULL, *current_props = NULL;
+
+            check = ossl_parse_query(libctx, "type=parameters");
             current_props =
                 ossl_parse_property(libctx, OSSL_SERIALIZER_properties(ser));
             if (ossl_property_match_count(check, current_props) > 0)

[ML] commit 33c41876edbb8e63b2f6633db894726f48044932
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Mon Jun 22 16:33:13 2020 +0200

    apps/cmp.c: Fix memory leaks in handle_opt_geninfo() found by Coverity
    
    CID 1463578:  Resource leaks  (RESOURCE_LEAK)
    CID 1463575:  Resource leaks  (RESOURCE_LEAK)
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/12231)

diff --git a/apps/cmp.c b/apps/cmp.c
index 05fae77d38..638005b4fc 100644
--- a/apps/cmp.c
+++ b/apps/cmp.c
@@ -2042,12 +2042,11 @@ static int handle_opt_geninfo(OSSL_CMP_CTX *ctx)
         return 0;
     }
 
-    aint = ASN1_INTEGER_new();
-    if (aint == NULL || !ASN1_INTEGER_set(aint, value))
+    if ((aint = ASN1_INTEGER_new()) == NULL)
         goto oom;
 
     val = ASN1_TYPE_new();
-    if (val == NULL) {
+    if (!ASN1_INTEGER_set(aint, value) || val == NULL) {
         ASN1_INTEGER_free(aint);
         goto oom;
     }
@@ -2065,6 +2064,7 @@ static int handle_opt_geninfo(OSSL_CMP_CTX *ctx)
     return 1;
 
  oom:
+    ASN1_OBJECT_free(type);
     CMP_err("out of memory");
     return 0;
 }

[DF] commit 7905806c94b17b1907d5352ceb047dd8d859288c
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Wed Jun 17 17:26:47 2020 +1000

    Fix potential double free in rsa_keygen pairwise test.
    
    It should never hit this branch of code, so there is no feasible test.
    Found due to a similar issue in PR #12176.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/12177)

diff --git a/crypto/rsa/rsa_gen.c b/crypto/rsa/rsa_gen.c
index e391f6419a..1cdc8d91e8 100644
--- a/crypto/rsa/rsa_gen.c
+++ b/crypto/rsa/rsa_gen.c
@@ -451,6 +451,12 @@ static int rsa_keygen(OPENSSL_CTX *libctx, RSA *rsa, int bits, int primes,
             BN_clear_free(rsa->dmp1);
             BN_clear_free(rsa->dmq1);
             BN_clear_free(rsa->iqmp);
+            rsa->d = NULL;
+            rsa->p = NULL;
+            rsa->q = NULL;
+            rsa->dmp1 = NULL;
+            rsa->dmq1 = NULL;
+            rsa->iqmp = NULL;
         }
     }
     return ok;

[DF] commit 0d52ede71685e4176999cc5e52000dcb540747fc
Author: Matt Caswell <matt@openssl.org>
Date:   Wed May 13 14:45:36 2020 +0100

    Fix error path in int create_ssl_ctx_pair()
    
    If we hit the error path and create_ssl_ctx_pair has been passed a
    pre-created SSL_CTX then we could end up with a double free.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/11834)

diff --git a/test/ssltestlib.c b/test/ssltestlib.c
index ce0e776110..96c1a7f2de 100644
--- a/test/ssltestlib.c
+++ b/test/ssltestlib.c
@@ -741,8 +741,10 @@ const SSL_METHOD *cm,
     return 1;
 
  err:
-    SSL_CTX_free(serverctx);
-    SSL_CTX_free(clientctx);
+    if (*sctx == NULL)
+        SSL_CTX_free(serverctx);
+    if (cctx != NULL && *cctx == NULL)
+        SSL_CTX_free(clientctx);
     return 0;
 }
 

[ML] commit 5606922c3d2e8c3d3ffda4347cb9fe3992d75f89
Author: Richard Levitte <levitte@openssl.org>
Date:   Sat May 23 17:34:07 2020 +0200

    PROV: Fix RSA-OAEP memory leak
    
    The OAEP label wasn't freed when the operation context was freed.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/11927)

diff --git a/providers/implementations/asymciphers/rsa_enc.c b/providers/implementations/asymciphers/rsa_enc.c
index 405842e69e..1f9ded4a65 100644
--- a/providers/implementations/asymciphers/rsa_enc.c
+++ b/providers/implementations/asymciphers/rsa_enc.c
@@ -257,6 +257,7 @@ static void rsa_freectx(void *vprsactx)
 
     EVP_MD_free(prsactx->oaep_md);
     EVP_MD_free(prsactx->mgf1_md);
+    OPENSSL_free(prsactx->oaep_label);
 
     OPENSSL_free(prsactx);
 }

[UAF] commit e12813d0d31f4f7be2ccc592d382ef3e94bdb842
Author: Tomas Mraz <tmraz@fedoraproject.org>
Date:   Thu May 21 13:16:57 2020 +0200

    Prevent use after free of global_engine_lock
    
    If buggy application calls engine functions after cleanup of engines
    already happened the global_engine_lock will be used although
    already freed.
    
    See for example:
    https://bugzilla.redhat.com/show_bug.cgi?id=1831086
    
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    (Merged from https://github.com/openssl/openssl/pull/11896)

diff --git a/crypto/engine/eng_lib.c b/crypto/engine/eng_lib.c
index 4ba235ca75..0cdb3fde42 100644
--- a/crypto/engine/eng_lib.c
+++ b/crypto/engine/eng_lib.c
@@ -171,6 +171,7 @@ void engine_cleanup_int(void)
         cleanup_stack = NULL;
     }
     CRYPTO_THREAD_lock_free(global_engine_lock);
+    global_engine_lock = NULL;
 }
 
 /* Now the "ex_data" support */

[ML] commit 3c38fa4b797848a76b83f91e423de470adbb3b61
Author: Dr. David von Oheimb <David.von.Oheimb@siemens.com>
Date:   Tue May 12 10:14:00 2020 +0200

    Preliminary fix of memory leak in try_decode_PKCS12() - full fix is in #11733
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/11470)

diff --git a/crypto/store/loader_file.c b/crypto/store/loader_file.c
index 9f6158ff79..320c527a65 100644
--- a/crypto/store/loader_file.c
+++ b/crypto/store/loader_file.c
@@ -278,6 +278,7 @@ static OSSL_STORE_INFO *try_decode_PKCS12(const char *pem_name,
                         (void)sk_X509_shift(chain);
                     }
                 }
+                sk_X509_free(chain);
                 if (!ok) {
                     OSSL_STORE_INFO_free(osi_ca);
                     OSSL_STORE_INFO_free(osi_cert);

[ML] commit 15dd075f708c58bbbbd18f98608fecfcb97f693a
Author: Matt Caswell <matt@openssl.org>
Date:   Fri May 1 15:15:13 2020 +0100

    Fix a memory leak in CONF .include handling
    
    If OPENSSL_CONF_INCLUDE has been set then we may leak the "include"
    buffer.
    
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/11691)

diff --git a/crypto/conf/conf_def.c b/crypto/conf/conf_def.c
index 9dbda10edf..6efe291ac8 100644
--- a/crypto/conf/conf_def.c
+++ b/crypto/conf/conf_def.c
@@ -420,6 +420,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                     OPENSSL_strlcpy(include_path, include_dir, newlen);
                     OPENSSL_strlcat(include_path, "/", newlen);
                     OPENSSL_strlcat(include_path, include, newlen);
+                    OPENSSL_free(include);
                 } else {
                     include_path = include;
                 }
@@ -429,15 +430,11 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                 next = process_include(include_path, &dirctx, &dirpath);
                 if (include_path != dirpath) {
                     /* dirpath will contain include in case of a directory */
-                    OPENSSL_free(include);
-                    if (include_path != include)
-                        OPENSSL_free(include_path);
+                    OPENSSL_free(include_path);
                 }
 #else
                 next = BIO_new_file(include_path, "r");
-                OPENSSL_free(include);
-                if (include_path != include)
-                    OPENSSL_free(include_path);
+                OPENSSL_free(include_path);
 #endif
 
                 if (next != NULL) {

[DF] commit 92f0684d11de6e7ff35cd14d26160545451d1ea6
Author: Pauli <paul.dale@oracle.com>
Date:   Mon Apr 27 07:32:43 2020 +1000

    param bld: avoid freeing the param builder structure on error paths.
    
    The param builder was recently modified so that it doesn't free the passed in
    param builder structure.  Some of the error paths didn't get synced up with this
    change and resulted in double frees.
    
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/11651)

diff --git a/crypto/param_build.c b/crypto/param_build.c
index c4624ec33e..43b194bcea 100644
--- a/crypto/param_build.c
+++ b/crypto/param_build.c
@@ -361,14 +361,12 @@ OSSL_PARAM *OSSL_PARAM_BLD_to_param(OSSL_PARAM_BLD *bld)
         if (s == NULL) {
             CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_TO_PARAM,
                       CRYPTO_R_SECURE_MALLOC_FAILURE);
-            OPENSSL_free(bld);
             return NULL;
         }
     }
     params = OPENSSL_malloc(total);
     if (params == NULL) {
         CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_TO_PARAM, ERR_R_MALLOC_FAILURE);
-        OPENSSL_free(bld);
         OPENSSL_secure_free(s);
         return NULL;
     }

[ML] commit f5056577ba08b3694aab2722eae1c97bf00acc80
Author: Shane Lontis <shane.lontis@oracle.com>
Date:   Thu Apr 9 12:47:46 2020 +1000

    Move legacy ciphers into the legacy provider
    
    DES, idea, seed, rc2, rc4, rc5, cast and blowfish have been moved out of the default provider.
    Code shared between desx and tdes has been moved into a seperate file (cipher_tdes_common.c).
    3 test recipes failed due to using app/openssl calls that used legacy ciphers.
    These calls have been updated to supply both the default and legacy providers.
    Fixed openssl app '-provider' memory leak
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/11419)

diff --git a/apps/include/apps.h b/apps/include/apps.h
index 90f9c2bbe6..f43c12dbf1 100644
--- a/apps/include/apps.h
+++ b/apps/include/apps.h
@@ -286,5 +286,6 @@ extern VERIFY_CB_ARGS verify_args;
 OSSL_PARAM *app_params_new_from_opts(STACK_OF(OPENSSL_STRING) *opts,
                                      const OSSL_PARAM *paramdefs);
 void app_params_free(OSSL_PARAM *params);
+void app_providers_cleanup(void);
 
 #endif
diff --git a/apps/include/opt.h b/apps/include/opt.h
index b4257cca7d..9f82b6f04f 100644
--- a/apps/include/opt.h
+++ b/apps/include/opt.h
@@ -275,8 +275,8 @@
 
 # define OPT_PROV_OPTIONS \
         OPT_SECTION("Provider"), \
-        { "provider", OPT_PROV_PROVIDER, 's', "Provder to load (can be specified multiple times)" }, \
-        { "provider_path", OPT_PROV_PROVIDER_PATH, 's', "Provider load path" }
+        { "provider_path", OPT_PROV_PROVIDER_PATH, 's', "Provider load path (must be before 'provider' argument if required)" }, \
+        { "provider", OPT_PROV_PROVIDER, 's', "Provider to load (can be specified multiple times)" }
 
 # define OPT_PROV_CASES \
         OPT_PROV__FIRST: case OPT_PROV__LAST: break; \
diff --git a/apps/lib/app_provider.c b/apps/lib/app_provider.c
index ac01e8826b..ca24328a2e 100644
--- a/apps/lib/app_provider.c
+++ b/apps/lib/app_provider.c
@@ -10,12 +10,17 @@
 #include "apps.h"
 #include <openssl/err.h>
 #include <openssl/provider.h>
+#include <openssl/safestack.h>
+
+DEFINE_STACK_OF(OSSL_PROVIDER)
 
 /*
  * See comments in opt_verify for explanation of this.
  */
 enum prov_range { OPT_PROV_ENUM };
 
+static STACK_OF(OSSL_PROVIDER) *app_providers = NULL;
+
 static int opt_provider_load(const char *provider)
 {
     OSSL_PROVIDER *prov;
@@ -26,9 +31,27 @@ static int opt_provider_load(const char *provider)
                           opt_getprog(), provider);
         return 0;
     }
+    if (app_providers == NULL)
+        app_providers = sk_OSSL_PROVIDER_new_null();
+    if (app_providers == NULL
+        || !sk_OSSL_PROVIDER_push(app_providers, prov)) {
+        app_providers_cleanup();
+        return 0;
+    }
     return 1;
 }
 
+static void provider_free(OSSL_PROVIDER *prov)
+{
+    OSSL_PROVIDER_unload(prov);
+}
+
+void app_providers_cleanup(void)
+{
+    sk_OSSL_PROVIDER_pop_free(app_providers, provider_free);
+    app_providers = NULL;
+}
+
 static int opt_provider_path(const char *path)
 {
     if (path != NULL && *path == '\0')
diff --git a/apps/openssl.c b/apps/openssl.c
index cafe4046e6..558f662e14 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -368,6 +368,7 @@ int main(int argc, char *argv[])
     }
     ret = 1;
  end:
+    app_providers_cleanup();
     OPENSSL_free(default_config_file);
     lh_FUNCTION_free(prog);
     OPENSSL_free(arg.argv);
diff --git a/crypto/bf/build.info b/crypto/bf/build.info
index 59d5bbcfe3..9fa8187818 100644
--- a/crypto/bf/build.info
+++ b/crypto/bf/build.info
@@ -11,7 +11,15 @@ IF[{- !$disabled{asm} -}]
   ENDIF
 ENDIF
 
-SOURCE[../../libcrypto]=bf_skey.c bf_ecb.c bf_cfb64.c bf_ofb64.c $BFASM
+$ALL=bf_skey.c bf_ecb.c bf_cfb64.c bf_ofb64.c $BFASM
+
+SOURCE[../../libcrypto]=$ALL
+
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# blowfish functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$ALL
+ENDIF
 
 GENERATE[bf-586.s]=asm/bf-586.pl
 DEPEND[bf-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/cast/build.info b/crypto/cast/build.info
index e21e6d55ee..8763f22405 100644
--- a/crypto/cast/build.info
+++ b/crypto/cast/build.info
@@ -12,7 +12,15 @@ IF[{- !$disabled{asm} && !$disabled{pic} -}]
   ENDIF
 ENDIF
 
-SOURCE[../../libcrypto]=c_skey.c c_ecb.c $CASTASM c_cfb64.c c_ofb64.c
+$ALL=c_skey.c c_ecb.c $CASTASM c_cfb64.c c_ofb64.c
+
+SOURCE[../../libcrypto]=$ALL
+
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# cast functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$ALL
+ENDIF
 
 GENERATE[cast-586.s]=asm/cast-586.pl
 DEPEND[cast-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/des/build.info b/crypto/des/build.info
index 1fbbcdf2f9..0e5fd171e2 100644
--- a/crypto/des/build.info
+++ b/crypto/des/build.info
@@ -15,20 +15,23 @@ ENDIF
 
 LIBS=../../libcrypto
 $COMMON=set_key.c ecb3_enc.c $DESASM
-SOURCE[../../libcrypto]=$COMMON\
-        ecb_enc.c  cbc_enc.c \
-        cfb64enc.c cfb64ede.c cfb_enc.c \
-        ofb64ede.c ofb64enc.c ofb_enc.c \
-        str2key.c  pcbc_enc.c qud_cksm.c rand_key.c \
-        fcrypt.c xcbc_enc.c cbc_cksm.c
+$ALL=$COMMON\
+     ecb_enc.c  cbc_enc.c \
+     cfb64enc.c cfb64ede.c cfb_enc.c \
+     ofb64ede.c ofb64enc.c ofb_enc.c \
+     str2key.c  pcbc_enc.c qud_cksm.c rand_key.c \
+     fcrypt.c xcbc_enc.c cbc_cksm.c
+
+SOURCE[../../libcrypto]=$ALL
 SOURCE[../../providers/libfips.a]=$COMMON
 DEFINE[../../libcrypto]=$DESDEF
 DEFINE[../../providers/libfips.a]=$DESDEF
+DEFINE[../../providers/liblegacy.a]=$DESDEF
 
 # When all deprecated symbols are removed, libcrypto doesn't export the
 # DES functions, so we must include them directly in liblegacy.a
 IF[{- $disabled{'deprecated-3.0'} && !$disabled{"mdc2"} -}]
-  SOURCE[../../providers/liblegacy.a]=set_key.c $DESASM
+  SOURCE[../../providers/liblegacy.a]=$ALL
   DEFINE[../../providers/liblegacy.a]=$DESDEF
 ENDIF
 
diff --git a/crypto/idea/build.info b/crypto/idea/build.info
index 2326123797..5441351b9c 100644
--- a/crypto/idea/build.info
+++ b/crypto/idea/build.info
@@ -1,3 +1,10 @@
 LIBS=../../libcrypto
-SOURCE[../../libcrypto]=\
-        i_cbc.c i_cfb64.c i_ofb64.c i_ecb.c i_skey.c
+$ALL=i_cbc.c i_cfb64.c i_ofb64.c i_ecb.c i_skey.c
+
+SOURCE[../../libcrypto]=$ALL
+
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# idea functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$ALL
+ENDIF
diff --git a/crypto/rc2/build.info b/crypto/rc2/build.info
index 47a3fd0d4e..b6d60d6ee3 100644
--- a/crypto/rc2/build.info
+++ b/crypto/rc2/build.info
@@ -1,3 +1,11 @@
 LIBS=../../libcrypto
-SOURCE[../../libcrypto]=\
-        rc2_ecb.c rc2_skey.c rc2_cbc.c rc2cfb64.c rc2ofb64.c
+
+$ALL=rc2_ecb.c rc2_skey.c rc2_cbc.c rc2cfb64.c rc2ofb64.c
+
+SOURCE[../../libcrypto]=$ALL
+
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# rc2 functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$ALL
+ENDIF
diff --git a/crypto/rc4/build.info b/crypto/rc4/build.info
index abc0c52d0c..c7f17ca5f5 100644
--- a/crypto/rc4/build.info
+++ b/crypto/rc4/build.info
@@ -19,6 +19,12 @@ ENDIF
 
 SOURCE[../../libcrypto]=$RC4ASM
 
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# rc4 functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$RC4ASM
+ENDIF
+
 GENERATE[rc4-586.s]=asm/rc4-586.pl
 DEPEND[rc4-586.s]=../perlasm/x86asm.pl
 
diff --git a/crypto/rc5/build.info b/crypto/rc5/build.info
index c684d1ee2e..3e2def8a65 100644
--- a/crypto/rc5/build.info
+++ b/crypto/rc5/build.info
@@ -12,8 +12,15 @@ IF[{- !$disabled{asm} -}]
   ENDIF
 ENDIF
 
-SOURCE[../../libcrypto]=\
-        rc5_skey.c rc5_ecb.c $RC5ASM rc5cfb64.c rc5ofb64.c
+$ALL=rc5_skey.c rc5_ecb.c $RC5ASM rc5cfb64.c rc5ofb64.c
+
+SOURCE[../../libcrypto]=$ALL
+
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# rc5 functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$ALL
+ENDIF
 
 GENERATE[rc5-586.s]=asm/rc5-586.pl
 DEPEND[rc5-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/seed/build.info b/crypto/seed/build.info
index abdcbcaa94..5336f0399c 100644
--- a/crypto/seed/build.info
+++ b/crypto/seed/build.info
@@ -1,2 +1,10 @@
 LIBS=../../libcrypto
-SOURCE[../../libcrypto]=seed.c seed_ecb.c seed_cbc.c seed_cfb.c seed_ofb.c
+$ALL=seed.c seed_ecb.c seed_cbc.c seed_cfb.c seed_ofb.c
+
+SOURCE[../../libcrypto]=$ALL
+
+# When all deprecated symbols are removed, libcrypto doesn't export the
+# seed functions, so we must include them directly in liblegacy.a
+IF[{- $disabled{'deprecated-3.0'} -}]
+  SOURCE[../../providers/liblegacy.a]=$ALL
+ENDIF
diff --git a/providers/build.info b/providers/build.info
index a58c8eae75..54c3381bca 100644
--- a/providers/build.info
+++ b/providers/build.info
@@ -47,7 +47,7 @@ $COMMON_INCLUDES=../crypto ../include implementations/include common/include
 
 INCLUDE[$LIBCOMMON]=$COMMON_INCLUDES
 INCLUDE[$LIBIMPLEMENTATIONS]=.. $COMMON_INCLUDES
-INCLUDE[$LIBLEGACY]=$COMMON_INCLUDES
+INCLUDE[$LIBLEGACY]=.. $COMMON_INCLUDES
 INCLUDE[$LIBNONFIPS]=$COMMON_INCLUDES
 INCLUDE[$LIBFIPS]=.. $COMMON_INCLUDES
 DEFINE[$LIBFIPS]=FIPS_MODE
diff --git a/providers/defltprov.c b/providers/defltprov.c
index 2ec229e16b..f93bd31d57 100644
--- a/providers/defltprov.c
+++ b/providers/defltprov.c
@@ -254,43 +254,12 @@ static const OSSL_ALGORITHM_CAPABLE deflt_ciphers[] = {
     ALG("DES-EDE3-CFB", tdes_ede3_cfb_functions),
     ALG("DES-EDE3-CFB8", tdes_ede3_cfb8_functions),
     ALG("DES-EDE3-CFB1", tdes_ede3_cfb1_functions),
+    ALG("DES3-WRAP:id-smime-alg-CMS3DESwrap", tdes_wrap_cbc_functions),
     ALG("DES-EDE-ECB:DES-EDE", tdes_ede2_ecb_functions),
     ALG("DES-EDE-CBC", tdes_ede2_cbc_functions),
     ALG("DES-EDE-OFB", tdes_ede2_ofb_functions),
     ALG("DES-EDE-CFB", tdes_ede2_cfb_functions),
-    ALG("DESX-CBC:DESX", tdes_desx_cbc_functions),
-    ALG("DES3-WRAP:id-smime-alg-CMS3DESwrap", tdes_wrap_cbc_functions),
-    ALG("DES-ECB", des_ecb_functions),
-    ALG("DES-CBC:DES", des_cbc_functions),
-    ALG("DES-OFB", des_ofb64_functions),
-    ALG("DES-CFB", des_cfb64_functions),
-    ALG("DES-CFB1", des_cfb1_functions),
-    ALG("DES-CFB8", des_cfb8_functions),
 #endif /* OPENSSL_NO_DES */
-#ifndef OPENSSL_NO_BF
-    ALG("BF-ECB", blowfish128ecb_functions),
-    ALG("BF-CBC:BF:BLOWFISH", blowfish128cbc_functions),
-    ALG("BF-OFB", blowfish64ofb64_functions),
-    ALG("BF-CFB", blowfish64cfb64_functions),
-#endif /* OPENSSL_NO_BF */
-#ifndef OPENSSL_NO_IDEA
-    ALG("IDEA-ECB", idea128ecb_functions),
-    ALG("IDEA-CBC:IDEA", idea128cbc_functions),
-    ALG("IDEA-OFB:IDEA-OFB64", idea128ofb64_functions),
-    ALG("IDEA-CFB:IDEA-CFB64", idea128cfb64_functions),
-#endif /* OPENSSL_NO_IDEA */
-#ifndef OPENSSL_NO_CAST
-    ALG("CAST5-ECB", cast5128ecb_functions),
-    ALG("CAST5-CBC:CAST-CBC:CAST", cast5128cbc_functions),
-    ALG("CAST5-OFB", cast564ofb64_functions),
-    ALG("CAST5-CFB", cast564cfb64_functions),
-#endif /* OPENSSL_NO_CAST */
-#ifndef OPENSSL_NO_SEED
-    ALG("SEED-ECB", seed128ecb_functions),
-    ALG("SEED-CBC:SEED", seed128cbc_functions),
-    ALG("SEED-OFB:SEED-OFB128", seed128ofb128_functions),
-    ALG("SEED-CFB:SEED-CFB128", seed128cfb128_functions),
-#endif /* OPENSSL_NO_SEED */
 #ifndef OPENSSL_NO_SM4
     ALG("SM4-ECB", sm4128ecb_functions),
     ALG("SM4-CBC:SM4", sm4128cbc_functions),
@@ -298,27 +267,6 @@ static const OSSL_ALGORITHM_CAPABLE deflt_ciphers[] = {
     ALG("SM4-OFB:SM4-OFB128", sm4128ofb128_functions),
     ALG("SM4-CFB:SM4-CFB128", sm4128cfb128_functions),
 #endif /* OPENSSL_NO_SM4 */
-#ifndef OPENSSL_NO_RC4
-    ALG("RC4", rc4128_functions),
-    ALG("RC4-40", rc440_functions),
-# ifndef OPENSSL_NO_MD5
-    ALG("RC4-HMAC-MD5", rc4_hmac_md5_functions),
-# endif /* OPENSSL_NO_MD5 */
-#endif /* OPENSSL_NO_RC4 */
-#ifndef OPENSSL_NO_RC5
-    ALG("RC5-ECB", rc5128ecb_functions),
-    ALG("RC5-CBC", rc5128cbc_functions),
-    ALG("RC5-OFB", rc5128ofb64_functions),
-    ALG("RC5-CFB", rc5128cfb64_functions),
-#endif /* OPENSSL_NO_RC5 */
-#ifndef OPENSSL_NO_RC2
-    ALG("RC2-ECB", rc2128ecb_functions),
-    ALG("RC2-CBC", rc2128cbc_functions),
-    ALG("RC2-40-CBC", rc240cbc_functions),
-    ALG("RC2-64-CBC", rc264cbc_functions),
-    ALG("RC2-CFB", rc2128cfb128_functions),
-    ALG("RC2-OFB", rc2128ofb128_functions),
-#endif /* OPENSSL_NO_RC2 */
 #ifndef OPENSSL_NO_CHACHA
     ALG("ChaCha20", chacha20_functions),
 # ifndef OPENSSL_NO_POLY1305
diff --git a/providers/implementations/ciphers/build.info b/providers/implementations/ciphers/build.info
index c45ea00f16..c97008c330 100644
--- a/providers/implementations/ciphers/build.info
+++ b/providers/implementations/ciphers/build.info
@@ -11,17 +11,17 @@ $NULL_GOAL=../../libimplementations.a
 $AES_GOAL=../../libimplementations.a
 $TDES_1_GOAL=../../libimplementations.a
 $TDES_2_GOAL=../../libimplementations.a
-$DES_GOAL=../../libimplementations.a
 $ARIA_GOAL=../../libimplementations.a
 $CAMELLIA_GOAL=../../libimplementations.a
-$BLOWFISH_GOAL=../../libimplementations.a
-$IDEA_GOAL=../../libimplementations.a
-$CAST5_GOAL=../../libimplementations.a
-$SEED_GOAL=../../libimplementations.a
+$DES_GOAL=../../liblegacy.a
+$BLOWFISH_GOAL=../../liblegacy.a
+$IDEA_GOAL=../../liblegacy.a
+$CAST5_GOAL=../../liblegacy.a
+$RC2_GOAL=../../liblegacy.a
+$RC4_GOAL=../../liblegacy.a
+$RC5_GOAL=../../liblegacy.a
+$SEED_GOAL=../../liblegacy.a
 $SM4_GOAL=../../libimplementations.a
-$RC4_GOAL=../../libimplementations.a
-$RC5_GOAL=../../libimplementations.a
-$RC2_GOAL=../../libimplementations.a
 $CHACHA_GOAL=../../libimplementations.a
 $CHACHAPOLY_GOAL=../../libimplementations.a
 $SIV_GOAL=../../libimplementations.a
@@ -33,7 +33,7 @@ SOURCE[$COMMON_GOAL]=\
         ciphercommon_ccm.c ciphercommon_ccm_hw.c
 
 IF[{- !$disabled{des} -}]
-  SOURCE[$TDES_1_GOAL]=cipher_tdes.c cipher_tdes_hw.c
+  SOURCE[$TDES_1_GOAL]=cipher_tdes.c cipher_tdes_common.c cipher_tdes_hw.c
 ENDIF
 
 SOURCE[$NULL_GOAL]=\
@@ -63,7 +63,7 @@ IF[{- !$disabled{des} -}]
       cipher_tdes_default.c cipher_tdes_default_hw.c \
       cipher_tdes_wrap.c cipher_tdes_wrap_hw.c
   SOURCE[$DES_GOAL]=\
-      cipher_desx.c cipher_desx_hw.c \
+      cipher_desx.c cipher_desx_hw.c cipher_tdes_common.c\
       cipher_des.c cipher_des_hw.c
 ENDIF
 
diff --git a/providers/implementations/ciphers/cipher_tdes.c b/providers/implementations/ciphers/cipher_tdes.c
index ea0c987a80..82af8bdc16 100644
--- a/providers/implementations/ciphers/cipher_tdes.c
+++ b/providers/implementations/ciphers/cipher_tdes.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2019-2020 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -19,101 +19,10 @@
 #include "prov/implementations.h"
 #include "prov/providercommonerr.h"
 
-void *tdes_newctx(void *provctx, int mode, size_t kbits, size_t blkbits,
-                  size_t ivbits, uint64_t flags, const PROV_CIPHER_HW *hw)
-{
-    PROV_TDES_CTX *tctx = OPENSSL_zalloc(sizeof(*tctx));
-
-    if (tctx != NULL)
-        cipher_generic_initkey(tctx, kbits, blkbits, ivbits, mode, flags, hw,
-                               provctx);
-    return tctx;
-}
-
-void tdes_freectx(void *vctx)
-{
-    PROV_TDES_CTX *ctx = (PROV_TDES_CTX *)vctx;
-
-    OPENSSL_clear_free(ctx,  sizeof(*ctx));
-}
-
-static int tdes_init(void *vctx, const unsigned char *key, size_t keylen,
-                     const unsigned char *iv, size_t ivlen, int enc)
-{
-    PROV_CIPHER_CTX *ctx = (PROV_CIPHER_CTX *)vctx;
-
-    ctx->enc = enc;
-
-    if (iv != NULL) {
-        if (!cipher_generic_initiv(ctx, iv, ivlen))
-            return 0;
-    }
-
-    if (key != NULL) {
-        if (keylen != ctx->keylen) {
-            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEYLEN);
-            return 0;
-        }
-        return ctx->hw->init(ctx, key, ctx->keylen);
-    }
-    return 1;
-}
-
-int tdes_einit(void *vctx, const unsigned char *key, size_t keylen,
-               const unsigned char *iv, size_t ivlen)
-{
-    return tdes_init(vctx, key, keylen, iv, ivlen, 1);
-}
-
-int tdes_dinit(void *vctx, const unsigned char *key, size_t keylen,
-               const unsigned char *iv, size_t ivlen)
-{
-    return tdes_init(vctx, key, keylen, iv, ivlen, 0);
-}
-
-static int tdes_generatekey(PROV_CIPHER_CTX *ctx, void *ptr)
-{
-
-    DES_cblock *deskey = ptr;
-    size_t kl = ctx->keylen;
-
-    if (kl == 0 || RAND_priv_bytes_ex(ctx->libctx, ptr, kl) <= 0)
-        return 0;
-    DES_set_odd_parity(deskey);
-    if (kl >= 16)
-        DES_set_odd_parity(deskey + 1);
-    if (kl >= 24) {
-        DES_set_odd_parity(deskey + 2);
-        return 1;
-    }
-    return 0;
-}
-
-CIPHER_DEFAULT_GETTABLE_CTX_PARAMS_START(tdes)
-    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_RANDOM_KEY, NULL, 0),
-CIPHER_DEFAULT_GETTABLE_CTX_PARAMS_END(tdes)
-
-int tdes_get_ctx_params(void *vctx, OSSL_PARAM params[])
-{
-    PROV_CIPHER_CTX  *ctx = (PROV_CIPHER_CTX *)vctx;
-    OSSL_PARAM *p;
-
-    if (!cipher_generic_get_ctx_params(vctx, params))
-        return 0;
-
-    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_RANDOM_KEY);
-    if (p != NULL && !tdes_generatekey(ctx, p->data)) {
-        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GENERATE_KEY);
-        return 0;
-    }
-    return 1;
-}
-
 /*
  * TODO(3.0) - ECB mode does not use an IV - but existing test code is setting
  * an IV. Fixing this could potentially make applications break.
  */
-
 /* tdes_ede3_ecb_functions */
 IMPLEMENT_tdes_cipher(ede3, EDE3, ecb, ECB, TDES_FLAGS, 64*3, 64, 64, block);
 /* tdes_ede3_cbc_functions */
diff --git a/providers/implementations/ciphers/cipher_tdes_common.c b/providers/implementations/ciphers/cipher_tdes_common.c
new file mode 100644
index 0000000000..36a8962e03
--- /dev/null
+++ b/providers/implementations/ciphers/cipher_tdes_common.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2019-2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+/*
+ * DES low level APIs are deprecated for public use, but still ok for internal
+ * use.
+ */
+#include "internal/deprecated.h"
+
+#include "prov/ciphercommon.h"
+#include "cipher_tdes.h"
+#include <openssl/rand.h>
+#include "prov/implementations.h"
+#include "prov/providercommonerr.h"
+
+void *tdes_newctx(void *provctx, int mode, size_t kbits, size_t blkbits,
+                  size_t ivbits, uint64_t flags, const PROV_CIPHER_HW *hw)
+{
+    PROV_TDES_CTX *tctx = OPENSSL_zalloc(sizeof(*tctx));
+
+    if (tctx != NULL)
+        cipher_generic_initkey(tctx, kbits, blkbits, ivbits, mode, flags, hw,
+                               provctx);
+    return tctx;
+}
+
+void tdes_freectx(void *vctx)
+{
+    PROV_TDES_CTX *ctx = (PROV_TDES_CTX *)vctx;
+
+    OPENSSL_clear_free(ctx,  sizeof(*ctx));
+}
+
+static int tdes_init(void *vctx, const unsigned char *key, size_t keylen,
+                     const unsigned char *iv, size_t ivlen, int enc)
+{
+    PROV_CIPHER_CTX *ctx = (PROV_CIPHER_CTX *)vctx;
+
+    ctx->enc = enc;
+
+    if (iv != NULL) {
+        if (!cipher_generic_initiv(ctx, iv, ivlen))
+            return 0;
+    }
+
+    if (key != NULL) {
+        if (keylen != ctx->keylen) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEYLEN);
+            return 0;
+        }
+        return ctx->hw->init(ctx, key, ctx->keylen);
+    }
+    return 1;
+}
+
+int tdes_einit(void *vctx, const unsigned char *key, size_t keylen,
+               const unsigned char *iv, size_t ivlen)
+{
+    return tdes_init(vctx, key, keylen, iv, ivlen, 1);
+}
+
+int tdes_dinit(void *vctx, const unsigned char *key, size_t keylen,
+               const unsigned char *iv, size_t ivlen)
+{
+    return tdes_init(vctx, key, keylen, iv, ivlen, 0);
+}
+
+CIPHER_DEFAULT_GETTABLE_CTX_PARAMS_START(tdes)
+    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_RANDOM_KEY, NULL, 0),
+CIPHER_DEFAULT_GETTABLE_CTX_PARAMS_END(tdes)
+
+static int tdes_generatekey(PROV_CIPHER_CTX *ctx, void *ptr)
+{
+
+    DES_cblock *deskey = ptr;
+    size_t kl = ctx->keylen;
+
+    if (kl == 0 || RAND_priv_bytes_ex(ctx->libctx, ptr, kl) <= 0)
+        return 0;
+    DES_set_odd_parity(deskey);
+    if (kl >= 16)
+        DES_set_odd_parity(deskey + 1);
+    if (kl >= 24) {
+        DES_set_odd_parity(deskey + 2);
+        return 1;
+    }
+    return 0;
+}
+
+int tdes_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    PROV_CIPHER_CTX  *ctx = (PROV_CIPHER_CTX *)vctx;
+    OSSL_PARAM *p;
+
+    if (!cipher_generic_get_ctx_params(vctx, params))
+        return 0;
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_RANDOM_KEY);
+    if (p != NULL && !tdes_generatekey(ctx, p->data)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GENERATE_KEY);
+        return 0;
+    }
+    return 1;
+}
diff --git a/providers/legacyprov.c b/providers/legacyprov.c
index 3494a8801c..a439cfd32f 100644
--- a/providers/legacyprov.c
+++ b/providers/legacyprov.c
@@ -15,6 +15,8 @@
 #include <openssl/params.h>
 #include "prov/implementations.h"
 
+#define ALG(NAMES, FUNC) { NAMES, "provider=legacy", FUNC }
+
 #ifdef STATIC_LEGACY
 OSSL_provider_init_fn ossl_legacy_provider_init;
 # define OSSL_provider_init ossl_legacy_provider_init
@@ -56,25 +58,78 @@ static int legacy_get_params(const OSSL_PROVIDER *prov, OSSL_PARAM params[])
 
 static const OSSL_ALGORITHM legacy_digests[] = {
 #ifndef OPENSSL_NO_MD2
-    { "MD2", "provider=legacy", md2_functions },
+    ALG("MD2", md2_functions),
 #endif
-
 #ifndef OPENSSL_NO_MD4
-    { "MD4", "provider=legacy", md4_functions },
+    ALG("MD4", md4_functions),
 #endif
-
 #ifndef OPENSSL_NO_MDC2
-    { "MDC2", "provider=legacy", mdc2_functions },
+    ALG("MDC2", mdc2_functions),
 #endif /* OPENSSL_NO_MDC2 */
-
 #ifndef OPENSSL_NO_WHIRLPOOL
-    { "WHIRLPOOL", "provider=legacy", wp_functions },
+    ALG("WHIRLPOOL", wp_functions),
 #endif /* OPENSSL_NO_WHIRLPOOL */
-
 #ifndef OPENSSL_NO_RMD160
-    { "RIPEMD-160:RIPEMD160:RIPEMD:RMD160", "provider=legacy", ripemd160_functions },
+    ALG("RIPEMD-160:RIPEMD160:RIPEMD:RMD160", ripemd160_functions),
 #endif /* OPENSSL_NO_RMD160 */
+    { NULL, NULL, NULL }
+};
 
+static const OSSL_ALGORITHM legacy_ciphers[] = {
+#ifndef OPENSSL_NO_CAST
+    ALG("CAST5-ECB", cast5128ecb_functions),
+    ALG("CAST5-CBC:CAST-CBC:CAST", cast5128cbc_functions),
+    ALG("CAST5-OFB", cast564ofb64_functions),
+    ALG("CAST5-CFB", cast564cfb64_functions),
+#endif /* OPENSSL_NO_CAST */
+#ifndef OPENSSL_NO_BF
+    ALG("BF-ECB", blowfish128ecb_functions),
+    ALG("BF-CBC:BF:BLOWFISH", blowfish128cbc_functions),
+    ALG("BF-OFB", blowfish64ofb64_functions),
+    ALG("BF-CFB", blowfish64cfb64_functions),
+#endif /* OPENSSL_NO_BF */
+#ifndef OPENSSL_NO_IDEA
+    ALG("IDEA-ECB", idea128ecb_functions),
+    ALG("IDEA-CBC:IDEA", idea128cbc_functions),
+    ALG("IDEA-OFB:IDEA-OFB64", idea128ofb64_functions),
+    ALG("IDEA-CFB:IDEA-CFB64", idea128cfb64_functions),
+#endif /* OPENSSL_NO_IDEA */
+#ifndef OPENSSL_NO_SEED
+    ALG("SEED-ECB", seed128ecb_functions),
+    ALG("SEED-CBC:SEED", seed128cbc_functions),
+    ALG("SEED-OFB:SEED-OFB128", seed128ofb128_functions),
+    ALG("SEED-CFB:SEED-CFB128", seed128cfb128_functions),
+#endif /* OPENSSL_NO_SEED */
+#ifndef OPENSSL_NO_RC2
+    ALG("RC2-ECB", rc2128ecb_functions),
+    ALG("RC2-CBC", rc2128cbc_functions),
+    ALG("RC2-40-CBC", rc240cbc_functions),
+    ALG("RC2-64-CBC", rc264cbc_functions),
+    ALG("RC2-CFB", rc2128cfb128_functions),
+    ALG("RC2-OFB", rc2128ofb128_functions),
+#endif /* OPENSSL_NO_RC2 */
+#ifndef OPENSSL_NO_RC4
+    ALG("RC4", rc4128_functions),
+    ALG("RC4-40", rc440_functions),
+# ifndef OPENSSL_NO_MD5
+    ALG("RC4-HMAC-MD5", rc4_hmac_md5_functions),
+# endif /* OPENSSL_NO_MD5 */
+#endif /* OPENSSL_NO_RC4 */
+#ifndef OPENSSL_NO_RC5
+    ALG("RC5-ECB", rc5128ecb_functions),
+    ALG("RC5-CBC", rc5128cbc_functions),
+    ALG("RC5-OFB", rc5128ofb64_functions),
+    ALG("RC5-CFB", rc5128cfb64_functions),
+#endif /* OPENSSL_NO_RC5 */
+#ifndef OPENSSL_NO_DES
+    ALG("DESX-CBC:DESX", tdes_desx_cbc_functions),
+    ALG("DES-ECB", des_ecb_functions),
+    ALG("DES-CBC:DES", des_cbc_functions),
+    ALG("DES-OFB", des_ofb64_functions),
+    ALG("DES-CFB", des_cfb64_functions),
+    ALG("DES-CFB1", des_cfb1_functions),
+    ALG("DES-CFB8", des_cfb8_functions),
+#endif /* OPENSSL_NO_DES */
     { NULL, NULL, NULL }
 };
 
@@ -86,6 +141,8 @@ static const OSSL_ALGORITHM *legacy_query(OSSL_PROVIDER *prov,
     switch (operation_id) {
     case OSSL_OP_DIGEST:
         return legacy_digests;
+    case OSSL_OP_CIPHER:
+        return legacy_ciphers;
     }
     return NULL;
 }
diff --git a/test/recipes/20-test_enc.t b/test/recipes/20-test_enc.t
index b4a8e01878..896de8cde3 100644
--- a/test/recipes/20-test_enc.t
+++ b/test/recipes/20-test_enc.t
@@ -14,7 +14,7 @@ use File::Spec::Functions qw/catfile/;
 use File::Copy;
 use File::Compare qw/compare_text/;
 use File::Basename;
-use OpenSSL::Test qw/:DEFAULT srctop_file/;
+use OpenSSL::Test qw/:DEFAULT srctop_file bldtop_dir/;
 
 setup("test_enc");
 
@@ -26,6 +26,8 @@ my $testsrc = srctop_file("test","recipes",basename($0));
 my $test = catfile(".", "p");
 
 my $cmd = "openssl";
+my $provpath = bldtop_dir("providers");
+my @prov = ("-provider_path", $provpath, "-provider", "default", "-provider", "legacy");
 
 my $ciphersstatus = undef;
 my @ciphers =
@@ -59,8 +61,8 @@ plan tests => 2 + (scalar @ciphers)*2;
 		 @d = ( "enc", @{$variant{$t}}, "-d" );
 	     }
 
-	     ok(run(app([$cmd, @e, "-in", $test, "-out", $cipherfile]))
-		&& run(app([$cmd, @d, "-in", $cipherfile, "-out", $clearfile]))
+	     ok(run(app([$cmd, @e, @prov, "-in", $test, "-out", $cipherfile]))
+		&& run(app([$cmd, @d, @prov, "-in", $cipherfile, "-out", $clearfile]))
 		&& compare_text($test,$clearfile) == 0, $t);
 	 }
      }
diff --git a/test/recipes/20-test_enc_more.t b/test/recipes/20-test_enc_more.t
index a59663412a..7edcff01c8 100644
--- a/test/recipes/20-test_enc_more.t
+++ b/test/recipes/20-test_enc_more.t
@@ -15,7 +15,7 @@ use File::Spec::Functions qw/catfile/;
 use File::Copy;
 use File::Compare qw/compare_text/;
 use File::Basename;
-use OpenSSL::Test qw/:DEFAULT srctop_file/;
+use OpenSSL::Test qw/:DEFAULT srctop_file bldtop_dir/;
 
 setup("test_evp_more");
 
@@ -25,6 +25,8 @@ my $cipherlist = undef;
 my $plaintext = catfile(".", "testdatafile");
 my $fail = "";
 my $cmd = "openssl";
+my $provpath = bldtop_dir("providers");
+my @prov = ("-provider_path", $provpath, "-provider", "default", "-provider", "legacy");
 
 my $ciphersstatus = undef;
 my @ciphers =
@@ -49,9 +51,9 @@ SKIP: {
         my $clearfile = "$plaintext.$ciphername.clear";
         my @common = ( $cmd, "enc", "$cipher", "-k", "test" );
 
-        ok(run(app([@common, "-e", "-in", $plaintext, "-out", $cipherfile]))
+        ok(run(app([@common, @prov, "-e", "-in", $plaintext, "-out", $cipherfile]))
            && compare_text($plaintext, $cipherfile) != 0
-           && run(app([@common, "-d", "-in", $cipherfile, "-out", $clearfile]))
+           && run(app([@common, @prov, "-d", "-in", $cipherfile, "-out", $clearfile]))
            && compare_text($plaintext, $clearfile) == 0
            , $ciphername);
     }
diff --git a/test/recipes/80-test_cms.t b/test/recipes/80-test_cms.t
index fd66557616..0e2969dee0 100644
--- a/test/recipes/80-test_cms.t
+++ b/test/recipes/80-test_cms.t
@@ -13,7 +13,7 @@ use warnings;
 use POSIX;
 use File::Spec::Functions qw/catfile/;
 use File::Compare qw/compare_text/;
-use OpenSSL::Test qw/:DEFAULT srctop_dir srctop_file/;
+use OpenSSL::Test qw/:DEFAULT srctop_dir srctop_file bldtop_dir/;
 use OpenSSL::Test::Utils;
 
 setup("test_cms");
@@ -21,6 +21,9 @@ setup("test_cms");
 plan skip_all => "CMS is not supported by this OpenSSL build"
     if disabled("cms");
 
+my $provpath = bldtop_dir("providers");
+my @prov = ("-provider_path", $provpath, "-provider", "default", "-provider", "legacy");
+
 my $datadir = srctop_dir("test", "recipes", "80-test_cms_data");
 my $smdir    = srctop_dir("test", "smime-certs");
 my $smcont   = srctop_file("test", "smcont.txt");
@@ -311,10 +314,11 @@ my @smime_cms_tests = (
     ],
 
     [ "encrypted content test streaming PEM format, 128 bit RC2 key",
-      [ "{cmd1}", "-EncryptedData_encrypt", "-in", $smcont, "-outform", "PEM",
+      [ "{cmd1}", @prov, "-EncryptedData_encrypt",
+        "-in", $smcont, "-outform", "PEM",
         "-rc2", "-secretkey", "000102030405060708090A0B0C0D0E0F",
         "-stream", "-out", "{output}.cms" ],
-      [ "{cmd2}", "-EncryptedData_decrypt", "-in", "{output}.cms",
+      [ "{cmd2}", @prov, "-EncryptedData_decrypt", "-in", "{output}.cms",
         "-inform", "PEM",
         "-secretkey", "000102030405060708090A0B0C0D0E0F",
         "-out", "{output}.txt" ],
@@ -322,10 +326,11 @@ my @smime_cms_tests = (
     ],
 
     [ "encrypted content test streaming PEM format, 40 bit RC2 key",
-      [ "{cmd1}", "-EncryptedData_encrypt", "-in", $smcont, "-outform", "PEM",
+      [ "{cmd1}", @prov, "-EncryptedData_encrypt",
+        "-in", $smcont, "-outform", "PEM",
         "-rc2", "-secretkey", "0001020304",
         "-stream", "-out", "{output}.cms" ],
-      [ "{cmd2}", "-EncryptedData_decrypt", "-in", "{output}.cms",
+      [ "{cmd2}", @prov, "-EncryptedData_decrypt", "-in", "{output}.cms",
         "-inform", "PEM",
         "-secretkey", "0001020304", "-out", "{output}.txt" ],
       \&final_compare

[ML] commit 0e8b6c97ba7ac37f5e92f6a24d128b04b5336388
Author: Aaron Thompson <dev@aaront.org>
Date:   Tue Mar 31 06:47:58 2020 +0000

    Fix bugs in EC code introduced with FIPS changes.
    
    a9612d6c034f47c4788c67d85651d0cd58c3faf7 introduced possible memory leaks in EC_GROUP_cmp and EC_POINTs_mul, and a possible BN_CTX_end without BN_CTX_start in ec_field_inverse_mod_ord.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/11452)

diff --git a/crypto/ec/ec_lib.c b/crypto/ec/ec_lib.c
index 078d8b35fa..5540ec1bc2 100644
--- a/crypto/ec/ec_lib.c
+++ b/crypto/ec/ec_lib.c
@@ -599,12 +599,7 @@ int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)
     BIGNUM *a1, *a2, *a3, *b1, *b2, *b3;
 #ifndef FIPS_MODE
     BN_CTX *ctx_new = NULL;
-
-    if (ctx == NULL)
-        ctx_new = ctx = BN_CTX_new();
 #endif
-    if (ctx == NULL)
-        return -1;
 
     /* compare the field types */
     if (EC_METHOD_get_field_type(EC_GROUP_method_of(a)) !=
@@ -617,6 +612,13 @@ int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)
     if (a->meth->flags & EC_FLAGS_CUSTOM_CURVE)
         return 0;
 
+#ifndef FIPS_MODE
+    if (ctx == NULL)
+        ctx_new = ctx = BN_CTX_new();
+#endif
+    if (ctx == NULL)
+        return -1;
+
     BN_CTX_start(ctx);
     a1 = BN_CTX_get(ctx);
     a2 = BN_CTX_get(ctx);
@@ -1047,14 +1049,7 @@ int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
     size_t i = 0;
 #ifndef FIPS_MODE
     BN_CTX *new_ctx = NULL;
-
-    if (ctx == NULL)
-        ctx = new_ctx = BN_CTX_secure_new();
 #endif
-    if (ctx == NULL) {
-        ECerr(EC_F_EC_POINTS_MUL, ERR_R_INTERNAL_ERROR);
-        return 0;
-    }
 
     if ((scalar == NULL) && (num == 0)) {
         return EC_POINT_set_to_infinity(group, r);
@@ -1071,6 +1066,15 @@ int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
         }
     }
 
+#ifndef FIPS_MODE
+    if (ctx == NULL)
+        ctx = new_ctx = BN_CTX_secure_new();
+#endif
+    if (ctx == NULL) {
+        ECerr(EC_F_EC_POINTS_MUL, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
     if (group->meth->mul != NULL)
         ret = group->meth->mul(group, r, scalar, num, points, scalars, ctx);
     else
@@ -1183,16 +1187,18 @@ static int ec_field_inverse_mod_ord(const EC_GROUP *group, BIGNUM *r,
     int ret = 0;
 #ifndef FIPS_MODE
     BN_CTX *new_ctx = NULL;
+#endif
+
+    if (group->mont_data == NULL)
+        return 0;
 
+#ifndef FIPS_MODE
     if (ctx == NULL)
         ctx = new_ctx = BN_CTX_secure_new();
 #endif
     if (ctx == NULL)
         return 0;
 
-    if (group->mont_data == NULL)
-        goto err;
-
     BN_CTX_start(ctx);
     if ((e = BN_CTX_get(ctx)) == NULL)
         goto err;

[DF] commit fe56d5951f0b42fd3ff1cf42a96d07f06f9692bc
Author: Matt Caswell <matt@openssl.org>
Date:   Mon Mar 30 14:15:06 2020 +0100

    Don't double free a DH object
    
    Having created a DH object and assigned it to an EVP_PKEY - we should
    not free both the EVP_PKEY and the original DH. This will lead to a
    double free occurring.
    
    This issue was discovered and reported by GitHub Security Lab team member
    Agustin Gianni.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/11441)

diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 534902f9b9..4c4e6cb209 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -2152,9 +2152,10 @@ static int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)
                  ERR_R_EVP_LIB);
         goto err;
     }
+    dh = NULL;
 
     if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),
-                      0, dh)) {
+                      0, EVP_PKEY_get0_DH(peer_tmp))) {
         SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_PROCESS_SKE_DHE,
                  SSL_R_DH_KEY_TOO_SMALL);
         goto err;

[ML] commit a076951b71a1837e68eaf6bfd92e6a4d40b0940a
Author: Richard Levitte <levitte@openssl.org>
Date:   Fri Feb 7 09:13:21 2020 +0100

    X509_PUBKEY_set(): Fix memory leak
    
    With the provided method of creating the new X509_PUBKEY, an extra
    EVP_PKEY is created and needs to be properly cleaned away.
    
    (note: we could choose to keep it just as well, but there are
    consequences, explained in a comment in the code)
    
    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
    (Merged from https://github.com/openssl/openssl/pull/11038)

diff --git a/crypto/x509/x_pubkey.c b/crypto/x509/x_pubkey.c
index 42b94d9198..a583813b58 100644
--- a/crypto/x509/x_pubkey.c
+++ b/crypto/x509/x_pubkey.c
@@ -111,6 +111,22 @@ int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)
         goto error;
     }
     *x = pk;
+
+    /*
+     * pk->pkey is NULL when using the legacy routine, but is non-NULL when
+     * going through the serializer, and for all intents and purposes, it's
+     * a perfect copy of |pkey|, just not the same instance.  In that case,
+     * we could simply return early, right here.
+     * However, in the interest of being cautious leaning on paranoia, some
+     * application might very well depend on the passed |pkey| being used
+     * and none other, so we spend a few more cycles throwing away the newly
+     * created |pk->pkey| and replace it with |pkey|.
+     * TODO(3.0) Investigate if it's safe to change to simply return here
+     * if |pk->pkey != NULL|.
+     */
+    if (pk->pkey != NULL)
+        EVP_PKEY_free(pk->pkey);
+
     pk->pkey = pkey;
     return 1;
 

commit 22c22369bc09988eb8c6fdf4f543581a78fd3eb1
Author: Richard Levitte <levitte@openssl.org>
Date:   Tue Jul 2 16:23:27 2019 +0200

    Use leak sanitizer instead of internal mdebug to check for memory leaks
    
    The leak sanitizer gives better reports (complete stack traces) and
    works as a wrapper around the application instead of relying on
    cooperative enabling and disabling calls (which are too easy to get
    unbalanced).
    
    Related to #8322
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/9294)

diff --git a/.travis.yml b/.travis.yml
index 5e65d37795..6d0fa801e8 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -27,7 +27,7 @@ compiler:
 
 env:
     - CONFIG_OPTS="" DESTDIR="_install"
-    - CONFIG_OPTS="no-asm -Werror --debug no-afalgeng no-shared enable-crypto-mdebug enable-rc5 enable-md2"
+    - CONFIG_OPTS="no-asm -Werror --debug no-afalgeng no-shared enable-rc5 enable-md2 -fsanitize=address" LSAN_OPTIONS="report_objects=1"
     - CONFIG_OPTS="no-asm no-makedepend enable-buildtest-c++ --strict-warnings -D_DEFAULT_SOURCE" BUILDONLY="yes" CHECKDOCS="yes" GENERATE="yes" CPPFLAGS="-ansi"
 
 matrix:

[ML] commit defd3ed820e413d418e408c5a5ea92c889c83727
Author: Pauli <paul.dale@oracle.com>
Date:   Sun Nov 24 18:15:15 2019 +1000

    Property: fix memory leak.
    
    Coverity 1456008.
    
    Reviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>
    (Merged from https://github.com/openssl/openssl/pull/10509)

diff --git a/crypto/property/property.c b/crypto/property/property.c
index 33e7469351..0e31b8fa81 100644
--- a/crypto/property/property.c
+++ b/crypto/property/property.c
@@ -546,9 +546,9 @@ int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, int nid,
         }
         ossl_method_free(&p->method);
     }
-    OPENSSL_free(p);
 err:
     res = 0;
+    OPENSSL_free(p);
 end:
     ossl_property_unlock(store);
     return res;

[ML] commit 93863030867ad0331bf7f199f8a266ad99ee4cf2
Author: Matt Caswell <matt@openssl.org>
Date:   Tue Nov 12 17:37:11 2019 +0000

    Make sure we free the CONF structure allocated by confdump
    
    A travis build was failing because of a memory leak in confdump due to
    us not freeing an allocated CONF structure.
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/10429)

diff --git a/test/confdump.c b/test/confdump.c
index b83119ef34..dbf6244653 100644
--- a/test/confdump.c
+++ b/test/confdump.c
@@ -51,10 +51,10 @@ static void dump_section(const char *name, const CONF *cnf)
 int main(int argc, char **argv)
 {
     long eline;
-    CONF *conf;
+    CONF *conf = NCONF_new(NCONF_default());
+    int ret = 1;
 
-    if ((conf = NCONF_new(NCONF_default())) != NULL
-        && NCONF_load(conf, argv[1], &eline)) {
+    if (conf != NULL && NCONF_load(conf, argv[1], &eline)) {
         int i;
 
         collect_all_sections(conf);
@@ -62,9 +62,10 @@ int main(int argc, char **argv)
             dump_section(sk_OPENSSL_CSTRING_value(section_names, i), conf);
         }
         sk_OPENSSL_CSTRING_free(section_names);
+        ret = 0;
     } else {
         ERR_print_errors_fp(stderr);
-        return 1;
     }
-    return 0;
+    NCONF_free(conf);
+    return ret;
 }

[ML] commit 6624e1f7b6a397948561e9cc2774f0c8af1d2c79
Author: Scott Wilson <scott@sawilson.xyz>
Date:   Thu Oct 31 22:37:51 2019 +1100

    Fix potential memory leak in dh_ameth.c
    
    Free dukm in error handling of dh_cms_encrypt()
    
    Fixes #10294
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Patrick Steuer <patrick.steuer@de.ibm.com>
    (Merged from https://github.com/openssl/openssl/pull/10310)

diff --git a/crypto/dh/dh_ameth.c b/crypto/dh/dh_ameth.c
index abb9bfdcbe..7907f50192 100644
--- a/crypto/dh/dh_ameth.c
+++ b/crypto/dh/dh_ameth.c
@@ -976,6 +976,7 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
  err:
     OPENSSL_free(penc);
     X509_ALGOR_free(wrap_alg);
+    OPENSSL_free(dukm);
     return rv;
 }
 

[DF] commit fb1ecf85c9f732e5827771ff243d7a70e06ce112
Author: Richard Levitte <levitte@openssl.org>
Date:   Tue Oct 29 22:17:19 2019 +0100

    evp_pkey_ctx_free_old_ops(): Make sure to assign NULL to freed pointers
    
    Otherwise, should this function be called more than once on the same
    EVP_PKEY_CTX, we get double free issues.
    
    Reviewed-by: Tomas Mraz <tmraz@fedoraproject.org>
    (Merged from https://github.com/openssl/openssl/pull/10292)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 1186e5ba3a..350d963086 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -201,10 +201,14 @@ void evp_pkey_ctx_free_old_ops(EVP_PKEY_CTX *ctx)
         if (ctx->op.kex.exchprovctx != NULL && ctx->op.kex.exchange != NULL)
             ctx->op.kex.exchange->freectx(ctx->op.kex.exchprovctx);
         EVP_KEYEXCH_free(ctx->op.kex.exchange);
+        ctx->op.kex.exchprovctx = NULL;
+        ctx->op.kex.exchange = NULL;
     } else if (EVP_PKEY_CTX_IS_SIGNATURE_OP(ctx)) {
         if (ctx->op.sig.sigprovctx != NULL && ctx->op.sig.signature != NULL)
             ctx->op.sig.signature->freectx(ctx->op.sig.sigprovctx);
         EVP_SIGNATURE_free(ctx->op.sig.signature);
+        ctx->op.sig.sigprovctx = NULL;
+        ctx->op.sig.signature = NULL;
     }
 }
 

[DF] commit dbb72124cdf1ad0dc223cfd570219e9af043ce7f
Author: Paul Yang <kaishen.yy@antfin.com>
Date:   Sat Sep 21 00:32:57 2019 +0800

    Fix a double free issue when signing SM2 cert
    
    If the SM2 ID value has not been passed correctly when signing an SM2
    certificate/certificate request, a double free occurs. For instance:
    
      openssl req -x509 ... -sm2-id 1234567812345678
    
    The '-sm2-id' should not be used in this scenario, while the '-sigopt' is
    the correct one to use. Documentation has also been updated to make the
    options more clear.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/9958)

diff --git a/apps/req.c b/apps/req.c
index f11d341c12..1c9672cca1 100644
--- a/apps/req.c
+++ b/apps/req.c
@@ -1751,15 +1751,19 @@ int do_X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md,
 #endif
 
     rv = do_sign_init(mctx, pkey, md, sigopts);
-    if (rv > 0)
+    if (rv > 0) {
         rv = X509_sign_ctx(x, mctx);
 #ifndef OPENSSL_NO_SM2
-    /* only in SM2 case we need to free the pctx explicitly */
-    if (ec_pkey_is_sm2(pkey)) {
-        pctx = EVP_MD_CTX_pkey_ctx(mctx);
-        EVP_PKEY_CTX_free(pctx);
-    }
+        /*
+         * only in SM2 case we need to free the pctx explicitly
+         * if do_sign_init() fails, pctx is already freed in it
+         */
+        if (ec_pkey_is_sm2(pkey)) {
+            pctx = EVP_MD_CTX_pkey_ctx(mctx);
+            EVP_PKEY_CTX_free(pctx);
+        }
 #endif
+    }
     EVP_MD_CTX_free(mctx);
     return rv > 0 ? 1 : 0;
 }
@@ -1774,15 +1778,19 @@ int do_X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md,
 #endif
 
     rv = do_sign_init(mctx, pkey, md, sigopts);
-    if (rv > 0)
+    if (rv > 0) {
         rv = X509_REQ_sign_ctx(x, mctx);
 #ifndef OPENSSL_NO_SM2
-    /* only in SM2 case we need to free the pctx explicitly */
-    if (ec_pkey_is_sm2(pkey)) {
-        pctx = EVP_MD_CTX_pkey_ctx(mctx);
-        EVP_PKEY_CTX_free(pctx);
-    }
+        /*
+         * only in SM2 case we need to free the pctx explicitly
+         * if do_sign_init() fails, pctx is already freed in it
+         */
+        if (ec_pkey_is_sm2(pkey)) {
+            pctx = EVP_MD_CTX_pkey_ctx(mctx);
+            EVP_PKEY_CTX_free(pctx);
+        }
 #endif
+    }
     EVP_MD_CTX_free(mctx);
     return rv > 0 ? 1 : 0;
 }
@@ -1797,15 +1805,19 @@ int do_X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md,
 #endif
 
     rv = do_sign_init(mctx, pkey, md, sigopts);
-    if (rv > 0)
+    if (rv > 0) {
         rv = X509_CRL_sign_ctx(x, mctx);
 #ifndef OPENSSL_NO_SM2
-    /* only in SM2 case we need to free the pctx explicitly */
-    if (ec_pkey_is_sm2(pkey)) {
-        pctx = EVP_MD_CTX_pkey_ctx(mctx);
-        EVP_PKEY_CTX_free(pctx);
-    }
+        /*
+         * only in SM2 case we need to free the pctx explicitly
+         * if do_sign_init() fails, no need to double free pctx
+         */
+        if (ec_pkey_is_sm2(pkey)) {
+            pctx = EVP_MD_CTX_pkey_ctx(mctx);
+            EVP_PKEY_CTX_free(pctx);
+        }
 #endif
+    }
     EVP_MD_CTX_free(mctx);
     return rv > 0 ? 1 : 0;
 }
diff --git a/doc/man1/openssl-req.pod b/doc/man1/openssl-req.pod
index 4300504f87..02635b56ea 100644
--- a/doc/man1/openssl-req.pod
+++ b/doc/man1/openssl-req.pod
@@ -342,8 +342,8 @@ for key generation operations.
 
 =item B<-sm2-id>
 
-Specify the ID string to use when verifying an SM2 certificate. The ID string is
-required by the SM2 signature algorithm for signing and verification.
+Specify the ID string to use when verifying an SM2 certificate request. The ID
+string is required by the SM2 signature algorithm for signing and verification.
 
 =item B<-sm2-hex-id>
 

[ML] commit f28bc7d386b25fb75625d0c62c6b2e6d21de0d09
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Mon Sep 9 19:12:25 2019 +0200

    Fix potential memory leaks with BN_to_ASN1_INTEGER
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/9833)

diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index e0d02bb01a..2726f5d151 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -449,6 +449,7 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
     unsigned char *buffer = NULL;
     const EC_POINT *point = NULL;
     point_conversion_form_t form;
+    ASN1_INTEGER *orig;
 
     if (params == NULL) {
         if ((ret = ECPARAMETERS_new()) == NULL) {
@@ -499,8 +500,9 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
         ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
         goto err;
     }
-    ret->order = BN_to_ASN1_INTEGER(tmp, ret->order);
+    ret->order = BN_to_ASN1_INTEGER(tmp, orig = ret->order);
     if (ret->order == NULL) {
+        ret->order = orig;
         ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
         goto err;
     }
@@ -508,8 +510,9 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
     /* set the cofactor (optional) */
     tmp = EC_GROUP_get0_cofactor(group);
     if (tmp != NULL) {
-        ret->cofactor = BN_to_ASN1_INTEGER(tmp, ret->cofactor);
+        ret->cofactor = BN_to_ASN1_INTEGER(tmp, orig = ret->cofactor);
         if (ret->cofactor == NULL) {
+            ret->cofactor = orig;
             ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
             goto err;
         }
diff --git a/crypto/x509/v3_asid.c b/crypto/x509/v3_asid.c
index 1d41380c41..2287675005 100644
--- a/crypto/x509/v3_asid.c
+++ b/crypto/x509/v3_asid.c
@@ -256,6 +256,7 @@ static int extract_min_max(ASIdOrRange *aor,
 static int ASIdentifierChoice_is_canonical(ASIdentifierChoice *choice)
 {
     ASN1_INTEGER *a_max_plus_one = NULL;
+    ASN1_INTEGER *orig;
     BIGNUM *bn = NULL;
     int i, ret = 0;
 
@@ -298,9 +299,15 @@ static int ASIdentifierChoice_is_canonical(ASIdentifierChoice *choice)
          */
         if ((bn == NULL && (bn = BN_new()) == NULL) ||
             ASN1_INTEGER_to_BN(a_max, bn) == NULL ||
-            !BN_add_word(bn, 1) ||
-            (a_max_plus_one =
-             BN_to_ASN1_INTEGER(bn, a_max_plus_one)) == NULL) {
+            !BN_add_word(bn, 1)) {
+            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,
+                      ERR_R_MALLOC_FAILURE);
+            goto done;
+        }
+
+        if ((a_max_plus_one =
+                BN_to_ASN1_INTEGER(bn, orig = a_max_plus_one)) == NULL) {
+            a_max_plus_one = orig;
             X509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,
                       ERR_R_MALLOC_FAILURE);
             goto done;
@@ -351,6 +358,7 @@ int X509v3_asid_is_canonical(ASIdentifiers *asid)
 static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)
 {
     ASN1_INTEGER *a_max_plus_one = NULL;
+    ASN1_INTEGER *orig;
     BIGNUM *bn = NULL;
     int i, ret = 0;
 
@@ -416,9 +424,15 @@ static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)
          */
         if ((bn == NULL && (bn = BN_new()) == NULL) ||
             ASN1_INTEGER_to_BN(a_max, bn) == NULL ||
-            !BN_add_word(bn, 1) ||
-            (a_max_plus_one =
-             BN_to_ASN1_INTEGER(bn, a_max_plus_one)) == NULL) {
+            !BN_add_word(bn, 1)) {
+            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
+                      ERR_R_MALLOC_FAILURE);
+            goto done;
+        }
+
+        if ((a_max_plus_one =
+                 BN_to_ASN1_INTEGER(bn, orig = a_max_plus_one)) == NULL) {
+            a_max_plus_one = orig;
             X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
                       ERR_R_MALLOC_FAILURE);
             goto done;

[ML] commit 5b3accde606ffe01466426bd59407ffca0690d23
Author: FdaSilvaYY <fdasilvayy@gmail.com>
Date:   Mon May 20 00:33:58 2019 +0200

    OCSP: fix memory leak in OCSP_url_svcloc_new method.
    Add a few coverage test case.
    
    Fixes #8949
    
    [extended tests]
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/8959)

diff --git a/crypto/ocsp/ocsp_ext.c b/crypto/ocsp/ocsp_ext.c
index 8ebfd6284e..c5cf279170 100644
--- a/crypto/ocsp/ocsp_ext.c
+++ b/crypto/ocsp/ocsp_ext.c
@@ -439,6 +439,7 @@ X509_EXTENSION *OCSP_url_svcloc_new(X509_NAME *issuer, const char **urls)
 
     if ((sloc = OCSP_SERVICELOC_new()) == NULL)
         goto err;
+    X509_NAME_free(sloc->issuer);
     if ((sloc->issuer = X509_NAME_dup(issuer)) == NULL)
         goto err;
     if (urls && *urls
@@ -449,12 +450,11 @@ X509_EXTENSION *OCSP_url_svcloc_new(X509_NAME *issuer, const char **urls)
             goto err;
         if ((ad->method = OBJ_nid2obj(NID_ad_OCSP)) == NULL)
             goto err;
-        if ((ad->location = GENERAL_NAME_new()) == NULL)
-            goto err;
         if ((ia5 = ASN1_IA5STRING_new()) == NULL)
             goto err;
         if (!ASN1_STRING_set((ASN1_STRING *)ia5, *urls, -1))
             goto err;
+        /* ad->location is allocated inside ACCESS_DESCRIPTION_new */
         ad->location->type = GEN_URI;
         ad->location->d.ia5 = ia5;
         ia5 = NULL;
diff --git a/test/ocspapitest.c b/test/ocspapitest.c
index 03b88e064b..355bd448ae 100644
--- a/test/ocspapitest.c
+++ b/test/ocspapitest.c
@@ -47,6 +47,24 @@ static int get_cert_and_key(X509 **cert_out, EVP_PKEY **key_out)
     return 0;
 }
 
+static int get_cert(X509 **cert_out)
+{
+    BIO *certbio;
+    X509 *cert = NULL;
+
+    if (!TEST_ptr(certbio = BIO_new_file(certstr, "r")))
+        return 0;
+    cert = PEM_read_bio_X509(certbio, NULL, NULL, NULL);
+    BIO_free(certbio);
+    if (!TEST_ptr(cert))
+        goto end;
+    *cert_out = cert;
+    return 1;
+ end:
+    X509_free(cert);
+    return 0;
+}
+
 static OCSP_BASICRESP *make_dummy_resp(void)
 {
     const unsigned char namestr[] = "openssl.example.com";
@@ -131,7 +149,67 @@ static int test_resp_signer(void)
     EVP_PKEY_free(key);
     return ret;
 }
-#endif
+
+static int test_access_description(int testcase)
+{
+    ACCESS_DESCRIPTION *ad = ACCESS_DESCRIPTION_new();
+    int ret = 0;
+
+    if (!TEST_ptr(ad))
+        goto err;
+
+    switch (testcase) {
+    case 0:     /* no change */
+        break;
+    case 1:     /* check and release current location */
+        if (!TEST_ptr(ad->location))
+            goto err;
+        GENERAL_NAME_free(ad->location);
+        ad->location = NULL;
+        break;
+    case 2:     /* replace current location */
+        GENERAL_NAME_free(ad->location);
+        ad->location = GENERAL_NAME_new();
+        if (!TEST_ptr(ad->location))
+            goto err;
+        break;
+    }
+    ACCESS_DESCRIPTION_free(ad);
+    ret = 1;
+err:
+    return ret;
+}
+
+static int test_ocsp_url_svcloc_new(void)
+{
+    static const char *  urls[] = {
+        "www.openssl.org",
+        "www.openssl.net",
+        NULL
+    };
+
+    X509 *issuer = NULL;
+    X509_EXTENSION * ext = NULL;
+    int ret = 0;
+
+    if (!TEST_true(get_cert(&issuer)))
+        goto err;
+
+    /*
+     * Test calling this ocsp method to catch any memory leak
+     */
+    ext = OCSP_url_svcloc_new(X509_get_issuer_name(issuer), urls);
+    if (!TEST_ptr(ext))
+        goto err;
+
+    X509_EXTENSION_free(ext);
+    ret = 1;
+err:
+    X509_free(issuer);
+    return ret;
+}
+
+#endif /* OPENSSL_NO_OCSP */
 
 OPT_TEST_DECLARE_USAGE("certfile privkeyfile\n")
 
@@ -142,6 +220,8 @@ int setup_tests(void)
         return 0;
 #ifndef OPENSSL_NO_OCSP
     ADD_TEST(test_resp_signer);
+    ADD_ALL_TESTS(test_access_description, 3);
+    ADD_TEST(test_ocsp_url_svcloc_new);
 #endif
     return 1;
 }

[DF] commit 4f29f3a29b8b416a501c7166dbbca5284b198f81
Author: Richard Levitte <levitte@openssl.org>
Date:   Mon Apr 15 13:15:55 2019 +0200

    asn1parse: avoid double free
    
    |str| was used for multiple conflicting purposes.  When using
    '-strictpem', it's used to uniquely hold a reference to the loaded
    payload.  However, when using '-strparse', |str| was re-used to hold
    the position from where to start parsing.
    
    So when '-strparse' and '-strictpem' are were together, |str| ended up
    pointing into data pointed at by |at|, and was yet being freed, with
    the result that the payload it held a reference to became a memory
    leak, and there was a double free conflict when both |str| and |at|
    were being freed.
    
    The situation is resolved by always having |buf| hold the pointer to
    the file data, and always and only use |str| to hold the position to
    start parsing from.  Now, we only need to free |buf| properly and not
    |str|.
    
    Fixes #8752
    
    Reviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>
    (Merged from https://github.com/openssl/openssl/pull/8753)

diff --git a/apps/asn1pars.c b/apps/asn1pars.c
index 4c1ce48544..14f1dcad32 100644
--- a/apps/asn1pars.c
+++ b/apps/asn1pars.c
@@ -170,17 +170,17 @@ int asn1parse_main(int argc, char **argv)
     if (derfile && (derout = bio_open_default(derfile, 'w', FORMAT_ASN1)) == NULL)
         goto end;
 
+    if ((buf = BUF_MEM_new()) == NULL)
+        goto end;
     if (strictpem) {
-        if (PEM_read_bio(in, &name, &header, &str, &num) !=
-            1) {
+        if (PEM_read_bio(in, &name, &header, &str, &num) != 1) {
             BIO_printf(bio_err, "Error reading PEM file\n");
             ERR_print_errors(bio_err);
             goto end;
         }
+        buf->data = (char *)str;
+        buf->length = buf->max = num;
     } else {
-
-        if ((buf = BUF_MEM_new()) == NULL)
-            goto end;
         if (!BUF_MEM_grow(buf, BUFSIZ * 8))
             goto end;           /* Pre-allocate :-) */
 
@@ -303,8 +303,6 @@ int asn1parse_main(int argc, char **argv)
     BUF_MEM_free(buf);
     OPENSSL_free(name);
     OPENSSL_free(header);
-    if (strictpem)
-        OPENSSL_free(str);
     ASN1_TYPE_free(at);
     sk_OPENSSL_STRING_free(osk);
     return ret;

[ML] commit 183f52e29af27285ea4ed7c947b71c83618f8702
Author: Matt Caswell <matt@openssl.org>
Date:   Tue Mar 26 14:42:14 2019 +0000

    Fix a memory leak in ARIA GCM
    
    Fixes #8567
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/8586)

diff --git a/crypto/evp/e_aria.c b/crypto/evp/e_aria.c
index 1d4ac2a252..882849486e 100644
--- a/crypto/evp/e_aria.c
+++ b/crypto/evp/e_aria.c
@@ -486,6 +486,16 @@ static int aria_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 0;
 }
 
+static int aria_gcm_cleanup(EVP_CIPHER_CTX *ctx)
+{
+    EVP_ARIA_GCM_CTX *gctx = EVP_C_DATA(EVP_ARIA_GCM_CTX, ctx);
+
+    if (gctx->iv != EVP_CIPHER_CTX_iv_noconst(ctx))
+        OPENSSL_free(gctx->iv);
+
+    return 1;
+}
+
 static int aria_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                             const unsigned char *iv, int enc)
 {
@@ -727,6 +737,8 @@ static int aria_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     }
 }
 
+#define aria_ccm_cleanup    NULL
+
 #define ARIA_AUTH_FLAGS  (EVP_CIPH_FLAG_DEFAULT_ASN1 \
                           | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \
                           | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \
@@ -739,7 +751,7 @@ static const EVP_CIPHER aria_##keylen##_##mode = { \
         ARIA_AUTH_FLAGS|EVP_CIPH_##MODE##_MODE,    \
         aria_##mode##_init_key,                    \
         aria_##mode##_cipher,                      \
-        NULL,                                      \
+        aria_##mode##_cleanup,                     \
         sizeof(EVP_ARIA_##MODE##_CTX),             \
         NULL,NULL,aria_##mode##_ctrl,NULL };       \
 const EVP_CIPHER *EVP_aria_##keylen##_##mode(void) \
diff --git a/test/recipes/30-test_evp_data/evpciph.txt b/test/recipes/30-test_evp_data/evpciph.txt
index 8bf5ac1844..c6a117cf50 100644
--- a/test/recipes/30-test_evp_data/evpciph.txt
+++ b/test/recipes/30-test_evp_data/evpciph.txt
@@ -2233,7 +2233,7 @@ IV = 00000000000000000000000000000000
 Plaintext = 11111111aaaaaaaa11111111bbbbbbbb11111111cccccccc11111111dddddddd22222222aaaaaaaa22222222bbbbbbbb22222222cccccccc22222222dddddddd33333333aaaaaaaa33333333bbbbbbbb33333333cccccccc33333333dddddddd44444444aaaaaaaa44444444bbbbbbbb44444444cccccccc44444444dddddddd55555555aaaaaaaa55555555bbbbbbbb55555555cccccccc55555555dddddddd
 Ciphertext = 30026c329666141721178b99c0a1f1b2f06940253f7b3089e2a30ea86aa3c88f5940f05ad7ee41d71347bb7261e348f18360473fdf7d4e7723bffb4411cc13f6cdd89f3bc7b9c768145022c7a74f14d7c305cd012a10f16050c23f1ae5c23f45998d13fbaa041e51619577e0772764896a5d4516d8ffceb3bf7e05f613edd9a60cdcedaff9cfcaf4e00d445a54334f73ab2cad944e51d266548e61c6eb0aa1cd
 
-Title = ARIA GCM test vectors from IETF draft-ietf-avtcore-aria-srtp-10
+Title = ARIA GCM test vectors from RFC8269
 
 Cipher = ARIA-128-GCM
 Key = e91e5e75da65554a48181f3846349562
@@ -2251,6 +2251,36 @@ Tag = e210d6ced2cf430ff841472915e7ef48
 Plaintext = f57af5fd4ae19562976ec57a5a7ad55a5af5c5e5c5fdf5c55ad57a4a7272d57262e9729566ed66e97ac54a4a5a7ad5e15ae5fdd5fd5ac5d56ae56ad5c572d54ae54ac55a956afd6aed5a4ac562957a9516991691d572fd14e97ae962ed7a9f4a955af572e162f57a956666e17ae1f54a95f566d54a66e16e4afd6a9f7ae1c5c55ae5d56afde916c5e94a6ec56695e14afde1148416e94ad57ac5146ed59d1cc5
 Ciphertext = 6f9e4bcbc8c85fc0128fb1e4a0a20cb9932ff74581f54fc013dd054b19f99371425b352d97d3f337b90b63d1b082adeeea9d2d7391897d591b985e55fb50cb5350cf7d38dc27dda127c078a149c8eb98083d66363a46e3726af217d3a00275ad5bf772c7610ea4c23006878f0ee69a8397703169a419303f40b72e4573714d19e2697df61e7c7252e5abc6bade876ac4961bfac4d5e867afca351a48aed52822
 
+Title = ARIA GCM self-generated test vectors
+
+Cipher = ARIA-128-GCM
+Key = e91e5e75da65554a48181f3846349562
+# Shorter than default IV
+IV = 0001020304
+AAD = 8008315ebf2e6fe020e8f5eb
+Tag = ebaa2645bb154542117ee46031aa176e
+Plaintext = f57af5fd4ae19562976ec57a5a7ad55a5af5c5e5c5fdf5c55ad57a4a7272d57262e9729566ed66e97ac54a4a5a7ad5e15ae5fdd5fd5ac5d56ae56ad5c572d54ae54ac55a956afd6aed5a4ac562957a9516991691d572fd14e97ae962ed7a9f4a955af572e162f57a956666e17ae1f54a95f566d54a66e16e4afd6a9f7ae1c5c55ae5d56afde916c5e94a6ec56695e14afde1148416e94ad57ac5146ed59d1cc5
+Ciphertext = 1723ccfc0ed44a12520473cfeb63bc933cd450a943f5f1cba78e19d72f80cc102acc51f2459a06cf6435182b8ddd451f83e13479efe5ec7dfbf16229f4017920fb41457a9b6fe1a401b30b2f332d827ae2f86e962326927c1ed8bfedac1f7a00ddde63bd392a8f28a488ba5974689f8d15b9b1739fb50aae0ff244026ec72064003c621b33ffc8086b0a97eefb70604a2826f6499f6eb12d67a0da03fc8e1482
+
+Cipher = ARIA-128-GCM
+Key = e91e5e75da65554a48181f3846349562
+# Longer than default IV
+IV = 000102030405060708090a0b0c0d0e0f
+AAD = 8008315ebf2e6fe020e8f5eb
+Tag = 61f7f44c7da3c60195b29ae0b46051a4
+Plaintext = f57af5fd4ae19562976ec57a5a7ad55a5af5c5e5c5fdf5c55ad57a4a7272d57262e9729566ed66e97ac54a4a5a7ad5e15ae5fdd5fd5ac5d56ae56ad5c572d54ae54ac55a956afd6aed5a4ac562957a9516991691d572fd14e97ae962ed7a9f4a955af572e162f57a956666e17ae1f54a95f566d54a66e16e4afd6a9f7ae1c5c55ae5d56afde916c5e94a6ec56695e14afde1148416e94ad57ac5146ed59d1cc5
+Ciphertext = 0d3e98fcaf7a2c4fe9198d66add90d113e5e0ff47598c40a4bf501960d935a4156c9a4d46c9358a608e10a16479a4247c9ab9bb4a02809e3eac3571b832590fe2ca3e2d545741e36282d96c041fc7d39a46ed60214c2c0ec70f27768dfea4f9563b5d5c2ac33b1368a78f2908f5daf942433fec6ab588f09e908e95cc8dfa85d1a0dfd5835dc14e148323230c63eedc99a9ce942214cb3768b97b821d613629f
+
+Cipher = ARIA-128-GCM
+Key = e91e5e75da65554a48181f3846349562
+# Extra long IV
+IV = 000102030405060708090a0b0c0d0e0f1011
+AAD = 8008315ebf2e6fe020e8f5eb
+Tag = c8b31ab6c2ddccab06b76af4e56e664e
+Plaintext = f57af5fd4ae19562976ec57a5a7ad55a5af5c5e5c5fdf5c55ad57a4a7272d57262e9729566ed66e97ac54a4a5a7ad5e15ae5fdd5fd5ac5d56ae56ad5c572d54ae54ac55a956afd6aed5a4ac562957a9516991691d572fd14e97ae962ed7a9f4a955af572e162f57a956666e17ae1f54a95f566d54a66e16e4afd6a9f7ae1c5c55ae5d56afde916c5e94a6ec56695e14afde1148416e94ad57ac5146ed59d1cc5
+Ciphertext = 616a7bce24206501082cef7267c09a4affa54f8f82eb7fb2cdebdcaab4b6ab05c37e891c2d0fc90d15c5fb684247625c8bc0befad86896ae1c8f5a8506954caba4e13df0a0eb23853d4474e7f3b2c57bb398456a24d198e14566bce8a5f8d3bcdb12994d2fdc0f5cf19aeff990c1fe119e01f9fcc86757b1d43a9accf7b2f913c2208a46c1967f403867f89b46ffe96864c63f042265806ea5270e0dddd0e8dd
+
+
 Title = ARIA CCM test vectors from IETF draft-ietf-avtcore-aria-srtp-02
 
 # 16-byte Tag

commit a383083194b882a904ae66fcf74ebc348602407c
Author: Richard Levitte <levitte@openssl.org>
Date:   Thu Mar 14 21:51:50 2019 +0100

    Replumbing: better reference counter control in ossl_method_construct()
    
    Fully assume that the method constructors use reference counting.
    Otherwise, we may leak memory, or loose track and do a double free.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/8341)

diff --git a/crypto/core_fetch.c b/crypto/core_fetch.c
index bfdd36d429..d38e1325c6 100644
--- a/crypto/core_fetch.c
+++ b/crypto/core_fetch.c
@@ -39,25 +39,33 @@ static int ossl_method_construct_this(OSSL_PROVIDER *provider, void *cbdata)
                                             data->mcm_data)) == NULL)
             continue;
 
+        /*
+         * Note regarding putting the method in stores:
+         *
+         * we don't need to care if it actually got in or not here.
+         * If it didn't get in, it will simply not be available when
+         * ossl_method_construct() tries to get it from the store.
+         *
+         * It is *expected* that the put function increments the refcnt
+         * of the passed method.
+         */
+
         if (data->force_store || !no_store) {
             /*
              * If we haven't been told not to store,
              * add to the global store
              */
-            if (!data->mcm->put(data->libctx, NULL,
-                                thismap->property_definition,
-                                method, data->mcm_data)) {
-                data->mcm->destruct(method, data->mcm_data);
-                continue;
-            }
+            data->mcm->put(data->libctx, NULL,
+                           thismap->property_definition,
+                           method, data->mcm_data);
         }
 
-        if (!data->mcm->put(data->libctx, data->store,
-                            thismap->property_definition,
-                            method, data->mcm_data)) {
-            data->mcm->destruct(method, data->mcm_data);
-            continue;
-        }
+        data->mcm->put(data->libctx, data->store,
+                       thismap->property_definition,
+                       method, data->mcm_data);
+
+        /* refcnt-- because we're dropping the reference */
+        data->mcm->destruct(method, data->mcm_data);
     }
 
     return 1;
diff --git a/doc/internal/man3/ossl_method_construct.pod b/doc/internal/man3/ossl_method_construct.pod
index e91cfcd638..3664635467 100644
--- a/doc/internal/man3/ossl_method_construct.pod
+++ b/doc/internal/man3/ossl_method_construct.pod
@@ -49,6 +49,11 @@ functions given by the sub-system specific method creator through
 C<mcm> and the data in C<mcm_data> (which is passed by
 ossl_method_construct()).
 
+This function assumes that the sub-system method creator implements
+reference counting and acts accordingly (i.e. it will call the
+sub-system destruct() method to decrement the reference count when
+appropriate).
+
 =head2 Structures
 
 A central part of constructing a sub-system specific method is to give
@@ -82,6 +87,8 @@ The method to be looked up should be identified with data from C<data>
 (which is the C<mcm_data> that was passed to ossl_construct_method())
 and the provided property query C<propquery>.
 
+This function is expected to increment the method's reference count.
+
 =item put()
 
 Places the C<method> created by the construct() function (see below)
@@ -96,6 +103,8 @@ The method should be associated with the given property definition
 C<propdef> and any identification data given through C<data> (which is
 the C<mcm_data> that was passed to ossl_construct_method()).
 
+This function is expected to increment the C<method>'s reference count.
+
 =item construct()
 
 Constructs a sub-system method given a dispatch table C<fns>.
@@ -106,9 +115,12 @@ is recommended.
 If such a reference is kept, the I<provider object> reference counter
 must be incremented, using ossl_provider_upref().
 
+This function is expected to set the method's reference count to 1.
+
 =item desctruct()
 
-Destruct the given C<method>.
+Decrement the C<method>'s reference count, and destruct it when
+the reference count reaches zero.
 
 =back
 

[ML] commit 13d06925e8cb15bf4247f14280d535618e7a4b2b
Author: Dr. Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>
Date:   Tue Mar 12 23:04:14 2019 +0100

    trace: don't leak the line prefix
    
    The openssl app registers trace callbacks which automatically
    set a line prefix in the OSSL_TRACE_CTRL_BEGIN callback.
    This prefix needs to be cleared in the OSSL_TRACE_CTRL_END
    callback, otherwise a memory leak is reported when openssl
    is built with crypto-mdebug enabled.
    
    This leak causes the tests to fail when tracing and memory
    debugging are enabled.
    
    The leak can be observed by any command that produces trace
    output, e.g. by
    
      OPENSSL_TRACE=ANY util/shlib_wrap.sh  apps/openssl version
      ...
      [00:19:14]  4061 file=apps/bf_prefix.c, line=152, ...
      26 bytes leaked in 1 chunks
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/8463)

diff --git a/apps/openssl.c b/apps/openssl.c
index 72a0bb0085..db1dbb767d 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -126,30 +126,17 @@ typedef struct tracedata_st {
 static size_t internal_trace_cb(const char *buf, size_t cnt,
                                 int category, int cmd, void *vdata)
 {
-    int ret;
+    int ret = 0;
     tracedata *trace_data = vdata;
-    int set_prefix = 0;
+    union {
+        CRYPTO_THREAD_ID tid;
+        unsigned long ltid;
+    } tid;
+    char buffer[256];
 
     switch (cmd) {
     case OSSL_TRACE_CTRL_BEGIN:
         trace_data->ingroup = 1;
-        set_prefix = 1;
-        break;
-    case OSSL_TRACE_CTRL_DURING:
-        if (!trace_data->ingroup)
-            set_prefix = 1;
-        break;
-    case OSSL_TRACE_CTRL_END:
-        trace_data->ingroup = 0;
-        break;
-    }
-
-    if (set_prefix) {
-        union {
-            CRYPTO_THREAD_ID tid;
-            unsigned long ltid;
-        } tid;
-        char buffer[256];
 
         tid.ltid = 0;
         tid.tid = CRYPTO_THREAD_get_current_id();
@@ -158,8 +145,17 @@ static size_t internal_trace_cb(const char *buf, size_t cnt,
                      OSSL_trace_get_category_name(category));
         BIO_ctrl(trace_data->bio, PREFIX_CTRL_SET_PREFIX,
                  strlen(buffer), buffer);
+        break;
+    case OSSL_TRACE_CTRL_WRITE:
+        ret = BIO_write(trace_data->bio, buf, cnt);
+        break;
+    case OSSL_TRACE_CTRL_END:
+        trace_data->ingroup = 0;
+
+        BIO_ctrl(trace_data->bio, PREFIX_CTRL_SET_PREFIX, 0, NULL);
+
+        break;
     }
-    ret = BIO_write(trace_data->bio, buf, cnt);
 
     return ret < 0 ? 0 : ret;
 }
diff --git a/crypto/trace.c b/crypto/trace.c
index 4e93c43def..533770c669 100644
--- a/crypto/trace.c
+++ b/crypto/trace.c
@@ -65,7 +65,7 @@ static int trace_write(BIO *channel,
                        const char *buf, size_t num, size_t *written)
 {
     struct trace_data_st *ctx = BIO_get_data(channel);
-    size_t cnt = ctx->callback(buf, num, ctx->category, OSSL_TRACE_CTRL_DURING,
+    size_t cnt = ctx->callback(buf, num, ctx->category, OSSL_TRACE_CTRL_WRITE,
                                ctx->data);
 
     *written = cnt;
diff --git a/include/openssl/trace.h b/include/openssl/trace.h
index da0ba0b5df..767b19fa7d 100644
--- a/include/openssl/trace.h
+++ b/include/openssl/trace.h
@@ -95,7 +95,7 @@ typedef size_t (*OSSL_trace_cb)(const char *buffer, size_t count,
  * Possible |cmd| numbers.
  */
 # define OSSL_TRACE_CTRL_BEGIN  0
-# define OSSL_TRACE_CTRL_DURING 1
+# define OSSL_TRACE_CTRL_WRITE  1
 # define OSSL_TRACE_CTRL_END    2
 
 /*

[ML] commit 81d61a62faa809e6c51f5fc2b86fb0d31146fd5e
Author: Nicola Tuveri <nic.tuv@gmail.com>
Date:   Wed Mar 13 11:38:40 2019 +0200

    Fix memory leak in ectest
    
    Fixes #8462
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/8466)

diff --git a/test/ectest.c b/test/ectest.c
index d2ad3774b5..59c7e99d8c 100644
--- a/test/ectest.c
+++ b/test/ectest.c
@@ -1503,6 +1503,7 @@ static int underflow_test(void)
     BN_CTX_end(ctx);
     EC_POINT_free(P);
     EC_POINT_free(Q);
+    EC_POINT_free(R);
     EC_GROUP_free(grp);
     BN_CTX_free(ctx);
 

[ML] commit 81cd023f1dc5a8c9094f8e91c1e85e3c9b98a551
Author: Matt Caswell <matt@openssl.org>
Date:   Tue Mar 12 10:21:39 2019 +0000

    Fix memory leaks in pkread.c demo file
    
    Also make various changes to bring the file into line with current coding
    style.
    
    Fixes #8456
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    Reviewed-by: Paul Yang <yang.yang@baishancloud.com>
    (Merged from https://github.com/openssl/openssl/pull/8457)

diff --git a/demos/pkcs12/pkread.c b/demos/pkcs12/pkread.c
index 992b42c09d..33fba5d290 100644
--- a/demos/pkcs12/pkread.c
+++ b/demos/pkcs12/pkread.c
@@ -17,7 +17,7 @@
 
 static char *find_friendly_name(PKCS12 *p12)
 {
-    STACK_OF(PKCS7) *safes = PKCS12_unpack_authsafes(p12);
+    STACK_OF(PKCS7) *safes;
     int n, m;
     char *name = NULL;
     PKCS7 *safe;
@@ -48,56 +48,64 @@ static char *find_friendly_name(PKCS12 *p12)
 int main(int argc, char **argv)
 {
     FILE *fp;
-    EVP_PKEY *pkey;
-    X509 *cert;
+    EVP_PKEY *pkey = NULL;
+    X509 *cert = NULL;
     STACK_OF(X509) *ca = NULL;
-    PKCS12 *p12;
-    const char *name;
-    int i;
+    PKCS12 *p12 = NULL;
+    char *name = NULL;
+    int i, ret = EXIT_FAILURE;
 
     if (argc != 4) {
         fprintf(stderr, "Usage: pkread p12file password opfile\n");
-        exit(1);
+        exit(EXIT_FAILURE);
     }
-    OpenSSL_add_all_algorithms();
-    ERR_load_crypto_strings();
+
     if ((fp = fopen(argv[1], "rb")) == NULL) {
         fprintf(stderr, "Error opening file %s\n", argv[1]);
-        exit(1);
+        exit(EXIT_FAILURE);
     }
     p12 = d2i_PKCS12_fp(fp, NULL);
     fclose(fp);
-    if (!p12) {
+    if (p12 == NULL) {
         fprintf(stderr, "Error reading PKCS#12 file\n");
         ERR_print_errors_fp(stderr);
-        exit(1);
+        goto err;
     }
     if (!PKCS12_parse(p12, argv[2], &pkey, &cert, &ca)) {
         fprintf(stderr, "Error parsing PKCS#12 file\n");
         ERR_print_errors_fp(stderr);
-        exit(1);
+        goto err;
     }
     name = find_friendly_name(p12);
     PKCS12_free(p12);
     if ((fp = fopen(argv[3], "w")) == NULL) {
         fprintf(stderr, "Error opening file %s\n", argv[1]);
-        exit(1);
+        goto err;
     }
-    if (name)
+    if (name != NULL)
         fprintf(fp, "***Friendly Name***\n%s\n", name);
-    if (pkey) {
+    if (pkey != NULL) {
         fprintf(fp, "***Private Key***\n");
         PEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, NULL, NULL);
     }
-    if (cert) {
+    if (cert != NULL) {
         fprintf(fp, "***User Certificate***\n");
         PEM_write_X509_AUX(fp, cert);
     }
-    if (ca && sk_X509_num(ca)) {
+    if (ca != NULL && sk_X509_num(ca) > 0) {
         fprintf(fp, "***Other Certificates***\n");
         for (i = 0; i < sk_X509_num(ca); i++)
             PEM_write_X509_AUX(fp, sk_X509_value(ca, i));
     }
     fclose(fp);
-    return 0;
+
+    ret = EXIT_SUCCESS;
+
+ err:
+    OPENSSL_free(name);
+    X509_free(cert);
+    EVP_PKEY_free(pkey);
+    sk_X509_pop_free(ca, X509_free);
+
+    return ret;
 }

[ML] commit 18e1e302452e6dea4500b6f981cee7e151294dea
Author: Richard Levitte <levitte@openssl.org>
Date:   Sun Feb 10 15:16:20 2019 +0100

    apps/openssl.c: avoid memory leaks
    
    The trace API doesn't know that the BIOs we give it, let alone those
    we attach to callbacks as 'void *data', need to be cleaned up.  This
    must be done in the application.
    
    To ensure this cleanup is done as late as possible, use atexit().
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/8198)

diff --git a/apps/openssl.c b/apps/openssl.c
index 43263295d8..854f943f66 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -163,10 +163,27 @@ static size_t internal_trace_cb(const char *buf, size_t cnt,
     return ret < 0 ? 0 : ret;
 }
 
+DEFINE_STACK_OF(tracedata)
+static STACK_OF(tracedata) *trace_data_stack;
+
+static void tracedata_free(tracedata *data)
+{
+    BIO_free_all(data->bio);
+    OPENSSL_free(data);
+}
+
+static STACK_OF(tracedata) *trace_data_stack;
+
+static void cleanup_trace(void)
+{
+    sk_tracedata_pop_free(trace_data_stack, tracedata_free);
+}
+
 static void setup_trace(const char *str)
 {
     char *val;
 
+    trace_data_stack = sk_tracedata_new_null();
     val = OPENSSL_strdup(str);
 
     if (val != NULL) {
@@ -184,7 +201,10 @@ static void setup_trace(const char *str)
                 if (trace_data == NULL
                     || (trace_data->bio = channel) == NULL
                     || OSSL_trace_set_callback(category, internal_trace_cb,
-                                               trace_data) == 0) {
+                                               trace_data) == 0
+                    || sk_tracedata_push(trace_data_stack, trace_data) == 0) {
+                    OSSL_trace_set_callback(category, NULL, NULL);
+                    BIO_free_all(channel);
                     fprintf(stderr,
                             "warning: unable to setup trace callback for category '%s'.\n",
                             item);
@@ -198,6 +218,7 @@ static void setup_trace(const char *str)
     }
 
     OPENSSL_free(val);
+    atexit(cleanup_trace);
 }
 
 int main(int argc, char *argv[])

[UAF] commit 5dc40a83c74be579575a512b30d9c1e0364e6a7b
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Wed Jan 30 16:20:31 2019 +0100

    Fix a crash in reuse of i2d_X509_PUBKEY
    
    If the second PUBKEY is malformed there is use after free.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/8122)

diff --git a/crypto/x509/x_pubkey.c b/crypto/x509/x_pubkey.c
index f980af77f6..be42684e44 100644
--- a/crypto/x509/x_pubkey.c
+++ b/crypto/x509/x_pubkey.c
@@ -36,6 +36,7 @@ static int pubkey_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
         /* Attempt to decode public key and cache in pubkey structure. */
         X509_PUBKEY *pubkey = (X509_PUBKEY *)*pval;
         EVP_PKEY_free(pubkey->pkey);
+        pubkey->pkey = NULL;
         /*
          * Opportunistically decode the key but remove any non fatal errors
          * from the queue. Subsequent explicit attempts to decode/use the key
diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index eefebd586d..eac0c43ba1 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -299,6 +299,21 @@ static const unsigned char kExampleECPubKeyDER[] = {
     0x56, 0x6a, 0xc6, 0xc8, 0xa5, 0x0b, 0xe5
 };
 
+/*
+ * kExampleBadECKeyDER is a sample EC public key with a wrong OID
+ * 1.2.840.10045.2.2 instead of 1.2.840.10045.2.1 - EC Public Key
+ */
+static const unsigned char kExampleBadECPubKeyDER[] = {
+    0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
+    0x02, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03,
+    0x42, 0x00, 0x04, 0xba, 0xeb, 0x83, 0xfb, 0x3b, 0xb2, 0xff, 0x30, 0x53,
+    0xdb, 0xce, 0x32, 0xf2, 0xac, 0xae, 0x44, 0x0d, 0x3d, 0x13, 0x53, 0xb8,
+    0xd1, 0x68, 0x55, 0xde, 0x44, 0x46, 0x05, 0xa6, 0xc9, 0xd2, 0x04, 0xb7,
+    0xe3, 0xa2, 0x96, 0xc8, 0xb2, 0x5e, 0x22, 0x03, 0xd7, 0x03, 0x7a, 0x8b,
+    0x13, 0x5c, 0x42, 0x49, 0xc2, 0xab, 0x86, 0xd6, 0xac, 0x6b, 0x93, 0x20,
+    0x56, 0x6a, 0xc6, 0xc8, 0xa5, 0x0b, 0xe5
+};
+
 static const unsigned char pExampleECParamDER[] = {
     0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07
 };
@@ -963,6 +978,37 @@ static int test_HKDF(void)
     return ret;
 }
 
+#ifndef OPENSSL_NO_EC
+static int test_X509_PUBKEY_inplace(void)
+{
+  int ret = 0;
+  X509_PUBKEY *xp = NULL;
+  const unsigned char *p = kExampleECPubKeyDER;
+  size_t input_len = sizeof(kExampleECPubKeyDER);
+
+  if (!TEST_ptr(xp = d2i_X509_PUBKEY(NULL, &p, input_len)))
+    goto done;
+
+  if (!TEST_ptr(X509_PUBKEY_get0(xp)))
+    goto done;
+
+  p = kExampleBadECPubKeyDER;
+  input_len = sizeof(kExampleBadECPubKeyDER);
+
+  if (!TEST_ptr(xp = d2i_X509_PUBKEY(&xp, &p, input_len)))
+    goto done;
+
+  if (!TEST_true(X509_PUBKEY_get0(xp) == NULL))
+    goto done;
+
+  ret = 1;
+
+done:
+  X509_PUBKEY_free(xp);
+  return ret;
+}
+#endif
+
 int setup_tests(void)
 {
     ADD_TEST(test_EVP_DigestSignInit);
@@ -987,5 +1033,8 @@ int setup_tests(void)
         return 0;
     ADD_ALL_TESTS(test_EVP_PKEY_check, OSSL_NELEM(keycheckdata));
     ADD_TEST(test_HKDF);
+#ifndef OPENSSL_NO_EC
+    ADD_TEST(test_X509_PUBKEY_inplace);
+#endif
     return 1;
 }

[ML] commit a727627922b8a9ec6628ffaa2054b4b3833d674b
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Tue Jan 29 14:16:28 2019 +0100

    Fix a memory leak with di2_X509_CRL reuse
    
    Additionally avoid undefined behavior with
    in-place memcpy in X509_CRL_digest.
    
    Fixes #8099
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/8112)

diff --git a/crypto/x509/x_crl.c b/crypto/x509/x_crl.c
index 89e13e8721..3984f0147f 100644
--- a/crypto/x509/x_crl.c
+++ b/crypto/x509/x_crl.c
@@ -158,6 +158,18 @@ static int crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
     int idx;
 
     switch (operation) {
+    case ASN1_OP_D2I_PRE:
+        if (crl->meth->crl_free) {
+            if (!crl->meth->crl_free(crl))
+                return 0;
+        }
+        AUTHORITY_KEYID_free(crl->akid);
+        ISSUING_DIST_POINT_free(crl->idp);
+        ASN1_INTEGER_free(crl->crl_number);
+        ASN1_INTEGER_free(crl->base_crl_number);
+        sk_GENERAL_NAMES_pop_free(crl->issuers, GENERAL_NAMES_free);
+        /* fall thru */
+
     case ASN1_OP_NEW_POST:
         crl->idp = NULL;
         crl->akid = NULL;
diff --git a/test/crltest.c b/test/crltest.c
index 3b0fab774e..6a2ef4e90d 100644
--- a/test/crltest.c
+++ b/test/crltest.c
@@ -357,6 +357,20 @@ static int test_unknown_critical_crl(int n)
     return r;
 }
 
+static int test_reuse_crl(void)
+{
+    X509_CRL *reused_crl = CRL_from_strings(kBasicCRL);
+    char *p;
+    BIO *b = glue2bio(kRevokedCRL, &p);
+
+    reused_crl = PEM_read_bio_X509_CRL(b, &reused_crl, NULL, NULL);
+
+    OPENSSL_free(p);
+    BIO_free(b);
+    X509_CRL_free(reused_crl);
+    return 1;
+}
+
 int setup_tests(void)
 {
     if (!TEST_ptr(test_root = X509_from_strings(kCRLTestRoot))
@@ -368,6 +382,7 @@ int setup_tests(void)
     ADD_TEST(test_bad_issuer_crl);
     ADD_TEST(test_known_critical_crl);
     ADD_ALL_TESTS(test_unknown_critical_crl, OSSL_NELEM(unknown_critical_crls));
+    ADD_TEST(test_reuse_crl);
     return 1;
 }
 

[ML] commit c6048af23c577bcf85f15122dd03b65f959c9ecb
Author: Corey Minyard <cminyard@mvista.com>
Date:   Mon Jan 21 17:47:02 2019 +1000

    Fix a memory leak in the mem bio
    
    If you use a BIO and set up your own buffer that is not freed, the
    memory bio will leak the BIO_BUF_MEM object it allocates.
    
    The trouble is that the BIO_BUF_MEM is allocated and kept around,
    but it is not freed if BIO_NOCLOSE is set.
    
    The freeing of BIO_BUF_MEM was fairly confusing, simplify things
    so mem_buf_free only frees the memory buffer and free the BIO_BUF_MEM
    in mem_free(), where it should be done.
    
    Alse add a test for a leak in the memory bio
    Setting a memory buffer caused a leak.
    
    Signed-off-by: Corey Minyard <minyard@acm.org>
    
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/8051)

diff --git a/crypto/bio/bss_mem.c b/crypto/bio/bss_mem.c
index ee9ea917a0..89c54b2d53 100644
--- a/crypto/bio/bss_mem.c
+++ b/crypto/bio/bss_mem.c
@@ -20,7 +20,7 @@ static long mem_ctrl(BIO *h, int cmd, long arg1, void *arg2);
 static int mem_new(BIO *h);
 static int secmem_new(BIO *h);
 static int mem_free(BIO *data);
-static int mem_buf_free(BIO *data, int free_all);
+static int mem_buf_free(BIO *data);
 static int mem_buf_sync(BIO *h);
 
 static const BIO_METHOD mem_method = {
@@ -140,10 +140,20 @@ static int secmem_new(BIO *bi)
 
 static int mem_free(BIO *a)
 {
-    return mem_buf_free(a, 1);
+    BIO_BUF_MEM *bb;
+
+    if (a == NULL)
+        return 0;
+
+    bb = (BIO_BUF_MEM *)a->ptr;
+    if (!mem_buf_free(a))
+        return 0;
+    OPENSSL_free(bb->readp);
+    OPENSSL_free(bb);
+    return 1;
 }
 
-static int mem_buf_free(BIO *a, int free_all)
+static int mem_buf_free(BIO *a)
 {
     if (a == NULL)
         return 0;
@@ -155,11 +165,6 @@ static int mem_buf_free(BIO *a, int free_all)
         if (a->flags & BIO_FLAGS_MEM_RDONLY)
             b->data = NULL;
         BUF_MEM_free(b);
-        if (free_all) {
-            OPENSSL_free(bb->readp);
-            OPENSSL_free(bb);
-        }
-        a->ptr = NULL;
     }
     return 1;
 }
@@ -266,11 +271,10 @@ static long mem_ctrl(BIO *b, int cmd, long num, void *ptr)
         }
         break;
     case BIO_C_SET_BUF_MEM:
-        mem_buf_free(b, 0);
+        mem_buf_free(b);
         b->shutdown = (int)num;
         bbm->buf = ptr;
         *bbm->readp = *bbm->buf;
-        b->ptr = bbm;
         break;
     case BIO_C_GET_BUF_MEM_PTR:
         if (ptr != NULL) {
diff --git a/test/bio_memleak_test.c b/test/bio_memleak_test.c
new file mode 100644
index 0000000000..36680e30a8
--- /dev/null
+++ b/test/bio_memleak_test.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+#include <stdio.h>
+#include <string.h>
+#include <openssl/buffer.h>
+#include <openssl/bio.h>
+
+#include "testutil.h"
+
+static int test_bio_memleak(void)
+{
+    int ok = 0;
+    BIO *bio;
+    BUF_MEM bufmem;
+    const char *str = "BIO test\n";
+    char buf[100];
+
+    bio = BIO_new(BIO_s_mem());
+    if (bio == NULL)
+        goto finish;
+    bufmem.length = strlen(str) + 1;
+    bufmem.data = (char *) str;
+    bufmem.max = bufmem.length;
+    BIO_set_mem_buf(bio, &bufmem, BIO_NOCLOSE);
+    BIO_set_flags(bio, BIO_FLAGS_MEM_RDONLY);
+
+    if (BIO_read(bio, buf, sizeof(buf)) <= 0)
+	goto finish;
+
+    ok = strcmp(buf, str) == 0;
+
+finish:
+    BIO_free(bio);
+    return ok;
+}
+
+int global_init(void)
+{
+    CRYPTO_set_mem_debug(1);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+    return 1;
+}
+
+int setup_tests(void)
+{
+    ADD_TEST(test_bio_memleak);
+    return 1;
+}
diff --git a/test/build.info b/test/build.info
index 962af11eef..2e17a5fb8c 100644
--- a/test/build.info
+++ b/test/build.info
@@ -42,7 +42,7 @@ INCLUDE_MAIN___test_libtestutil_OLB = /INCLUDE=main
           packettest asynctest secmemtest srptest memleaktest stack_test \
           dtlsv1listentest ct_test threadstest afalgtest d2i_test \
           ssl_test_ctx_test ssl_test x509aux cipherlist_test asynciotest \
-          bio_callback_test \
+          bio_callback_test bio_memleak_test \
           bioprinttest sslapitest dtlstest sslcorrupttest bio_enc_test \
           pkey_meth_test pkey_meth_kdf_test uitest cipherbytes_test \
           asn1_encode_test asn1_decode_test asn1_string_table_test \
@@ -300,6 +300,10 @@ INCLUDE_MAIN___test_libtestutil_OLB = /INCLUDE=main
   INCLUDE[bio_callback_test]=../include
   DEPEND[bio_callback_test]=../libcrypto libtestutil.a
 
+  SOURCE[bio_memleak_test]=bio_memleak_test.c
+  INCLUDE[bio_memleak_test]=../include
+  DEPEND[bio_memleak_test]=../libcrypto libtestutil.a
+
   SOURCE[bioprinttest]=bioprinttest.c
   INCLUDE[bioprinttest]=../include
   DEPEND[bioprinttest]=../libcrypto libtestutil.a
diff --git a/test/recipes/90-test_bio_memleak.t b/test/recipes/90-test_bio_memleak.t
new file mode 100644
index 0000000000..93f7f928a7
--- /dev/null
+++ b/test/recipes/90-test_bio_memleak.t
@@ -0,0 +1,12 @@
+#! /usr/bin/env perl
+# Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the "License").  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# https://www.openssl.org/source/license.html
+
+
+use OpenSSL::Test::Simple;
+
+simple_test("test_bio_memleak", "bio_memleak_test");

[ML] commit 01666a8c1db3ecfb999e1a8f2c5436d114f95681
Author: Matt Caswell <matt@openssl.org>
Date:   Thu Oct 18 10:12:07 2018 +0100

    Fix a DTLS memory leak
    
    Fixes #7428
    
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/7431)

diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index ac5fd09134..7d0e9d0ba8 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -1519,8 +1519,10 @@ MSG_PROCESS_RETURN tls_process_client_hello(SSL *s, PACKET *pkt)
              * So check cookie length...
              */
             if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) {
-                if (clienthello->dtls_cookie_len == 0)
+                if (clienthello->dtls_cookie_len == 0) {
+                    OPENSSL_free(clienthello);
                     return MSG_PROCESS_FINISHED_READING;
+                }
             }
         }
 

[ML] commit 037241bf046be8cfc7e9216959393dd20b06fc21
Author: Rich Salz <rsalz@openssl.org>
Date:   Wed Jul 25 15:57:18 2018 -0400

    Check for failures, to avoid memory leak
    
    Thanks to Jiecheng Wu, Zuxing Gu for the report.
    
    Reviewed-by: Andy Polyakov <appro@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/6791)

diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index 6fc6146cfd..21302685d8 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -92,19 +92,19 @@ static int eckey_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
 static EC_KEY *eckey_type2param(int ptype, const void *pval)
 {
     EC_KEY *eckey = NULL;
+    EC_GROUP *group = NULL;
+
     if (ptype == V_ASN1_SEQUENCE) {
         const ASN1_STRING *pstr = pval;
-        const unsigned char *pm = NULL;
-        int pmlen;
-        pm = pstr->data;
-        pmlen = pstr->length;
+        const unsigned char *pm = pstr->data;
+        int pmlen = pstr->length;
+
         if ((eckey = d2i_ECParameters(NULL, &pm, pmlen)) == NULL) {
             ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);
             goto ecerr;
         }
     } else if (ptype == V_ASN1_OBJECT) {
         const ASN1_OBJECT *poid = pval;
-        EC_GROUP *group;
 
         /*
          * type == V_ASN1_OBJECT => the parameters are given by an asn1 OID
@@ -129,6 +129,7 @@ static EC_KEY *eckey_type2param(int ptype, const void *pval)
 
  ecerr:
     EC_KEY_free(eckey);
+    EC_GROUP_free(group);
     return NULL;
 }
 
diff --git a/crypto/x509v3/v3_tlsf.c b/crypto/x509v3/v3_tlsf.c
index 5f2d5d2cf8..61c16381b9 100644
--- a/crypto/x509v3/v3_tlsf.c
+++ b/crypto/x509v3/v3_tlsf.c
@@ -122,13 +122,12 @@ static TLS_FEATURE *v2i_TLS_FEATURE(const X509V3_EXT_METHOD *method,
             }
         }
 
-        ai = ASN1_INTEGER_new();
-        if (ai == NULL) {
+        if ((ai = ASN1_INTEGER_new()) == NULL
+                || !ASN1_INTEGER_set(ai, tlsextid)
+                || sk_ASN1_INTEGER_push(tlsf, ai) <= 0) {
             X509V3err(X509V3_F_V2I_TLS_FEATURE, ERR_R_MALLOC_FAILURE);
             goto err;
         }
-        ASN1_INTEGER_set(ai, tlsextid);
-        sk_ASN1_INTEGER_push(tlsf, ai);
     }
     return tlsf;
 

[ML] commit fbe9dafdddc5e4aa7190617d189eeadf2da34a4d
Author: Matt Caswell <matt@openssl.org>
Date:   Tue Jul 17 10:27:57 2018 +0100

    Fix a memory leak in the ticket test
    
    Also fixes a function name typo.
    
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    (Merged from https://github.com/openssl/openssl/pull/6729)

diff --git a/test/sslapitest.c b/test/sslapitest.c
index f4358538d9..8cc493406b 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -1233,7 +1233,7 @@ static int post_handshake_verify(SSL *sssl, SSL *cssl)
     return 1;
 }
 
-static int setup_ticket_text(int stateful, int idx, SSL_CTX **sctx,
+static int setup_ticket_test(int stateful, int idx, SSL_CTX **sctx,
                              SSL_CTX **cctx)
 {
     int sess_id_ctx = 1;
@@ -1326,7 +1326,7 @@ static int test_tickets(int stateful, int idx)
     new_called = 0;
     do_cache = 1;
 
-    if (!setup_ticket_text(stateful, idx, &sctx, &cctx))
+    if (!setup_ticket_test(stateful, idx, &sctx, &cctx))
         goto end;
 
     if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,
@@ -1357,7 +1357,7 @@ static int test_tickets(int stateful, int idx)
     /* Stop caching sessions - just count them */
     do_cache = 0;
 
-    if (!setup_ticket_text(stateful, idx, &sctx, &cctx))
+    if (!setup_ticket_test(stateful, idx, &sctx, &cctx))
         goto end;
 
     if (!check_resumption(idx, sctx, cctx, 0))
@@ -1366,8 +1366,11 @@ static int test_tickets(int stateful, int idx)
     /* Start again with caching sessions */
     new_called = 0;
     do_cache = 1;
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+    sctx = cctx = NULL;
 
-    if (!setup_ticket_text(stateful, idx, &sctx, &cctx))
+    if (!setup_ticket_test(stateful, idx, &sctx, &cctx))
         goto end;
 
     if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl,

[ML] commit f99648638c8340cbc0cb7ddaa54309435bda9530
Author: Rich Salz <rsalz@openssl.org>
Date:   Mon Jul 9 14:55:17 2018 -0400

    Add tests for the "req" command, -addext flag
    
    Also fixed a memory leak found by the test.
    
    Reviewed-by: Andy Polyakov <appro@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/6681)

diff --git a/apps/req.c b/apps/req.c
index 066e7c668f..48f3a3ab98 100644
--- a/apps/req.c
+++ b/apps/req.c
@@ -947,6 +947,7 @@ int req_main(int argc, char **argv)
         ERR_print_errors(bio_err);
     }
     NCONF_free(req_conf);
+    NCONF_free(addext_conf);
     BIO_free(addext_bio);
     BIO_free(in);
     BIO_free_all(out);
diff --git a/test/recipes/25-test_req.t b/test/recipes/25-test_req.t
index fa79219e1d..b6d233548f 100644
--- a/test/recipes/25-test_req.t
+++ b/test/recipes/25-test_req.t
@@ -15,7 +15,7 @@ use OpenSSL::Test qw/:DEFAULT srctop_file/;
 
 setup("test_req");
 
-plan tests => 8;
+plan tests => 9;
 
 require_ok(srctop_file('test','recipes','tconversion.pl'));
 
@@ -23,26 +23,30 @@ open RND, ">>", ".rnd";
 print RND "string to make the random number generator think it has randomness";
 close RND;
 
-# Check for duplicate -addext parameters
+# What type of key to generate?
+my @req_new;
+if (disabled("rsa")) {
+    @req_new = ("-newkey", "dsa:".srctop_file("apps", "dsa512.pem"));
+} else {
+    @req_new = ("-new");
+    note("There should be a 2 sequences of .'s and some +'s.");
+    note("There should not be more that at most 80 per line");
+}
+
+# Check for duplicate -addext parameters, and one "working" case.
+my @addext_args = ( "openssl", "req", "-new", "-out", "testreq.pem",
+    "-config", srctop_file("test", "test.cnf"), @req_new );
 my $val = "subjectAltName=DNS:example.com";
 my $val2 = " " . $val;
 my $val3 = $val;
 $val3 =~ s/=/    =/;
-ok(!run(app(["openssl", "req", "-new", "-addext", $val, "-addext", $val])));
-ok(!run(app(["openssl", "req", "-new", "-addext", $val, "-addext", $val2])));
-ok(!run(app(["openssl", "req", "-new", "-addext", $val, "-addext", $val3])));
-ok(!run(app(["openssl", "req", "-new", "-addext", $val2, "-addext", $val3])));
+ok( run(app([@addext_args, "-addext", $val])));
+ok(!run(app([@addext_args, "-addext", $val, "-addext", $val])));
+ok(!run(app([@addext_args, "-addext", $val, "-addext", $val2])));
+ok(!run(app([@addext_args, "-addext", $val, "-addext", $val3])));
+ok(!run(app([@addext_args, "-addext", $val2, "-addext", $val3])));
 
 subtest "generating certificate requests" => sub {
-    my @req_new;
-    if (disabled("rsa")) {
-	@req_new = ("-newkey", "dsa:".srctop_file("apps", "dsa512.pem"));
-    } else {
-	@req_new = ("-new");
-	note("There should be a 2 sequences of .'s and some +'s.");
-	note("There should not be more that at most 80 per line");
-    }
-
     plan tests => 2;
 
     ok(run(app(["openssl", "req", "-config", srctop_file("test", "test.cnf"),

[UAF] commit c0a58e034d3eff68ca5e0d36d7b4d147425b0599
Author: Marcus Huewe <suse-tux@gmx.de>
Date:   Fri May 11 12:24:56 2018 +0200

    Do not free a session before calling the remove_session_cb
    
    If the remove_session_cb accesses the session's data (for instance,
    via SSL_SESSION_get_protocol_version), a potential use after free
    can occur. For this, consider the following scenario when adding
    a new session via SSL_CTX_add_session:
    
    - The session cache is full
      (SSL_CTX_sess_number(ctx) > SSL_CTX_sess_get_cache_size(ctx))
    - Only the session cache has a reference to ctx->session_cache_tail
      (that is, ctx->session_cache_tail->references == 1)
    
    Since the cache is full, remove_session_lock is called to remove
    ctx->session_cache_tail from the cache. That is, it
    SSL_SESSION_free()s the session, which free()s the data. Afterwards,
    the free()d session is passed to the remove_session_cb. If the callback
    accesses the session's data, we have a use after free.
    
    The free before calling the callback behavior was introduced in
    commit e4612d02c53cccd24fa97b08fc01250d1238cca1 ("Remove sessions
    from external cache, even if internal cache not used.").
    
    CLA: trivial
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/6222)

diff --git a/ssl/ssl_sess.c b/ssl/ssl_sess.c
index 525edb3289..0723765366 100644
--- a/ssl/ssl_sess.c
+++ b/ssl/ssl_sess.c
@@ -769,11 +769,11 @@ static int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)
         if (lck)
             CRYPTO_THREAD_unlock(ctx->lock);
 
-        if (ret)
-            SSL_SESSION_free(r);
-
         if (ctx->remove_session_cb != NULL)
             ctx->remove_session_cb(ctx, c);
+
+        if (ret)
+            SSL_SESSION_free(r);
     } else
         ret = 0;
     return ret;

[ML] commit bdd5f12ea6b76fb133b152a3ca38a3c045be4de3
Author: Matt Caswell <matt@openssl.org>
Date:   Tue May 29 16:05:10 2018 +0100

    Fix a memory leak in an error path
    
    Found by Coverity
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/6373)

diff --git a/apps/s_client.c b/apps/s_client.c
index 9122d48936..09f534033f 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -201,6 +201,7 @@ static int psk_use_session_cb(SSL *s, const EVP_MD *md,
         cipher = SSL_CIPHER_find(s, tls13_aes128gcmsha256_id);
         if (cipher == NULL) {
             BIO_printf(bio_err, "Error finding suitable ciphersuite\n");
+            OPENSSL_free(key);
             return 0;
         }
 

[ML] commit 28c73b34dfe00e786fc9198d89e089655ec5ae01
Author: Matt Caswell <matt@openssl.org>
Date:   Tue May 29 16:01:30 2018 +0100

    Free a variable
    
    Fix a memory leak in storeutl.
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/6373)

diff --git a/apps/storeutl.c b/apps/storeutl.c
index 0f310d2ec9..50007f6e8b 100644
--- a/apps/storeutl.c
+++ b/apps/storeutl.c
@@ -308,6 +308,7 @@ int storeutl_main(int argc, char *argv[])
                   text, noout, recursive, 0, out, prog);
 
  end:
+    OPENSSL_free(fingerprint);
     OPENSSL_free(alias);
     ASN1_INTEGER_free(serial);
     X509_NAME_free(subject);

[ML] commit aebd0e5ca12d1ba0b229a4121a54afa5ea2d8aa1
Author: Pavel Kopyl <p.kopyl@samsung.com>
Date:   Fri Nov 3 18:18:59 2017 +0300

    Fix memory leaks in CA related functions.
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/4700)

diff --git a/apps/ca.c b/apps/ca.c
index ea774ad557..afc5e349b4 100644
--- a/apps/ca.c
+++ b/apps/ca.c
@@ -934,10 +934,13 @@ end_of_options:
             if (j > 0) {
                 total_done++;
                 BIO_printf(bio_err, "\n");
-                if (!BN_add_word(serial, 1))
+                if (!BN_add_word(serial, 1)) {
+                    X509_free(x);
                     goto end;
+                }
                 if (!sk_X509_push(cert_sk, x)) {
                     BIO_printf(bio_err, "Memory allocation failure\n");
+                    X509_free(x);
                     goto end;
                 }
             }
diff --git a/apps/verify.c b/apps/verify.c
index 5ad6ef4151..38377a57e4 100644
--- a/apps/verify.c
+++ b/apps/verify.c
@@ -225,6 +225,7 @@ static int check(X509_STORE *ctx, const char *file,
 
     X509_STORE_set_flags(ctx, vflags);
     if (!X509_STORE_CTX_init(csc, ctx, x, uchain)) {
+        X509_STORE_CTX_free(csc);
         printf("error %s: X.509 store context initialization failed\n",
                (file == NULL) ? "stdin" : file);
         goto end;
diff --git a/crypto/conf/conf_api.c b/crypto/conf/conf_api.c
index ade54839bb..9606b7f222 100644
--- a/crypto/conf/conf_api.c
+++ b/crypto/conf/conf_api.c
@@ -204,12 +204,14 @@ CONF_VALUE *_CONF_new_section(CONF *conf, const char *section)
     v->value = (char *)sk;
 
     vv = lh_CONF_VALUE_insert(conf->data, v);
-    if (vv != NULL)
+    if (vv != NULL || lh_CONF_VALUE_error(conf->data) > 0)
         goto err;
     return v;
 
  err:
     sk_CONF_VALUE_free(sk);
+    if (v != NULL)
+        OPENSSL_free(v->section);
     OPENSSL_free(v);
     return NULL;
 }
diff --git a/crypto/engine/eng_lib.c b/crypto/engine/eng_lib.c
index 95736eda6a..9028319788 100644
--- a/crypto/engine/eng_lib.c
+++ b/crypto/engine/eng_lib.c
@@ -154,8 +154,10 @@ void engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)
     if (!int_cleanup_check(1))
         return;
     item = int_cleanup_item(cb);
-    if (item)
-        sk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item);
+    if (item != NULL) {
+        if (sk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item) <= 0)
+            OPENSSL_free(item);
+    }
 }
 
 /* The API function that performs all cleanup */

[DF] commit 67cc2bae02fdcc0d9409861d1e941e72774411ba
Author: Nicola Tuveri <nic.tuv@gmail.com>
Date:   Tue Apr 10 03:19:30 2018 +0300

    [SM2_sign] fix double free and return value
    
    Currently, critical bugs prevent using SM2 signatures through the
    `EVP_PKEY` interface: any application that managed to satisfy the
    requirement of forcing SM3 as the message digest â even if this is
    currently not possible transparently through the `EVP_PKEY` interface
    and requires manually forcing the MD selection â would crash with a
    segmentation fault upon calling the `SM2_sign()` function.
    
    This is easily verified using the OpenSSL CLI to execute this critical
    code path under the right conditions:
    `openssl dgst -sm3 -hex -sign sm2.eckey /path/to/file/to/sign`
    
    The issue is caused by a double free at the end of `SM2_sign()` in
    `crypto/sm2/sm2_sign.c` in case of successful signature generation.
    In addition, even if the double free was not causing segfaults,
    the function returns the wrong return value in case of success (it
    would return 0 rather than 1).
    
    This patch fixes both problems.
    
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/6066)

diff --git a/crypto/sm2/sm2_sign.c b/crypto/sm2/sm2_sign.c
index 12ccd28bcf..e12eca12fb 100644
--- a/crypto/sm2/sm2_sign.c
+++ b/crypto/sm2/sm2_sign.c
@@ -279,9 +279,7 @@ int SM2_sign(int type, const unsigned char *dgst, int dgstlen,
 
     *siglen = i2d_ECDSA_SIG(s, &sig);
 
-    ECDSA_SIG_free(s);
-
-    ret = 0;
+    ret = 1;
 
  done:
     ECDSA_SIG_free(s);

[ML] commit 9f2a3bb19d42e6942cbbb7ea0a41a342ce158b94
Author: Matt Caswell <matt@openssl.org>
Date:   Mon Apr 16 18:41:01 2018 +0100

    Fix a memory leak in an error path
    
    Found by Coverity.
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5970)

diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c
index 1bf2f267ed..b13c006be8 100644
--- a/crypto/srp/srp_vfy.c
+++ b/crypto/srp/srp_vfy.c
@@ -69,8 +69,10 @@ static int t_fromb64(unsigned char *a, size_t alen, const char *src)
      *  4 bytes unencoded = 6 bytes encoded
      *  etc
      */
-    if (padsize == 3)
-        return -1;
+    if (padsize == 3) {
+        outl = -1;
+        goto err;
+    }
 
     /* Valid padsize values are now 0, 1 or 2 */
 
@@ -80,12 +82,12 @@ static int t_fromb64(unsigned char *a, size_t alen, const char *src)
     /* Add any encoded padding that is required */
     if (padsize != 0
             && EVP_DecodeUpdate(ctx, a, &outl, pad, padsize) < 0) {
-        EVP_ENCODE_CTX_free(ctx);
-        return -1;
+        outl = -1;
+        goto err;
     }
     if (EVP_DecodeUpdate(ctx, a, &outl2, (const unsigned char *)src, size) < 0) {
-        EVP_ENCODE_CTX_free(ctx);
-        return -1;
+        outl = -1;
+        goto err;
     }
     outl += outl2;
     EVP_DecodeFinal(ctx, a + outl, &outl2);
@@ -93,8 +95,11 @@ static int t_fromb64(unsigned char *a, size_t alen, const char *src)
 
     /* Strip off the leading padding */
     if (padsize != 0) {
-        if ((int)padsize >= outl)
-            return -1;
+        if ((int)padsize >= outl) {
+            outl = -1;
+            goto err;
+        }
+
         /*
          * If we added 1 byte of padding prior to encoding then we have 2 bytes
          * of "real" data which gets spread across 4 encoded bytes like this:
@@ -112,6 +117,7 @@ static int t_fromb64(unsigned char *a, size_t alen, const char *src)
         outl -= padsize;
     }
 
+ err:
     EVP_ENCODE_CTX_free(ctx);
 
     return outl;

[ML] commit 63a65d16acca53622a08861cdde8fe0e79beb522
Author: Dr. Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>
Date:   Sun Apr 8 12:09:10 2018 +0200

    DRBG: fix memory leak on error in rand_drbg_get_entropy()
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5918)

diff --git a/crypto/rand/rand_lib.c b/crypto/rand/rand_lib.c
index 3589e75853..6e98e4ddf8 100644
--- a/crypto/rand/rand_lib.c
+++ b/crypto/rand/rand_lib.c
@@ -229,7 +229,7 @@ size_t rand_drbg_get_entropy(RAND_DRBG *drbg,
              */
             RANDerr(RAND_F_RAND_DRBG_GET_ENTROPY,
                     RAND_R_PREDICTION_RESISTANCE_NOT_SUPPORTED);
-            return 0;
+            goto err;
         }
 
         /* Get entropy by polling system entropy sources. */
@@ -241,6 +241,7 @@ size_t rand_drbg_get_entropy(RAND_DRBG *drbg,
         *pout = rand_pool_detach(pool);
     }
 
+ err:
     rand_pool_free(pool);
     return ret;
 }

[ML] commit a080c3e816e923680e57e647b5cbc3896e8e8106
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Fri Mar 16 21:12:22 2018 +0100

    Fix a memory leak in tls1_mac
    
    Reviewed-by: Tim Hudson <tjh@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5650)

diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
index 4ffc84279d..fa902f30fb 100644
--- a/ssl/record/ssl3_record.c
+++ b/ssl/record/ssl3_record.c
@@ -1297,8 +1297,10 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
         mac_ctx = hash;
     } else {
         hmac = EVP_MD_CTX_new();
-        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))
+        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash)) {
+            EVP_MD_CTX_free(hmac);
             return 0;
+        }
         mac_ctx = hmac;
     }
 

[ML] commit 302d1697fe09a9f4e89980f4ea84f86e63fc5e8d
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Fri Mar 16 16:45:55 2018 +0100

    Fix a memory leak in n_ssl3_mac
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5648)

diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
index 5bfbaf982e..4ffc84279d 100644
--- a/ssl/record/ssl3_record.c
+++ b/ssl/record/ssl3_record.c
@@ -1256,7 +1256,7 @@ int n_ssl3_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
             || EVP_DigestUpdate(md_ctx, ssl3_pad_2, npad) <= 0
             || EVP_DigestUpdate(md_ctx, md, md_size) <= 0
             || EVP_DigestFinal_ex(md_ctx, md, &md_size_u) <= 0) {
-            EVP_MD_CTX_reset(md_ctx);
+            EVP_MD_CTX_free(md_ctx);
             return 0;
         }
 

[ML] commit 01985122ae2b144cdd3a2061640e76bff491dc7f
Author: Matt Caswell <matt@openssl.org>
Date:   Wed Mar 14 14:32:48 2018 +0000

    Fix a memory leak in the ca application
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5444)

diff --git a/apps/ca.c b/apps/ca.c
index 743e48185b..d530cf5cd7 100644
--- a/apps/ca.c
+++ b/apps/ca.c
@@ -1861,11 +1861,11 @@ static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509,
     irow = NULL;
     ok = 1;
  end:
-    if (irow != NULL) {
+    if (ok != 1) {
         for (i = 0; i < DB_NUMBER; i++)
             OPENSSL_free(row[i]);
-        OPENSSL_free(irow);
     }
+    OPENSSL_free(irow);
 
     X509_NAME_free(CAname);
     X509_NAME_free(subject);

[ML] commit 55a7f77d72930f9aee1a51e0af9658b2728be127
Author: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date:   Fri Mar 2 09:27:39 2018 +0100

    Fix a possible memory leak in engine_table_register
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5489)

diff --git a/crypto/engine/eng_table.c b/crypto/engine/eng_table.c
index 219253a38a..ffdecb9991 100644
--- a/crypto/engine/eng_table.c
+++ b/crypto/engine/eng_table.c
@@ -109,6 +109,11 @@ int engine_table_register(ENGINE_TABLE **table, ENGINE_CLEANUP_CB *cleanup,
             }
             fnd->funct = NULL;
             (void)lh_ENGINE_PILE_insert(&(*table)->piles, fnd);
+            if (lh_ENGINE_PILE_retrieve(&(*table)->piles, &tmplate) != fnd) {
+                sk_ENGINE_free(fnd->sk);
+                OPENSSL_free(fnd);
+                goto end;
+            }
         }
         /* A registration shouldn't add duplicate entries */
         (void)sk_ENGINE_delete_ptr(fnd->sk, e);

[UAF] commit 34ff74eb183519ccedf11c97e754450469707951
Author: Matt Caswell <matt@openssl.org>
Date:   Mon Feb 26 19:34:42 2018 +0000

    Clear some sslapitest global variables after use
    
    Otherwise we get a use after free if the test order is randomised.
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5467)

diff --git a/test/sslapitest.c b/test/sslapitest.c
index 1cf5c4fc6c..6480885fcd 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -3227,6 +3227,7 @@ static int test_export_key_mat_early(int idx)
         SSL_SESSION_free(sess);
     SSL_SESSION_free(clientpsk);
     SSL_SESSION_free(serverpsk);
+    clientpsk = serverpsk = NULL;
     SSL_free(serverssl);
     SSL_free(clientssl);
     SSL_CTX_free(sctx);

[ML] commit 62542d046483687330c55b36fa27d82dc03958c2
Author: Matt Caswell <matt@openssl.org>
Date:   Mon Feb 12 16:58:33 2018 +0000

    Fix a memory leak in an error path
    
    Found by Coverity.
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/5336)

diff --git a/crypto/rsa/rsa_mp.c b/crypto/rsa/rsa_mp.c
index 97a09f1387..7e38179b97 100644
--- a/crypto/rsa/rsa_mp.c
+++ b/crypto/rsa/rsa_mp.c
@@ -51,6 +51,7 @@ RSA_PRIME_INFO *rsa_multip_info_new(void)
     BN_free(pinfo->d);
     BN_free(pinfo->t);
     BN_free(pinfo->pp);
+    OPENSSL_free(pinfo);
     return NULL;
 }
 

[ML] commit 4e525a0b4db2b11bee15a485b6ed6622ca8948f1
Author: Richard Levitte <levitte@openssl.org>
Date:   Wed Jan 31 22:08:12 2018 +0100

    ocsp.c doesn't free the whole output chain, maybe causing a memory leak
    
    Reviewed-by: Rich Salz <rsalz@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5224)

diff --git a/apps/ocsp.c b/apps/ocsp.c
index 122aee6770..bd16a5b869 100644
--- a/apps/ocsp.c
+++ b/apps/ocsp.c
@@ -730,7 +730,7 @@ redo_accept:
     free_index(rdb);
     BIO_free_all(cbio);
     BIO_free_all(acbio);
-    BIO_free(out);
+    BIO_free_all(out);
     OCSP_REQUEST_free(req);
     OCSP_RESPONSE_free(resp);
     OCSP_BASICRESP_free(bs);

[ML] commit a26dd465b21d8def440c16b6bd90227b03e12e02
Author: Todd Short <tshort@akamai.com>
Date:   Mon Jan 22 14:30:24 2018 -0500

    Fix error-path memory leak in asn_mime.c
    
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/5142)

diff --git a/crypto/asn1/asn_mime.c b/crypto/asn1/asn_mime.c
index 936c8a5b00..2faff455c5 100644
--- a/crypto/asn1/asn_mime.c
+++ b/crypto/asn1/asn_mime.c
@@ -425,6 +425,7 @@ ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
             || hdr->value == NULL) {
             sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
             ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_SIG_CONTENT_TYPE);
+            sk_BIO_pop_free(parts, BIO_vfree);
             return NULL;
         }
 

