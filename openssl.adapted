[FUNC] **new** commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/pem/pem_lib.c b/crypto/pem/pem_lib.c
--- a/crypto/pem/pem_lib.c
+++ b/crypto/pem/pem_lib.c
@@ -229,6 +234,8 @@
-static void *pem_malloc(int num, unsigned int flags)
+static void *pem_malloc(int num, unsigned int flags,
+                        const char *file, int line)
 {
-    return (flags & PEM_FLAG_SECURE) ? OPENSSL_secure_malloc(num)
-                                     : OPENSSL_malloc(num);
+    return (flags & PEM_FLAG_SECURE) ? CRYPTO_secure_malloc(num, file, line)
+                                     : CRYPTO_malloc(num, file, line);
+
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -232,22 +226,20 @@
 OPENSSL_STACK *OPENSSL_sk_new_reserve(OPENSSL_sk_compfunc c, int n)
 {
     OPENSSL_STACK *st = OPENSSL_zalloc(sizeof(OPENSSL_STACK));
 
-    if (st == NULL) {
-        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
+    if (st == NULL)
         return NULL;
-    }
 
     st->comp = c;
 
     if (n <= 0)
         return st;
 
     if (!sk_reserve(st, n, 1)) {
         OPENSSL_sk_free(st);
         return NULL;
     }
 
     return st;
 }
 

[FUNC] **new** commit 30eba7f35983a917f1007bce45040c0af3442e42
Date:   Sun Aug 7 07:08:28 2022 +0200

    stack.c: add missing direct error reporting and improve coding style
    
    Doing so, had to fix sloppiness in using the stack API in crypto/conf/conf_def.c,
    ssl/ssl_ciph.c, ssl/statem/statem_srvr.c, and mostly in test/helpers/ssltestlib.c.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/18918)

diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -225,20 +232,22 @@
 OPENSSL_STACK *OPENSSL_sk_new_reserve(OPENSSL_sk_compfunc c, int n)
 {
     OPENSSL_STACK *st = OPENSSL_zalloc(sizeof(OPENSSL_STACK));
 
-    if (st == NULL)
+    if (st == NULL) {
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
+    }
 
     st->comp = c;
 
     if (n <= 0)
         return st;
 
     if (!sk_reserve(st, n, 1)) {
         OPENSSL_sk_free(st);
         return NULL;
     }
 
     return st;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -47,36 +47,35 @@
 OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)
 {
     OPENSSL_STACK *ret;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)
         goto err;
 
     if (sk == NULL) {
         ret->num = 0;
         ret->sorted = 0;
         ret->comp = NULL;
     } else {
         /* direct structure assignment */
         *ret = *sk;
     }
 
     if (sk == NULL || sk->num == 0) {
         /* postpone |ret->data| allocation */
         ret->data = NULL;
         ret->num_alloc = 0;
         return ret;
     }
 
     /* duplicate |sk->data| content */
     ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc);
     if (ret->data == NULL)
         goto err;
     memcpy(ret->data, sk->data, sizeof(void *) * sk->num);
     return ret;
 
  err:
-    ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     OPENSSL_sk_free(ret);
     return NULL;
 }
 

commit 30eba7f35983a917f1007bce45040c0af3442e42
Date:   Sun Aug 7 07:08:28 2022 +0200

    stack.c: add missing direct error reporting and improve coding style
    
    Doing so, had to fix sloppiness in using the stack API in crypto/conf/conf_def.c,
    ssl/ssl_ciph.c, ssl/statem/statem_srvr.c, and mostly in test/helpers/ssltestlib.c.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/18918)

diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -47,35 +47,36 @@
 OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)
 {
     OPENSSL_STACK *ret;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)
         goto err;
 
     if (sk == NULL) {
         ret->num = 0;
         ret->sorted = 0;
         ret->comp = NULL;
     } else {
         /* direct structure assignment */
         *ret = *sk;
     }
 
     if (sk == NULL || sk->num == 0) {
         /* postpone |ret->data| allocation */
         ret->data = NULL;
         ret->num_alloc = 0;
         return ret;
     }
 
     /* duplicate |sk->data| content */
-    if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL)
+    ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc);
+    if (ret->data == NULL)
         goto err;
     memcpy(ret->data, sk->data, sizeof(void *) * sk->num);
     return ret;
 
  err:
     ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     OPENSSL_sk_free(ret);
     return NULL;
 }
 

commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -83,49 +82,48 @@
 OPENSSL_STACK *OPENSSL_sk_deep_copy(const OPENSSL_STACK *sk,
                                     OPENSSL_sk_copyfunc copy_func,
                                     OPENSSL_sk_freefunc free_func)
 {
     OPENSSL_STACK *ret;
     int i;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)
         goto err;
 
     if (sk == NULL) {
         ret->num = 0;
         ret->sorted = 0;
         ret->comp = NULL;
     } else {
         /* direct structure assignment */
         *ret = *sk;
     }
 
     if (sk == NULL || sk->num == 0) {
         /* postpone |ret| data allocation */
         ret->data = NULL;
         ret->num_alloc = 0;
         return ret;
     }
 
     ret->num_alloc = sk->num > min_nodes ? sk->num : min_nodes;
     ret->data = OPENSSL_zalloc(sizeof(*ret->data) * ret->num_alloc);
     if (ret->data == NULL)
         goto err;
 
     for (i = 0; i < ret->num; ++i) {
         if (sk->data[i] == NULL)
             continue;
         if ((ret->data[i] = copy_func(sk->data[i])) == NULL) {
             while (--i >= 0)
                 if (ret->data[i] != NULL)
                     free_func((void *)ret->data[i]);
             goto err;
         }
     }
     return ret;
 
  err:
-    ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     OPENSSL_sk_free(ret);
     return NULL;
 }
 

commit 30eba7f35983a917f1007bce45040c0af3442e42
Date:   Sun Aug 7 07:08:28 2022 +0200

    stack.c: add missing direct error reporting and improve coding style
    
    Doing so, had to fix sloppiness in using the stack API in crypto/conf/conf_def.c,
    ssl/ssl_ciph.c, ssl/statem/statem_srvr.c, and mostly in test/helpers/ssltestlib.c.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/18918)

diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -82,49 +83,49 @@
 OPENSSL_STACK *OPENSSL_sk_deep_copy(const OPENSSL_STACK *sk,
-                             OPENSSL_sk_copyfunc copy_func,
-                             OPENSSL_sk_freefunc free_func)
+                                    OPENSSL_sk_copyfunc copy_func,
+                                    OPENSSL_sk_freefunc free_func)
 {
     OPENSSL_STACK *ret;
     int i;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)
         goto err;
 
     if (sk == NULL) {
         ret->num = 0;
         ret->sorted = 0;
         ret->comp = NULL;
     } else {
         /* direct structure assignment */
         *ret = *sk;
     }
 
     if (sk == NULL || sk->num == 0) {
         /* postpone |ret| data allocation */
         ret->data = NULL;
         ret->num_alloc = 0;
         return ret;
     }
 
     ret->num_alloc = sk->num > min_nodes ? sk->num : min_nodes;
     ret->data = OPENSSL_zalloc(sizeof(*ret->data) * ret->num_alloc);
     if (ret->data == NULL)
         goto err;
 
     for (i = 0; i < ret->num; ++i) {
         if (sk->data[i] == NULL)
             continue;
         if ((ret->data[i] = copy_func(sk->data[i])) == NULL) {
             while (--i >= 0)
                 if (ret->data[i] != NULL)
                     free_func((void *)ret->data[i]);
             goto err;
         }
     }
     return ret;
 
  err:
     ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     OPENSSL_sk_free(ret);
     return NULL;
 }
 

 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -81,35 +81,33 @@
 BIO *BIO_new_ex(OSSL_LIB_CTX *libctx, const BIO_METHOD *method)
 {
     BIO *bio = OPENSSL_zalloc(sizeof(*bio));
 
-    if (bio == NULL) {
-        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
+    if (bio == NULL)
         return NULL;
-    }
 
     bio->libctx = libctx;
     bio->method = method;
     bio->shutdown = 1;
     bio->references = 1;
 
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data))
         goto err;
 
     bio->lock = CRYPTO_THREAD_lock_new();
     if (bio->lock == NULL) {
-        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_CRYPTO_LIB);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         goto err;
     }
 
     if (method->create != NULL && !method->create(bio)) {
         ERR_raise(ERR_LIB_BIO, ERR_R_INIT_FAIL);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         CRYPTO_THREAD_lock_free(bio->lock);
         goto err;
     }
     if (method->create == NULL)
         bio->init = 1;
 
     return bio;
 

[FUNC] **new** commit b0ee1de9ab4fb8586934f3a8126432f06abf7115
Date:   Tue Apr 27 19:56:39 2021 +0100

    Create libcrypto support for BIO_new_from_core_bio()
    
    Previously the concept of wrapping an OSSL_CORE_BIO in a real BIO was an
    internal only concept for our own providers. Since this is likely to be
    generally useful, we make it a part of the public API.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15072)

diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -71,34 +71,35 @@
-BIO *BIO_new(const BIO_METHOD *method)
+BIO *BIO_new_ex(OSSL_LIB_CTX *libctx, const BIO_METHOD *method)
 {
     BIO *bio = OPENSSL_zalloc(sizeof(*bio));
 
     if (bio == NULL) {
         ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
+    bio->libctx = libctx;
     bio->method = method;
     bio->shutdown = 1;
     bio->references = 1;
 
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data))
         goto err;
 
     bio->lock = CRYPTO_THREAD_lock_new();
     if (bio->lock == NULL) {
         ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         goto err;
     }
 
     if (method->create != NULL && !method->create(bio)) {
         ERR_raise(ERR_LIB_BIO, ERR_R_INIT_FAIL);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         CRYPTO_THREAD_lock_free(bio->lock);
         goto err;
     }
     if (method->create == NULL)
         bio->init = 1;
 
     return bio;
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -81,35 +81,33 @@
 BIO *BIO_new_ex(OSSL_LIB_CTX *libctx, const BIO_METHOD *method)
 {
     BIO *bio = OPENSSL_zalloc(sizeof(*bio));
 
-    if (bio == NULL) {
-        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
+    if (bio == NULL)
         return NULL;
-    }
 
     bio->libctx = libctx;
     bio->method = method;
     bio->shutdown = 1;
     bio->references = 1;
 
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data))
         goto err;
 
     bio->lock = CRYPTO_THREAD_lock_new();
     if (bio->lock == NULL) {
-        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_CRYPTO_LIB);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         goto err;
     }
 
     if (method->create != NULL && !method->create(bio)) {
         ERR_raise(ERR_LIB_BIO, ERR_R_INIT_FAIL);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         CRYPTO_THREAD_lock_free(bio->lock);
         goto err;
     }
     if (method->create == NULL)
         bio->init = 1;
 
     return bio;
 

commit b0ee1de9ab4fb8586934f3a8126432f06abf7115
Date:   Tue Apr 27 19:56:39 2021 +0100

    Create libcrypto support for BIO_new_from_core_bio()
    
    Previously the concept of wrapping an OSSL_CORE_BIO in a real BIO was an
    internal only concept for our own providers. Since this is likely to be
    generally useful, we make it a part of the public API.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15072)

diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -71,34 +71,35 @@
-BIO *BIO_new(const BIO_METHOD *method)
+BIO *BIO_new_ex(OSSL_LIB_CTX *libctx, const BIO_METHOD *method)
 {
     BIO *bio = OPENSSL_zalloc(sizeof(*bio));
 
     if (bio == NULL) {
         ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
+    bio->libctx = libctx;
     bio->method = method;
     bio->shutdown = 1;
     bio->references = 1;
 
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data))
         goto err;
 
     bio->lock = CRYPTO_THREAD_lock_new();
     if (bio->lock == NULL) {
         ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         goto err;
     }
 
     if (method->create != NULL && !method->create(bio)) {
         ERR_raise(ERR_LIB_BIO, ERR_R_INIT_FAIL);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
         CRYPTO_THREAD_lock_free(bio->lock);
         goto err;
     }
     if (method->create == NULL)
         bio->init = 1;
 
     return bio;
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/bn/bn_lib.c b/crypto/bn/bn_lib.c
--- a/crypto/bn/bn_lib.c
+++ b/crypto/bn/bn_lib.c
@@ -243,23 +243,21 @@
 BIGNUM *BN_new(void)
 {
     BIGNUM *ret;
 
-    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
+    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL)
         return NULL;
-    }
     ret->flags = BN_FLG_MALLOCED;
     bn_check_top(ret);
     return ret;
 }
 
  BIGNUM *BN_secure_new(void)
  {
      BIGNUM *ret = BN_new();
      if (ret != NULL)
          ret->flags |= BN_FLG_SECURE;
      return ret;
  }
 
 /* This is used by bn_expand2() */
 /* The caller MUST check that words > b->dmax before calling this */
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/bn/bn_lib.c b/crypto/bn/bn_lib.c
--- a/crypto/bn/bn_lib.c
+++ b/crypto/bn/bn_lib.c
@@ -1043,12 +1039,10 @@
 BN_GENCB *BN_GENCB_new(void)
 {
     BN_GENCB *ret;
 
-    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {
-        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
+    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)
         return NULL;
-    }
 
     return ret;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/buffer/buffer.c b/crypto/buffer/buffer.c
--- a/crypto/buffer/buffer.c
+++ b/crypto/buffer/buffer.c
@@ -73,37 +71,36 @@
 size_t BUF_MEM_grow(BUF_MEM *str, size_t len)
 {
     char *ret;
     size_t n;
 
     if (str->length >= len) {
         str->length = len;
         return len;
     }
     if (str->max >= len) {
         if (str->data != NULL)
             memset(&str->data[str->length], 0, len - str->length);
         str->length = len;
         return len;
     }
     /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */
     if (len > LIMIT_BEFORE_EXPANSION) {
-        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
     n = (len + 3) / 3 * 4;
     if ((str->flags & BUF_MEM_FLAG_SECURE))
         ret = sec_alloc_realloc(str, n);
     else
         ret = OPENSSL_realloc(str->data, n);
     if (ret == NULL) {
-        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         len = 0;
     } else {
         str->data = ret;
         str->max = n;
         memset(&str->data[str->length], 0, len - str->length);
         str->length = len;
     }
     return len;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/buffer/buffer.c b/crypto/buffer/buffer.c
--- a/crypto/buffer/buffer.c
+++ b/crypto/buffer/buffer.c
@@ -110,38 +107,37 @@
 size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len)
 {
     char *ret;
     size_t n;
 
     if (str->length >= len) {
         if (str->data != NULL)
             memset(&str->data[len], 0, str->length - len);
         str->length = len;
         return len;
     }
     if (str->max >= len) {
         memset(&str->data[str->length], 0, len - str->length);
         str->length = len;
         return len;
     }
     /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */
     if (len > LIMIT_BEFORE_EXPANSION) {
-        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
     n = (len + 3) / 3 * 4;
     if ((str->flags & BUF_MEM_FLAG_SECURE))
         ret = sec_alloc_realloc(str, n);
     else
         ret = OPENSSL_clear_realloc(str->data, str->max, n);
     if (ret == NULL) {
-        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         len = 0;
     } else {
         str->data = ret;
         str->max = n;
         memset(&str->data[str->length], 0, len - str->length);
         str->length = len;
     }
     return len;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -105,25 +105,25 @@
 EVP_MD_CTX *evp_md_ctx_new_ex(EVP_PKEY *pkey, const ASN1_OCTET_STRING *id,
                               OSSL_LIB_CTX *libctx, const char *propq)
 {
     EVP_MD_CTX *ctx;
     EVP_PKEY_CTX *pctx = NULL;
 
     if ((ctx = EVP_MD_CTX_new()) == NULL
         || (pctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq)) == NULL) {
-        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
 
     if (id != NULL && EVP_PKEY_CTX_set1_id(pctx, id->data, id->length) <= 0)
         goto err;
 
     EVP_MD_CTX_set_pkey_ctx(ctx, pctx);
     return ctx;
 
  err:
     EVP_PKEY_CTX_free(pctx);
     EVP_MD_CTX_free(ctx);
     return NULL;
 }
 #endif
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -957,125 +953,125 @@
 static void *evp_md_from_algorithm(int name_id,
                                    const OSSL_ALGORITHM *algodef,
                                    OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
     if ((md->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
         EVP_MD_free(md);
         return NULL;
     }
     md->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

[CORR] **new** commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -884,121 +885,125 @@
 static void *evp_md_from_algorithm(int name_id,
                                    const OSSL_ALGORITHM *algodef,
                                    OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
+    if ((md->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
+        EVP_MD_free(md);
+        return NULL;
+    }
     md->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

[CORR] **new** commit 309a78aa305ee14878e453c78ccf9a7dc91264cf
Date:   Tue Mar 16 14:14:43 2021 +0100

    CORE: Add an algorithm_description field to OSSL_ALGORITHM
    
    This corresponds to the |info| field in EVP_PKEY_ASN1_METHOD, as well
    as the generic use of OBJ_nid2ln() as a one line description.
    
    We also add the base functionality to make use of this field.
    
    Fixes #14514
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14656)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -886,119 +886,121 @@
-static void *evp_md_from_dispatch(int name_id,
-                                  const OSSL_DISPATCH *fns,
-                                  OSSL_PROVIDER *prov)
+static void *evp_md_from_algorithm(int name_id,
+                                   const OSSL_ALGORITHM *algodef,
+                                   OSSL_PROVIDER *prov)
 {
+    const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
+    md->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

[NA] **new** commit 1f79baa55ee00c64372397292ab9c88b5c373d93
Date:   Tue Mar 16 10:06:29 2021 +1000

    Remove TODOs from digest.c
    
    They aren't relevant:
    . Digest Sign isn't supported in the FIPS provider.
    . Remove legacy NID use.
    
    Fixes #14394
    Fixes #14395
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14565)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -890,120 +881,119 @@
 static void *evp_md_from_dispatch(int name_id,
                                   const OSSL_DISPATCH *fns,
                                   OSSL_PROVIDER *prov)
 {
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
-    /* TODO(3.x) get rid of the need for legacy NIDs */
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

[CORR] **new** commit d84f5515faf3fe00ed5eeca7e7b8b041be863e90
Date:   Fri Feb 19 17:03:43 2021 +0000

    Don't hold a lock when calling a callback in ossl_namemap_doall_names
    
    We don't want to hold a read lock when calling a user supplied callback.
    That callback could do anything so the risk of a deadlock is high.
    Instead we collect all the names first inside the read lock, and then
    subsequently call the user callback outside the read lock.
    
    Fixes #14225
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14250)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -868,120 +868,120 @@
 static void *evp_md_from_dispatch(int name_id,
                                   const OSSL_DISPATCH *fns,
                                   OSSL_PROVIDER *prov)
 {
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     /* TODO(3.x) get rid of the need for legacy NIDs */
     md->type = NID_undef;
-    evp_names_do_all(prov, name_id, set_legacy_nid, &md->type);
-    if (md->type == -1) {
+    if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
+            || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 
[FUNC] **new** commit 4e62f1a3af36512a1f5e1273d2dc54e3ce7f5fca
Date:   Fri Jan 7 11:46:33 2022 +1100

    Add context dup functions for digests and ciphers
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17529)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -508,0 +508,11 @@
+EVP_MD_CTX *EVP_MD_CTX_dup(const EVP_MD_CTX *in)
+{
+    EVP_MD_CTX *out = EVP_MD_CTX_new();
+
+    if (out != NULL && !EVP_MD_CTX_copy_ex(out, in)) {
+        EVP_MD_CTX_free(out);
+        out = NULL;
+    }
+    return out;
+}
+
[CORR] **new** commit bb98a1123b3d7a8464f2c1f61ffd41f826c7c423
Date:   Mon Jul 26 15:53:25 2021 +0100

    Fix EVP_MD_meth_dup and EVP_CIPHER_meth_dup
    
    Make sure the origin is set correctly when duping an EVP_MD or EVP_CIPHER.
    
    Fixes #16157
    
    Reviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16159)

diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -810,20 +810,21 @@
 EVP_MD *EVP_MD_meth_dup(const EVP_MD *md)
 {
     EVP_MD *to = NULL;
 
     /*
      * Non-legacy EVP_MDs can't be duplicated like this.
      * Use EVP_MD_up_ref() instead.
      */
     if (md->prov != NULL)
         return NULL;
 
     if ((to = EVP_MD_meth_new(md->type, md->pkey_type)) != NULL) {
         CRYPTO_RWLOCK *lock = to->lock;
 
         memcpy(to, md, sizeof(*to));
         to->lock = lock;
+        to->origin = EVP_ORIG_METH;
     }
     return to;
 }
 
[FUNC] **new** commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -763,11 +786,12 @@
 EVP_MD *EVP_MD_meth_new(int md_type, int pkey_type)
 {
     EVP_MD *md = evp_md_new();
 
     if (md != NULL) {
         md->type = md_type;
         md->pkey_type = pkey_type;
+        md->origin = EVP_ORIG_METH;
     }
     return md;
 }
 
[FUNC] **new** commit ff0266eddc34e3f00494651e76bf46e6501dfc0b
Date:   Tue Mar 9 12:07:36 2021 +1000

    Add ossl_sa symbols
    
    Partial fix for #12964
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14473)

diff --git a/crypto/sparse_array.c b/crypto/sparse_array.c
--- a/crypto/sparse_array.c
+++ b/crypto/sparse_array.c
@@ -63,7 +63,7 @@
-OPENSSL_SA *OPENSSL_SA_new(void)
+OPENSSL_SA *ossl_sa_new(void)
 {
     OPENSSL_SA *res = OPENSSL_zalloc(sizeof(*res));
 
     return res;
 }
 
[FUNC] **new** commit b9a2f24e44f53c7c3a63a7f7b165e8267cbdda42
Date:   Thu Mar 10 12:42:05 2022 +0000

    Fix IV length caching in EVP encryption code
    
    The IV length cache value was being invalidated excessively, causing IV
    length caching to be ineffective.
    
    Related to #17064.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Tim Hudson <tjh@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17862)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -69,5 +69,12 @@
 EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)
 {
-    return OPENSSL_zalloc(sizeof(EVP_CIPHER_CTX));
+    EVP_CIPHER_CTX *ctx;
+
+    ctx = OPENSSL_zalloc(sizeof(EVP_CIPHER_CTX));
+    if (ctx == NULL)
+        return NULL;
+
+    ctx->iv_len = -1;
+    return ctx;
 }
 
commit 4e62f1a3af36512a1f5e1273d2dc54e3ce7f5fca
Date:   Fri Jan 7 11:46:33 2022 +1100

    Add context dup functions for digests and ciphers
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17529)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1349,0 +1349,11 @@
+EVP_CIPHER_CTX *EVP_CIPHER_CTX_dup(const EVP_CIPHER_CTX *in)
+{
+    EVP_CIPHER_CTX *out = EVP_CIPHER_CTX_new();
+
+    if (out != NULL && !EVP_CIPHER_CTX_copy(out, in)) {
+        EVP_CIPHER_CTX_free(out);
+        out = NULL;
+    }
+    return out;
+}
+
[IR] **new** commit 83abd33cf7b3ed40fb94aa1338b6c40b44fa8ad3
Date:   Fri Mar 26 17:53:00 2021 +0100

    Drop TODO 3.0 as we cannot get rid of legacy nids in 3.0
    
    Fixes #14393
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14703)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1397,22 +1397,22 @@
 EVP_CIPHER *evp_cipher_new(void)
 {
     EVP_CIPHER *cipher = OPENSSL_zalloc(sizeof(EVP_CIPHER));
 
     if (cipher != NULL) {
         cipher->lock = CRYPTO_THREAD_lock_new();
         if (cipher->lock == NULL) {
             OPENSSL_free(cipher);
             return NULL;
         }
         cipher->refcnt = 1;
     }
     return cipher;
 }
 
 /*
  * FIPS module note: since internal fetches will be entirely
  * provider based, we know that none of its code depends on legacy
  * NIDs or any functionality that use them.
  */
 #ifndef FIPS_MODULE
-/* TODO(3.x) get rid of the need for legacy NIDs */
+/* After removal of legacy support get rid of the need for legacy NIDs */
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -60,109 +60,109 @@
 static void *evp_mac_from_algorithm(int name_id,
                                     const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MAC *mac = NULL;
     int fnmaccnt = 0, fnctxcnt = 0;
 
     if ((mac = evp_mac_new()) == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);
         return NULL;
     }
     mac->name_id = name_id;
     if ((mac->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
         evp_mac_free(mac);
         return NULL;
     }
     mac->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_MAC_NEWCTX:
             if (mac->newctx != NULL)
                 break;
             mac->newctx = OSSL_FUNC_mac_newctx(fns);
             fnctxcnt++;
             break;
         case OSSL_FUNC_MAC_DUPCTX:
             if (mac->dupctx != NULL)
                 break;
             mac->dupctx = OSSL_FUNC_mac_dupctx(fns);
             break;
         case OSSL_FUNC_MAC_FREECTX:
             if (mac->freectx != NULL)
                 break;
             mac->freectx = OSSL_FUNC_mac_freectx(fns);
             fnctxcnt++;
             break;
         case OSSL_FUNC_MAC_INIT:
             if (mac->init != NULL)
                 break;
             mac->init = OSSL_FUNC_mac_init(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_UPDATE:
             if (mac->update != NULL)
                 break;
             mac->update = OSSL_FUNC_mac_update(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_FINAL:
             if (mac->final != NULL)
                 break;
             mac->final = OSSL_FUNC_mac_final(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_GETTABLE_PARAMS:
             if (mac->gettable_params != NULL)
                 break;
             mac->gettable_params =
                 OSSL_FUNC_mac_gettable_params(fns);
             break;
         case OSSL_FUNC_MAC_GETTABLE_CTX_PARAMS:
             if (mac->gettable_ctx_params != NULL)
                 break;
             mac->gettable_ctx_params =
                 OSSL_FUNC_mac_gettable_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_SETTABLE_CTX_PARAMS:
             if (mac->settable_ctx_params != NULL)
                 break;
             mac->settable_ctx_params =
                 OSSL_FUNC_mac_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_GET_PARAMS:
             if (mac->get_params != NULL)
                 break;
             mac->get_params = OSSL_FUNC_mac_get_params(fns);
             break;
         case OSSL_FUNC_MAC_GET_CTX_PARAMS:
             if (mac->get_ctx_params != NULL)
                 break;
             mac->get_ctx_params = OSSL_FUNC_mac_get_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_SET_CTX_PARAMS:
             if (mac->set_ctx_params != NULL)
                 break;
             mac->set_ctx_params = OSSL_FUNC_mac_set_ctx_params(fns);
             break;
         }
     }
     if (fnmaccnt != 3
         || fnctxcnt != 2) {
         /*
          * In order to be a consistent set of functions we must have at least
          * a complete set of "mac" functions, and a complete set of context
          * management functions, as well as the size function.
          */
         evp_mac_free(mac);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     mac->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return mac;
 }
 

commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -49,105 +51,109 @@
 static void *evp_mac_from_algorithm(int name_id,
                                     const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MAC *mac = NULL;
     int fnmaccnt = 0, fnctxcnt = 0;
 
     if ((mac = evp_mac_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     mac->name_id = name_id;
+    if ((mac->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
+        evp_mac_free(mac);
+        return NULL;
+    }
     mac->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_MAC_NEWCTX:
             if (mac->newctx != NULL)
                 break;
             mac->newctx = OSSL_FUNC_mac_newctx(fns);
             fnctxcnt++;
             break;
         case OSSL_FUNC_MAC_DUPCTX:
             if (mac->dupctx != NULL)
                 break;
             mac->dupctx = OSSL_FUNC_mac_dupctx(fns);
             break;
         case OSSL_FUNC_MAC_FREECTX:
             if (mac->freectx != NULL)
                 break;
             mac->freectx = OSSL_FUNC_mac_freectx(fns);
             fnctxcnt++;
             break;
         case OSSL_FUNC_MAC_INIT:
             if (mac->init != NULL)
                 break;
             mac->init = OSSL_FUNC_mac_init(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_UPDATE:
             if (mac->update != NULL)
                 break;
             mac->update = OSSL_FUNC_mac_update(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_FINAL:
             if (mac->final != NULL)
                 break;
             mac->final = OSSL_FUNC_mac_final(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_GETTABLE_PARAMS:
             if (mac->gettable_params != NULL)
                 break;
             mac->gettable_params =
                 OSSL_FUNC_mac_gettable_params(fns);
             break;
         case OSSL_FUNC_MAC_GETTABLE_CTX_PARAMS:
             if (mac->gettable_ctx_params != NULL)
                 break;
             mac->gettable_ctx_params =
                 OSSL_FUNC_mac_gettable_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_SETTABLE_CTX_PARAMS:
             if (mac->settable_ctx_params != NULL)
                 break;
             mac->settable_ctx_params =
                 OSSL_FUNC_mac_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_GET_PARAMS:
             if (mac->get_params != NULL)
                 break;
             mac->get_params = OSSL_FUNC_mac_get_params(fns);
             break;
         case OSSL_FUNC_MAC_GET_CTX_PARAMS:
             if (mac->get_ctx_params != NULL)
                 break;
             mac->get_ctx_params = OSSL_FUNC_mac_get_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_SET_CTX_PARAMS:
             if (mac->set_ctx_params != NULL)
                 break;
             mac->set_ctx_params = OSSL_FUNC_mac_set_ctx_params(fns);
             break;
         }
     }
     if (fnmaccnt != 3
         || fnctxcnt != 2) {
         /*
          * In order to be a consistent set of functions we must have at least
          * a complete set of "mac" functions, and a complete set of context
          * management functions, as well as the size function.
          */
         evp_mac_free(mac);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     mac->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return mac;
 }
 

commit 309a78aa305ee14878e453c78ccf9a7dc91264cf
Date:   Tue Mar 16 14:14:43 2021 +0100

    CORE: Add an algorithm_description field to OSSL_ALGORITHM
    
    This corresponds to the |info| field in EVP_PKEY_ASN1_METHOD, as well
    as the generic use of OBJ_nid2ln() as a one line description.
    
    We also add the base functionality to make use of this field.
    
    Fixes #14514
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14656)

diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -49,103 +49,105 @@
-static void *evp_mac_from_dispatch(int name_id,
-                                   const OSSL_DISPATCH *fns,
-                                   OSSL_PROVIDER *prov)
+static void *evp_mac_from_algorithm(int name_id,
+                                    const OSSL_ALGORITHM *algodef,
+                                    OSSL_PROVIDER *prov)
 {
+    const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MAC *mac = NULL;
     int fnmaccnt = 0, fnctxcnt = 0;
 
     if ((mac = evp_mac_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     mac->name_id = name_id;
+    mac->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_MAC_NEWCTX:
             if (mac->newctx != NULL)
                 break;
             mac->newctx = OSSL_FUNC_mac_newctx(fns);
             fnctxcnt++;
             break;
         case OSSL_FUNC_MAC_DUPCTX:
             if (mac->dupctx != NULL)
                 break;
             mac->dupctx = OSSL_FUNC_mac_dupctx(fns);
             break;
         case OSSL_FUNC_MAC_FREECTX:
             if (mac->freectx != NULL)
                 break;
             mac->freectx = OSSL_FUNC_mac_freectx(fns);
             fnctxcnt++;
             break;
         case OSSL_FUNC_MAC_INIT:
             if (mac->init != NULL)
                 break;
             mac->init = OSSL_FUNC_mac_init(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_UPDATE:
             if (mac->update != NULL)
                 break;
             mac->update = OSSL_FUNC_mac_update(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_FINAL:
             if (mac->final != NULL)
                 break;
             mac->final = OSSL_FUNC_mac_final(fns);
             fnmaccnt++;
             break;
         case OSSL_FUNC_MAC_GETTABLE_PARAMS:
             if (mac->gettable_params != NULL)
                 break;
             mac->gettable_params =
                 OSSL_FUNC_mac_gettable_params(fns);
             break;
         case OSSL_FUNC_MAC_GETTABLE_CTX_PARAMS:
             if (mac->gettable_ctx_params != NULL)
                 break;
             mac->gettable_ctx_params =
                 OSSL_FUNC_mac_gettable_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_SETTABLE_CTX_PARAMS:
             if (mac->settable_ctx_params != NULL)
                 break;
             mac->settable_ctx_params =
                 OSSL_FUNC_mac_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_GET_PARAMS:
             if (mac->get_params != NULL)
                 break;
             mac->get_params = OSSL_FUNC_mac_get_params(fns);
             break;
         case OSSL_FUNC_MAC_GET_CTX_PARAMS:
             if (mac->get_ctx_params != NULL)
                 break;
             mac->get_ctx_params = OSSL_FUNC_mac_get_ctx_params(fns);
             break;
         case OSSL_FUNC_MAC_SET_CTX_PARAMS:
             if (mac->set_ctx_params != NULL)
                 break;
             mac->set_ctx_params = OSSL_FUNC_mac_set_ctx_params(fns);
             break;
         }
     }
     if (fnmaccnt != 3
         || fnctxcnt != 2) {
         /*
          * In order to be a consistent set of functions we must have at least
          * a complete set of "mac" functions, and a complete set of context
          * management functions, as well as the size function.
          */
         evp_mac_free(mac);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     mac->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return mac;
 }
 
[FUNC] **new** commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -31,15 +31,10 @@
 static OSSL_PROVIDER *provider_new(const char *name,
-                                   OSSL_provider_init_fn *init_function);
+                                   OSSL_provider_init_fn *init_function,
+                                   STACK_OF(INFOPAIR) *parameters);
 
 /*-
  * Provider Object structure
  * =========================
  */
 
-typedef struct {
-    char *name;
-    char *value;
-} INFOPAIR;
-DEFINE_STACK_OF(INFOPAIR)
-
 #ifndef FIPS_MODULE

[FUNC] **new** commit c1fb5e072fdeffc5b686e265283f0b31b1c37c3b
Date:   Fri May 7 11:03:59 2021 +0100

    Exclude child provider code from the FIPS module
    
    We don't need the child provider code in the FIPS module so we exclude
    it.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -31,14 +31,15 @@
 static OSSL_PROVIDER *provider_new(const char *name,
                                    OSSL_provider_init_fn *init_function);
 
 /*-
  * Provider Object structure
  * =========================
  */
 
 typedef struct {
     char *name;
     char *value;
 } INFOPAIR;
 DEFINE_STACK_OF(INFOPAIR)
 
+#ifndef FIPS_MODULE
[CORR] **new** commit dc6d9ede6241e6858f8fa78435d6c8eb9cf85aa1
Date:   Mon Nov 8 16:47:38 2021 +0000

    Don't try and do ossl_provider_find in ossl_provider_new
    
    We leave it to the caller to confirm that the provider does not exist
    in the store. If it does exist then later adding it to the store will
    fail.
    
    It is possible that the provider could be added to the store in
    between the caller checking, and the caller calling ossl_provider_new.
    We leave it to the caller to properly handle the failure when it
    attempts to add the provider to the store. This is simpler than
    having ossl_provider_new try to handle it.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16980)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -508,66 +513,58 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     OSSL_PROVIDER_INFO template;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
-    if ((prov = ossl_provider_find(libctx, name,
-                                   noconfig)) != NULL) { /* refcount +1 */
-        ossl_provider_free(prov); /* refcount -1 */
-        ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
-                       "name=%s", name);
-        return NULL;
-    }
-
     memset(&template, 0, sizeof(template));
     if (init_function == NULL) {
         const OSSL_PROVIDER_INFO *p;
         size_t i;
 
         /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
                 template = *p;
                 break;
             }
         }
         if (p->name == NULL) {
             /* Check if this is a user added builtin provider */
             if (!CRYPTO_THREAD_read_lock(store->lock))
                 return NULL;
             for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
                 if (strcmp(p->name, name) == 0) {
                     template = *p;
                     break;
                 }
             }
             CRYPTO_THREAD_unlock(store->lock);
         }
     } else {
         template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, template.init, template.parameters)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called and it must
      * then be added to the provider store.
      */
 
     return prov;
 }
 
 /* Assumes that the store lock is held */

[FUNC] **new** commit b7248964a40d272bb2edc7d2f94b9ce35c804cff
Date:   Mon Jun 21 15:59:41 2021 +0100

    make struct provider_info_st a full type
    
    Create the OSSL_PROVIDER_INFO to replace struct provider_info_st.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -449,66 +449,66 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
-    struct provider_info_st template;
+    OSSL_PROVIDER_INFO template;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
     memset(&template, 0, sizeof(template));
     if (init_function == NULL) {
-        const struct provider_info_st *p;
+        const OSSL_PROVIDER_INFO *p;
         size_t i;
 
         /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
                 template = *p;
                 break;
             }
         }
         if (p->name == NULL) {
             /* Check if this is a user added builtin provider */
             if (!CRYPTO_THREAD_read_lock(store->lock))
                 return NULL;
             for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
                 if (strcmp(p->name, name) == 0) {
                     template = *p;
                     break;
                 }
             }
             CRYPTO_THREAD_unlock(store->lock);
         }
     } else {
         template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, template.init, template.parameters)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called and it must
      * then be added to the provider store.
      */
 
     return prov;
 }
 
 /* Assumes that the store lock is held */

[CORR] **new** commit f109e96559097b882ad772b6b6396abfb1818cfe
Date:   Mon Jun 21 12:49:59 2021 +0100

    Don't hold any locks while calling the provider init function
    
    Previously providers were added to the store first, and then subsequently
    initialised. This meant that during initialisation the provider object
    could be shared between multiple threads and hence the locks needed to be
    held. However this causes problems because the provider init function is
    essentially a user callback and could do virtually anything. There are
    many API calls that could be invoked that could subsequently attempt to
    acquire the locks. This will fail because the locks are already held.
    
    However, now we have refactored things so that the provider is created and
    initialised before being added to the store. Therefore at the point of
    initialisation the provider object is not shared with other threads and so
    no locks need to be held.
    
    Fixes #15793
    Fixes #15712
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -449,65 +449,66 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     struct provider_info_st template;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
     memset(&template, 0, sizeof(template));
     if (init_function == NULL) {
         const struct provider_info_st *p;
         size_t i;
 
         /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
                 template = *p;
                 break;
             }
         }
         if (p->name == NULL) {
             /* Check if this is a user added builtin provider */
             if (!CRYPTO_THREAD_read_lock(store->lock))
                 return NULL;
             for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
                 if (strcmp(p->name, name) == 0) {
                     template = *p;
                     break;
                 }
             }
             CRYPTO_THREAD_unlock(store->lock);
         }
     } else {
         template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, template.init, template.parameters)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called and it must
      * then be added to the provider store.
      */
 
     return prov;
 }
 
+/* Assumes that the store lock is held */

[FUNC] **new** commit b91687c567abdd37cc1920be543eb1961a7351b4
Date:   Mon Jun 21 12:13:31 2021 +0100

    Only associate a provider with a store once it has been added to it
    
    This means we can distinguish providers that have been added to the
    store, and those which haven't yet been.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -449,66 +449,65 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     struct provider_info_st template;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
     memset(&template, 0, sizeof(template));
     if (init_function == NULL) {
         const struct provider_info_st *p;
         size_t i;
 
         /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
                 template = *p;
                 break;
             }
         }
         if (p->name == NULL) {
             /* Check if this is a user added builtin provider */
             if (!CRYPTO_THREAD_read_lock(store->lock))
                 return NULL;
             for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
                 if (strcmp(p->name, name) == 0) {
                     template = *p;
                     break;
                 }
             }
             CRYPTO_THREAD_unlock(store->lock);
         }
     } else {
         template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, template.init, template.parameters)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
-    prov->store = store;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called and it must
      * then be added to the provider store.
      */
 
     return prov;
 }
 

[FUNC] **new** commit 29aff653150c363be2d84f789a10b46d99d5cab9
Date:   Mon Jun 21 09:23:30 2021 +0100

    Add a new provider to the store only after we activate it
    
    Rather than creating the provider, adding to the store and then activating
    it, we do things the other way around, i.e. activate first and then add to
    the store. This means that the activation should occur before other threads
    are aware of the provider.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -455,80 +455,66 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     struct provider_info_st template;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
     memset(&template, 0, sizeof(template));
     if (init_function == NULL) {
         const struct provider_info_st *p;
         size_t i;
 
         /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
                 template = *p;
                 break;
             }
         }
         if (p->name == NULL) {
             /* Check if this is a user added builtin provider */
             if (!CRYPTO_THREAD_read_lock(store->lock))
                 return NULL;
             for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
                 if (strcmp(p->name, name) == 0) {
                     template = *p;
                     break;
                 }
             }
             CRYPTO_THREAD_unlock(store->lock);
         }
     } else {
         template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, template.init, template.parameters)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
     prov->store = store;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
-    if (!CRYPTO_THREAD_write_lock(store->lock))
-        return NULL;
-    if (!ossl_provider_up_ref(prov)) { /* +1 One reference for the store */
-        ossl_provider_free(prov); /* -1 Reference that was to be returned */
-        prov = NULL;
-    } else if (sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
-        ossl_provider_free(prov); /* -1 Store reference */
-        ossl_provider_free(prov); /* -1 Reference that was to be returned */
-        prov = NULL;
-    }
-    CRYPTO_THREAD_unlock(store->lock);
-
-    if (prov == NULL)
-        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
-
     /*
      * At this point, the provider is only partially "loaded".  To be
-     * fully "loaded", ossl_provider_activate() must also be called.
+     * fully "loaded", ossl_provider_activate() must also be called and it must
+     * then be added to the provider store.
      */
 
     return prov;
 }
 

commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -401,78 +455,80 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
+    struct provider_info_st template;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
+    memset(&template, 0, sizeof(template));
     if (init_function == NULL) {
         const struct provider_info_st *p;
         size_t i;
 
         /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
-                init_function = p->init;
+                template = *p;
                 break;
             }
         }
         if (p->name == NULL) {
             /* Check if this is a user added builtin provider */
             if (!CRYPTO_THREAD_read_lock(store->lock))
                 return NULL;
             for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
                 if (strcmp(p->name, name) == 0) {
-                    init_function = p->init;
+                    template = *p;
                     break;
                 }
             }
             CRYPTO_THREAD_unlock(store->lock);
         }
     } else {
         template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
-    if ((prov = provider_new(name, init_function)) == NULL)
+    if ((prov = provider_new(name, template.init, template.parameters)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
     prov->store = store;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
     if (!CRYPTO_THREAD_write_lock(store->lock))
         return NULL;
     if (!ossl_provider_up_ref(prov)) { /* +1 One reference for the store */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     } else if (sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
         ossl_provider_free(prov); /* -1 Store reference */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     }
     CRYPTO_THREAD_unlock(store->lock);
 
     if (prov == NULL)
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called.
      */
 
     return prov;
 }
 

[FUNC] **new** commit 1d74203cf5d8542d349fbb2d5f35ad40994dec9f
Date:   Fri Jun 18 12:28:40 2021 +0100

    Instantiate user-added builtin providers when we need them
    
    Previously we created the provider object for builtin providers at the
    point that OPENSSL_add_builtin() was called. Instead we delay that until
    the provider is actually loaded.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -338,63 +401,78 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
     if (init_function == NULL) {
-        const struct predefined_providers_st *p;
+        const struct provider_info_st *p;
+        size_t i;
 
-        /* Check if this is a built-in provider */
+        /* Check if this is a predefined builtin provider */
         for (p = ossl_predefined_providers; p->name != NULL; p++) {
             if (strcmp(p->name, name) == 0) {
                 init_function = p->init;
                 break;
             }
         }
+        if (p->name == NULL) {
+            /* Check if this is a user added builtin provider */
+            if (!CRYPTO_THREAD_read_lock(store->lock))
+                return NULL;
+            for (i = 0, p = store->provinfo; i < store->numprovinfo; p++, i++) {
+                if (strcmp(p->name, name) == 0) {
+                    init_function = p->init;
+                    break;
+                }
+            }
+            CRYPTO_THREAD_unlock(store->lock);
+        }
+    } else {
+        template.init = init_function;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, init_function)) == NULL)
         return NULL;
 
     prov->libctx = libctx;
     prov->store = store;
 #ifndef FIPS_MODULE
     prov->error_lib = ERR_get_next_error_library();
 #endif
 
     if (!CRYPTO_THREAD_write_lock(store->lock))
         return NULL;
     if (!ossl_provider_up_ref(prov)) { /* +1 One reference for the store */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     } else if (sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
         ossl_provider_free(prov); /* -1 Store reference */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     }
     CRYPTO_THREAD_unlock(store->lock);
 
     if (prov == NULL)
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called.
      */
 
     return prov;
 }
 

[FUNC] **new** commit 8d4dec0d4b3055b4c2e7ece5ac99b67b3e77995e
Date:   Fri Jun 18 10:08:23 2021 +0100

    Instantiate predefined providers just-in-time
    
    Previously we instantiated all the predefined providers at the point that
    we create the provider store. Instead we move them to be instantiated as we
    need them.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -364,51 +338,63 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
+    if (init_function == NULL) {
+        const struct predefined_providers_st *p;
+
+        /* Check if this is a built-in provider */
+        for (p = ossl_predefined_providers; p->name != NULL; p++) {
+            if (strcmp(p->name, name) == 0) {
+                init_function = p->init;
+                break;
+            }
+        }
+    }
+
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, init_function)) == NULL)
         return NULL;
 
+    prov->libctx = libctx;
+    prov->store = store;
+#ifndef FIPS_MODULE
+    prov->error_lib = ERR_get_next_error_library();
+#endif
+
     if (!CRYPTO_THREAD_write_lock(store->lock))
         return NULL;
     if (!ossl_provider_up_ref(prov)) { /* +1 One reference for the store */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     } else if (sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
         ossl_provider_free(prov); /* -1 Store reference */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
-    } else {
-        prov->libctx = libctx;
-        prov->store = store;
-#ifndef FIPS_MODULE
-        prov->error_lib = ERR_get_next_error_library();
-#endif
     }
     CRYPTO_THREAD_unlock(store->lock);
 
     if (prov == NULL)
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called.
      */
 
     return prov;
 }
 

[CORR] **new** commit cd3f8c1b11b0b9f4163bc8c62cbae38aec1b4030
Date:   Thu Feb 18 15:31:56 2021 -0500

    Always check CRYPTO_LOCK_{read,write}_lock
    
    Some functions that lock things are void, so we just return early.
    
    Also make ossl_namemap_empty return 0 on error.  Updated the docs, and added
    some code to ossl_namemap_stored() to handle the failure, and updated the
    tests to allow for failure.
    
    Fixes: #14230
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14238)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -284,50 +286,51 @@
 OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
                                  OSSL_provider_init_fn *init_function,
                                  int noconfig)
 {
     struct provider_store_st *store = NULL;
     OSSL_PROVIDER *prov = NULL;
 
     if ((store = get_provider_store(libctx)) == NULL)
         return NULL;
 
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
         ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        "name=%s", name);
         return NULL;
     }
 
     /* provider_new() generates an error, so no need here */
     if ((prov = provider_new(name, init_function)) == NULL)
         return NULL;
 
-    CRYPTO_THREAD_write_lock(store->lock);
+    if (!CRYPTO_THREAD_write_lock(store->lock))
+        return NULL;
     if (!ossl_provider_up_ref(prov)) { /* +1 One reference for the store */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     } else if (sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
         ossl_provider_free(prov); /* -1 Store reference */
         ossl_provider_free(prov); /* -1 Reference that was to be returned */
         prov = NULL;
     } else {
         prov->libctx = libctx;
         prov->store = store;
 #ifndef FIPS_MODULE
         prov->error_lib = ERR_get_next_error_library();
 #endif
     }
     CRYPTO_THREAD_unlock(store->lock);
 
     if (prov == NULL)
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
 
     /*
      * At this point, the provider is only partially "loaded".  To be
      * fully "loaded", ossl_provider_activate() must also be called.
      */
 
     return prov;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -744,22 +742,28 @@
 static int infopair_add(STACK_OF(INFOPAIR) **infopairsk, const char *name,
                         const char *value)
 {
     INFOPAIR *pair = NULL;
 
-    if ((pair = OPENSSL_zalloc(sizeof(*pair))) != NULL
-        && (*infopairsk != NULL
-            || (*infopairsk = sk_INFOPAIR_new_null()) != NULL)
-        && (pair->name = OPENSSL_strdup(name)) != NULL
-        && (pair->value = OPENSSL_strdup(value)) != NULL
-        && sk_INFOPAIR_push(*infopairsk, pair) > 0)
-        return 1;
+    if ((pair = OPENSSL_zalloc(sizeof(*pair))) == NULL
+        || (pair->name = OPENSSL_strdup(name)) == NULL
+        || (pair->value = OPENSSL_strdup(value)) == NULL)
+        goto err;
+
+    if ((*infopairsk == NULL
+         && (*infopairsk = sk_INFOPAIR_new_null()) == NULL)
+        || sk_INFOPAIR_push(*infopairsk, pair) <= 0) {
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_CRYPTO_LIB);
+        goto err;
+    }
+
+    return 1;
 
+ err:
     if (pair != NULL) {
         OPENSSL_free(pair->name);
         OPENSSL_free(pair->value);
         OPENSSL_free(pair);
     }
-    ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 

commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -559,22 +608,22 @@
-int ossl_provider_add_parameter(OSSL_PROVIDER *prov,
-                                const char *name, const char *value)
+static int infopair_add(STACK_OF(INFOPAIR) **infopairsk, const char *name,
+                        const char *value)
 {
     INFOPAIR *pair = NULL;
 
     if ((pair = OPENSSL_zalloc(sizeof(*pair))) != NULL
-        && (prov->parameters != NULL
-            || (prov->parameters = sk_INFOPAIR_new_null()) != NULL)
+        && (*infopairsk != NULL
+            || (*infopairsk = sk_INFOPAIR_new_null()) != NULL)
         && (pair->name = OPENSSL_strdup(name)) != NULL
         && (pair->value = OPENSSL_strdup(value)) != NULL
-        && sk_INFOPAIR_push(prov->parameters, pair) > 0)
+        && sk_INFOPAIR_push(*infopairsk, pair) > 0)
         return 1;
 
     if (pair != NULL) {
         OPENSSL_free(pair->name);
         OPENSSL_free(pair->value);
         OPENSSL_free(pair);
     }
     ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -169,0 +171,23 @@
+static INFOPAIR *infopair_copy(const INFOPAIR *src)
+{
+    INFOPAIR *dest = OPENSSL_zalloc(sizeof(*dest));
+
+    if (dest == NULL)
+        return NULL;
+    if (src->name != NULL) {
+        dest->name = OPENSSL_strdup(src->name);
+        if (dest->name == NULL)
+            goto err;
+    }
+    if (src->value != NULL) {
+        dest->value = OPENSSL_strdup(src->value);
+        if (dest->value == NULL)
+            goto err;
+    }
+    return dest;
+ err:
+    OPENSSL_free(dest->name);
+    OPENSSL_free(dest);
+    return NULL;
+}
+
commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -581,0 +630,6 @@
+int ossl_provider_add_parameter(OSSL_PROVIDER *prov,
+                                const char *name, const char *value)
+{
+    return infopair_add(&prov->parameters, name, value);
+}
+
commit b7248964a40d272bb2edc7d2f94b9ce35c804cff
Date:   Mon Jun 21 15:59:41 2021 +0100

    make struct provider_info_st a full type
    
    Create the OSSL_PROVIDER_INFO to replace struct provider_info_st.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -667,19 +667,19 @@
-int ossl_provider_info_add_parameter(struct provider_info_st *provinfo,
+int ossl_provider_info_add_parameter(OSSL_PROVIDER_INFO *provinfo,
                                      const char *name,
                                      const char *value)
 {
     return infopair_add(&provinfo->parameters, name, value);
 }
 
 /*
  * Provider activation.
  *
  * What "activation" means depends on the provider form; for built in
  * providers (in the library or the application alike), the provider
  * can already be considered to be loaded, all that's needed is to
  * initialize it.  However, for dynamically loadable provider modules,
  * we must first load that module.
  *
  * Built in modules are distinguished from dynamically loaded modules
  * with an already assigned init function.
  */

commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -581,12 +636,19 @@
+int ossl_provider_info_add_parameter(struct provider_info_st *provinfo,
+                                     const char *name,
+                                     const char *value)
+{
+    return infopair_add(&provinfo->parameters, name, value);
+}
+
 /*
  * Provider activation.
  *
  * What "activation" means depends on the provider form; for built in
  * providers (in the library or the application alike), the provider
  * can already be considered to be loaded, all that's needed is to
  * initialize it.  However, for dynamically loadable provider modules,
  * we must first load that module.
  *
  * Built in modules are distinguished from dynamically loaded modules
  * with an already assigned init function.
  */
[PERF] **new** commit 927d0566ded0dff9d6c5abc8a40bb84068446b76
Date:   Mon Mar 14 08:13:12 2022 +0000

    Refactor OSSL_LIB_CTX to avoid using CRYPTO_EX_DATA
    
    This refactors OSSL_LIB_CTX to avoid using CRYPTO_EX_DATA. The assorted
    objects to be managed by OSSL_LIB_CTX are hardcoded and are initialized
    eagerly rather than lazily, which avoids the need for locking on access
    in most cases.
    
    Fixes #17116.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17881)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -302,20 +303,20 @@
-static void *provider_store_new(OSSL_LIB_CTX *ctx)
+void *ossl_provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
         || (store->default_path_lock = CRYPTO_THREAD_lock_new()) == NULL
 #ifndef FIPS_MODULE
         || (store->child_cbs = sk_OSSL_PROVIDER_CHILD_CB_new_null()) == NULL
 #endif
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
-        provider_store_free(store);
+        ossl_provider_store_free(store);
         return NULL;
     }
     store->libctx = ctx;
     store->use_fallbacks = 1;
 
     return store;
 }
 

commit 8d4dec0d4b3055b4c2e7ece5ac99b67b3e77995e
Date:   Fri Jun 18 10:08:23 2021 +0100

    Instantiate predefined providers just-in-time
    
    Previously we instantiated all the predefined providers at the point that
    we create the provider store. Instead we move them to be instantiated as we
    need them.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -184,46 +184,20 @@
 static void *provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
-    const struct predefined_providers_st *p = NULL;
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
         || (store->default_path_lock = CRYPTO_THREAD_lock_new()) == NULL
 #ifndef FIPS_MODULE
         || (store->child_cbs = sk_OSSL_PROVIDER_CHILD_CB_new_null()) == NULL
 #endif
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         provider_store_free(store);
         return NULL;
     }
     store->libctx = ctx;
     store->use_fallbacks = 1;
 
-    for (p = ossl_predefined_providers; p->name != NULL; p++) {
-        OSSL_PROVIDER *prov = NULL;
-
-        /*
-         * We use the internal constructor directly here,
-         * otherwise we get a call loop
-         */
-        prov = provider_new(p->name, p->init);
-
-        if (prov == NULL
-            || sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
-            ossl_provider_free(prov);
-            provider_store_free(store);
-            ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
-            return NULL;
-        }
-        prov->libctx = ctx;
-        prov->store = store;
-#ifndef FIPS_MODULE
-        prov->error_lib = ERR_get_next_error_library();
-#endif
-        if(p->is_fallback)
-            ossl_provider_set_fallback(prov);
-    }
-
     return store;
 }
 

commit c1fb5e072fdeffc5b686e265283f0b31b1c37c3b
Date:   Fri May 7 11:03:59 2021 +0100

    Exclude child provider code from the FIPS module
    
    We don't need the child provider code in the FIPS module so we exclude
    it.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -173,44 +183,46 @@
 static void *provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
     const struct predefined_providers_st *p = NULL;
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
         || (store->default_path_lock = CRYPTO_THREAD_lock_new()) == NULL
+#ifndef FIPS_MODULE
         || (store->child_cbs = sk_OSSL_PROVIDER_CHILD_CB_new_null()) == NULL
+#endif
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         provider_store_free(store);
         return NULL;
     }
     store->libctx = ctx;
     store->use_fallbacks = 1;
 
     for (p = ossl_predefined_providers; p->name != NULL; p++) {
         OSSL_PROVIDER *prov = NULL;
 
         /*
          * We use the internal constructor directly here,
          * otherwise we get a call loop
          */
         prov = provider_new(p->name, p->init);
 
         if (prov == NULL
             || sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
             ossl_provider_free(prov);
             provider_store_free(store);
             ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         prov->libctx = ctx;
         prov->store = store;
 #ifndef FIPS_MODULE
         prov->error_lib = ERR_get_next_error_library();
 #endif
         if(p->is_fallback)
             ossl_provider_set_fallback(prov);
     }
 
     return store;
 }
 

[FUNC] **new** commit 8c627075656cf2709680eeb5aa1826f00db2e483
Date:   Thu Apr 29 16:37:42 2021 +0100

    Add support for child provider to up_ref/free their parent
    
    If the ref counts on a child provider change, then this needs to be
    reflected in the parent so we add callbacks to do this.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -170,43 +172,44 @@
 static void *provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
     const struct predefined_providers_st *p = NULL;
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
         || (store->default_path_lock = CRYPTO_THREAD_lock_new()) == NULL
         || (store->child_cbs = sk_OSSL_PROVIDER_CHILD_CB_new_null()) == NULL
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         provider_store_free(store);
         return NULL;
     }
+    store->libctx = ctx;
     store->use_fallbacks = 1;
 
     for (p = ossl_predefined_providers; p->name != NULL; p++) {
         OSSL_PROVIDER *prov = NULL;
 
         /*
          * We use the internal constructor directly here,
          * otherwise we get a call loop
          */
         prov = provider_new(p->name, p->init);
 
         if (prov == NULL
             || sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
             ossl_provider_free(prov);
             provider_store_free(store);
             ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         prov->libctx = ctx;
         prov->store = store;
 #ifndef FIPS_MODULE
         prov->error_lib = ERR_get_next_error_library();
 #endif
         if(p->is_fallback)
             ossl_provider_set_fallback(prov);
     }
 
     return store;
 }
 

[FUNC] **new** commit 7b88c184b66c0d7cfb1f76422448af6a636eea8c
Date:   Fri Apr 23 12:08:27 2021 +0100

    Register callbacks with core for child provider creation/deletion
    
    By adding callbacks to the core this will enable (in future commits) the
    ability to add/remove child providers as the providers are added/removed
    from the parent libctx.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -154,42 +170,43 @@
 static void *provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
     const struct predefined_providers_st *p = NULL;
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
         || (store->default_path_lock = CRYPTO_THREAD_lock_new()) == NULL
+        || (store->child_cbs = sk_OSSL_PROVIDER_CHILD_CB_new_null()) == NULL
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         provider_store_free(store);
         return NULL;
     }
     store->use_fallbacks = 1;
 
     for (p = ossl_predefined_providers; p->name != NULL; p++) {
         OSSL_PROVIDER *prov = NULL;
 
         /*
          * We use the internal constructor directly here,
          * otherwise we get a call loop
          */
         prov = provider_new(p->name, p->init);
 
         if (prov == NULL
             || sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
             ossl_provider_free(prov);
             provider_store_free(store);
             ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         prov->libctx = ctx;
         prov->store = store;
 #ifndef FIPS_MODULE
         prov->error_lib = ERR_get_next_error_library();
 #endif
         if(p->is_fallback)
             ossl_provider_set_fallback(prov);
     }
 
     return store;
 }
 

[CORR] **new** commit 86522324d2a398ad3ed2f648a66b62b0a6176258
Date:   Mon Mar 22 23:44:22 2021 +0100

    Adds a new lock to read default_path and uses a strdup() on default_path before using it
    Fixes #14483
    Signed-off-by: Sahana Prasad <sahana@redhat.com>
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14650)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -147,41 +149,42 @@
 static void *provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
     const struct predefined_providers_st *p = NULL;
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
+        || (store->default_path_lock = CRYPTO_THREAD_lock_new()) == NULL
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         provider_store_free(store);
         return NULL;
     }
     store->use_fallbacks = 1;
 
     for (p = ossl_predefined_providers; p->name != NULL; p++) {
         OSSL_PROVIDER *prov = NULL;
 
         /*
          * We use the internal constructor directly here,
          * otherwise we get a call loop
          */
         prov = provider_new(p->name, p->init);
 
         if (prov == NULL
             || sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
             ossl_provider_free(prov);
             provider_store_free(store);
             ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         prov->libctx = ctx;
         prov->store = store;
 #ifndef FIPS_MODULE
         prov->error_lib = ERR_get_next_error_library();
 #endif
         if(p->is_fallback)
             ossl_provider_set_fallback(prov);
     }
 
     return store;
 }
 

[INCR] **new** commit c8830891e6cb8d0782986662ca50b8fa7c97f49f
Date:   Tue Mar 9 15:26:17 2021 +1000

    Add ossl_provider symbols
    
    Partial fix for #12964
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14473)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -147,41 +147,41 @@
 static void *provider_store_new(OSSL_LIB_CTX *ctx)
 {
     struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
     const struct predefined_providers_st *p = NULL;
 
     if (store == NULL
         || (store->providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
         || (store->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         provider_store_free(store);
         return NULL;
     }
     store->use_fallbacks = 1;
 
-    for (p = predefined_providers; p->name != NULL; p++) {
+    for (p = ossl_predefined_providers; p->name != NULL; p++) {
         OSSL_PROVIDER *prov = NULL;
 
         /*
          * We use the internal constructor directly here,
          * otherwise we get a call loop
          */
         prov = provider_new(p->name, p->init);
 
         if (prov == NULL
             || sk_OSSL_PROVIDER_push(store->providers, prov) == 0) {
             ossl_provider_free(prov);
             provider_store_free(store);
             ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         prov->libctx = ctx;
         prov->store = store;
 #ifndef FIPS_MODULE
         prov->error_lib = ERR_get_next_error_library();
 #endif
         if(p->is_fallback)
             ossl_provider_set_fallback(prov);
     }
 
     return store;
 }
 
commit 4e62f1a3af36512a1f5e1273d2dc54e3ce7f5fca
Date:   Fri Jan 7 11:46:33 2022 +1100

    Add context dup functions for digests and ciphers
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17529)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -508,0 +508,11 @@
+EVP_MD_CTX *EVP_MD_CTX_dup(const EVP_MD_CTX *in)
+{
+    EVP_MD_CTX *out = EVP_MD_CTX_new();
+
+    if (out != NULL && !EVP_MD_CTX_copy_ex(out, in)) {
+        EVP_MD_CTX_free(out);
+        out = NULL;
+    }
+    return out;
+}
+
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -105,25 +105,25 @@
 EVP_MD_CTX *evp_md_ctx_new_ex(EVP_PKEY *pkey, const ASN1_OCTET_STRING *id,
                               OSSL_LIB_CTX *libctx, const char *propq)
 {
     EVP_MD_CTX *ctx;
     EVP_PKEY_CTX *pctx = NULL;
 
     if ((ctx = EVP_MD_CTX_new()) == NULL
         || (pctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq)) == NULL) {
-        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
 
     if (id != NULL && EVP_PKEY_CTX_set1_id(pctx, id->data, id->length) <= 0)
         goto err;
 
     EVP_MD_CTX_set_pkey_ctx(ctx, pctx);
     return ctx;
 
  err:
     EVP_PKEY_CTX_free(pctx);
     EVP_MD_CTX_free(ctx);
     return NULL;
 }
 #endif
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -957,125 +953,125 @@
 static void *evp_md_from_algorithm(int name_id,
                                    const OSSL_ALGORITHM *algodef,
                                    OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
     if ((md->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
         EVP_MD_free(md);
         return NULL;
     }
     md->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -884,121 +885,125 @@
 static void *evp_md_from_algorithm(int name_id,
                                    const OSSL_ALGORITHM *algodef,
                                    OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
+    if ((md->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
+        EVP_MD_free(md);
+        return NULL;
+    }
     md->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

commit 309a78aa305ee14878e453c78ccf9a7dc91264cf
Date:   Tue Mar 16 14:14:43 2021 +0100

    CORE: Add an algorithm_description field to OSSL_ALGORITHM
    
    This corresponds to the |info| field in EVP_PKEY_ASN1_METHOD, as well
    as the generic use of OBJ_nid2ln() as a one line description.
    
    We also add the base functionality to make use of this field.
    
    Fixes #14514
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14656)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -886,119 +886,121 @@
-static void *evp_md_from_dispatch(int name_id,
-                                  const OSSL_DISPATCH *fns,
-                                  OSSL_PROVIDER *prov)
+static void *evp_md_from_algorithm(int name_id,
+                                   const OSSL_ALGORITHM *algodef,
+                                   OSSL_PROVIDER *prov)
 {
+    const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
+    md->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

commit 1f79baa55ee00c64372397292ab9c88b5c373d93
Date:   Tue Mar 16 10:06:29 2021 +1000

    Remove TODOs from digest.c
    
    They aren't relevant:
    . Digest Sign isn't supported in the FIPS provider.
    . Remove legacy NID use.
    
    Fixes #14394
    Fixes #14395
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14565)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -890,120 +881,119 @@
 static void *evp_md_from_dispatch(int name_id,
                                   const OSSL_DISPATCH *fns,
                                   OSSL_PROVIDER *prov)
 {
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
-    /* TODO(3.x) get rid of the need for legacy NIDs */
     md->type = NID_undef;
     if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
             || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 

commit d84f5515faf3fe00ed5eeca7e7b8b041be863e90
Date:   Fri Feb 19 17:03:43 2021 +0000

    Don't hold a lock when calling a callback in ossl_namemap_doall_names
    
    We don't want to hold a read lock when calling a user supplied callback.
    That callback could do anything so the risk of a deadlock is high.
    Instead we collect all the names first inside the read lock, and then
    subsequently call the user callback outside the read lock.
    
    Fixes #14225
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14250)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -868,120 +868,120 @@
 static void *evp_md_from_dispatch(int name_id,
                                   const OSSL_DISPATCH *fns,
                                   OSSL_PROVIDER *prov)
 {
     EVP_MD *md = NULL;
     int fncnt = 0;
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
 #ifndef FIPS_MODULE
     /* TODO(3.x) get rid of the need for legacy NIDs */
     md->type = NID_undef;
-    evp_names_do_all(prov, name_id, set_legacy_nid, &md->type);
-    if (md->type == -1) {
+    if (!evp_names_do_all(prov, name_id, set_legacy_nid, &md->type)
+            || md->type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
         return NULL;
     }
 #endif
 
     md->name_id = name_id;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_DIGEST_NEWCTX:
             if (md->newctx == NULL) {
                 md->newctx = OSSL_FUNC_digest_newctx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_INIT:
             if (md->dinit == NULL) {
                 md->dinit = OSSL_FUNC_digest_init(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_UPDATE:
             if (md->dupdate == NULL) {
                 md->dupdate = OSSL_FUNC_digest_update(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_FINAL:
             if (md->dfinal == NULL) {
                 md->dfinal = OSSL_FUNC_digest_final(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DIGEST:
             if (md->digest == NULL)
                 md->digest = OSSL_FUNC_digest_digest(fns);
             /* We don't increment fnct for this as it is stand alone */
             break;
         case OSSL_FUNC_DIGEST_FREECTX:
             if (md->freectx == NULL) {
                 md->freectx = OSSL_FUNC_digest_freectx(fns);
                 fncnt++;
             }
             break;
         case OSSL_FUNC_DIGEST_DUPCTX:
             if (md->dupctx == NULL)
                 md->dupctx = OSSL_FUNC_digest_dupctx(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_PARAMS:
             if (md->get_params == NULL)
                 md->get_params = OSSL_FUNC_digest_get_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SET_CTX_PARAMS:
             if (md->set_ctx_params == NULL)
                 md->set_ctx_params = OSSL_FUNC_digest_set_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GET_CTX_PARAMS:
             if (md->get_ctx_params == NULL)
                 md->get_ctx_params = OSSL_FUNC_digest_get_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_PARAMS:
             if (md->gettable_params == NULL)
                 md->gettable_params = OSSL_FUNC_digest_gettable_params(fns);
             break;
         case OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS:
             if (md->settable_ctx_params == NULL)
                 md->settable_ctx_params =
                     OSSL_FUNC_digest_settable_ctx_params(fns);
             break;
         case OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS:
             if (md->gettable_ctx_params == NULL)
                 md->gettable_ctx_params =
                     OSSL_FUNC_digest_gettable_ctx_params(fns);
             break;
         }
     }
     if ((fncnt != 0 && fncnt != 5)
         || (fncnt == 0 && md->digest == NULL)) {
         /*
          * In order to be a consistent set of functions we either need the
          * whole set of init/update/final etc functions or none of them.
          * The "digest" function can standalone. We at least need one way to
          * generate digests.
          */
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     md->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     if (!evp_md_cache_constants(md)) {
         EVP_MD_free(md);
         ERR_raise(ERR_LIB_EVP, EVP_R_CACHE_CONSTANTS_FAILED);
         md = NULL;
     }
 
     return md;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -274,22 +274,20 @@
 static EVP_KEM *evp_kem_new(OSSL_PROVIDER *prov)
 {
     EVP_KEM *kem = OPENSSL_zalloc(sizeof(EVP_KEM));
 
-    if (kem == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+    if (kem == NULL)
         return NULL;
-    }
 
     kem->lock = CRYPTO_THREAD_lock_new();
     if (kem->lock == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_CRYPTO_LIB);
         OPENSSL_free(kem);
         return NULL;
     }
     kem->prov = prov;
     ossl_provider_up_ref(prov);
     kem->refcnt = 1;
 
     return kem;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -296,130 +294,130 @@
 static void *evp_kem_from_algorithm(int name_id, const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEM *kem = NULL;
     int ctxfncnt = 0, encfncnt = 0, decfncnt = 0;
     int gparamfncnt = 0, sparamfncnt = 0;
 
     if ((kem = evp_kem_new(prov)) == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);
         goto err;
     }
 
     kem->name_id = name_id;
     if ((kem->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL)
         goto err;
     kem->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEM_NEWCTX:
             if (kem->newctx != NULL)
                 break;
             kem->newctx = OSSL_FUNC_kem_newctx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE_INIT:
             if (kem->encapsulate_init != NULL)
                 break;
             kem->encapsulate_init = OSSL_FUNC_kem_encapsulate_init(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_AUTH_ENCAPSULATE_INIT:
             if (kem->auth_encapsulate_init != NULL)
                 break;
             kem->auth_encapsulate_init = OSSL_FUNC_kem_auth_encapsulate_init(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE:
             if (kem->encapsulate != NULL)
                 break;
             kem->encapsulate = OSSL_FUNC_kem_encapsulate(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE_INIT:
             if (kem->decapsulate_init != NULL)
                 break;
             kem->decapsulate_init = OSSL_FUNC_kem_decapsulate_init(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_AUTH_DECAPSULATE_INIT:
             if (kem->auth_decapsulate_init != NULL)
                 break;
             kem->auth_decapsulate_init = OSSL_FUNC_kem_auth_decapsulate_init(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE:
             if (kem->decapsulate != NULL)
                 break;
             kem->decapsulate = OSSL_FUNC_kem_decapsulate(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_FREECTX:
             if (kem->freectx != NULL)
                 break;
             kem->freectx = OSSL_FUNC_kem_freectx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_DUPCTX:
             if (kem->dupctx != NULL)
                 break;
             kem->dupctx = OSSL_FUNC_kem_dupctx(fns);
             break;
         case OSSL_FUNC_KEM_GET_CTX_PARAMS:
             if (kem->get_ctx_params != NULL)
                 break;
             kem->get_ctx_params
                 = OSSL_FUNC_kem_get_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS:
             if (kem->gettable_ctx_params != NULL)
                 break;
             kem->gettable_ctx_params
                 = OSSL_FUNC_kem_gettable_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SET_CTX_PARAMS:
             if (kem->set_ctx_params != NULL)
                 break;
             kem->set_ctx_params
                 = OSSL_FUNC_kem_set_ctx_params(fns);
             sparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS:
             if (kem->settable_ctx_params != NULL)
                 break;
             kem->settable_ctx_params
                 = OSSL_FUNC_kem_settable_ctx_params(fns);
             sparamfncnt++;
             break;
         }
     }
     if (ctxfncnt != 2
         || (encfncnt != 0 && encfncnt != 2 && encfncnt != 3)
         || (decfncnt != 0 && decfncnt != 2 && decfncnt != 3)
         || (encfncnt != decfncnt)
         || (gparamfncnt != 0 && gparamfncnt != 2)
         || (sparamfncnt != 0 && sparamfncnt != 2)) {
         /*
          * In order to be a consistent set of functions we must have at least
          * a set of context functions (newctx and freectx) as well as a pair
          * (or triplet) of "kem" functions:
          * (encapsulate_init, (and/or auth_encapsulate_init), encapsulate) or
          * (decapsulate_init, (and/or auth_decapsulate_init), decapsulate).
          * set_ctx_params and settable_ctx_params are optional, but if one of
          * them is present then the other one must also be present. The same
          * applies to get_ctx_params and gettable_ctx_params.
          * The dupctx function is optional.
          */
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         goto err;
     }
 
     return kem;
  err:
     EVP_KEM_free(kem);
     return NULL;
 }
 

[FUNC] **new** commit 78c44b05945be07eae86f0164b9b777e2de2295b
Date:   Fri Aug 26 11:54:35 2022 +1000

    Add HPKE DHKEM provider support for EC, X25519 and X448.
    
    The code is derived from @sftcd's work in PR #17172.
    This PR puts the DHKEM algorithms into the provider layer as
    KEM algorithms for EC and ECX.
    
    This PR only implements the DHKEM component of HPKE as specified in
    RFC 9180.
    
    crypto/hpke/hpke_util.c has been added for fuctions that will
    be shared between DHKEM and HPKE.
    
    API's for EVP_PKEY_auth_encapsulate_init() and EVP_PKEY_auth_decapsulate_init()
    have been added to support authenticated encapsulation. auth_init() functions
    were chosen rather that a EVP_PKEY_KEM_set_auth() interface to support
    future algorithms that could possibly need different init functions.
    
    Internal code has been refactored, so that it can be shared between the DHKEM
    and other systems. Since DHKEM operates on low level keys it needs to be
    able to do low level ECDH and ECXDH calls without converting the keys
    back into EVP_PKEY/EVP_PKEY_CTX form. See ossl_ecx_compute_key(),
    ossl_ec_public_from_private()
    
    DHKEM requires API's to derive a key using a seed (IKM). This did not sit
    well inside the DHKEM itself as dispatch functions. This functionality
    fits better inside the EC and ECX keymanagers keygen, since
    they are just variations of keygen where the private key is generated
    in a different manner. This should mainly be used for testing purposes.
    See ossl_ec_generate_key_dhkem().
    It supports this by allowing a settable param to be passed to keygen
    (See OSSL_PKEY_PARAM_DHKEM_IKM).
    The keygen calls code within ec and ecx dhkem implementation to handle this.
    See ossl_ecx_dhkem_derive_private() and ossl_ec_dhkem_derive_private().
    These 2 functions are also used by the EC/ECX DHKEM implementations to generate
    the sender ephemeral keys.
    
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19068)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -259,116 +296,130 @@
 static void *evp_kem_from_algorithm(int name_id, const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEM *kem = NULL;
     int ctxfncnt = 0, encfncnt = 0, decfncnt = 0;
     int gparamfncnt = 0, sparamfncnt = 0;
 
     if ((kem = evp_kem_new(prov)) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     kem->name_id = name_id;
     if ((kem->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL)
         goto err;
     kem->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEM_NEWCTX:
             if (kem->newctx != NULL)
                 break;
             kem->newctx = OSSL_FUNC_kem_newctx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE_INIT:
             if (kem->encapsulate_init != NULL)
                 break;
             kem->encapsulate_init = OSSL_FUNC_kem_encapsulate_init(fns);
             encfncnt++;
             break;
+        case OSSL_FUNC_KEM_AUTH_ENCAPSULATE_INIT:
+            if (kem->auth_encapsulate_init != NULL)
+                break;
+            kem->auth_encapsulate_init = OSSL_FUNC_kem_auth_encapsulate_init(fns);
+            encfncnt++;
+            break;
         case OSSL_FUNC_KEM_ENCAPSULATE:
             if (kem->encapsulate != NULL)
                 break;
             kem->encapsulate = OSSL_FUNC_kem_encapsulate(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE_INIT:
             if (kem->decapsulate_init != NULL)
                 break;
             kem->decapsulate_init = OSSL_FUNC_kem_decapsulate_init(fns);
             decfncnt++;
             break;
+        case OSSL_FUNC_KEM_AUTH_DECAPSULATE_INIT:
+            if (kem->auth_decapsulate_init != NULL)
+                break;
+            kem->auth_decapsulate_init = OSSL_FUNC_kem_auth_decapsulate_init(fns);
+            decfncnt++;
+            break;
         case OSSL_FUNC_KEM_DECAPSULATE:
             if (kem->decapsulate != NULL)
                 break;
             kem->decapsulate = OSSL_FUNC_kem_decapsulate(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_FREECTX:
             if (kem->freectx != NULL)
                 break;
             kem->freectx = OSSL_FUNC_kem_freectx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_DUPCTX:
             if (kem->dupctx != NULL)
                 break;
             kem->dupctx = OSSL_FUNC_kem_dupctx(fns);
             break;
         case OSSL_FUNC_KEM_GET_CTX_PARAMS:
             if (kem->get_ctx_params != NULL)
                 break;
             kem->get_ctx_params
                 = OSSL_FUNC_kem_get_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS:
             if (kem->gettable_ctx_params != NULL)
                 break;
             kem->gettable_ctx_params
                 = OSSL_FUNC_kem_gettable_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SET_CTX_PARAMS:
             if (kem->set_ctx_params != NULL)
                 break;
             kem->set_ctx_params
                 = OSSL_FUNC_kem_set_ctx_params(fns);
             sparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS:
             if (kem->settable_ctx_params != NULL)
                 break;
             kem->settable_ctx_params
                 = OSSL_FUNC_kem_settable_ctx_params(fns);
             sparamfncnt++;
             break;
         }
     }
     if (ctxfncnt != 2
-        || (encfncnt != 0 && encfncnt != 2)
-        || (decfncnt != 0 && decfncnt != 2)
-        || (encfncnt != 2 && decfncnt != 2)
+        || (encfncnt != 0 && encfncnt != 2 && encfncnt != 3)
+        || (decfncnt != 0 && decfncnt != 2 && decfncnt != 3)
+        || (encfncnt != decfncnt)
         || (gparamfncnt != 0 && gparamfncnt != 2)
         || (sparamfncnt != 0 && sparamfncnt != 2)) {
         /*
          * In order to be a consistent set of functions we must have at least
-         * a set of context functions (newctx and freectx) as well as a pair of
-         * "kem" functions: (encapsulate_init, encapsulate) or
-         * (decapsulate_init, decapsulate). set_ctx_params and settable_ctx_params are
-         * optional, but if one of them is present then the other one must also
-         * be present. The same applies to get_ctx_params and
-         * gettable_ctx_params. The dupctx function is optional.
+         * a set of context functions (newctx and freectx) as well as a pair
+         * (or triplet) of "kem" functions:
+         * (encapsulate_init, (and/or auth_encapsulate_init), encapsulate) or
+         * (decapsulate_init, (and/or auth_decapsulate_init), decapsulate).
+         * set_ctx_params and settable_ctx_params are optional, but if one of
+         * them is present then the other one must also be present. The same
+         * applies to get_ctx_params and gettable_ctx_params.
+         * The dupctx function is optional.
          */
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         goto err;
     }
 
     return kem;
  err:
     EVP_KEM_free(kem);
     return NULL;
 }
 

commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -186,114 +187,116 @@
 static void *evp_kem_from_algorithm(int name_id, const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEM *kem = NULL;
     int ctxfncnt = 0, encfncnt = 0, decfncnt = 0;
     int gparamfncnt = 0, sparamfncnt = 0;
 
     if ((kem = evp_kem_new(prov)) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     kem->name_id = name_id;
+    if ((kem->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL)
+        goto err;
     kem->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEM_NEWCTX:
             if (kem->newctx != NULL)
                 break;
             kem->newctx = OSSL_FUNC_kem_newctx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE_INIT:
             if (kem->encapsulate_init != NULL)
                 break;
             kem->encapsulate_init = OSSL_FUNC_kem_encapsulate_init(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE:
             if (kem->encapsulate != NULL)
                 break;
             kem->encapsulate = OSSL_FUNC_kem_encapsulate(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE_INIT:
             if (kem->decapsulate_init != NULL)
                 break;
             kem->decapsulate_init = OSSL_FUNC_kem_decapsulate_init(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE:
             if (kem->decapsulate != NULL)
                 break;
             kem->decapsulate = OSSL_FUNC_kem_decapsulate(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_FREECTX:
             if (kem->freectx != NULL)
                 break;
             kem->freectx = OSSL_FUNC_kem_freectx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_DUPCTX:
             if (kem->dupctx != NULL)
                 break;
             kem->dupctx = OSSL_FUNC_kem_dupctx(fns);
             break;
         case OSSL_FUNC_KEM_GET_CTX_PARAMS:
             if (kem->get_ctx_params != NULL)
                 break;
             kem->get_ctx_params
                 = OSSL_FUNC_kem_get_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS:
             if (kem->gettable_ctx_params != NULL)
                 break;
             kem->gettable_ctx_params
                 = OSSL_FUNC_kem_gettable_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SET_CTX_PARAMS:
             if (kem->set_ctx_params != NULL)
                 break;
             kem->set_ctx_params
                 = OSSL_FUNC_kem_set_ctx_params(fns);
             sparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS:
             if (kem->settable_ctx_params != NULL)
                 break;
             kem->settable_ctx_params
                 = OSSL_FUNC_kem_settable_ctx_params(fns);
             sparamfncnt++;
             break;
         }
     }
     if (ctxfncnt != 2
         || (encfncnt != 0 && encfncnt != 2)
         || (decfncnt != 0 && decfncnt != 2)
         || (encfncnt != 2 && decfncnt != 2)
         || (gparamfncnt != 0 && gparamfncnt != 2)
         || (sparamfncnt != 0 && sparamfncnt != 2)) {
         /*
          * In order to be a consistent set of functions we must have at least
          * a set of context functions (newctx and freectx) as well as a pair of
          * "kem" functions: (encapsulate_init, encapsulate) or
          * (decapsulate_init, decapsulate). set_ctx_params and settable_ctx_params are
          * optional, but if one of them is present then the other one must also
          * be present. The same applies to get_ctx_params and
          * gettable_ctx_params. The dupctx function is optional.
          */
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         goto err;
     }
 
     return kem;
  err:
     EVP_KEM_free(kem);
     return NULL;
 }
 

commit 309a78aa305ee14878e453c78ccf9a7dc91264cf
Date:   Tue Mar 16 14:14:43 2021 +0100

    CORE: Add an algorithm_description field to OSSL_ALGORITHM
    
    This corresponds to the |info| field in EVP_PKEY_ASN1_METHOD, as well
    as the generic use of OBJ_nid2ln() as a one line description.
    
    We also add the base functionality to make use of this field.
    
    Fixes #14514
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14656)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -186,112 +186,114 @@
-static void *evp_kem_from_dispatch(int name_id, const OSSL_DISPATCH *fns,
-                                   OSSL_PROVIDER *prov)
+static void *evp_kem_from_algorithm(int name_id, const OSSL_ALGORITHM *algodef,
+                                    OSSL_PROVIDER *prov)
 {
+    const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEM *kem = NULL;
     int ctxfncnt = 0, encfncnt = 0, decfncnt = 0;
     int gparamfncnt = 0, sparamfncnt = 0;
 
     if ((kem = evp_kem_new(prov)) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     kem->name_id = name_id;
+    kem->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEM_NEWCTX:
             if (kem->newctx != NULL)
                 break;
             kem->newctx = OSSL_FUNC_kem_newctx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE_INIT:
             if (kem->encapsulate_init != NULL)
                 break;
             kem->encapsulate_init = OSSL_FUNC_kem_encapsulate_init(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_ENCAPSULATE:
             if (kem->encapsulate != NULL)
                 break;
             kem->encapsulate = OSSL_FUNC_kem_encapsulate(fns);
             encfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE_INIT:
             if (kem->decapsulate_init != NULL)
                 break;
             kem->decapsulate_init = OSSL_FUNC_kem_decapsulate_init(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_DECAPSULATE:
             if (kem->decapsulate != NULL)
                 break;
             kem->decapsulate = OSSL_FUNC_kem_decapsulate(fns);
             decfncnt++;
             break;
         case OSSL_FUNC_KEM_FREECTX:
             if (kem->freectx != NULL)
                 break;
             kem->freectx = OSSL_FUNC_kem_freectx(fns);
             ctxfncnt++;
             break;
         case OSSL_FUNC_KEM_DUPCTX:
             if (kem->dupctx != NULL)
                 break;
             kem->dupctx = OSSL_FUNC_kem_dupctx(fns);
             break;
         case OSSL_FUNC_KEM_GET_CTX_PARAMS:
             if (kem->get_ctx_params != NULL)
                 break;
             kem->get_ctx_params
                 = OSSL_FUNC_kem_get_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS:
             if (kem->gettable_ctx_params != NULL)
                 break;
             kem->gettable_ctx_params
                 = OSSL_FUNC_kem_gettable_ctx_params(fns);
             gparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SET_CTX_PARAMS:
             if (kem->set_ctx_params != NULL)
                 break;
             kem->set_ctx_params
                 = OSSL_FUNC_kem_set_ctx_params(fns);
             sparamfncnt++;
             break;
         case OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS:
             if (kem->settable_ctx_params != NULL)
                 break;
             kem->settable_ctx_params
                 = OSSL_FUNC_kem_settable_ctx_params(fns);
             sparamfncnt++;
             break;
         }
     }
     if (ctxfncnt != 2
         || (encfncnt != 0 && encfncnt != 2)
         || (decfncnt != 0 && decfncnt != 2)
         || (encfncnt != 2 && decfncnt != 2)
         || (gparamfncnt != 0 && gparamfncnt != 2)
         || (sparamfncnt != 0 && sparamfncnt != 2)) {
         /*
          * In order to be a consistent set of functions we must have at least
          * a set of context functions (newctx and freectx) as well as a pair of
          * "kem" functions: (encapsulate_init, encapsulate) or
          * (decapsulate_init, decapsulate). set_ctx_params and settable_ctx_params are
          * optional, but if one of them is present then the other one must also
          * be present. The same applies to get_ctx_params and
          * gettable_ctx_params. The dupctx function is optional.
          */
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         goto err;
     }
 
     return kem;
  err:
     EVP_KEM_free(kem);
     return NULL;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -20,16 +20,17 @@
 static void *keymgmt_new(void)
 {
     EVP_KEYMGMT *keymgmt = NULL;
 
-    if ((keymgmt = OPENSSL_zalloc(sizeof(*keymgmt))) == NULL
-        || (keymgmt->lock = CRYPTO_THREAD_lock_new()) == NULL) {
+    if ((keymgmt = OPENSSL_zalloc(sizeof(*keymgmt))) == NULL)
+        return NULL;
+    if ((keymgmt->lock = CRYPTO_THREAD_lock_new()) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_CRYPTO_LIB);
         return NULL;
     }
 
     keymgmt->refcnt = 1;
 
     return keymgmt;
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -35,167 +36,170 @@
 static void *keymgmt_from_algorithm(int name_id,
                                     const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEYMGMT *keymgmt = NULL;
     int setparamfncnt = 0, getparamfncnt = 0;
     int setgenparamfncnt = 0;
     int importfncnt = 0, exportfncnt = 0;
 
-    if ((keymgmt = keymgmt_new()) == NULL) {
+    if ((keymgmt = keymgmt_new()) == NULL)
+        return NULL;
+
+    keymgmt->name_id = name_id;
+    if ((keymgmt->type_name = ossl_algorithm_get1_first_name(algodef)) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
         return NULL;
     }
-    keymgmt->name_id = name_id;
     keymgmt->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEYMGMT_NEW:
             if (keymgmt->new == NULL)
                 keymgmt->new = OSSL_FUNC_keymgmt_new(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_INIT:
             if (keymgmt->gen_init == NULL)
                 keymgmt->gen_init = OSSL_FUNC_keymgmt_gen_init(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE:
             if (keymgmt->gen_set_template == NULL)
                 keymgmt->gen_set_template =
                     OSSL_FUNC_keymgmt_gen_set_template(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS:
             if (keymgmt->gen_set_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_set_params =
                     OSSL_FUNC_keymgmt_gen_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS:
             if (keymgmt->gen_settable_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_settable_params =
                     OSSL_FUNC_keymgmt_gen_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN:
             if (keymgmt->gen == NULL)
                 keymgmt->gen = OSSL_FUNC_keymgmt_gen(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_CLEANUP:
             if (keymgmt->gen_cleanup == NULL)
                 keymgmt->gen_cleanup = OSSL_FUNC_keymgmt_gen_cleanup(fns);
             break;
         case OSSL_FUNC_KEYMGMT_FREE:
             if (keymgmt->free == NULL)
                 keymgmt->free = OSSL_FUNC_keymgmt_free(fns);
             break;
         case OSSL_FUNC_KEYMGMT_LOAD:
             if (keymgmt->load == NULL)
                 keymgmt->load = OSSL_FUNC_keymgmt_load(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GET_PARAMS:
             if (keymgmt->get_params == NULL) {
                 getparamfncnt++;
                 keymgmt->get_params = OSSL_FUNC_keymgmt_get_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS:
             if (keymgmt->gettable_params == NULL) {
                 getparamfncnt++;
                 keymgmt->gettable_params =
                     OSSL_FUNC_keymgmt_gettable_params(fns);
             }
             break;
          case OSSL_FUNC_KEYMGMT_SET_PARAMS:
             if (keymgmt->set_params == NULL) {
                 setparamfncnt++;
                 keymgmt->set_params = OSSL_FUNC_keymgmt_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS:
             if (keymgmt->settable_params == NULL) {
                 setparamfncnt++;
                 keymgmt->settable_params =
                     OSSL_FUNC_keymgmt_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME:
             if (keymgmt->query_operation_name == NULL)
                 keymgmt->query_operation_name =
                     OSSL_FUNC_keymgmt_query_operation_name(fns);
             break;
         case OSSL_FUNC_KEYMGMT_HAS:
             if (keymgmt->has == NULL)
                 keymgmt->has = OSSL_FUNC_keymgmt_has(fns);
             break;
         case OSSL_FUNC_KEYMGMT_DUP:
             if (keymgmt->dup == NULL)
                 keymgmt->dup = OSSL_FUNC_keymgmt_dup(fns);
             break;
         case OSSL_FUNC_KEYMGMT_VALIDATE:
             if (keymgmt->validate == NULL)
                 keymgmt->validate = OSSL_FUNC_keymgmt_validate(fns);
             break;
         case OSSL_FUNC_KEYMGMT_MATCH:
             if (keymgmt->match == NULL)
                 keymgmt->match = OSSL_FUNC_keymgmt_match(fns);
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT:
             if (keymgmt->import == NULL) {
                 importfncnt++;
                 keymgmt->import = OSSL_FUNC_keymgmt_import(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT_TYPES:
             if (keymgmt->import_types == NULL) {
                 importfncnt++;
                 keymgmt->import_types = OSSL_FUNC_keymgmt_import_types(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT:
             if (keymgmt->export == NULL) {
                 exportfncnt++;
                 keymgmt->export = OSSL_FUNC_keymgmt_export(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT_TYPES:
             if (keymgmt->export_types == NULL) {
                 exportfncnt++;
                 keymgmt->export_types = OSSL_FUNC_keymgmt_export_types(fns);
             }
             break;
         }
     }
     /*
      * Try to check that the method is sensible.
      * At least one constructor and the destructor are MANDATORY
      * The functions 'has' is MANDATORY
      * It makes no sense being able to free stuff if you can't create it.
      * It makes no sense providing OSSL_PARAM descriptors for import and
      * export if you can't import or export.
      */
     if (keymgmt->free == NULL
         || (keymgmt->new == NULL
             && keymgmt->gen == NULL
             && keymgmt->load == NULL)
         || keymgmt->has == NULL
         || (getparamfncnt != 0 && getparamfncnt != 2)
         || (setparamfncnt != 0 && setparamfncnt != 2)
         || (setgenparamfncnt != 0 && setgenparamfncnt != 2)
         || (importfncnt != 0 && importfncnt != 2)
         || (exportfncnt != 0 && exportfncnt != 2)
         || (keymgmt->gen != NULL
             && (keymgmt->gen_init == NULL
                 || keymgmt->gen_cleanup == NULL))) {
         EVP_KEYMGMT_free(keymgmt);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     keymgmt->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return keymgmt;
 }
 

[FUNC] **new** commit 85fcc3fb777c527a614e58c23609210a9edf893b
Date:   Thu Apr 8 19:02:44 2021 +0200

    Remove keymgmt_copy function from the provider API
    
    It is superceded by the keymgmt_dup.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14793)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -35,171 +35,167 @@
 static void *keymgmt_from_algorithm(int name_id,
                                     const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEYMGMT *keymgmt = NULL;
     int setparamfncnt = 0, getparamfncnt = 0;
     int setgenparamfncnt = 0;
     int importfncnt = 0, exportfncnt = 0;
 
     if ((keymgmt = keymgmt_new()) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
         return NULL;
     }
     keymgmt->name_id = name_id;
     keymgmt->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEYMGMT_NEW:
             if (keymgmt->new == NULL)
                 keymgmt->new = OSSL_FUNC_keymgmt_new(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_INIT:
             if (keymgmt->gen_init == NULL)
                 keymgmt->gen_init = OSSL_FUNC_keymgmt_gen_init(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE:
             if (keymgmt->gen_set_template == NULL)
                 keymgmt->gen_set_template =
                     OSSL_FUNC_keymgmt_gen_set_template(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS:
             if (keymgmt->gen_set_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_set_params =
                     OSSL_FUNC_keymgmt_gen_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS:
             if (keymgmt->gen_settable_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_settable_params =
                     OSSL_FUNC_keymgmt_gen_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN:
             if (keymgmt->gen == NULL)
                 keymgmt->gen = OSSL_FUNC_keymgmt_gen(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_CLEANUP:
             if (keymgmt->gen_cleanup == NULL)
                 keymgmt->gen_cleanup = OSSL_FUNC_keymgmt_gen_cleanup(fns);
             break;
         case OSSL_FUNC_KEYMGMT_FREE:
             if (keymgmt->free == NULL)
                 keymgmt->free = OSSL_FUNC_keymgmt_free(fns);
             break;
         case OSSL_FUNC_KEYMGMT_LOAD:
             if (keymgmt->load == NULL)
                 keymgmt->load = OSSL_FUNC_keymgmt_load(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GET_PARAMS:
             if (keymgmt->get_params == NULL) {
                 getparamfncnt++;
                 keymgmt->get_params = OSSL_FUNC_keymgmt_get_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS:
             if (keymgmt->gettable_params == NULL) {
                 getparamfncnt++;
                 keymgmt->gettable_params =
                     OSSL_FUNC_keymgmt_gettable_params(fns);
             }
             break;
          case OSSL_FUNC_KEYMGMT_SET_PARAMS:
             if (keymgmt->set_params == NULL) {
                 setparamfncnt++;
                 keymgmt->set_params = OSSL_FUNC_keymgmt_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS:
             if (keymgmt->settable_params == NULL) {
                 setparamfncnt++;
                 keymgmt->settable_params =
                     OSSL_FUNC_keymgmt_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME:
             if (keymgmt->query_operation_name == NULL)
                 keymgmt->query_operation_name =
                     OSSL_FUNC_keymgmt_query_operation_name(fns);
             break;
         case OSSL_FUNC_KEYMGMT_HAS:
             if (keymgmt->has == NULL)
                 keymgmt->has = OSSL_FUNC_keymgmt_has(fns);
             break;
-        case OSSL_FUNC_KEYMGMT_COPY:
-            if (keymgmt->copy == NULL)
-                keymgmt->copy = OSSL_FUNC_keymgmt_copy(fns);
-            break;
         case OSSL_FUNC_KEYMGMT_DUP:
             if (keymgmt->dup == NULL)
                 keymgmt->dup = OSSL_FUNC_keymgmt_dup(fns);
             break;
         case OSSL_FUNC_KEYMGMT_VALIDATE:
             if (keymgmt->validate == NULL)
                 keymgmt->validate = OSSL_FUNC_keymgmt_validate(fns);
             break;
         case OSSL_FUNC_KEYMGMT_MATCH:
             if (keymgmt->match == NULL)
                 keymgmt->match = OSSL_FUNC_keymgmt_match(fns);
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT:
             if (keymgmt->import == NULL) {
                 importfncnt++;
                 keymgmt->import = OSSL_FUNC_keymgmt_import(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT_TYPES:
             if (keymgmt->import_types == NULL) {
                 importfncnt++;
                 keymgmt->import_types = OSSL_FUNC_keymgmt_import_types(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT:
             if (keymgmt->export == NULL) {
                 exportfncnt++;
                 keymgmt->export = OSSL_FUNC_keymgmt_export(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT_TYPES:
             if (keymgmt->export_types == NULL) {
                 exportfncnt++;
                 keymgmt->export_types = OSSL_FUNC_keymgmt_export_types(fns);
             }
             break;
         }
     }
     /*
      * Try to check that the method is sensible.
      * At least one constructor and the destructor are MANDATORY
      * The functions 'has' is MANDATORY
      * It makes no sense being able to free stuff if you can't create it.
      * It makes no sense providing OSSL_PARAM descriptors for import and
      * export if you can't import or export.
      */
     if (keymgmt->free == NULL
         || (keymgmt->new == NULL
             && keymgmt->gen == NULL
             && keymgmt->load == NULL)
         || keymgmt->has == NULL
         || (getparamfncnt != 0 && getparamfncnt != 2)
         || (setparamfncnt != 0 && setparamfncnt != 2)
         || (setgenparamfncnt != 0 && setgenparamfncnt != 2)
         || (importfncnt != 0 && importfncnt != 2)
         || (exportfncnt != 0 && exportfncnt != 2)
         || (keymgmt->gen != NULL
             && (keymgmt->gen_init == NULL
                 || keymgmt->gen_cleanup == NULL))) {
         EVP_KEYMGMT_free(keymgmt);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     keymgmt->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return keymgmt;
 }
 

[PERF] **new** commit 4a9fe33c8e12f4fefae0471c0834f8e674dc7e4e
Date:   Wed Apr 7 19:35:13 2021 +0200

    Implement provider-side keymgmt_dup function
    
    To avoid mutating key data add OSSL_FUNC_KEYMGMT_DUP function
    to the provider API and implement it for all asym-key key
    managements.
    
    Use it when copying everything to an empty EVP_PKEY
    which is the case with EVP_PKEY_dup().
    
    Fixes #14658
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14793)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -35,167 +35,171 @@
 static void *keymgmt_from_algorithm(int name_id,
                                     const OSSL_ALGORITHM *algodef,
                                     OSSL_PROVIDER *prov)
 {
     const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEYMGMT *keymgmt = NULL;
     int setparamfncnt = 0, getparamfncnt = 0;
     int setgenparamfncnt = 0;
     int importfncnt = 0, exportfncnt = 0;
 
     if ((keymgmt = keymgmt_new()) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
         return NULL;
     }
     keymgmt->name_id = name_id;
     keymgmt->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEYMGMT_NEW:
             if (keymgmt->new == NULL)
                 keymgmt->new = OSSL_FUNC_keymgmt_new(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_INIT:
             if (keymgmt->gen_init == NULL)
                 keymgmt->gen_init = OSSL_FUNC_keymgmt_gen_init(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE:
             if (keymgmt->gen_set_template == NULL)
                 keymgmt->gen_set_template =
                     OSSL_FUNC_keymgmt_gen_set_template(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS:
             if (keymgmt->gen_set_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_set_params =
                     OSSL_FUNC_keymgmt_gen_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS:
             if (keymgmt->gen_settable_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_settable_params =
                     OSSL_FUNC_keymgmt_gen_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN:
             if (keymgmt->gen == NULL)
                 keymgmt->gen = OSSL_FUNC_keymgmt_gen(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_CLEANUP:
             if (keymgmt->gen_cleanup == NULL)
                 keymgmt->gen_cleanup = OSSL_FUNC_keymgmt_gen_cleanup(fns);
             break;
         case OSSL_FUNC_KEYMGMT_FREE:
             if (keymgmt->free == NULL)
                 keymgmt->free = OSSL_FUNC_keymgmt_free(fns);
             break;
         case OSSL_FUNC_KEYMGMT_LOAD:
             if (keymgmt->load == NULL)
                 keymgmt->load = OSSL_FUNC_keymgmt_load(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GET_PARAMS:
             if (keymgmt->get_params == NULL) {
                 getparamfncnt++;
                 keymgmt->get_params = OSSL_FUNC_keymgmt_get_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS:
             if (keymgmt->gettable_params == NULL) {
                 getparamfncnt++;
                 keymgmt->gettable_params =
                     OSSL_FUNC_keymgmt_gettable_params(fns);
             }
             break;
          case OSSL_FUNC_KEYMGMT_SET_PARAMS:
             if (keymgmt->set_params == NULL) {
                 setparamfncnt++;
                 keymgmt->set_params = OSSL_FUNC_keymgmt_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS:
             if (keymgmt->settable_params == NULL) {
                 setparamfncnt++;
                 keymgmt->settable_params =
                     OSSL_FUNC_keymgmt_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME:
             if (keymgmt->query_operation_name == NULL)
                 keymgmt->query_operation_name =
                     OSSL_FUNC_keymgmt_query_operation_name(fns);
             break;
         case OSSL_FUNC_KEYMGMT_HAS:
             if (keymgmt->has == NULL)
                 keymgmt->has = OSSL_FUNC_keymgmt_has(fns);
             break;
         case OSSL_FUNC_KEYMGMT_COPY:
             if (keymgmt->copy == NULL)
                 keymgmt->copy = OSSL_FUNC_keymgmt_copy(fns);
             break;
+        case OSSL_FUNC_KEYMGMT_DUP:
+            if (keymgmt->dup == NULL)
+                keymgmt->dup = OSSL_FUNC_keymgmt_dup(fns);
+            break;
         case OSSL_FUNC_KEYMGMT_VALIDATE:
             if (keymgmt->validate == NULL)
                 keymgmt->validate = OSSL_FUNC_keymgmt_validate(fns);
             break;
         case OSSL_FUNC_KEYMGMT_MATCH:
             if (keymgmt->match == NULL)
                 keymgmt->match = OSSL_FUNC_keymgmt_match(fns);
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT:
             if (keymgmt->import == NULL) {
                 importfncnt++;
                 keymgmt->import = OSSL_FUNC_keymgmt_import(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT_TYPES:
             if (keymgmt->import_types == NULL) {
                 importfncnt++;
                 keymgmt->import_types = OSSL_FUNC_keymgmt_import_types(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT:
             if (keymgmt->export == NULL) {
                 exportfncnt++;
                 keymgmt->export = OSSL_FUNC_keymgmt_export(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT_TYPES:
             if (keymgmt->export_types == NULL) {
                 exportfncnt++;
                 keymgmt->export_types = OSSL_FUNC_keymgmt_export_types(fns);
             }
             break;
         }
     }
     /*
      * Try to check that the method is sensible.
      * At least one constructor and the destructor are MANDATORY
      * The functions 'has' is MANDATORY
      * It makes no sense being able to free stuff if you can't create it.
      * It makes no sense providing OSSL_PARAM descriptors for import and
      * export if you can't import or export.
      */
     if (keymgmt->free == NULL
         || (keymgmt->new == NULL
             && keymgmt->gen == NULL
             && keymgmt->load == NULL)
         || keymgmt->has == NULL
         || (getparamfncnt != 0 && getparamfncnt != 2)
         || (setparamfncnt != 0 && setparamfncnt != 2)
         || (setgenparamfncnt != 0 && setgenparamfncnt != 2)
         || (importfncnt != 0 && importfncnt != 2)
         || (exportfncnt != 0 && exportfncnt != 2)
         || (keymgmt->gen != NULL
             && (keymgmt->gen_init == NULL
                 || keymgmt->gen_cleanup == NULL))) {
         EVP_KEYMGMT_free(keymgmt);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     keymgmt->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return keymgmt;
 }
 

commit 309a78aa305ee14878e453c78ccf9a7dc91264cf
Date:   Tue Mar 16 14:14:43 2021 +0100

    CORE: Add an algorithm_description field to OSSL_ALGORITHM
    
    This corresponds to the |info| field in EVP_PKEY_ASN1_METHOD, as well
    as the generic use of OBJ_nid2ln() as a one line description.
    
    We also add the base functionality to make use of this field.
    
    Fixes #14514
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14656)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -35,165 +35,167 @@
-static void *keymgmt_from_dispatch(int name_id,
-                                   const OSSL_DISPATCH *fns,
-                                   OSSL_PROVIDER *prov)
+static void *keymgmt_from_algorithm(int name_id,
+                                    const OSSL_ALGORITHM *algodef,
+                                    OSSL_PROVIDER *prov)
 {
+    const OSSL_DISPATCH *fns = algodef->implementation;
     EVP_KEYMGMT *keymgmt = NULL;
     int setparamfncnt = 0, getparamfncnt = 0;
     int setgenparamfncnt = 0;
     int importfncnt = 0, exportfncnt = 0;
 
     if ((keymgmt = keymgmt_new()) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
         return NULL;
     }
     keymgmt->name_id = name_id;
+    keymgmt->description = algodef->algorithm_description;
 
     for (; fns->function_id != 0; fns++) {
         switch (fns->function_id) {
         case OSSL_FUNC_KEYMGMT_NEW:
             if (keymgmt->new == NULL)
                 keymgmt->new = OSSL_FUNC_keymgmt_new(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_INIT:
             if (keymgmt->gen_init == NULL)
                 keymgmt->gen_init = OSSL_FUNC_keymgmt_gen_init(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE:
             if (keymgmt->gen_set_template == NULL)
                 keymgmt->gen_set_template =
                     OSSL_FUNC_keymgmt_gen_set_template(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS:
             if (keymgmt->gen_set_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_set_params =
                     OSSL_FUNC_keymgmt_gen_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS:
             if (keymgmt->gen_settable_params == NULL) {
                 setgenparamfncnt++;
                 keymgmt->gen_settable_params =
                     OSSL_FUNC_keymgmt_gen_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GEN:
             if (keymgmt->gen == NULL)
                 keymgmt->gen = OSSL_FUNC_keymgmt_gen(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GEN_CLEANUP:
             if (keymgmt->gen_cleanup == NULL)
                 keymgmt->gen_cleanup = OSSL_FUNC_keymgmt_gen_cleanup(fns);
             break;
         case OSSL_FUNC_KEYMGMT_FREE:
             if (keymgmt->free == NULL)
                 keymgmt->free = OSSL_FUNC_keymgmt_free(fns);
             break;
         case OSSL_FUNC_KEYMGMT_LOAD:
             if (keymgmt->load == NULL)
                 keymgmt->load = OSSL_FUNC_keymgmt_load(fns);
             break;
         case OSSL_FUNC_KEYMGMT_GET_PARAMS:
             if (keymgmt->get_params == NULL) {
                 getparamfncnt++;
                 keymgmt->get_params = OSSL_FUNC_keymgmt_get_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS:
             if (keymgmt->gettable_params == NULL) {
                 getparamfncnt++;
                 keymgmt->gettable_params =
                     OSSL_FUNC_keymgmt_gettable_params(fns);
             }
             break;
          case OSSL_FUNC_KEYMGMT_SET_PARAMS:
             if (keymgmt->set_params == NULL) {
                 setparamfncnt++;
                 keymgmt->set_params = OSSL_FUNC_keymgmt_set_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS:
             if (keymgmt->settable_params == NULL) {
                 setparamfncnt++;
                 keymgmt->settable_params =
                     OSSL_FUNC_keymgmt_settable_params(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME:
             if (keymgmt->query_operation_name == NULL)
                 keymgmt->query_operation_name =
                     OSSL_FUNC_keymgmt_query_operation_name(fns);
             break;
         case OSSL_FUNC_KEYMGMT_HAS:
             if (keymgmt->has == NULL)
                 keymgmt->has = OSSL_FUNC_keymgmt_has(fns);
             break;
         case OSSL_FUNC_KEYMGMT_COPY:
             if (keymgmt->copy == NULL)
                 keymgmt->copy = OSSL_FUNC_keymgmt_copy(fns);
             break;
         case OSSL_FUNC_KEYMGMT_VALIDATE:
             if (keymgmt->validate == NULL)
                 keymgmt->validate = OSSL_FUNC_keymgmt_validate(fns);
             break;
         case OSSL_FUNC_KEYMGMT_MATCH:
             if (keymgmt->match == NULL)
                 keymgmt->match = OSSL_FUNC_keymgmt_match(fns);
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT:
             if (keymgmt->import == NULL) {
                 importfncnt++;
                 keymgmt->import = OSSL_FUNC_keymgmt_import(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_IMPORT_TYPES:
             if (keymgmt->import_types == NULL) {
                 importfncnt++;
                 keymgmt->import_types = OSSL_FUNC_keymgmt_import_types(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT:
             if (keymgmt->export == NULL) {
                 exportfncnt++;
                 keymgmt->export = OSSL_FUNC_keymgmt_export(fns);
             }
             break;
         case OSSL_FUNC_KEYMGMT_EXPORT_TYPES:
             if (keymgmt->export_types == NULL) {
                 exportfncnt++;
                 keymgmt->export_types = OSSL_FUNC_keymgmt_export_types(fns);
             }
             break;
         }
     }
     /*
      * Try to check that the method is sensible.
      * At least one constructor and the destructor are MANDATORY
      * The functions 'has' is MANDATORY
      * It makes no sense being able to free stuff if you can't create it.
      * It makes no sense providing OSSL_PARAM descriptors for import and
      * export if you can't import or export.
      */
     if (keymgmt->free == NULL
         || (keymgmt->new == NULL
             && keymgmt->gen == NULL
             && keymgmt->load == NULL)
         || keymgmt->has == NULL
         || (getparamfncnt != 0 && getparamfncnt != 2)
         || (setparamfncnt != 0 && setparamfncnt != 2)
         || (setgenparamfncnt != 0 && setgenparamfncnt != 2)
         || (importfncnt != 0 && importfncnt != 2)
         || (exportfncnt != 0 && exportfncnt != 2)
         || (keymgmt->gen != NULL
             && (keymgmt->gen_init == NULL
                 || keymgmt->gen_cleanup == NULL))) {
         EVP_KEYMGMT_free(keymgmt);
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     keymgmt->prov = prov;
     if (prov != NULL)
         ossl_provider_up_ref(prov);
 
     return keymgmt;
 }
 
[INCR] **new** commit ed576acdf591d4164905ab98e89ca5a3b99d90ab
Date:   Fri May 21 16:58:08 2021 +0200

    Rename all getters to use get/get0 in name
    
    For functions that exist in 1.1.1 provide a simple aliases via #define.
    
    Fixes #15236
    
    Functions with OSSL_DECODER_, OSSL_ENCODER_, OSSL_STORE_LOADER_,
    EVP_KEYEXCH_, EVP_KEM_, EVP_ASYM_CIPHER_, EVP_SIGNATURE_,
    EVP_KEYMGMT_, EVP_RAND_, EVP_MAC_, EVP_KDF_, EVP_PKEY_,
    EVP_MD_, and EVP_CIPHER_ prefixes are renamed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15405)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -297,14 +297,14 @@
 void *evp_keymgmt_newdata(const EVP_KEYMGMT *keymgmt)
 {
-    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(keymgmt));
 
     /*
      * 'new' is currently mandatory on its own, but when new
      * constructors appear, it won't be quite as mandatory,
      * so we have a check for future cases.
      */
     if (keymgmt->new == NULL)
         return NULL;
     return keymgmt->new(provctx);
 }
 

[NA] **new** commit 91bd45eb9ac26daf87abc2c21cb03143a745a420
Date:   Fri Mar 12 17:14:09 2021 +0100

    keymgmt_meth: remove two TODO 3.0
    
    The first TODO 3.0 is not really a TODO, just a comment.
    
    The second one is something that is needed for compatibility
    with existing applications. There is no major reason in
    trying to change this behavior right now.
    
    Fixes #14400
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14534)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -285,14 +285,14 @@
 void *evp_keymgmt_newdata(const EVP_KEYMGMT *keymgmt)
 {
     void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
 
     /*
-     * TODO(3.0) 'new' is currently mandatory on its own, but when new
-     * constructors appear, it won't be quite as mandatory, so we have
-     * a check for future cases.
+     * 'new' is currently mandatory on its own, but when new
+     * constructors appear, it won't be quite as mandatory,
+     * so we have a check for future cases.
      */
     if (keymgmt->new == NULL)
         return NULL;
     return keymgmt->new(provctx);
 }
 
[FUNC] **new** commit 2145ba5e8383184d7f212500ec2f759bdf08503a
Date:   Fri Mar 19 18:45:43 2021 +0100

    Implement EVP_PKEY_dup() function
    
    Fixes #14501
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14624)

diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -1581,0 +1582,38 @@
+EVP_PKEY *EVP_PKEY_dup(EVP_PKEY *pkey)
+{
+    EVP_PKEY *dup_pk;
+
+    if (pkey == NULL) {
+        ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_NULL_PARAMETER);
+        return NULL;
+    }
+
+    if ((dup_pk = EVP_PKEY_new()) == NULL)
+        return NULL;
+
+    if (evp_pkey_is_blank(pkey))
+        goto done;
+
+    if (evp_pkey_is_provided(pkey)) {
+        if (!evp_keymgmt_util_copy(dup_pk, pkey,
+                                   OSSL_KEYMGMT_SELECT_ALL))
+            goto err;
+        goto done;
+    }
+
+    if (evp_pkey_is_legacy(pkey)) {
+        const EVP_PKEY_ASN1_METHOD *ameth = pkey->ameth;
+
+        if (ameth == NULL || ameth->copy == NULL) {
+            if (pkey->pkey.ptr == NULL /* empty key, just set type */
+                && EVP_PKEY_set_type(dup_pk, pkey->type) != 0)
+                goto done;
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_KEY_TYPE);
+            goto err;
+        }
+        if (!ameth->copy(dup_pk, pkey))
+            goto err;
+        goto done;
+    }
+
+    goto err;
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -374,115 +374,115 @@
 static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,
                                  const char *strtype,
                                  const char *propq,
                                  int nidtype,
                                  ENGINE *e,
                                  const unsigned char *key,
                                  size_t len,
                                  int key_is_priv)
 {
     EVP_PKEY *pkey = NULL;
     EVP_PKEY_CTX *ctx = NULL;
     const EVP_PKEY_ASN1_METHOD *ameth = NULL;
     int result = 0;
 
 # ifndef OPENSSL_NO_ENGINE
     /* Check if there is an Engine for this type */
     if (e == NULL) {
         ENGINE *tmpe = NULL;
 
         if (strtype != NULL)
             ameth = EVP_PKEY_asn1_find_str(&tmpe, strtype, -1);
         else if (nidtype != EVP_PKEY_NONE)
             ameth = EVP_PKEY_asn1_find(&tmpe, nidtype);
 
         /* If tmpe is NULL then no engine is claiming to support this type */
         if (tmpe == NULL)
             ameth = NULL;
 
         ENGINE_finish(tmpe);
     }
 # endif
 
     if (e == NULL && ameth == NULL) {
         /*
          * No engine is claiming to support this type, so lets see if we have
          * a provider.
          */
         ctx = EVP_PKEY_CTX_new_from_name(libctx,
                                          strtype != NULL ? strtype
                                                          : OBJ_nid2sn(nidtype),
                                          propq);
         if (ctx == NULL)
             goto err;
         /* May fail if no provider available */
         ERR_set_mark();
         if (EVP_PKEY_fromdata_init(ctx) == 1) {
             OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
             ERR_clear_last_mark();
             params[0] = OSSL_PARAM_construct_octet_string(
                             key_is_priv ? OSSL_PKEY_PARAM_PRIV_KEY
                                         : OSSL_PKEY_PARAM_PUB_KEY,
                             (void *)key, len);
 
             if (EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, params) != 1) {
                 ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
                 goto err;
             }
 
             EVP_PKEY_CTX_free(ctx);
 
             return pkey;
         }
         ERR_pop_to_mark();
         /* else not supported so fallback to legacy */
     }
 
     /* Legacy code path */
 
     pkey = EVP_PKEY_new();
     if (pkey == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);
         goto err;
     }
 
     if (!pkey_set_type(pkey, e, nidtype, strtype, -1, NULL)) {
         /* ERR_raise(ERR_LIB_EVP, ...) already called */
         goto err;
     }
 
     if (!ossl_assert(pkey->ameth != NULL))
         goto err;
 
     if (key_is_priv) {
         if (pkey->ameth->set_priv_key == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey->ameth->set_priv_key(pkey, key, len)) {
             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     } else {
         if (pkey->ameth->set_pub_key == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey->ameth->set_pub_key(pkey, key, len)) {
             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     }
 
     result = 1;
  err:
     if (!result) {
         EVP_PKEY_free(pkey);
         pkey = NULL;
     }
     EVP_PKEY_CTX_free(ctx);
     return pkey;
 }
 

[FUNC] **new** commit bd07cc1c7e3ca38689e59868b5945dc223235a49
Date:   Fri Aug 26 10:04:01 2022 +0200

    ERR: replace remnant ECerr() and EVPerr() calls in crypto/
    
    except those throwing ERR_R_MALLOC_FAILURE
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: David von Oheimb <david.von.oheimb@siemens.com>
    (Merged from https://github.com/openssl/openssl/pull/19302)

diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -374,115 +374,115 @@
 static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,
                                  const char *strtype,
                                  const char *propq,
                                  int nidtype,
                                  ENGINE *e,
                                  const unsigned char *key,
                                  size_t len,
                                  int key_is_priv)
 {
     EVP_PKEY *pkey = NULL;
     EVP_PKEY_CTX *ctx = NULL;
     const EVP_PKEY_ASN1_METHOD *ameth = NULL;
     int result = 0;
 
 # ifndef OPENSSL_NO_ENGINE
     /* Check if there is an Engine for this type */
     if (e == NULL) {
         ENGINE *tmpe = NULL;
 
         if (strtype != NULL)
             ameth = EVP_PKEY_asn1_find_str(&tmpe, strtype, -1);
         else if (nidtype != EVP_PKEY_NONE)
             ameth = EVP_PKEY_asn1_find(&tmpe, nidtype);
 
         /* If tmpe is NULL then no engine is claiming to support this type */
         if (tmpe == NULL)
             ameth = NULL;
 
         ENGINE_finish(tmpe);
     }
 # endif
 
     if (e == NULL && ameth == NULL) {
         /*
          * No engine is claiming to support this type, so lets see if we have
          * a provider.
          */
         ctx = EVP_PKEY_CTX_new_from_name(libctx,
                                          strtype != NULL ? strtype
                                                          : OBJ_nid2sn(nidtype),
                                          propq);
         if (ctx == NULL)
             goto err;
         /* May fail if no provider available */
         ERR_set_mark();
         if (EVP_PKEY_fromdata_init(ctx) == 1) {
             OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
             ERR_clear_last_mark();
             params[0] = OSSL_PARAM_construct_octet_string(
                             key_is_priv ? OSSL_PKEY_PARAM_PRIV_KEY
                                         : OSSL_PKEY_PARAM_PUB_KEY,
                             (void *)key, len);
 
             if (EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, params) != 1) {
                 ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
                 goto err;
             }
 
             EVP_PKEY_CTX_free(ctx);
 
             return pkey;
         }
         ERR_pop_to_mark();
         /* else not supported so fallback to legacy */
     }
 
     /* Legacy code path */
 
     pkey = EVP_PKEY_new();
     if (pkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!pkey_set_type(pkey, e, nidtype, strtype, -1, NULL)) {
-        /* EVPerr already called */
+        /* ERR_raise(ERR_LIB_EVP, ...) already called */
         goto err;
     }
 
     if (!ossl_assert(pkey->ameth != NULL))
         goto err;
 
     if (key_is_priv) {
         if (pkey->ameth->set_priv_key == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey->ameth->set_priv_key(pkey, key, len)) {
             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     } else {
         if (pkey->ameth->set_pub_key == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey->ameth->set_pub_key(pkey, key, len)) {
             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     }
 
     result = 1;
  err:
     if (!result) {
         EVP_PKEY_free(pkey);
         pkey = NULL;
     }
     EVP_PKEY_CTX_free(ctx);
     return pkey;
 }
 

[INCR] **new** commit 2db985b7b1e20ac670d196981aa7e8f31881d2eb
Date:   Fri Feb 5 13:55:50 2021 +1000

    Simplify the EVP_PKEY_XXX_fromdata_XX methods.
    
    The existing names such as EVP_PKEY_param_fromdata_settable were a bit
    confusing since the 'param' referred to key params not OSSL_PARAM. To simplify
    the interface a 'selection' parameter will be passed instead. The
    changes are:
    
    (1) EVP_PKEY_fromdata_init() replaces both EVP_PKEY_key_fromdata_init() and EVP_PKEY_param_fromdata_init().
    (2) EVP_PKEY_fromdata() has an additional selection parameter.
    (3) EVP_PKEY_fromdata_settable() replaces EVP_PKEY_key_fromdata_settable() and EVP_PKEY_param_fromdata_settable().
        EVP_PKEY_fromdata_settable() also uses a selection parameter.
    
    Fixes #12989
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14076)

diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -349,115 +349,115 @@
 static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,
                                  const char *strtype,
                                  const char *propq,
                                  int nidtype,
                                  ENGINE *e,
                                  const unsigned char *key,
                                  size_t len,
                                  int key_is_priv)
 {
     EVP_PKEY *pkey = NULL;
     EVP_PKEY_CTX *ctx = NULL;
     const EVP_PKEY_ASN1_METHOD *ameth = NULL;
     int result = 0;
 
 # ifndef OPENSSL_NO_ENGINE
     /* Check if there is an Engine for this type */
     if (e == NULL) {
         ENGINE *tmpe = NULL;
 
         if (strtype != NULL)
             ameth = EVP_PKEY_asn1_find_str(&tmpe, strtype, -1);
         else if (nidtype != EVP_PKEY_NONE)
             ameth = EVP_PKEY_asn1_find(&tmpe, nidtype);
 
         /* If tmpe is NULL then no engine is claiming to support this type */
         if (tmpe == NULL)
             ameth = NULL;
 
         ENGINE_finish(tmpe);
     }
 # endif
 
     if (e == NULL && ameth == NULL) {
         /*
          * No engine is claiming to support this type, so lets see if we have
          * a provider.
          */
         ctx = EVP_PKEY_CTX_new_from_name(libctx,
                                          strtype != NULL ? strtype
                                                          : OBJ_nid2sn(nidtype),
                                          propq);
         if (ctx == NULL)
             goto err;
         /* May fail if no provider available */
         ERR_set_mark();
-        if (EVP_PKEY_key_fromdata_init(ctx) == 1) {
+        if (EVP_PKEY_fromdata_init(ctx) == 1) {
             OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
             ERR_clear_last_mark();
             params[0] = OSSL_PARAM_construct_octet_string(
                             key_is_priv ? OSSL_PKEY_PARAM_PRIV_KEY
                                         : OSSL_PKEY_PARAM_PUB_KEY,
                             (void *)key, len);
 
-            if (EVP_PKEY_fromdata(ctx, &pkey, params) != 1) {
+            if (EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, params) != 1) {
                 ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
                 goto err;
             }
 
             EVP_PKEY_CTX_free(ctx);
 
             return pkey;
         }
         ERR_pop_to_mark();
         /* else not supported so fallback to legacy */
     }
 
     /* Legacy code path */
 
     pkey = EVP_PKEY_new();
     if (pkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!pkey_set_type(pkey, e, nidtype, strtype, -1, NULL)) {
         /* EVPerr already called */
         goto err;
     }
 
     if (!ossl_assert(pkey->ameth != NULL))
         goto err;
 
     if (key_is_priv) {
         if (pkey->ameth->set_priv_key == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey->ameth->set_priv_key(pkey, key, len)) {
             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     } else {
         if (pkey->ameth->set_pub_key == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey->ameth->set_pub_key(pkey, key, len)) {
             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     }
 
     result = 1;
  err:
     if (!result) {
         EVP_PKEY_free(pkey);
         pkey = NULL;
     }
     EVP_PKEY_CTX_free(ctx);
     return pkey;
 }
 
commit 2db985b7b1e20ac670d196981aa7e8f31881d2eb
Date:   Fri Feb 5 13:55:50 2021 +1000

    Simplify the EVP_PKEY_XXX_fromdata_XX methods.
    
    The existing names such as EVP_PKEY_param_fromdata_settable were a bit
    confusing since the 'param' referred to key params not OSSL_PARAM. To simplify
    the interface a 'selection' parameter will be passed instead. The
    changes are:
    
    (1) EVP_PKEY_fromdata_init() replaces both EVP_PKEY_key_fromdata_init() and EVP_PKEY_param_fromdata_init().
    (2) EVP_PKEY_fromdata() has an additional selection parameter.
    (3) EVP_PKEY_fromdata_settable() replaces EVP_PKEY_key_fromdata_settable() and EVP_PKEY_param_fromdata_settable().
        EVP_PKEY_fromdata_settable() also uses a selection parameter.
    
    Fixes #12989
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14076)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -348,5 +348,5 @@
-int EVP_PKEY_param_fromdata_init(EVP_PKEY_CTX *ctx)
+int EVP_PKEY_fromdata_init(EVP_PKEY_CTX *ctx)
 {
-    return fromdata_init(ctx, EVP_PKEY_OP_PARAMFROMDATA);
+    return fromdata_init(ctx, EVP_PKEY_OP_FROMDATA);
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -128,131 +128,131 @@
 int EVP_PKEY_generate(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
     int ret = 0;
     EVP_PKEY *allocated_pkey = NULL;
     /* Legacy compatible keygen callback info, only used with provider impls */
     int gentmp[2];
 
     if (ppkey == NULL)
         return -1;
 
     if (ctx == NULL)
         goto not_supported;
 
     if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)
         goto not_initialized;
 
     if (*ppkey == NULL)
         *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);
         return -1;
     }
 
     if (ctx->op.keymgmt.genctx == NULL)
         goto legacy;
 
     /*
      * Asssigning gentmp to ctx->keygen_info is something our legacy
      * implementations do.  Because the provider implementations aren't
      * allowed to reach into our EVP_PKEY_CTX, we need to provide similar
      * space for backward compatibility.  It's ok that we attach a local
      * variable, as it should only be useful in the calls down from here.
      * This is cleared as soon as it isn't useful any more, i.e. directly
      * after the evp_keymgmt_util_gen() call.
      */
     ctx->keygen_info = gentmp;
     ctx->keygen_info_count = 2;
 
     ret = 1;
     if (ctx->pkey != NULL) {
         EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;
         void *keydata =
             evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,
                                         &tmp_keymgmt, ctx->propquery);
 
         if (tmp_keymgmt == NULL)
             goto not_supported;
         /*
          * It's ok if keydata is NULL here.  The backend is expected to deal
          * with that as it sees fit.
          */
         ret = evp_keymgmt_gen_set_template(ctx->keymgmt,
                                            ctx->op.keymgmt.genctx, keydata);
     }
 
     /*
      * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
      * so we do not need to save it, just check it.
      */
     ret = ret
         && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,
                                  ossl_callback_to_pkey_gencb, ctx)
             != NULL);
 
     ctx->keygen_info = NULL;
 
 #ifndef FIPS_MODULE
     /* In case |*ppkey| was originally a legacy key */
     if (ret)
         evp_pkey_free_legacy(*ppkey);
 #endif
 
     /*
      * Because we still have legacy keys
      */
     (*ppkey)->type = ctx->legacy_keytype;
 
     goto end;
 
  legacy:
 #ifdef FIPS_MODULE
     goto not_supported;
 #else
     /*
      * If we get here then we're using legacy paramgen/keygen. In that case
      * the pkey in ctx (if there is one) had better not be provided (because the
      * legacy methods may not know how to handle it). However we can only get
      * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case
      * if ctx->pkey is provided because we don't allow this when we initialise
      * the ctx.
      */
     if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))
         goto not_accessible;
 
     switch (ctx->operation) {
     case EVP_PKEY_OP_PARAMGEN:
         ret = ctx->pmeth->paramgen(ctx, *ppkey);
         break;
     case EVP_PKEY_OP_KEYGEN:
         ret = ctx->pmeth->keygen(ctx, *ppkey);
         break;
     default:
         goto not_supported;
     }
 #endif
 
  end:
     if (ret <= 0) {
         if (allocated_pkey != NULL)
             *ppkey = NULL;
         EVP_PKEY_free(allocated_pkey);
     }
     return ret;
 
  not_supported:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     ret = -2;
     goto end;
  not_initialized:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);
     ret = -1;
     goto end;
 #ifndef FIPS_MODULE
  not_accessible:
     ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);
     ret = -1;
     goto end;
 #endif
 }
 

[INCR] **new** commit 64a644530e023d3064db9027b0977d33b1d2ad9a
Date:   Tue Jan 11 08:51:31 2022 +0100

    drop unused callback variable
    
    Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17471)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -128,132 +128,131 @@
 int EVP_PKEY_generate(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
     int ret = 0;
-    OSSL_CALLBACK cb;
     EVP_PKEY *allocated_pkey = NULL;
     /* Legacy compatible keygen callback info, only used with provider impls */
     int gentmp[2];
 
     if (ppkey == NULL)
         return -1;
 
     if (ctx == NULL)
         goto not_supported;
 
     if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)
         goto not_initialized;
 
     if (*ppkey == NULL)
         *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
     if (ctx->op.keymgmt.genctx == NULL)
         goto legacy;
 
     /*
      * Asssigning gentmp to ctx->keygen_info is something our legacy
      * implementations do.  Because the provider implementations aren't
      * allowed to reach into our EVP_PKEY_CTX, we need to provide similar
      * space for backward compatibility.  It's ok that we attach a local
      * variable, as it should only be useful in the calls down from here.
      * This is cleared as soon as it isn't useful any more, i.e. directly
      * after the evp_keymgmt_util_gen() call.
      */
     ctx->keygen_info = gentmp;
     ctx->keygen_info_count = 2;
 
     ret = 1;
     if (ctx->pkey != NULL) {
         EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;
         void *keydata =
             evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,
                                         &tmp_keymgmt, ctx->propquery);
 
         if (tmp_keymgmt == NULL)
             goto not_supported;
         /*
          * It's ok if keydata is NULL here.  The backend is expected to deal
          * with that as it sees fit.
          */
         ret = evp_keymgmt_gen_set_template(ctx->keymgmt,
                                            ctx->op.keymgmt.genctx, keydata);
     }
 
     /*
      * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
      * so we do not need to save it, just check it.
      */
     ret = ret
         && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,
                                  ossl_callback_to_pkey_gencb, ctx)
             != NULL);
 
     ctx->keygen_info = NULL;
 
 #ifndef FIPS_MODULE
     /* In case |*ppkey| was originally a legacy key */
     if (ret)
         evp_pkey_free_legacy(*ppkey);
 #endif
 
     /*
      * Because we still have legacy keys
      */
     (*ppkey)->type = ctx->legacy_keytype;
 
     goto end;
 
  legacy:
 #ifdef FIPS_MODULE
     goto not_supported;
 #else
     /*
      * If we get here then we're using legacy paramgen/keygen. In that case
      * the pkey in ctx (if there is one) had better not be provided (because the
      * legacy methods may not know how to handle it). However we can only get
      * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case
      * if ctx->pkey is provided because we don't allow this when we initialise
      * the ctx.
      */
     if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))
         goto not_accessible;
 
     switch (ctx->operation) {
     case EVP_PKEY_OP_PARAMGEN:
         ret = ctx->pmeth->paramgen(ctx, *ppkey);
         break;
     case EVP_PKEY_OP_KEYGEN:
         ret = ctx->pmeth->keygen(ctx, *ppkey);
         break;
     default:
         goto not_supported;
     }
 #endif
 
  end:
     if (ret <= 0) {
         if (allocated_pkey != NULL)
             *ppkey = NULL;
         EVP_PKEY_free(allocated_pkey);
     }
     return ret;
 
  not_supported:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     ret = -2;
     goto end;
  not_initialized:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);
     ret = -1;
     goto end;
 #ifndef FIPS_MODULE
  not_accessible:
     ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);
     ret = -1;
     goto end;
 #endif
 }
 

[NA] **new** commit 4c3c2633b226d930db7578346a1f5ddc48fd3466
Date:   Mon May 31 14:29:55 2021 +1000

    evp: remove TODOs
    
    Reviewed-by: Tim Hudson <tjh@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15539)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -126,133 +126,132 @@
 int EVP_PKEY_generate(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
     int ret = 0;
     OSSL_CALLBACK cb;
     EVP_PKEY *allocated_pkey = NULL;
     /* Legacy compatible keygen callback info, only used with provider impls */
     int gentmp[2];
 
     if (ppkey == NULL)
         return -1;
 
     if (ctx == NULL)
         goto not_supported;
 
     if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)
         goto not_initialized;
 
     if (*ppkey == NULL)
         *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
     if (ctx->op.keymgmt.genctx == NULL)
         goto legacy;
 
     /*
      * Asssigning gentmp to ctx->keygen_info is something our legacy
      * implementations do.  Because the provider implementations aren't
      * allowed to reach into our EVP_PKEY_CTX, we need to provide similar
      * space for backward compatibility.  It's ok that we attach a local
      * variable, as it should only be useful in the calls down from here.
      * This is cleared as soon as it isn't useful any more, i.e. directly
      * after the evp_keymgmt_util_gen() call.
      */
     ctx->keygen_info = gentmp;
     ctx->keygen_info_count = 2;
 
     ret = 1;
     if (ctx->pkey != NULL) {
         EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;
         void *keydata =
             evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,
                                         &tmp_keymgmt, ctx->propquery);
 
         if (tmp_keymgmt == NULL)
             goto not_supported;
         /*
          * It's ok if keydata is NULL here.  The backend is expected to deal
          * with that as it sees fit.
          */
         ret = evp_keymgmt_gen_set_template(ctx->keymgmt,
                                            ctx->op.keymgmt.genctx, keydata);
     }
 
     /*
      * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
      * so we do not need to save it, just check it.
      */
     ret = ret
         && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,
                                  ossl_callback_to_pkey_gencb, ctx)
             != NULL);
 
     ctx->keygen_info = NULL;
 
 #ifndef FIPS_MODULE
     /* In case |*ppkey| was originally a legacy key */
     if (ret)
         evp_pkey_free_legacy(*ppkey);
 #endif
 
     /*
      * Because we still have legacy keys
-     * TODO remove this #legacy internal keys are gone
      */
     (*ppkey)->type = ctx->legacy_keytype;
 
     goto end;
 
  legacy:
 #ifdef FIPS_MODULE
     goto not_supported;
 #else
     /*
      * If we get here then we're using legacy paramgen/keygen. In that case
      * the pkey in ctx (if there is one) had better not be provided (because the
      * legacy methods may not know how to handle it). However we can only get
      * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case
      * if ctx->pkey is provided because we don't allow this when we initialise
      * the ctx.
      */
     if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))
         goto not_accessible;
 
     switch (ctx->operation) {
     case EVP_PKEY_OP_PARAMGEN:
         ret = ctx->pmeth->paramgen(ctx, *ppkey);
         break;
     case EVP_PKEY_OP_KEYGEN:
         ret = ctx->pmeth->keygen(ctx, *ppkey);
         break;
     default:
         goto not_supported;
     }
 #endif
 
  end:
     if (ret <= 0) {
         if (allocated_pkey != NULL)
             *ppkey = NULL;
         EVP_PKEY_free(allocated_pkey);
     }
     return ret;
 
  not_supported:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     ret = -2;
     goto end;
  not_initialized:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);
     ret = -1;
     goto end;
 #ifndef FIPS_MODULE
  not_accessible:
     ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);
     ret = -1;
     goto end;
 #endif
 }
 

[FUNC] **new** commit f925315203f77d0241183ccabfc784d259b0a152
Date:   Sat Mar 20 13:49:08 2021 +0100

    Add convenience functions and macros for asymmetric key generation
    
    Add EVP_PKEY_gen(), EVP_PKEY_Q_gen(), EVP_RSA_gen(), and EVP_EC_gen().
    Also export auxiliary function OSSL_EC_curve_nid2name()
    and improve deprecation info on RSA and EC key generation/management functions.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14695)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -126,133 +126,133 @@
-int EVP_PKEY_gen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
+int EVP_PKEY_generate(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
     int ret = 0;
     OSSL_CALLBACK cb;
     EVP_PKEY *allocated_pkey = NULL;
     /* Legacy compatible keygen callback info, only used with provider impls */
     int gentmp[2];
 
     if (ppkey == NULL)
         return -1;
 
     if (ctx == NULL)
         goto not_supported;
 
     if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)
         goto not_initialized;
 
     if (*ppkey == NULL)
         *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
     if (ctx->op.keymgmt.genctx == NULL)
         goto legacy;
 
     /*
      * Asssigning gentmp to ctx->keygen_info is something our legacy
      * implementations do.  Because the provider implementations aren't
      * allowed to reach into our EVP_PKEY_CTX, we need to provide similar
      * space for backward compatibility.  It's ok that we attach a local
      * variable, as it should only be useful in the calls down from here.
      * This is cleared as soon as it isn't useful any more, i.e. directly
      * after the evp_keymgmt_util_gen() call.
      */
     ctx->keygen_info = gentmp;
     ctx->keygen_info_count = 2;
 
     ret = 1;
     if (ctx->pkey != NULL) {
         EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;
         void *keydata =
             evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,
                                         &tmp_keymgmt, ctx->propquery);
 
         if (tmp_keymgmt == NULL)
             goto not_supported;
         /*
          * It's ok if keydata is NULL here.  The backend is expected to deal
          * with that as it sees fit.
          */
         ret = evp_keymgmt_gen_set_template(ctx->keymgmt,
                                            ctx->op.keymgmt.genctx, keydata);
     }
 
     /*
      * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
      * so we do not need to save it, just check it.
      */
     ret = ret
         && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,
                                  ossl_callback_to_pkey_gencb, ctx)
             != NULL);
 
     ctx->keygen_info = NULL;
 
 #ifndef FIPS_MODULE
     /* In case |*ppkey| was originally a legacy key */
     if (ret)
         evp_pkey_free_legacy(*ppkey);
 #endif
 
     /*
      * Because we still have legacy keys
      * TODO remove this #legacy internal keys are gone
      */
     (*ppkey)->type = ctx->legacy_keytype;
 
     goto end;
 
  legacy:
 #ifdef FIPS_MODULE
     goto not_supported;
 #else
     /*
      * If we get here then we're using legacy paramgen/keygen. In that case
      * the pkey in ctx (if there is one) had better not be provided (because the
      * legacy methods may not know how to handle it). However we can only get
      * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case
      * if ctx->pkey is provided because we don't allow this when we initialise
      * the ctx.
      */
     if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))
         goto not_accessible;
 
     switch (ctx->operation) {
     case EVP_PKEY_OP_PARAMGEN:
         ret = ctx->pmeth->paramgen(ctx, *ppkey);
         break;
     case EVP_PKEY_OP_KEYGEN:
         ret = ctx->pmeth->keygen(ctx, *ppkey);
         break;
     default:
         goto not_supported;
     }
 #endif
 
  end:
     if (ret <= 0) {
         if (allocated_pkey != NULL)
             *ppkey = NULL;
         EVP_PKEY_free(allocated_pkey);
     }
     return ret;
 
  not_supported:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     ret = -2;
     goto end;
  not_initialized:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);
     ret = -1;
     goto end;
 #ifndef FIPS_MODULE
  not_accessible:
     ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);
     ret = -1;
     goto end;
 #endif
 }
 

[CORR] **new** commit bf23b9a163658496c3cabb1d0a00a88b94aede0a
Date:   Thu Mar 4 17:01:50 2021 +0100

    Fix reason code: EVP_R_OPERATON_NOT_INITIALIZED
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14429)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -125,133 +125,133 @@
 int EVP_PKEY_gen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
     int ret = 0;
     OSSL_CALLBACK cb;
     EVP_PKEY *allocated_pkey = NULL;
     /* Legacy compatible keygen callback info, only used with provider impls */
     int gentmp[2];
 
     if (ppkey == NULL)
         return -1;
 
     if (ctx == NULL)
         goto not_supported;
 
     if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)
         goto not_initialized;
 
     if (*ppkey == NULL)
         *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
     if (ctx->op.keymgmt.genctx == NULL)
         goto legacy;
 
     /*
      * Asssigning gentmp to ctx->keygen_info is something our legacy
      * implementations do.  Because the provider implementations aren't
      * allowed to reach into our EVP_PKEY_CTX, we need to provide similar
      * space for backward compatibility.  It's ok that we attach a local
      * variable, as it should only be useful in the calls down from here.
      * This is cleared as soon as it isn't useful any more, i.e. directly
      * after the evp_keymgmt_util_gen() call.
      */
     ctx->keygen_info = gentmp;
     ctx->keygen_info_count = 2;
 
     ret = 1;
     if (ctx->pkey != NULL) {
         EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;
         void *keydata =
             evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,
                                         &tmp_keymgmt, ctx->propquery);
 
         if (tmp_keymgmt == NULL)
             goto not_supported;
         /*
          * It's ok if keydata is NULL here.  The backend is expected to deal
          * with that as it sees fit.
          */
         ret = evp_keymgmt_gen_set_template(ctx->keymgmt,
                                            ctx->op.keymgmt.genctx, keydata);
     }
 
     /*
      * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
      * so we do not need to save it, just check it.
      */
     ret = ret
         && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,
                                  ossl_callback_to_pkey_gencb, ctx)
             != NULL);
 
     ctx->keygen_info = NULL;
 
 #ifndef FIPS_MODULE
     /* In case |*ppkey| was originally a legacy key */
     if (ret)
         evp_pkey_free_legacy(*ppkey);
 #endif
 
     /*
      * Because we still have legacy keys
      * TODO remove this #legacy internal keys are gone
      */
     (*ppkey)->type = ctx->legacy_keytype;
 
     goto end;
 
  legacy:
 #ifdef FIPS_MODULE
     goto not_supported;
 #else
     /*
      * If we get here then we're using legacy paramgen/keygen. In that case
      * the pkey in ctx (if there is one) had better not be provided (because the
      * legacy methods may not know how to handle it). However we can only get
      * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case
      * if ctx->pkey is provided because we don't allow this when we initialise
      * the ctx.
      */
     if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))
         goto not_accessible;
 
     switch (ctx->operation) {
     case EVP_PKEY_OP_PARAMGEN:
         ret = ctx->pmeth->paramgen(ctx, *ppkey);
         break;
     case EVP_PKEY_OP_KEYGEN:
         ret = ctx->pmeth->keygen(ctx, *ppkey);
         break;
     default:
         goto not_supported;
     }
 #endif
 
  end:
     if (ret <= 0) {
         if (allocated_pkey != NULL)
             *ppkey = NULL;
         EVP_PKEY_free(allocated_pkey);
     }
     return ret;
 
  not_supported:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     ret = -2;
     goto end;
  not_initialized:
-    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);
     ret = -1;
     goto end;
 #ifndef FIPS_MODULE
  not_accessible:
     ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);
     ret = -1;
     goto end;
 #endif
 }
 

[CORR] **new** commit b574c6a9ac96825b4f19c5e835273bf176174af8
Date:   Wed Feb 24 16:38:28 2021 +0000

    Cache legacy keys instead of downgrading them
    
    If someone calls an EVP_PKEY_get0*() function then we create a legacy
    key and cache it in the EVP_PKEY - but it doesn't become an "origin" and
    it doesn't ever get updated. This will be documented as a restriction of
    the EVP_PKEY_get0*() function with provided keys.
    
    Fixes #14020
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14319)

diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -125,124 +125,133 @@
 int EVP_PKEY_gen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
     int ret = 0;
     OSSL_CALLBACK cb;
     EVP_PKEY *allocated_pkey = NULL;
     /* Legacy compatible keygen callback info, only used with provider impls */
     int gentmp[2];
 
     if (ppkey == NULL)
         return -1;
 
     if (ctx == NULL)
         goto not_supported;
 
     if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)
         goto not_initialized;
 
     if (*ppkey == NULL)
         *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
     if (ctx->op.keymgmt.genctx == NULL)
         goto legacy;
 
     /*
      * Asssigning gentmp to ctx->keygen_info is something our legacy
      * implementations do.  Because the provider implementations aren't
      * allowed to reach into our EVP_PKEY_CTX, we need to provide similar
      * space for backward compatibility.  It's ok that we attach a local
      * variable, as it should only be useful in the calls down from here.
      * This is cleared as soon as it isn't useful any more, i.e. directly
      * after the evp_keymgmt_util_gen() call.
      */
     ctx->keygen_info = gentmp;
     ctx->keygen_info_count = 2;
 
     ret = 1;
     if (ctx->pkey != NULL) {
         EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;
         void *keydata =
             evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,
                                         &tmp_keymgmt, ctx->propquery);
 
         if (tmp_keymgmt == NULL)
             goto not_supported;
         /*
          * It's ok if keydata is NULL here.  The backend is expected to deal
          * with that as it sees fit.
          */
         ret = evp_keymgmt_gen_set_template(ctx->keymgmt,
                                            ctx->op.keymgmt.genctx, keydata);
     }
 
     /*
      * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
      * so we do not need to save it, just check it.
      */
     ret = ret
         && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,
                                  ossl_callback_to_pkey_gencb, ctx)
             != NULL);
 
     ctx->keygen_info = NULL;
 
 #ifndef FIPS_MODULE
     /* In case |*ppkey| was originally a legacy key */
     if (ret)
         evp_pkey_free_legacy(*ppkey);
 #endif
 
     /*
-     * Because we still have legacy keys, and evp_pkey_downgrade()
+     * Because we still have legacy keys
      * TODO remove this #legacy internal keys are gone
      */
     (*ppkey)->type = ctx->legacy_keytype;
 
     goto end;
 
  legacy:
 #ifdef FIPS_MODULE
     goto not_supported;
 #else
-    if (ctx->pkey && !evp_pkey_downgrade(ctx->pkey))
+    /*
+     * If we get here then we're using legacy paramgen/keygen. In that case
+     * the pkey in ctx (if there is one) had better not be provided (because the
+     * legacy methods may not know how to handle it). However we can only get
+     * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case
+     * if ctx->pkey is provided because we don't allow this when we initialise
+     * the ctx.
+     */
+    if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))
         goto not_accessible;
+
     switch (ctx->operation) {
     case EVP_PKEY_OP_PARAMGEN:
         ret = ctx->pmeth->paramgen(ctx, *ppkey);
         break;
     case EVP_PKEY_OP_KEYGEN:
         ret = ctx->pmeth->keygen(ctx, *ppkey);
         break;
     default:
         goto not_supported;
     }
 #endif
 
  end:
     if (ret <= 0) {
         if (allocated_pkey != NULL)
             *ppkey = NULL;
         EVP_PKEY_free(allocated_pkey);
     }
     return ret;
 
  not_supported:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     ret = -2;
     goto end;
  not_initialized:
     ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
     ret = -1;
     goto end;
 #ifndef FIPS_MODULE
  not_accessible:
     ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);
     ret = -1;
     goto end;
 #endif
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -126,15 +126,13 @@
 EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags)
 {
     EVP_PKEY_METHOD *pmeth;
 
     pmeth = OPENSSL_zalloc(sizeof(*pmeth));
-    if (pmeth == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+    if (pmeth == NULL)
         return NULL;
-    }
 
     pmeth->pkey_id = id;
     pmeth->flags = flags | EVP_PKEY_FLAG_DYNAMIC;
     return pmeth;
 }
 
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -472,135 +468,133 @@
 EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
 {
     EVP_PKEY_CTX *rctx;
 
 # ifndef OPENSSL_NO_ENGINE
     /* Make sure it's safe to copy a pkey context using an ENGINE */
     if (pctx->engine && !ENGINE_init(pctx->engine)) {
         ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
         return 0;
     }
 # endif
     rctx = OPENSSL_zalloc(sizeof(*rctx));
-    if (rctx == NULL) {
-        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+    if (rctx == NULL)
         return NULL;
-    }
 
     if (pctx->pkey != NULL)
         EVP_PKEY_up_ref(pctx->pkey);
     rctx->pkey = pctx->pkey;
     rctx->operation = pctx->operation;
     rctx->libctx = pctx->libctx;
     rctx->keytype = pctx->keytype;
     rctx->propquery = NULL;
     if (pctx->propquery != NULL) {
         rctx->propquery = OPENSSL_strdup(pctx->propquery);
         if (rctx->propquery == NULL)
             goto err;
     }
     rctx->legacy_keytype = pctx->legacy_keytype;
 
     if (EVP_PKEY_CTX_IS_DERIVE_OP(pctx)) {
         if (pctx->op.kex.exchange != NULL) {
             rctx->op.kex.exchange = pctx->op.kex.exchange;
             if (!EVP_KEYEXCH_up_ref(rctx->op.kex.exchange))
                 goto err;
         }
         if (pctx->op.kex.algctx != NULL) {
             if (!ossl_assert(pctx->op.kex.exchange != NULL))
                 goto err;
             rctx->op.kex.algctx
                 = pctx->op.kex.exchange->dupctx(pctx->op.kex.algctx);
             if (rctx->op.kex.algctx == NULL) {
                 EVP_KEYEXCH_free(rctx->op.kex.exchange);
                 rctx->op.kex.exchange = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_SIGNATURE_OP(pctx)) {
         if (pctx->op.sig.signature != NULL) {
             rctx->op.sig.signature = pctx->op.sig.signature;
             if (!EVP_SIGNATURE_up_ref(rctx->op.sig.signature))
                 goto err;
         }
         if (pctx->op.sig.algctx != NULL) {
             if (!ossl_assert(pctx->op.sig.signature != NULL))
                 goto err;
             rctx->op.sig.algctx
                 = pctx->op.sig.signature->dupctx(pctx->op.sig.algctx);
             if (rctx->op.sig.algctx == NULL) {
                 EVP_SIGNATURE_free(rctx->op.sig.signature);
                 rctx->op.sig.signature = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(pctx)) {
         if (pctx->op.ciph.cipher != NULL) {
             rctx->op.ciph.cipher = pctx->op.ciph.cipher;
             if (!EVP_ASYM_CIPHER_up_ref(rctx->op.ciph.cipher))
                 goto err;
         }
         if (pctx->op.ciph.algctx != NULL) {
             if (!ossl_assert(pctx->op.ciph.cipher != NULL))
                 goto err;
             rctx->op.ciph.algctx
                 = pctx->op.ciph.cipher->dupctx(pctx->op.ciph.algctx);
             if (rctx->op.ciph.algctx == NULL) {
                 EVP_ASYM_CIPHER_free(rctx->op.ciph.cipher);
                 rctx->op.ciph.cipher = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_KEM_OP(pctx)) {
         if (pctx->op.encap.kem != NULL) {
             rctx->op.encap.kem = pctx->op.encap.kem;
             if (!EVP_KEM_up_ref(rctx->op.encap.kem))
                 goto err;
         }
         if (pctx->op.encap.algctx != NULL) {
             if (!ossl_assert(pctx->op.encap.kem != NULL))
                 goto err;
             rctx->op.encap.algctx
                 = pctx->op.encap.kem->dupctx(pctx->op.encap.algctx);
             if (rctx->op.encap.algctx == NULL) {
                 EVP_KEM_free(rctx->op.encap.kem);
                 rctx->op.encap.kem = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_GEN_OP(pctx)) {
         /* Not supported - This would need a gen_dupctx() to work */
         goto err;
     }
 
     rctx->pmeth = pctx->pmeth;
 # ifndef OPENSSL_NO_ENGINE
     rctx->engine = pctx->engine;
 # endif
 
     if (pctx->peerkey != NULL)
         EVP_PKEY_up_ref(pctx->peerkey);
     rctx->peerkey = pctx->peerkey;
 
     if (pctx->pmeth == NULL) {
         if (rctx->operation == EVP_PKEY_OP_UNDEFINED) {
             EVP_KEYMGMT *tmp_keymgmt = pctx->keymgmt;
             void *provkey;
 
             provkey = evp_pkey_export_to_provider(pctx->pkey, pctx->libctx,
                                                   &tmp_keymgmt, pctx->propquery);
             if (provkey == NULL)
                 goto err;
             if (!EVP_KEYMGMT_up_ref(tmp_keymgmt))
                 goto err;
             EVP_KEYMGMT_free(rctx->keymgmt);
             rctx->keymgmt = tmp_keymgmt;
             return rctx;
         }
     } else if (pctx->pmeth->copy(rctx, pctx) > 0) {
         return rctx;
     }

[SEC] **new** commit 85407b77543a2d4330dbb40f6b8520ea0894a716
Date:   Thu Sep 2 16:39:21 2021 +1000

    Fix double free in EVP_PKEY_CTX_dup()
    
    If the internal operations dupctx() fails then a free is done (e.g. EVP_KEYEXCH_free()). If this is not set to NULL the EVP_PKEY_CTX_free() will do a double free.
    This was found by testing kdf_dupctx() in kdf_exch.c (Note this always
    fails since the internal KDF's do not have a dup method).
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16495)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -459,131 +459,135 @@
 EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
 {
     EVP_PKEY_CTX *rctx;
 
 # ifndef OPENSSL_NO_ENGINE
     /* Make sure it's safe to copy a pkey context using an ENGINE */
     if (pctx->engine && !ENGINE_init(pctx->engine)) {
         ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
         return 0;
     }
 # endif
     rctx = OPENSSL_zalloc(sizeof(*rctx));
     if (rctx == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     if (pctx->pkey != NULL)
         EVP_PKEY_up_ref(pctx->pkey);
     rctx->pkey = pctx->pkey;
     rctx->operation = pctx->operation;
     rctx->libctx = pctx->libctx;
     rctx->keytype = pctx->keytype;
     rctx->propquery = NULL;
     if (pctx->propquery != NULL) {
         rctx->propquery = OPENSSL_strdup(pctx->propquery);
         if (rctx->propquery == NULL)
             goto err;
     }
     rctx->legacy_keytype = pctx->legacy_keytype;
 
     if (EVP_PKEY_CTX_IS_DERIVE_OP(pctx)) {
         if (pctx->op.kex.exchange != NULL) {
             rctx->op.kex.exchange = pctx->op.kex.exchange;
             if (!EVP_KEYEXCH_up_ref(rctx->op.kex.exchange))
                 goto err;
         }
         if (pctx->op.kex.algctx != NULL) {
             if (!ossl_assert(pctx->op.kex.exchange != NULL))
                 goto err;
             rctx->op.kex.algctx
                 = pctx->op.kex.exchange->dupctx(pctx->op.kex.algctx);
             if (rctx->op.kex.algctx == NULL) {
                 EVP_KEYEXCH_free(rctx->op.kex.exchange);
+                rctx->op.kex.exchange = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_SIGNATURE_OP(pctx)) {
         if (pctx->op.sig.signature != NULL) {
             rctx->op.sig.signature = pctx->op.sig.signature;
             if (!EVP_SIGNATURE_up_ref(rctx->op.sig.signature))
                 goto err;
         }
         if (pctx->op.sig.algctx != NULL) {
             if (!ossl_assert(pctx->op.sig.signature != NULL))
                 goto err;
             rctx->op.sig.algctx
                 = pctx->op.sig.signature->dupctx(pctx->op.sig.algctx);
             if (rctx->op.sig.algctx == NULL) {
                 EVP_SIGNATURE_free(rctx->op.sig.signature);
+                rctx->op.sig.signature = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(pctx)) {
         if (pctx->op.ciph.cipher != NULL) {
             rctx->op.ciph.cipher = pctx->op.ciph.cipher;
             if (!EVP_ASYM_CIPHER_up_ref(rctx->op.ciph.cipher))
                 goto err;
         }
         if (pctx->op.ciph.algctx != NULL) {
             if (!ossl_assert(pctx->op.ciph.cipher != NULL))
                 goto err;
             rctx->op.ciph.algctx
                 = pctx->op.ciph.cipher->dupctx(pctx->op.ciph.algctx);
             if (rctx->op.ciph.algctx == NULL) {
                 EVP_ASYM_CIPHER_free(rctx->op.ciph.cipher);
+                rctx->op.ciph.cipher = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_KEM_OP(pctx)) {
         if (pctx->op.encap.kem != NULL) {
             rctx->op.encap.kem = pctx->op.encap.kem;
             if (!EVP_KEM_up_ref(rctx->op.encap.kem))
                 goto err;
         }
         if (pctx->op.encap.algctx != NULL) {
             if (!ossl_assert(pctx->op.encap.kem != NULL))
                 goto err;
             rctx->op.encap.algctx
                 = pctx->op.encap.kem->dupctx(pctx->op.encap.algctx);
             if (rctx->op.encap.algctx == NULL) {
                 EVP_KEM_free(rctx->op.encap.kem);
+                rctx->op.encap.kem = NULL;
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_GEN_OP(pctx)) {
         /* Not supported - This would need a gen_dupctx() to work */
         goto err;
     }
 
     rctx->pmeth = pctx->pmeth;
 # ifndef OPENSSL_NO_ENGINE
     rctx->engine = pctx->engine;
 # endif
 
     if (pctx->peerkey != NULL)
         EVP_PKEY_up_ref(pctx->peerkey);
     rctx->peerkey = pctx->peerkey;
 
     if (pctx->pmeth == NULL) {
         if (rctx->operation == EVP_PKEY_OP_UNDEFINED) {
             EVP_KEYMGMT *tmp_keymgmt = pctx->keymgmt;
             void *provkey;
 
             provkey = evp_pkey_export_to_provider(pctx->pkey, pctx->libctx,
                                                   &tmp_keymgmt, pctx->propquery);
             if (provkey == NULL)
                 goto err;
             if (!EVP_KEYMGMT_up_ref(tmp_keymgmt))
                 goto err;
             EVP_KEYMGMT_free(rctx->keymgmt);
             rctx->keymgmt = tmp_keymgmt;
             return rctx;
         }
     } else if (pctx->pmeth->copy(rctx, pctx) > 0) {
         return rctx;
     }

[INCR] **new** commit 7c14d0c1c0ece97f7406b4df466df6439146d6c6
Date:   Fri May 14 13:08:42 2021 +1000

    Rename the field 'provctx and data' to 'algctx' inside some objects containing
    pointers to provider size algorithm contexts.
    
    Fixes #14284
    
    The gettable_ctx_params methods were confusingly passing a 'provctx' and
    a provider context which are completely different objects.
    Some objects such as EVP_KDF used 'data' while others such as EVP_MD used 'provctx'.
    
    For libcrypto this 'ctx' is an opaque ptr returned when a providers algorithm
    implementation creates an internal context using a new_ctx() method.
    Hence the new name 'algctx'.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15275)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -455,131 +455,131 @@
 EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
 {
     EVP_PKEY_CTX *rctx;
 
 # ifndef OPENSSL_NO_ENGINE
     /* Make sure it's safe to copy a pkey context using an ENGINE */
     if (pctx->engine && !ENGINE_init(pctx->engine)) {
         ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
         return 0;
     }
 # endif
     rctx = OPENSSL_zalloc(sizeof(*rctx));
     if (rctx == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     if (pctx->pkey != NULL)
         EVP_PKEY_up_ref(pctx->pkey);
     rctx->pkey = pctx->pkey;
     rctx->operation = pctx->operation;
     rctx->libctx = pctx->libctx;
     rctx->keytype = pctx->keytype;
     rctx->propquery = NULL;
     if (pctx->propquery != NULL) {
         rctx->propquery = OPENSSL_strdup(pctx->propquery);
         if (rctx->propquery == NULL)
             goto err;
     }
     rctx->legacy_keytype = pctx->legacy_keytype;
 
     if (EVP_PKEY_CTX_IS_DERIVE_OP(pctx)) {
         if (pctx->op.kex.exchange != NULL) {
             rctx->op.kex.exchange = pctx->op.kex.exchange;
             if (!EVP_KEYEXCH_up_ref(rctx->op.kex.exchange))
                 goto err;
         }
-        if (pctx->op.kex.exchprovctx != NULL) {
+        if (pctx->op.kex.algctx != NULL) {
             if (!ossl_assert(pctx->op.kex.exchange != NULL))
                 goto err;
-            rctx->op.kex.exchprovctx
-                = pctx->op.kex.exchange->dupctx(pctx->op.kex.exchprovctx);
-            if (rctx->op.kex.exchprovctx == NULL) {
+            rctx->op.kex.algctx
+                = pctx->op.kex.exchange->dupctx(pctx->op.kex.algctx);
+            if (rctx->op.kex.algctx == NULL) {
                 EVP_KEYEXCH_free(rctx->op.kex.exchange);
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_SIGNATURE_OP(pctx)) {
         if (pctx->op.sig.signature != NULL) {
             rctx->op.sig.signature = pctx->op.sig.signature;
             if (!EVP_SIGNATURE_up_ref(rctx->op.sig.signature))
                 goto err;
         }
-        if (pctx->op.sig.sigprovctx != NULL) {
+        if (pctx->op.sig.algctx != NULL) {
             if (!ossl_assert(pctx->op.sig.signature != NULL))
                 goto err;
-            rctx->op.sig.sigprovctx
-                = pctx->op.sig.signature->dupctx(pctx->op.sig.sigprovctx);
-            if (rctx->op.sig.sigprovctx == NULL) {
+            rctx->op.sig.algctx
+                = pctx->op.sig.signature->dupctx(pctx->op.sig.algctx);
+            if (rctx->op.sig.algctx == NULL) {
                 EVP_SIGNATURE_free(rctx->op.sig.signature);
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(pctx)) {
         if (pctx->op.ciph.cipher != NULL) {
             rctx->op.ciph.cipher = pctx->op.ciph.cipher;
             if (!EVP_ASYM_CIPHER_up_ref(rctx->op.ciph.cipher))
                 goto err;
         }
-        if (pctx->op.ciph.ciphprovctx != NULL) {
+        if (pctx->op.ciph.algctx != NULL) {
             if (!ossl_assert(pctx->op.ciph.cipher != NULL))
                 goto err;
-            rctx->op.ciph.ciphprovctx
-                = pctx->op.ciph.cipher->dupctx(pctx->op.ciph.ciphprovctx);
-            if (rctx->op.ciph.ciphprovctx == NULL) {
+            rctx->op.ciph.algctx
+                = pctx->op.ciph.cipher->dupctx(pctx->op.ciph.algctx);
+            if (rctx->op.ciph.algctx == NULL) {
                 EVP_ASYM_CIPHER_free(rctx->op.ciph.cipher);
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_KEM_OP(pctx)) {
         if (pctx->op.encap.kem != NULL) {
             rctx->op.encap.kem = pctx->op.encap.kem;
             if (!EVP_KEM_up_ref(rctx->op.encap.kem))
                 goto err;
         }
-        if (pctx->op.encap.kemprovctx != NULL) {
+        if (pctx->op.encap.algctx != NULL) {
             if (!ossl_assert(pctx->op.encap.kem != NULL))
                 goto err;
-            rctx->op.encap.kemprovctx
-                = pctx->op.encap.kem->dupctx(pctx->op.encap.kemprovctx);
-            if (rctx->op.encap.kemprovctx == NULL) {
+            rctx->op.encap.algctx
+                = pctx->op.encap.kem->dupctx(pctx->op.encap.algctx);
+            if (rctx->op.encap.algctx == NULL) {
                 EVP_KEM_free(rctx->op.encap.kem);
                 goto err;
             }
             return rctx;
         }
     } else if (EVP_PKEY_CTX_IS_GEN_OP(pctx)) {
         /* Not supported - This would need a gen_dupctx() to work */
         goto err;
     }
 
     rctx->pmeth = pctx->pmeth;
 # ifndef OPENSSL_NO_ENGINE
     rctx->engine = pctx->engine;
 # endif
 
     if (pctx->peerkey != NULL)
         EVP_PKEY_up_ref(pctx->peerkey);
     rctx->peerkey = pctx->peerkey;
 
     if (pctx->pmeth == NULL) {
         if (rctx->operation == EVP_PKEY_OP_UNDEFINED) {
             EVP_KEYMGMT *tmp_keymgmt = pctx->keymgmt;
             void *provkey;
 
             provkey = evp_pkey_export_to_provider(pctx->pkey, pctx->libctx,
                                                   &tmp_keymgmt, pctx->propquery);
             if (provkey == NULL)
                 goto err;
             if (!EVP_KEYMGMT_up_ref(tmp_keymgmt))
                 goto err;
             EVP_KEYMGMT_free(rctx->keymgmt);
             rctx->keymgmt = tmp_keymgmt;
             return rctx;
         }
     } else if (pctx->pmeth->copy(rctx, pctx) > 0) {
         return rctx;
     }
commit e077455e9e57ed4ee4676996b4a9aa11df6327a6
Date:   Thu Sep 29 13:57:34 2022 +0200

    Stop raising ERR_R_MALLOC_FAILURE in most places
    
    Since OPENSSL_malloc() and friends report ERR_R_MALLOC_FAILURE, and
    at least handle the file name and line number they are called from,
    there's no need to report ERR_R_MALLOC_FAILURE where they are called
    directly, or when SSLfatal() and RLAYERfatal() is used, the reason
    `ERR_R_MALLOC_FAILURE` is changed to `ERR_R_CRYPTO_LIB`.
    
    There were a number of places where `ERR_R_MALLOC_FAILURE` was reported
    even though it was a function from a different sub-system that was
    called.  Those places are changed to report ERR_R_{lib}_LIB, where
    {lib} is the name of that sub-system.
    Some of them are tricky to get right, as we have a lot of functions
    that belong in the ASN1 sub-system, and all the `sk_` calls or from
    the CRYPTO sub-system.
    
    Some extra adaptation was necessary where there were custom OPENSSL_malloc()
    wrappers, and some bugs are fixed alongside these changes.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/19301)

diff --git a/providers/implementations/rands/drbg.c b/providers/implementations/rands/drbg.c
--- a/providers/implementations/rands/drbg.c
+++ b/providers/implementations/rands/drbg.c
@@ -145,44 +145,42 @@
 size_t ossl_drbg_get_seed(void *vdrbg, unsigned char **pout,
                           int entropy, size_t min_len,
                           size_t max_len, int prediction_resistance,
                           const unsigned char *adin, size_t adin_len)
 {
     PROV_DRBG *drbg = (PROV_DRBG *)vdrbg;
     size_t bytes_needed;
     unsigned char *buffer;
 
     /* Figure out how many bytes we need */
     bytes_needed = entropy >= 0 ? (entropy + 7) / 8 : 0;
     if (bytes_needed < min_len)
         bytes_needed = min_len;
     if (bytes_needed > max_len)
         bytes_needed = max_len;
 
     /* Allocate storage */
     buffer = OPENSSL_secure_malloc(bytes_needed);
-    if (buffer == NULL) {
-        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+    if (buffer == NULL)
         return 0;
-    }
 
     /*
      * Get random data.  Include our DRBG address as
      * additional input, in order to provide a distinction between
      * different DRBG child instances.
      *
      * Note: using the sizeof() operator on a pointer triggers
      *       a warning in some static code analyzers, but it's
      *       intentional and correct here.
      */
     if (!ossl_prov_drbg_generate(drbg, buffer, bytes_needed,
                                  drbg->strength, prediction_resistance,
                                  (unsigned char *)&drbg, sizeof(drbg))) {
         OPENSSL_secure_clear_free(buffer, bytes_needed);
         ERR_raise(ERR_LIB_PROV, PROV_R_GENERATE_ERROR);
         return 0;
     }
     *pout = buffer;
     return bytes_needed;
 }
 
 /* Implements the cleanup_entropy() callback */

[FUNC] **new** commit 335e85f54246cec8b58cb43dd2263ab9d506d622
Date:   Fri Feb 12 12:54:59 2021 +1000

    rand: update DRBGs to use the get_entropy call for seeding
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14162)

diff --git a/providers/implementations/rands/drbg.c b/providers/implementations/rands/drbg.c
--- a/providers/implementations/rands/drbg.c
+++ b/providers/implementations/rands/drbg.c
@@ -144,73 +144,44 @@
-static size_t prov_drbg_get_entropy(PROV_DRBG *drbg, unsigned char **pout,
-                                    int entropy, size_t min_len,
-                                    size_t max_len, int prediction_resistance)
+size_t ossl_drbg_get_seed(void *vdrbg, unsigned char **pout,
+                          int entropy, size_t min_len,
+                          size_t max_len, int prediction_resistance,
+                          const unsigned char *adin, size_t adin_len)
 {
-    unsigned int p_str;
-    size_t r, bytes_needed;
+    PROV_DRBG *drbg = (PROV_DRBG *)vdrbg;
+    size_t bytes_needed;
     unsigned char *buffer;
 
-    if (!get_parent_strength(drbg, &p_str))
-        return 0;
-    if (drbg->strength > p_str) {
-        /*
-         * We currently don't support the algorithm from NIST SP 800-90C
-         * 10.1.2 to use a weaker DRBG as source
-         */
-        ERR_raise(ERR_LIB_PROV, PROV_R_PARENT_STRENGTH_TOO_WEAK);
-        return 0;
-    }
-
-    if (drbg->parent_generate == NULL) {
-        ERR_raise(ERR_LIB_PROV, PROV_R_PARENT_CANNOT_GENERATE_RANDOM_NUMBERS);
-        return 0;
-    }
-
     /* Figure out how many bytes we need */
     bytes_needed = entropy >= 0 ? (entropy + 7) / 8 : 0;
     if (bytes_needed < min_len)
         bytes_needed = min_len;
     if (bytes_needed > max_len)
         bytes_needed = max_len;
 
     /* Allocate storage */
     buffer = OPENSSL_secure_malloc(bytes_needed);
     if (buffer == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
     /*
-     * Our lock is already held, but we need to lock our parent before
-     * generating bits from it.  Note: taking the lock will be a no-op
-     * if locking is not required (while drbg->parent->lock == NULL).
-     */
-    ossl_drbg_lock_parent(drbg);
-    /*
-     * Get random data from parent.  Include our DRBG address as
+     * Get random data.  Include our DRBG address as
      * additional input, in order to provide a distinction between
      * different DRBG child instances.
      *
      * Note: using the sizeof() operator on a pointer triggers
      *       a warning in some static code analyzers, but it's
      *       intentional and correct here.
      */
-    r = drbg->parent_generate(drbg->parent, buffer, bytes_needed,
-                              drbg->strength, prediction_resistance,
-                              (unsigned char *)&drbg,
-                              sizeof(drbg));
-    ossl_drbg_unlock_parent(drbg);
-    if (r == 0) {
+    if (!ossl_prov_drbg_generate(drbg, buffer, bytes_needed,
+                                 drbg->strength, prediction_resistance,
+                                 (unsigned char *)&drbg, sizeof(drbg))) {
         OPENSSL_secure_clear_free(buffer, bytes_needed);
         ERR_raise(ERR_LIB_PROV, PROV_R_GENERATE_ERROR);
         return 0;
     }
     *pout = buffer;
     return bytes_needed;
 }
 
-/*
- * Implements the cleanup_entropy() callback
- *
- */
-static void prov_drbg_cleanup_entropy(ossl_unused PROV_DRBG *drbg,
-                                      unsigned char *out, size_t outlen)
+/* Implements the cleanup_entropy() callback */
[FUNC] **new** commit 9ed185a926cc1b8527bba8efa28a6b15392484ce
Date:   Fri Feb 12 12:44:21 2021 +1000

    RNG seed: add get_entropy hook for seeding.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14162)

diff --git a/providers/implementations/rands/seed_src.c b/providers/implementations/rands/seed_src.c
--- a/providers/implementations/rands/seed_src.c
+++ b/providers/implementations/rands/seed_src.c
@@ -37,0 +37,1 @@
+static OSSL_FUNC_rand_get_seed_fn seed_get_seed;
commit cd3f8c1b11b0b9f4163bc8c62cbae38aec1b4030
Date:   Thu Feb 18 15:31:56 2021 -0500

    Always check CRYPTO_LOCK_{read,write}_lock
    
    Some functions that lock things are void, so we just return early.
    
    Also make ossl_namemap_empty return 0 on error.  Updated the docs, and added
    some code to ossl_namemap_stored() to handle the failure, and updated the
    tests to allow for failure.
    
    Fixes: #14230
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14238)

diff --git a/crypto/mem_sec.c b/crypto/mem_sec.c
--- a/crypto/mem_sec.c
+++ b/crypto/mem_sec.c
@@ -156,22 +157,23 @@
 void CRYPTO_secure_free(void *ptr, const char *file, int line)
 {
 #ifndef OPENSSL_NO_SECURE_MEMORY
     size_t actual_size;
 
     if (ptr == NULL)
         return;
     if (!CRYPTO_secure_allocated(ptr)) {
         CRYPTO_free(ptr, file, line);
         return;
     }
-    CRYPTO_THREAD_write_lock(sec_malloc_lock);
+    if (!CRYPTO_THREAD_write_lock(sec_malloc_lock))
+        return;
     actual_size = sh_actual_size(ptr);
     CLEAR(ptr, actual_size);
     secure_mem_used -= actual_size;
     sh_free(ptr);
     CRYPTO_THREAD_unlock(sec_malloc_lock);
 #else
     CRYPTO_free(ptr, file, line);
 #endif /* OPENSSL_NO_SECURE_MEMORY */
 }
 
commit cd3f8c1b11b0b9f4163bc8c62cbae38aec1b4030
Date:   Thu Feb 18 15:31:56 2021 -0500

    Always check CRYPTO_LOCK_{read,write}_lock
    
    Some functions that lock things are void, so we just return early.
    
    Also make ossl_namemap_empty return 0 on error.  Updated the docs, and added
    some code to ossl_namemap_stored() to handle the failure, and updated the
    tests to allow for failure.
    
    Fixes: #14230
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14238)

diff --git a/crypto/mem_sec.c b/crypto/mem_sec.c
--- a/crypto/mem_sec.c
+++ b/crypto/mem_sec.c
@@ -178,27 +180,28 @@
 void CRYPTO_secure_clear_free(void *ptr, size_t num,
                               const char *file, int line)
 {
 #ifndef OPENSSL_NO_SECURE_MEMORY
     size_t actual_size;
 
     if (ptr == NULL)
         return;
     if (!CRYPTO_secure_allocated(ptr)) {
         OPENSSL_cleanse(ptr, num);
         CRYPTO_free(ptr, file, line);
         return;
     }
-    CRYPTO_THREAD_write_lock(sec_malloc_lock);
+    if (!CRYPTO_THREAD_write_lock(sec_malloc_lock))
+        return;
     actual_size = sh_actual_size(ptr);
     CLEAR(ptr, actual_size);
     secure_mem_used -= actual_size;
     sh_free(ptr);
     CRYPTO_THREAD_unlock(sec_malloc_lock);
 #else
     if (ptr == NULL)
         return;
     OPENSSL_cleanse(ptr, num);
     CRYPTO_free(ptr, file, line);
 #endif /* OPENSSL_NO_SECURE_MEMORY */
 }
 
[FUNC] **new** commit 5c41cee225094e6298799b709278b0431643fb1f
Date:   Wed Jan 12 14:25:46 2022 +1100

    mem: do not produce usage counts when tsan is unavailable.
    
    Doing the tsan operations under lock would be difficult to arrange here (locks
    require memory allocation).
    
    Reviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
    (Merged from https://github.com/openssl/openssl/pull/17479)

diff --git a/crypto/mem.c b/crypto/mem.c
--- a/crypto/mem.c
+++ b/crypto/mem.c
@@ -24,5 +24,9 @@
 static CRYPTO_free_fn free_impl = CRYPTO_free;
 
 #if !defined(OPENSSL_NO_CRYPTO_MDEBUG) && !defined(FIPS_MODULE)
 # include "internal/tsan_assist.h"
 
+# ifdef TSAN_REQUIRES_LOCKING
+#  define INCREMENT(x) /* empty */
+#  define LOAD(x) 0
+# else  /* TSAN_REQUIRES_LOCKING */
[FUNC] **new** commit d8f6c533cfcbcad350c9cfb2c112eb9f938ba83c
Date:   Sun Sep 26 15:28:19 2021 +0800

    Fix return value of BIO_free
    
    CLA: trivial
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16682)

diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -125,33 +125,33 @@
 int BIO_free(BIO *a)
 {
     int ret;
 
     if (a == NULL)
         return 0;
 
     if (CRYPTO_DOWN_REF(&a->references, &ret, a->lock) <= 0)
         return 0;
 
     REF_PRINT_COUNT("BIO", a);
     if (ret > 0)
         return 1;
     REF_ASSERT_ISNT(ret < 0);
 
     if (HAS_CALLBACK(a)) {
         ret = (int)bio_call_callback(a, BIO_CB_FREE, NULL, 0, 0, 0L, 1L, NULL);
         if (ret <= 0)
-            return ret;
+            return 0;
     }
 
     if ((a->method != NULL) && (a->method->destroy != NULL))
         a->method->destroy(a);
 
     CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, a, &a->ex_data);
 
     CRYPTO_THREAD_lock_free(a->lock);
 
     OPENSSL_free(a);
 
     return 1;
 }
 

[FUNC] **new** commit 0800318a0c1f80ed838838951b0478cb977d40a6
Date:   Mon May 24 18:15:57 2021 +0200

    Deprecate old style BIO callback calls
    
    New style BIO_debug_callback_ex() function added to provide
    replacement for BIO_debug_callback().
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15440)

diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -115,33 +125,33 @@
 int BIO_free(BIO *a)
 {
     int ret;
 
     if (a == NULL)
         return 0;
 
     if (CRYPTO_DOWN_REF(&a->references, &ret, a->lock) <= 0)
         return 0;
 
     REF_PRINT_COUNT("BIO", a);
     if (ret > 0)
         return 1;
     REF_ASSERT_ISNT(ret < 0);
 
-    if (a->callback != NULL || a->callback_ex != NULL) {
+    if (HAS_CALLBACK(a)) {
         ret = (int)bio_call_callback(a, BIO_CB_FREE, NULL, 0, 0, 0L, 1L, NULL);
         if (ret <= 0)
             return ret;
     }
 
     if ((a->method != NULL) && (a->method->destroy != NULL))
         a->method->destroy(a);
 
     CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, a, &a->ex_data);
 
     CRYPTO_THREAD_lock_free(a->lock);
 
     OPENSSL_free(a);
 
     return 1;
 }
 
commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -1033,15 +1034,13 @@
 void EVP_MD_free(EVP_MD *md)
 {
     int i;
 
-    if (md == NULL)
+    if (md == NULL || md->origin != EVP_ORIG_DYNAMIC)
         return;
 
     CRYPTO_DOWN_REF(&md->refcnt, &i, md->lock);
     if (i > 0)
         return;
-    ossl_provider_free(md->prov);
-    CRYPTO_THREAD_lock_free(md->lock);
-    OPENSSL_free(md);
+    evp_md_free_int(md);
 }
 
[INCR] **new** commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -115,11 +115,9 @@
 void EVP_MD_CTX_free(EVP_MD_CTX *ctx)
 {
     if (ctx == NULL)
         return;
 
     EVP_MD_CTX_reset(ctx);
-
     OPENSSL_free(ctx);
-    return;
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -818,7 +818,8 @@
 void evp_md_free_int(EVP_MD *md)
 {
+    OPENSSL_free(md->type_name);
     ossl_provider_free(md->prov);
     CRYPTO_THREAD_lock_free(md->lock);
     OPENSSL_free(md);
 }
 

commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -794,0 +818,7 @@
+void evp_md_free_int(EVP_MD *md)
+{
+    ossl_provider_free(md->prov);
+    CRYPTO_THREAD_lock_free(md->lock);
+    OPENSSL_free(md);
+}
+
commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -794,4 +825,8 @@
 void EVP_MD_meth_free(EVP_MD *md)
 {
-    EVP_MD_free(md);
+    if (md == NULL || md->origin != EVP_ORIG_METH)
+       return;
+
+    evp_md_free_int(md);
 }
+
[FUNC] **new** commit 93429fc0ce9468242a463ff5878cd53b97e7f13f
Date:   Thu Jul 21 12:46:27 2022 +1000

    Coverity 1507376: Dereference after null check
    
    Reviewed-by: Hugo Landau <hlandau@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/18837)

diff --git a/crypto/sparse_array.c b/crypto/sparse_array.c
--- a/crypto/sparse_array.c
+++ b/crypto/sparse_array.c
@@ -110,6 +110,8 @@
 void ossl_sa_free(OPENSSL_SA *sa)
 {
-    sa_doall(sa, &sa_free_node, NULL, NULL);
-    OPENSSL_free(sa);
+    if (sa != NULL) {
+        sa_doall(sa, &sa_free_node, NULL, NULL);
+        OPENSSL_free(sa);
+    }
 }
 

commit ff0266eddc34e3f00494651e76bf46e6501dfc0b
Date:   Tue Mar 9 12:07:36 2021 +1000

    Add ossl_sa symbols
    
    Partial fix for #12964
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14473)

diff --git a/crypto/sparse_array.c b/crypto/sparse_array.c
--- a/crypto/sparse_array.c
+++ b/crypto/sparse_array.c
@@ -115,6 +115,6 @@
-void OPENSSL_SA_free(OPENSSL_SA *sa)
+void ossl_sa_free(OPENSSL_SA *sa)
 {
     sa_doall(sa, &sa_free_node, NULL, NULL);
     OPENSSL_free(sa);
 }
 
commit ff0266eddc34e3f00494651e76bf46e6501dfc0b
Date:   Tue Mar 9 12:07:36 2021 +1000

    Add ossl_sa symbols
    
    Partial fix for #12964
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14473)

diff --git a/crypto/sparse_array.c b/crypto/sparse_array.c
--- a/crypto/sparse_array.c
+++ b/crypto/sparse_array.c
@@ -121,7 +121,7 @@
-void OPENSSL_SA_free_leaves(OPENSSL_SA *sa)
+void ossl_sa_free_leaves(OPENSSL_SA *sa)
 {
     sa_doall(sa, &sa_free_node, &sa_free_leaf, NULL);
     OPENSSL_free(sa);
 }
 
 /* Wrap this in a structure to avoid compiler warnings */
commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -69,6 +69,8 @@
 void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)
 {
+    if (ctx == NULL)
+        return;
     EVP_CIPHER_CTX_reset(ctx);
     OPENSSL_free(ctx);
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1611,7 +1616,8 @@
 void evp_cipher_free_int(EVP_CIPHER *cipher)
 {
+    OPENSSL_free(cipher->type_name);
     ossl_provider_free(cipher->prov);
     CRYPTO_THREAD_lock_free(cipher->lock);
     OPENSSL_free(cipher);
 }
 

commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1609,0 +1611,7 @@
+void evp_cipher_free_int(EVP_CIPHER *cipher)
+{
+    ossl_provider_free(cipher->prov);
+    CRYPTO_THREAD_lock_free(cipher->lock);
+    OPENSSL_free(cipher);
+}
+
commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1609,15 +1618,13 @@
 void EVP_CIPHER_free(EVP_CIPHER *cipher)
 {
     int i;
 
-    if (cipher == NULL || cipher->prov == NULL)
+    if (cipher == NULL || cipher->origin != EVP_ORIG_DYNAMIC)
         return;
 
     CRYPTO_DOWN_REF(&cipher->refcnt, &i, cipher->lock);
     if (i > 0)
         return;
-    ossl_provider_free(cipher->prov);
-    CRYPTO_THREAD_lock_free(cipher->lock);
-    OPENSSL_free(cipher);
+    evp_cipher_free_int(cipher);
 }
 

commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1607,15 +1609,15 @@
 void EVP_CIPHER_free(EVP_CIPHER *cipher)
 {
     int i;
 
-    if (cipher == NULL)
+    if (cipher == NULL || cipher->prov == NULL)
         return;
 
     CRYPTO_DOWN_REF(&cipher->refcnt, &i, cipher->lock);
     if (i > 0)
         return;
     ossl_provider_free(cipher->prov);
     CRYPTO_THREAD_lock_free(cipher->lock);
     OPENSSL_free(cipher);
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -18,16 +19,17 @@
 static void evp_mac_free(void *vmac)
 {
     EVP_MAC *mac = vmac;
     int ref = 0;
 
     if (mac == NULL)
         return;
 
     CRYPTO_DOWN_REF(&mac->refcnt, &ref, mac->lock);
     if (ref > 0)
         return;
+    OPENSSL_free(mac->type_name);
     ossl_provider_free(mac->prov);
     CRYPTO_THREAD_lock_free(mac->lock);
     OPENSSL_free(mac);
 }
 
commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -486,61 +535,61 @@
 void ossl_provider_free(OSSL_PROVIDER *prov)
 {
     if (prov != NULL) {
         int ref = 0;
 
         CRYPTO_DOWN_REF(&prov->refcnt, &ref, prov->refcnt_lock);
 
         /*
          * When the refcount drops to zero, we clean up the provider.
          * Note that this also does teardown, which may seem late,
          * considering that init happens on first activation.  However,
          * there may be other structures hanging on to the provider after
          * the last deactivation and may therefore need full access to the
          * provider's services.  Therefore, we deinit late.
          */
         if (ref == 0) {
             if (prov->flag_initialized) {
                 ossl_provider_teardown(prov);
 #ifndef OPENSSL_NO_ERR
 # ifndef FIPS_MODULE
                 if (prov->error_strings != NULL) {
                     ERR_unload_strings(prov->error_lib, prov->error_strings);
                     OPENSSL_free(prov->error_strings);
                     prov->error_strings = NULL;
                 }
 # endif
 #endif
                 OPENSSL_free(prov->operation_bits);
                 prov->operation_bits = NULL;
                 prov->operation_bits_sz = 0;
                 prov->flag_initialized = 0;
             }
 
 #ifndef FIPS_MODULE
             /*
              * We deregister thread handling whether or not the provider was
              * initialized. If init was attempted but was not successful then
              * the provider may still have registered a thread handler.
              */
             ossl_init_thread_deregister(prov);
             DSO_free(prov->module);
 #endif
             OPENSSL_free(prov->name);
             OPENSSL_free(prov->path);
-            sk_INFOPAIR_pop_free(prov->parameters, free_infopair);
+            sk_INFOPAIR_pop_free(prov->parameters, infopair_free);
             CRYPTO_THREAD_lock_free(prov->opbits_lock);
             CRYPTO_THREAD_lock_free(prov->flag_lock);
 #ifndef HAVE_ATOMICS
             CRYPTO_THREAD_lock_free(prov->refcnt_lock);
 #endif
             OPENSSL_free(prov);
         }
 #ifndef FIPS_MODULE
         else if (prov->ischild) {
             ossl_provider_free_parent(prov, 0);
         }
 #endif
     }
 }
 
 /* Setters */

commit 8c627075656cf2709680eeb5aa1826f00db2e483
Date:   Thu Apr 29 16:37:42 2021 +0100

    Add support for child provider to up_ref/free their parent
    
    If the ref counts on a child provider change, then this needs to be
    reflected in the parent so we add callbacks to do this.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -375,56 +408,61 @@
 void ossl_provider_free(OSSL_PROVIDER *prov)
 {
     if (prov != NULL) {
         int ref = 0;
 
         CRYPTO_DOWN_REF(&prov->refcnt, &ref, prov->refcnt_lock);
 
         /*
          * When the refcount drops to zero, we clean up the provider.
          * Note that this also does teardown, which may seem late,
          * considering that init happens on first activation.  However,
          * there may be other structures hanging on to the provider after
          * the last deactivation and may therefore need full access to the
          * provider's services.  Therefore, we deinit late.
          */
         if (ref == 0) {
             if (prov->flag_initialized) {
                 ossl_provider_teardown(prov);
 #ifndef OPENSSL_NO_ERR
 # ifndef FIPS_MODULE
                 if (prov->error_strings != NULL) {
                     ERR_unload_strings(prov->error_lib, prov->error_strings);
                     OPENSSL_free(prov->error_strings);
                     prov->error_strings = NULL;
                 }
 # endif
 #endif
                 OPENSSL_free(prov->operation_bits);
                 prov->operation_bits = NULL;
                 prov->operation_bits_sz = 0;
                 prov->flag_initialized = 0;
             }
 
 #ifndef FIPS_MODULE
             /*
              * We deregister thread handling whether or not the provider was
              * initialized. If init was attempted but was not successful then
              * the provider may still have registered a thread handler.
              */
             ossl_init_thread_deregister(prov);
             DSO_free(prov->module);
 #endif
             OPENSSL_free(prov->name);
             OPENSSL_free(prov->path);
             sk_INFOPAIR_pop_free(prov->parameters, free_infopair);
             CRYPTO_THREAD_lock_free(prov->opbits_lock);
             CRYPTO_THREAD_lock_free(prov->flag_lock);
 #ifndef HAVE_ATOMICS
             CRYPTO_THREAD_lock_free(prov->refcnt_lock);
 #endif
             OPENSSL_free(prov);
         }
+#ifndef FIPS_MODULE
+        else if (prov->ischild) {
+            ossl_provider_free_parent(prov, 0);
+        }
+#endif
     }
 }
 
 /* Setters */

[FUNC] **new** commit f12a5690de906c05031f0195b6dec6925ff27231
Date:   Wed Apr 21 16:51:41 2021 +0100

    Add the concept of a child OSSL_LIB_CTX
    
    Add a child OSSL_LIB_CTX that will mirror the providers loaded into the
    parent libctx. This is useful for providers that want to use algorithms
    from other providers and just need to inherit the providers used by the
    application.
    
    Fixes #14925
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -348,57 +358,56 @@
 void ossl_provider_free(OSSL_PROVIDER *prov)
 {
     if (prov != NULL) {
         int ref = 0;
 
         CRYPTO_DOWN_REF(&prov->refcnt, &ref, prov->refcnt_lock);
 
         /*
          * When the refcount drops to zero, we clean up the provider.
          * Note that this also does teardown, which may seem late,
          * considering that init happens on first activation.  However,
          * there may be other structures hanging on to the provider after
          * the last deactivation and may therefore need full access to the
          * provider's services.  Therefore, we deinit late.
          */
         if (ref == 0) {
             if (prov->flag_initialized) {
-                if (prov->teardown != NULL)
-                    prov->teardown(prov->provctx);
+                ossl_provider_teardown(prov);
 #ifndef OPENSSL_NO_ERR
 # ifndef FIPS_MODULE
                 if (prov->error_strings != NULL) {
                     ERR_unload_strings(prov->error_lib, prov->error_strings);
                     OPENSSL_free(prov->error_strings);
                     prov->error_strings = NULL;
                 }
 # endif
 #endif
                 OPENSSL_free(prov->operation_bits);
                 prov->operation_bits = NULL;
                 prov->operation_bits_sz = 0;
                 prov->flag_initialized = 0;
             }
 
 #ifndef FIPS_MODULE
             /*
              * We deregister thread handling whether or not the provider was
              * initialized. If init was attempted but was not successful then
              * the provider may still have registered a thread handler.
              */
             ossl_init_thread_deregister(prov);
             DSO_free(prov->module);
 #endif
             OPENSSL_free(prov->name);
             OPENSSL_free(prov->path);
             sk_INFOPAIR_pop_free(prov->parameters, free_infopair);
             CRYPTO_THREAD_lock_free(prov->opbits_lock);
             CRYPTO_THREAD_lock_free(prov->flag_lock);
 #ifndef HAVE_ATOMICS
             CRYPTO_THREAD_lock_free(prov->refcnt_lock);
 #endif
             OPENSSL_free(prov);
         }
     }
 }
 
 /* Setters */

[CORR] **new** commit 2d5695016d880b9c6681f293ed5afb0379ce86b7
Date:   Fri Apr 23 16:18:28 2021 +0100

    Properly protect access to the provider flag_activated field
    
    This was not always locked when it should be.
    
    Fixes #15005
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15010)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -348,58 +345,57 @@
 void ossl_provider_free(OSSL_PROVIDER *prov)
 {
     if (prov != NULL) {
         int ref = 0;
 
         CRYPTO_DOWN_REF(&prov->refcnt, &ref, prov->refcnt_lock);
 
         /*
          * When the refcount drops to zero, we clean up the provider.
          * Note that this also does teardown, which may seem late,
          * considering that init happens on first activation.  However,
          * there may be other structures hanging on to the provider after
          * the last deactivation and may therefore need full access to the
          * provider's services.  Therefore, we deinit late.
          */
         if (ref == 0) {
             if (prov->flag_initialized) {
                 if (prov->teardown != NULL)
                     prov->teardown(prov->provctx);
 #ifndef OPENSSL_NO_ERR
 # ifndef FIPS_MODULE
                 if (prov->error_strings != NULL) {
                     ERR_unload_strings(prov->error_lib, prov->error_strings);
                     OPENSSL_free(prov->error_strings);
                     prov->error_strings = NULL;
                 }
 # endif
 #endif
                 OPENSSL_free(prov->operation_bits);
                 prov->operation_bits = NULL;
                 prov->operation_bits_sz = 0;
                 prov->flag_initialized = 0;
             }
 
 #ifndef FIPS_MODULE
             /*
              * We deregister thread handling whether or not the provider was
              * initialized. If init was attempted but was not successful then
              * the provider may still have registered a thread handler.
              */
             ossl_init_thread_deregister(prov);
             DSO_free(prov->module);
 #endif
             OPENSSL_free(prov->name);
             OPENSSL_free(prov->path);
             sk_INFOPAIR_pop_free(prov->parameters, free_infopair);
             CRYPTO_THREAD_lock_free(prov->opbits_lock);
             CRYPTO_THREAD_lock_free(prov->flag_lock);
 #ifndef HAVE_ATOMICS
             CRYPTO_THREAD_lock_free(prov->refcnt_lock);
-            CRYPTO_THREAD_lock_free(prov->activatecnt_lock);
 #endif
             OPENSSL_free(prov);
         }
     }
 }
 
 /* Setters */

[CORR] **new** commit ee067bc066ccc21462a1a489f8f1314c7207c01f
Date:   Tue Mar 16 12:03:08 2021 +0000

    Ensure we deregister thread handlers even after a failed init
    
    If we attempt to init a provider but that init fails, then we should
    still deregister any thread handlers. The provider may have failed after
    these were registered.
    
    Fixes #13338
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14576)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -345,55 +345,58 @@
 void ossl_provider_free(OSSL_PROVIDER *prov)
 {
     if (prov != NULL) {
         int ref = 0;
 
         CRYPTO_DOWN_REF(&prov->refcnt, &ref, prov->refcnt_lock);
 
         /*
          * When the refcount drops to zero, we clean up the provider.
          * Note that this also does teardown, which may seem late,
          * considering that init happens on first activation.  However,
          * there may be other structures hanging on to the provider after
          * the last deactivation and may therefore need full access to the
          * provider's services.  Therefore, we deinit late.
          */
         if (ref == 0) {
             if (prov->flag_initialized) {
-#ifndef FIPS_MODULE
-                ossl_init_thread_deregister(prov);
-#endif
                 if (prov->teardown != NULL)
                     prov->teardown(prov->provctx);
 #ifndef OPENSSL_NO_ERR
 # ifndef FIPS_MODULE
                 if (prov->error_strings != NULL) {
                     ERR_unload_strings(prov->error_lib, prov->error_strings);
                     OPENSSL_free(prov->error_strings);
                     prov->error_strings = NULL;
                 }
 # endif
 #endif
                 OPENSSL_free(prov->operation_bits);
                 prov->operation_bits = NULL;
                 prov->operation_bits_sz = 0;
                 prov->flag_initialized = 0;
             }
 
 #ifndef FIPS_MODULE
+            /*
+             * We deregister thread handling whether or not the provider was
+             * initialized. If init was attempted but was not successful then
+             * the provider may still have registered a thread handler.
+             */
+            ossl_init_thread_deregister(prov);
             DSO_free(prov->module);
 #endif
             OPENSSL_free(prov->name);
             OPENSSL_free(prov->path);
             sk_INFOPAIR_pop_free(prov->parameters, free_infopair);
             CRYPTO_THREAD_lock_free(prov->opbits_lock);
             CRYPTO_THREAD_lock_free(prov->flag_lock);
 #ifndef HAVE_ATOMICS
             CRYPTO_THREAD_lock_free(prov->refcnt_lock);
             CRYPTO_THREAD_lock_free(prov->activatecnt_lock);
 #endif
             OPENSSL_free(prov);
         }
     }
 }
 
 /* Setters */

[CORR] **new** commit c2ec2bb7c146d1e48568f27d11dca02c06c36338
Date:   Mon Mar 1 13:27:24 2021 +0100

    Make provider provider_init thread safe, and flag checking/setting too
    
    provider_init() makes changes in the provider structure, and needs a
    bit of protection to ensure that doesn't happen concurrently with race
    conditions.
    
    This also demands a bit of protection of the flags, since they are
    bits and presumably occupy the same byte in memory.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14354)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -336,54 +340,55 @@
 void ossl_provider_free(OSSL_PROVIDER *prov)
 {
     if (prov != NULL) {
         int ref = 0;
 
         CRYPTO_DOWN_REF(&prov->refcnt, &ref, prov->refcnt_lock);
 
         /*
          * When the refcount drops to zero, we clean up the provider.
          * Note that this also does teardown, which may seem late,
          * considering that init happens on first activation.  However,
          * there may be other structures hanging on to the provider after
          * the last deactivation and may therefore need full access to the
          * provider's services.  Therefore, we deinit late.
          */
         if (ref == 0) {
             if (prov->flag_initialized) {
 #ifndef FIPS_MODULE
                 ossl_init_thread_deregister(prov);
 #endif
                 if (prov->teardown != NULL)
                     prov->teardown(prov->provctx);
 #ifndef OPENSSL_NO_ERR
 # ifndef FIPS_MODULE
                 if (prov->error_strings != NULL) {
                     ERR_unload_strings(prov->error_lib, prov->error_strings);
                     OPENSSL_free(prov->error_strings);
                     prov->error_strings = NULL;
                 }
 # endif
 #endif
                 OPENSSL_free(prov->operation_bits);
                 prov->operation_bits = NULL;
                 prov->operation_bits_sz = 0;
                 prov->flag_initialized = 0;
             }
 
 #ifndef FIPS_MODULE
             DSO_free(prov->module);
 #endif
             OPENSSL_free(prov->name);
             OPENSSL_free(prov->path);
             sk_INFOPAIR_pop_free(prov->parameters, free_infopair);
             CRYPTO_THREAD_lock_free(prov->opbits_lock);
+            CRYPTO_THREAD_lock_free(prov->flag_lock);
 #ifndef HAVE_ATOMICS
             CRYPTO_THREAD_lock_free(prov->refcnt_lock);
             CRYPTO_THREAD_lock_free(prov->activatecnt_lock);
 #endif
             OPENSSL_free(prov);
         }
     }
 }
 
 /* Setters */
[CORR] **new** commit c59fc87b338880893286934f02c446854f5baabf
Date:   Fri Nov 5 13:42:40 2021 +0000

    Don't attempt to deactive child providers if we don't need to
    
    If a provider doesn't have any child providers then there is no need
    to attempt to remove them - so we should not do so. This removes some
    potentialy thread races.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/16980)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -229,8 +229,8 @@
 static void provider_deactivate_free(OSSL_PROVIDER *prov)
 {
     if (prov->flag_activated)
-        ossl_provider_deactivate(prov);
+        ossl_provider_deactivate(prov, 1);
     ossl_provider_free(prov);
 }
 
 #ifndef FIPS_MODULE

commit c1fb5e072fdeffc5b686e265283f0b31b1c37c3b
Date:   Fri May 7 11:03:59 2021 +0100

    Exclude child provider code from the FIPS module
    
    We don't need the child provider code in the FIPS module so we exclude
    it.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -145,7 +151,8 @@
 static void provider_deactivate_free(OSSL_PROVIDER *prov)
 {
     if (prov->flag_activated)
         ossl_provider_deactivate(prov);
     ossl_provider_free(prov);
 }
 
+#ifndef FIPS_MODULE
commit c1fb5e072fdeffc5b686e265283f0b31b1c37c3b
Date:   Fri May 7 11:03:59 2021 +0100

    Exclude child provider code from the FIPS module
    
    We don't need the child provider code in the FIPS module so we exclude
    it.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -152,5 +159,6 @@
 static void ossl_provider_child_cb_free(OSSL_PROVIDER_CHILD_CB *cb)
 {
     OPENSSL_free(cb);
 }
+#endif
 

commit 7b88c184b66c0d7cfb1f76422448af6a636eea8c
Date:   Fri Apr 23 12:08:27 2021 +0100

    Register callbacks with core for child provider creation/deletion
    
    By adding callbacks to the core this will enable (in future commits) the
    ability to add/remove child providers as the providers are added/removed
    from the parent libctx.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -140,0 +149,5 @@
+static void ossl_provider_child_cb_free(OSSL_PROVIDER_CHILD_CB *cb)
+{
+    OPENSSL_free(cb);
+}
+
commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -169,0 +164,7 @@
+static void infopair_free(INFOPAIR *pair)
+{
+    OPENSSL_free(pair->name);
+    OPENSSL_free(pair->value);
+    OPENSSL_free(pair);
+}
+
commit 927d0566ded0dff9d6c5abc8a40bb84068446b76
Date:   Mon Mar 14 08:13:12 2022 +0000

    Refactor OSSL_LIB_CTX to avoid using CRYPTO_EX_DATA
    
    This refactors OSSL_LIB_CTX to avoid using CRYPTO_EX_DATA. The assorted
    objects to be managed by OSSL_LIB_CTX are hardcoded and are initialized
    eagerly rather than lazily, which avoids the need for locking on access
    in most cases.
    
    Fixes #17116.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/17881)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -280,22 +281,22 @@
-static void provider_store_free(void *vstore)
+void ossl_provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
     size_t i;
 
     if (store == NULL)
         return;
     store->freeing = 1;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
 #ifndef FIPS_MODULE
     sk_OSSL_PROVIDER_CHILD_CB_pop_free(store->child_cbs,
                                        ossl_provider_child_cb_free);
 #endif
     CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
     for (i = 0; i < store->numprovinfo; i++)
         ossl_provider_info_clear(&store->provinfo[i]);
     OPENSSL_free(store->provinfo);
     OPENSSL_free(store);
 }
 

commit 352d482a2990cc04adff48aeda9c080d4a839f1e
Date:   Fri Jun 18 15:56:54 2021 +0100

    Instantiate configuration supplied providers when we need them
    
    If provider specified in a config file are not "activated" then we defer
    instantiating the provider object until it is actually needed.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -169,22 +201,22 @@
 static void provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
     size_t i;
 
     if (store == NULL)
         return;
     store->freeing = 1;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
 #ifndef FIPS_MODULE
     sk_OSSL_PROVIDER_CHILD_CB_pop_free(store->child_cbs,
                                        ossl_provider_child_cb_free);
 #endif
     CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
     for (i = 0; i < store->numprovinfo; i++)
-        OPENSSL_free(store->provinfo[i].name);
+        ossl_provider_info_clear(&store->provinfo[i]);
     OPENSSL_free(store->provinfo);
     OPENSSL_free(store);
 }
 

commit 1d74203cf5d8542d349fbb2d5f35ad40994dec9f
Date:   Fri Jun 18 12:28:40 2021 +0100

    Instantiate user-added builtin providers when we need them
    
    Previously we created the provider object for builtin providers at the
    point that OPENSSL_add_builtin() was called. Instead we delay that until
    the provider is actually loaded.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15854)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -166,18 +169,22 @@
 static void provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
+    size_t i;
 
     if (store == NULL)
         return;
     store->freeing = 1;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
 #ifndef FIPS_MODULE
     sk_OSSL_PROVIDER_CHILD_CB_pop_free(store->child_cbs,
                                        ossl_provider_child_cb_free);
 #endif
     CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
+    for (i = 0; i < store->numprovinfo; i++)
+        OPENSSL_free(store->provinfo[i].name);
+    OPENSSL_free(store->provinfo);
     OPENSSL_free(store);
 }
 

commit c1fb5e072fdeffc5b686e265283f0b31b1c37c3b
Date:   Fri May 7 11:03:59 2021 +0100

    Exclude child provider code from the FIPS module
    
    We don't need the child provider code in the FIPS module so we exclude
    it.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -157,16 +165,18 @@
 static void provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
 
     if (store == NULL)
         return;
     store->freeing = 1;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
+#ifndef FIPS_MODULE
     sk_OSSL_PROVIDER_CHILD_CB_pop_free(store->child_cbs,
                                        ossl_provider_child_cb_free);
+#endif
     CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
     OPENSSL_free(store);
 }
 

commit 7b88c184b66c0d7cfb1f76422448af6a636eea8c
Date:   Fri Apr 23 12:08:27 2021 +0100

    Register callbacks with core for child provider creation/deletion
    
    By adding callbacks to the core this will enable (in future commits) the
    ability to add/remove child providers as the providers are added/removed
    from the parent libctx.
    
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14991)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -140,14 +154,16 @@
 static void provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
 
     if (store == NULL)
         return;
     store->freeing = 1;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
+    sk_OSSL_PROVIDER_CHILD_CB_pop_free(store->child_cbs,
+                                       ossl_provider_child_cb_free);
     CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
     OPENSSL_free(store);
 }
 

[FUNC] **new** commit 0090e50890ce7691f7d6ba4a301b17c2ce58a204
Date:   Tue Apr 27 15:17:25 2021 +1000

    provider: flush the store cache when providers are loaded/unloaded.
    
    When the providers change, the method cache needs to be flushed.  This also
    impacts the cache is full partial flushes and the algorithm flushing by ID.
    
    A new function is introduced to clear all of the operation bits in all
    providers in a library context.
    
    Fixes #15032
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15042)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -134,13 +135,14 @@
 static void provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
 
     if (store == NULL)
         return;
+    store->freeing = 1;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
     CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
     OPENSSL_free(store);
 }
 

commit 86522324d2a398ad3ed2f648a66b62b0a6176258
Date:   Mon Mar 22 23:44:22 2021 +0100

    Adds a new lock to read default_path and uses a strdup() on default_path before using it
    Fixes #14483
    Signed-off-by: Sahana Prasad <sahana@redhat.com>
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14650)

diff --git a/crypto/provider_core.c b/crypto/provider_core.c
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -135,12 +136,13 @@
 static void provider_store_free(void *vstore)
 {
     struct provider_store_st *store = vstore;
 
     if (store == NULL)
         return;
     OPENSSL_free(store->default_path);
     sk_OSSL_PROVIDER_pop_free(store->providers, provider_deactivate_free);
+    CRYPTO_THREAD_lock_free(store->default_path_lock);
     CRYPTO_THREAD_lock_free(store->lock);
     OPENSSL_free(store);
 }
 
commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -115,11 +115,9 @@
 void EVP_MD_CTX_free(EVP_MD_CTX *ctx)
 {
     if (ctx == NULL)
         return;
 
     EVP_MD_CTX_reset(ctx);
-
     OPENSSL_free(ctx);
-    return;
 }
 
commit f6c95e46c03025b2694241e1ad785d8bd3ac083b
Date:   Tue Feb 16 17:51:56 2021 -0500

    Add "origin" field to EVP_CIPHER, EVP_MD
    
    Add a "where did this EVP_{CIPHER,MD} come from" flag: global, via fetch,
    or via EVP_{CIPHER,MD}_meth_new.  Update EVP_{CIPHER,MD}_free to handle all
    three origins. The flag is deliberately right before some function pointers,
    so that compile-time failures (int/pointer) will occur, as opposed to
    taking a bit in the existing "flags" field.  The "global variable" flag
    is non-zero, so the default case of using OPENSSL_zalloc (for provider
    ciphers), will do the right thing. Ref-counting is a no-op for
    Make up_ref no-op for global MD and CIPHER objects
    
    Deprecate EVP_MD_CTX_md().  Added EVP_MD_CTX_get0_md() (same semantics as
    the deprecated function) and EVP_MD_CTX_get1_md().  Likewise, deprecate
    EVP_CIPHER_CTX_cipher() in favor of EVP_CIPHER_CTX_get0_cipher(), and add
    EVP_CIPHER_CTX_get1_CIPHER().
    
    Refactor EVP_MD_free() and EVP_MD_meth_free() to call new common
    evp_md_free_int() function.
    Refactor EVP_CIPHER_free() and EVP_CIPHER_meth_free() to call new common
    evp_cipher_free_int() function.
    
    Also change some flags tests to explicit test == or != zero. E.g.,
            if (flags & x) --> if ((flags & x) != 0)
            if (!(flags & x)) --> if ((flags & x) == 0)
    Only done for those lines where "get0_cipher" calls were made.
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -1033,15 +1034,13 @@
 void EVP_MD_free(EVP_MD *md)
 {
     int i;
 
-    if (md == NULL)
+    if (md == NULL || md->origin != EVP_ORIG_DYNAMIC)
         return;
 
     CRYPTO_DOWN_REF(&md->refcnt, &i, md->lock);
     if (i > 0)
         return;
-    ossl_provider_free(md->prov);
-    CRYPTO_THREAD_lock_free(md->lock);
-    OPENSSL_free(md);
+    evp_md_free_int(md);
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -300,15 +303,16 @@
 void EVP_KEM_free(EVP_KEM *kem)
 {
     int i;
 
     if (kem == NULL)
         return;
 
     CRYPTO_DOWN_REF(&kem->refcnt, &i, kem->lock);
     if (i > 0)
         return;
+    OPENSSL_free(kem->type_name);
     ossl_provider_free(kem->prov);
     CRYPTO_THREAD_lock_free(kem->lock);
     OPENSSL_free(kem);
 }
 

commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -300,14 +300,15 @@
 void EVP_KEM_free(EVP_KEM *kem)
 {
-    if (kem != NULL) {
-        int i;
-
-        CRYPTO_DOWN_REF(&kem->refcnt, &i, kem->lock);
-        if (i > 0)
-            return;
-        ossl_provider_free(kem->prov);
-        CRYPTO_THREAD_lock_free(kem->lock);
-        OPENSSL_free(kem);
-    }
+    int i;
+
+    if (kem == NULL)
+        return;
+
+    CRYPTO_DOWN_REF(&kem->refcnt, &i, kem->lock);
+    if (i > 0)
+        return;
+    ossl_provider_free(kem->prov);
+    CRYPTO_THREAD_lock_free(kem->lock);
+    OPENSSL_free(kem);
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -229,15 +233,16 @@
 void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt)
 {
     int ref = 0;
 
     if (keymgmt == NULL)
         return;
 
     CRYPTO_DOWN_REF(&keymgmt->refcnt, &ref, keymgmt->lock);
     if (ref > 0)
         return;
+    OPENSSL_free(keymgmt->type_name);
     ossl_provider_free(keymgmt->prov);
     CRYPTO_THREAD_lock_free(keymgmt->lock);
     OPENSSL_free(keymgmt);
 }
 
commit b574c6a9ac96825b4f19c5e835273bf176174af8
Date:   Wed Feb 24 16:38:28 2021 +0000

    Cache legacy keys instead of downgrading them
    
    If someone calls an EVP_PKEY_get0*() function then we create a legacy
    key and cache it in the EVP_PKEY - but it doesn't become an "origin" and
    it doesn't ever get updated. This will be documented as a restriction of
    the EVP_PKEY_get0*() function with provided keys.
    
    Fixes #14020
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14319)

diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -1560,16 +1518,36 @@
 void evp_pkey_free_legacy(EVP_PKEY *x)
 {
-    if (x->ameth != NULL) {
-        if (x->ameth->pkey_free != NULL)
-            x->ameth->pkey_free(x);
+    const EVP_PKEY_ASN1_METHOD *ameth = x->ameth;
+    ENGINE *tmpe = NULL;
+
+    if (ameth == NULL && x->legacy_cache_pkey.ptr != NULL)
+        ameth = EVP_PKEY_asn1_find(&tmpe, x->type);
+
+    if (ameth != NULL) {
+        if (x->legacy_cache_pkey.ptr != NULL) {
+            /*
+             * We should never have both a legacy origin key, and a key in the
+             * legacy cache.
+             */
+            assert(x->pkey.ptr == NULL);
+            /*
+             * For the purposes of freeing we make the legacy cache look like
+             * a legacy origin key.
+             */
+            x->pkey = x->legacy_cache_pkey;
+            x->legacy_cache_pkey.ptr = NULL;
+        }
+        if (ameth->pkey_free != NULL)
+            ameth->pkey_free(x);
         x->pkey.ptr = NULL;
     }
 # ifndef OPENSSL_NO_ENGINE
+    ENGINE_finish(tmpe);
     ENGINE_finish(x->engine);
     x->engine = NULL;
     ENGINE_finish(x->pmeth_engine);
     x->pmeth_engine = NULL;
 # endif
 }
 #endif  /* FIPS_MODULE */
 
commit 7c14d0c1c0ece97f7406b4df466df6439146d6c6
Date:   Fri May 14 13:08:42 2021 +1000

    Rename the field 'provctx and data' to 'algctx' inside some objects containing
    pointers to provider size algorithm contexts.
    
    Fixes #14284
    
    The gettable_ctx_params methods were confusingly passing a 'provctx' and
    a provider context which are completely different objects.
    Some objects such as EVP_KDF used 'data' while others such as EVP_MD used 'provctx'.
    
    For libcrypto this 'ctx' is an opaque ptr returned when a providers algorithm
    implementation creates an internal context using a new_ctx() method.
    Hence the new name 'algctx'.
    
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    Reviewed-by: Paul Dale <pauli@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/15275)

diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -360,33 +360,33 @@
 void evp_pkey_ctx_free_old_ops(EVP_PKEY_CTX *ctx)
 {
     if (EVP_PKEY_CTX_IS_SIGNATURE_OP(ctx)) {
-        if (ctx->op.sig.sigprovctx != NULL && ctx->op.sig.signature != NULL)
-            ctx->op.sig.signature->freectx(ctx->op.sig.sigprovctx);
+        if (ctx->op.sig.algctx != NULL && ctx->op.sig.signature != NULL)
+            ctx->op.sig.signature->freectx(ctx->op.sig.algctx);
         EVP_SIGNATURE_free(ctx->op.sig.signature);
-        ctx->op.sig.sigprovctx = NULL;
+        ctx->op.sig.algctx = NULL;
         ctx->op.sig.signature = NULL;
     } else if (EVP_PKEY_CTX_IS_DERIVE_OP(ctx)) {
-        if (ctx->op.kex.exchprovctx != NULL && ctx->op.kex.exchange != NULL)
-            ctx->op.kex.exchange->freectx(ctx->op.kex.exchprovctx);
+        if (ctx->op.kex.algctx != NULL && ctx->op.kex.exchange != NULL)
+            ctx->op.kex.exchange->freectx(ctx->op.kex.algctx);
         EVP_KEYEXCH_free(ctx->op.kex.exchange);
-        ctx->op.kex.exchprovctx = NULL;
+        ctx->op.kex.algctx = NULL;
         ctx->op.kex.exchange = NULL;
     } else if (EVP_PKEY_CTX_IS_KEM_OP(ctx)) {
-        if (ctx->op.encap.kemprovctx != NULL && ctx->op.encap.kem != NULL)
-            ctx->op.encap.kem->freectx(ctx->op.encap.kemprovctx);
+        if (ctx->op.encap.algctx != NULL && ctx->op.encap.kem != NULL)
+            ctx->op.encap.kem->freectx(ctx->op.encap.algctx);
         EVP_KEM_free(ctx->op.encap.kem);
-        ctx->op.encap.kemprovctx = NULL;
+        ctx->op.encap.algctx = NULL;
         ctx->op.encap.kem = NULL;
     }
     else if (EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(ctx)) {
-        if (ctx->op.ciph.ciphprovctx != NULL && ctx->op.ciph.cipher != NULL)
-            ctx->op.ciph.cipher->freectx(ctx->op.ciph.ciphprovctx);
+        if (ctx->op.ciph.algctx != NULL && ctx->op.ciph.cipher != NULL)
+            ctx->op.ciph.cipher->freectx(ctx->op.ciph.algctx);
         EVP_ASYM_CIPHER_free(ctx->op.ciph.cipher);
-        ctx->op.ciph.ciphprovctx = NULL;
+        ctx->op.ciph.algctx = NULL;
         ctx->op.ciph.cipher = NULL;
     } else if (EVP_PKEY_CTX_IS_GEN_OP(ctx)) {
         if (ctx->op.keymgmt.genctx != NULL && ctx->keymgmt != NULL)
             evp_keymgmt_gen_cleanup(ctx->keymgmt, ctx->op.keymgmt.genctx);
     }
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/signature.c b/crypto/evp/signature.c
--- a/crypto/evp/signature.c
+++ b/crypto/evp/signature.c
@@ -276,14 +279,15 @@
 void EVP_SIGNATURE_free(EVP_SIGNATURE *signature)
 {
     int i;
 
     if (signature == NULL)
         return;
     CRYPTO_DOWN_REF(&signature->refcnt, &i, signature->lock);
     if (i > 0)
         return;
+    OPENSSL_free(signature->type_name);
     ossl_provider_free(signature->prov);
     CRYPTO_THREAD_lock_free(signature->lock);
     OPENSSL_free(signature);
 }
 

commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/signature.c b/crypto/evp/signature.c
--- a/crypto/evp/signature.c
+++ b/crypto/evp/signature.c
@@ -276,14 +276,14 @@
 void EVP_SIGNATURE_free(EVP_SIGNATURE *signature)
 {
-    if (signature != NULL) {
-        int i;
+    int i;
 
-        CRYPTO_DOWN_REF(&signature->refcnt, &i, signature->lock);
-        if (i > 0)
-            return;
-        ossl_provider_free(signature->prov);
-        CRYPTO_THREAD_lock_free(signature->lock);
-        OPENSSL_free(signature);
-    }
+    if (signature == NULL)
+        return;
+    CRYPTO_DOWN_REF(&signature->refcnt, &i, signature->lock);
+    if (i > 0)
+        return;
+    ossl_provider_free(signature->prov);
+    CRYPTO_THREAD_lock_free(signature->lock);
+    OPENSSL_free(signature);
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/exchange.c b/crypto/evp/exchange.c
--- a/crypto/evp/exchange.c
+++ b/crypto/evp/exchange.c
@@ -143,14 +146,15 @@
 void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange)
 {
     int i;
 
     if (exchange == NULL)
         return;
     CRYPTO_DOWN_REF(&exchange->refcnt, &i, exchange->lock);
     if (i > 0)
         return;
+    OPENSSL_free(exchange->type_name);
     ossl_provider_free(exchange->prov);
     CRYPTO_THREAD_lock_free(exchange->lock);
     OPENSSL_free(exchange);
 }
 

commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/exchange.c b/crypto/evp/exchange.c
--- a/crypto/evp/exchange.c
+++ b/crypto/evp/exchange.c
@@ -143,14 +143,14 @@
 void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange)
 {
-    if (exchange != NULL) {
-        int i;
-
-        CRYPTO_DOWN_REF(&exchange->refcnt, &i, exchange->lock);
-        if (i > 0)
-            return;
-        ossl_provider_free(exchange->prov);
-        CRYPTO_THREAD_lock_free(exchange->lock);
-        OPENSSL_free(exchange);
-    }
+    int i;
+
+    if (exchange == NULL)
+        return;
+    CRYPTO_DOWN_REF(&exchange->refcnt, &i, exchange->lock);
+    if (i > 0)
+        return;
+    ossl_provider_free(exchange->prov);
+    CRYPTO_THREAD_lock_free(exchange->lock);
+    OPENSSL_free(exchange);
 }
 
commit 6c9bc258d2e9e7b500236a1c696da1f384f0b907
Date:   Fri Apr 16 16:22:03 2021 +0200

    Add type_name member to provided methods and use it
    
    Fixes #14701
    
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14898)

diff --git a/crypto/evp/asymcipher.c b/crypto/evp/asymcipher.c
--- a/crypto/evp/asymcipher.c
+++ b/crypto/evp/asymcipher.c
@@ -392,14 +395,15 @@
 void EVP_ASYM_CIPHER_free(EVP_ASYM_CIPHER *cipher)
 {
     int i;
 
     if (cipher == NULL)
         return;
     CRYPTO_DOWN_REF(&cipher->refcnt, &i, cipher->lock);
     if (i > 0)
         return;
+    OPENSSL_free(cipher->type_name);
     ossl_provider_free(cipher->prov);
     CRYPTO_THREAD_lock_free(cipher->lock);
     OPENSSL_free(cipher);
 }
 

commit 543e740b95e303790f8fe6ec59458b4ecdcfb56c
Date:   Mon Feb 15 12:31:36 2021 -0500

    Standard style for all EVP_xxx_free routines
    
    Reviewed-by: Matt Caswell <matt@openssl.org>
    Reviewed-by: Richard Levitte <levitte@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/14193)

diff --git a/crypto/evp/asymcipher.c b/crypto/evp/asymcipher.c
--- a/crypto/evp/asymcipher.c
+++ b/crypto/evp/asymcipher.c
@@ -392,14 +392,14 @@
 void EVP_ASYM_CIPHER_free(EVP_ASYM_CIPHER *cipher)
 {
-    if (cipher != NULL) {
-        int i;
-
-        CRYPTO_DOWN_REF(&cipher->refcnt, &i, cipher->lock);
-        if (i > 0)
-            return;
-        ossl_provider_free(cipher->prov);
-        CRYPTO_THREAD_lock_free(cipher->lock);
-        OPENSSL_free(cipher);
-    }
+    int i;
+
+    if (cipher == NULL)
+        return;
+    CRYPTO_DOWN_REF(&cipher->refcnt, &i, cipher->lock);
+    if (i > 0)
+        return;
+    ossl_provider_free(cipher->prov);
+    CRYPTO_THREAD_lock_free(cipher->lock);
+    OPENSSL_free(cipher);
 }
 
commit 335e85f54246cec8b58cb43dd2263ab9d506d622
Date:   Fri Feb 12 12:54:59 2021 +1000

    rand: update DRBGs to use the get_entropy call for seeding
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14162)

diff --git a/providers/implementations/rands/drbg.c b/providers/implementations/rands/drbg.c
--- a/providers/implementations/rands/drbg.c
+++ b/providers/implementations/rands/drbg.c
@@ -211,10 +188,6 @@
-/*
- * Implements the cleanup_entropy() callback
- *
- */
-static void prov_drbg_cleanup_entropy(ossl_unused PROV_DRBG *drbg,
-                                      unsigned char *out, size_t outlen)
+void ossl_drbg_clear_seed(ossl_unused void *vdrbg,
+                          unsigned char *out, size_t outlen)
 {
     OPENSSL_secure_clear_free(out, outlen);
 }
 
commit 9ed185a926cc1b8527bba8efa28a6b15392484ce
Date:   Fri Feb 12 12:44:21 2021 +1000

    RNG seed: add get_entropy hook for seeding.
    
    Reviewed-by: Shane Lontis <shane.lontis@oracle.com>
    (Merged from https://github.com/openssl/openssl/pull/14162)

diff --git a/providers/implementations/rands/seed_src.c b/providers/implementations/rands/seed_src.c
--- a/providers/implementations/rands/seed_src.c
+++ b/providers/implementations/rands/seed_src.c
@@ -37,1 +38,2 @@
+static OSSL_FUNC_rand_clear_seed_fn seed_clear_seed;
 
