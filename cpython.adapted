[INCR] **new** commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -1949,47 +1283,47 @@
 pymalloc_alloc(void *Py_UNUSED(ctx), size_t nbytes)
 {
 #ifdef WITH_VALGRIND
     if (UNLIKELY(running_on_valgrind == -1)) {
         running_on_valgrind = RUNNING_ON_VALGRIND;
     }
     if (UNLIKELY(running_on_valgrind)) {
         return NULL;
     }
 #endif
 
     if (UNLIKELY(nbytes == 0)) {
         return NULL;
     }
     if (UNLIKELY(nbytes > SMALL_REQUEST_THRESHOLD)) {
         return NULL;
     }
 
     uint size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;
     poolp pool = usedpools[size + size];
-    block *bp;
+    pymem_block *bp;
 
     if (LIKELY(pool != pool->nextpool)) {
         /*
          * There is a used pool for this size class.
          * Pick up the head block of its free list.
          */
         ++pool->ref.count;
         bp = pool->freeblock;
         assert(bp != NULL);
 
-        if (UNLIKELY((pool->freeblock = *(block **)bp) == NULL)) {
+        if (UNLIKELY((pool->freeblock = *(pymem_block **)bp) == NULL)) {
             // Reached the end of the free list, try to extend it.
             pymalloc_pool_extend(pool, size);
         }
     }
     else {
         /* There isn't a pool of the right size class immediately
          * available:  use a free pool.
          */
         bp = allocate_from_new_pool(size);
     }
 
     return (void *)bp;
 }
 
 

[INCR] **new** commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -1948,47 +1949,47 @@
-pymalloc_alloc(void *ctx, size_t nbytes)
+pymalloc_alloc(void *Py_UNUSED(ctx), size_t nbytes)
 {
 #ifdef WITH_VALGRIND
     if (UNLIKELY(running_on_valgrind == -1)) {
         running_on_valgrind = RUNNING_ON_VALGRIND;
     }
     if (UNLIKELY(running_on_valgrind)) {
         return NULL;
     }
 #endif
 
     if (UNLIKELY(nbytes == 0)) {
         return NULL;
     }
     if (UNLIKELY(nbytes > SMALL_REQUEST_THRESHOLD)) {
         return NULL;
     }
 
     uint size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;
     poolp pool = usedpools[size + size];
     block *bp;
 
     if (LIKELY(pool != pool->nextpool)) {
         /*
          * There is a used pool for this size class.
          * Pick up the head block of its free list.
          */
         ++pool->ref.count;
         bp = pool->freeblock;
         assert(bp != NULL);
 
         if (UNLIKELY((pool->freeblock = *(block **)bp) == NULL)) {
             // Reached the end of the free list, try to extend it.
             pymalloc_pool_extend(pool, size);
         }
     }
     else {
         /* There isn't a pool of the right size class immediately
          * available:  use a free pool.
          */
         bp = allocate_from_new_pool(size);
     }
 
     return (void *)bp;
 }
 
 
[FUNC] **new** commit 8319114feedd2a5b77378bba24eb9fb2689c5033
Date:   Tue Dec 7 16:02:53 2021 +0000

    bpo-45947: Place dict and values pointer at fixed (negative) offset just before GC header. (GH-29879)
    
    * Place __dict__ immediately before GC header for plain Python objects.
    
    * Fix up lazy dict creation logic to use managed dict pointers.
    
    * Manage values pointer, placing them directly before managed dict pointers.
    
    * Convert hint-based load/store attr specialization target managed dict classes.
    
    * Specialize LOAD_METHOD for managed dict objects.
    
    * Remove unsafe _PyObject_GC_Calloc function.
    
    * Remove unsafe _PyObject_GC_Malloc() function.
    
    * Add comment explaning use of Py_TPFLAGS_MANAGED_DICT.

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2273,12 +2258,18 @@
-PyObject *
-_PyObject_GC_Malloc(size_t basicsize)
-{
-    return _PyObject_GC_Alloc(0, basicsize);
-}
-
-PyObject *
-_PyObject_GC_Calloc(size_t basicsize)
+gc_alloc(size_t basicsize, size_t presize)
 {
-    return _PyObject_GC_Alloc(1, basicsize);
+    PyThreadState *tstate = _PyThreadState_GET();
+    if (basicsize > PY_SSIZE_T_MAX - presize) {
+        return _PyErr_NoMemory(tstate);
+    }
+    size_t size = presize + basicsize;
+    char *mem = PyObject_Malloc(size);
+    if (mem == NULL) {
+        return _PyErr_NoMemory(tstate);
+    }
+    ((PyObject **)mem)[0] = NULL;
+    ((PyObject **)mem)[1] = NULL;
+    PyObject *op = (PyObject *)(mem + presize);
+    _PyObject_GC_Link(op);
+    return op;
 }
 
commit 8319114feedd2a5b77378bba24eb9fb2689c5033
Date:   Tue Dec 7 16:02:53 2021 +0000

    bpo-45947: Place dict and values pointer at fixed (negative) offset just before GC header. (GH-29879)
    
    * Place __dict__ immediately before GC header for plain Python objects.
    
    * Fix up lazy dict creation logic to use managed dict pointers.
    
    * Manage values pointer, placing them directly before managed dict pointers.
    
    * Convert hint-based load/store attr specialization target managed dict classes.
    
    * Specialize LOAD_METHOD for managed dict objects.
    
    * Remove unsafe _PyObject_GC_Calloc function.
    
    * Remove unsafe _PyObject_GC_Malloc() function.
    
    * Add comment explaning use of Py_TPFLAGS_MANAGED_DICT.

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2286,10 +2277,11 @@
 _PyObject_GC_New(PyTypeObject *tp)
 {
-    PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));
+    size_t presize = _PyType_PreHeaderSize(tp);
+    PyObject *op = gc_alloc(_PyObject_SIZE(tp), presize);
     if (op == NULL) {
         return NULL;
     }
     _PyObject_Init(op, tp);
     return op;
 }
 
[FUNC] **new** commit 74d5f61ebd1cb14907bf7dae1ad9c1e676707bc5
Date:   Tue Nov 29 12:15:21 2022 +0100

    gh-99845: Clean up _PyObject_VAR_SIZE() usage (#99847)
    
    * code_sizeof() now uses an unsigned type (size_t) to compute the result.
    * Fix _PyObject_ComputedDictPointer(): cast _PyObject_VAR_SIZE() to
      Py_ssize_t, rather than long: it's a different type on 64-bit Windows.
    * Clarify that _PyObject_VAR_SIZE() uses an unsigned type (size_t).

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2330,19 +2330,18 @@
 _PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
 {
-    size_t size;
     PyVarObject *op;
 
     if (nitems < 0) {
         PyErr_BadInternalCall();
         return NULL;
     }
     size_t presize = _PyType_PreHeaderSize(tp);
-    size = _PyObject_VAR_SIZE(tp, nitems);
+    size_t size = _PyObject_VAR_SIZE(tp, nitems);
     op = (PyVarObject *)gc_alloc(size, presize);
     if (op == NULL) {
         return NULL;
     }
     _PyObject_InitVar(op, tp, nitems);
     return op;
 }
 

commit 8319114feedd2a5b77378bba24eb9fb2689c5033
Date:   Tue Dec 7 16:02:53 2021 +0000

    bpo-45947: Place dict and values pointer at fixed (negative) offset just before GC header. (GH-29879)
    
    * Place __dict__ immediately before GC header for plain Python objects.
    
    * Fix up lazy dict creation logic to use managed dict pointers.
    
    * Manage values pointer, placing them directly before managed dict pointers.
    
    * Convert hint-based load/store attr specialization target managed dict classes.
    
    * Specialize LOAD_METHOD for managed dict objects.
    
    * Remove unsafe _PyObject_GC_Calloc function.
    
    * Remove unsafe _PyObject_GC_Malloc() function.
    
    * Add comment explaning use of Py_TPFLAGS_MANAGED_DICT.

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2297,18 +2289,19 @@
 _PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
 {
     size_t size;
     PyVarObject *op;
 
     if (nitems < 0) {
         PyErr_BadInternalCall();
         return NULL;
     }
+    size_t presize = _PyType_PreHeaderSize(tp);
     size = _PyObject_VAR_SIZE(tp, nitems);
-    op = (PyVarObject *) _PyObject_GC_Malloc(size);
+    op = (PyVarObject *)gc_alloc(size, presize);
     if (op == NULL) {
         return NULL;
     }
     _PyObject_InitVar(op, tp, nitems);
     return op;
 }
 
commit 74d5f61ebd1cb14907bf7dae1ad9c1e676707bc5
Date:   Tue Nov 29 12:15:21 2022 +0100

    gh-99845: Clean up _PyObject_VAR_SIZE() usage (#99847)
    
    * code_sizeof() now uses an unsigned type (size_t) to compute the result.
    * Fix _PyObject_ComputedDictPointer(): cast _PyObject_VAR_SIZE() to
      Py_ssize_t, rather than long: it's a different type on 64-bit Windows.
    * Clarify that _PyObject_VAR_SIZE() uses an unsigned type (size_t).

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2350,17 +2349,17 @@
 _PyObject_GC_Resize(PyVarObject *op, Py_ssize_t nitems)
 {
     const size_t basicsize = _PyObject_VAR_SIZE(Py_TYPE(op), nitems);
     _PyObject_ASSERT((PyObject *)op, !_PyObject_GC_IS_TRACKED(op));
-    if (basicsize > PY_SSIZE_T_MAX - sizeof(PyGC_Head)) {
+    if (basicsize > (size_t)PY_SSIZE_T_MAX - sizeof(PyGC_Head)) {
         return (PyVarObject *)PyErr_NoMemory();
     }
 
     PyGC_Head *g = AS_GC(op);
     g = (PyGC_Head *)PyObject_Realloc(g,  sizeof(PyGC_Head) + basicsize);
     if (g == NULL)
         return (PyVarObject *)PyErr_NoMemory();
     op = (PyVarObject *) FROM_GC(g);
     Py_SET_SIZE(op, nitems);
     return op;
 }
 
commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -93,11 +93,11 @@
-_PyMem_RawMalloc(void *ctx, size_t size)
+_PyMem_RawMalloc(void *Py_UNUSED(ctx), size_t size)
 {
     /* PyMem_RawMalloc(0) means malloc(1). Some systems would return NULL
        for malloc(0), which would be treated as an error. Some platforms would
        return a pointer with no memory behind it, which would break pymalloc.
        To solve these problems, allocate an extra byte. */
     if (size == 0)
         size = 1;
     return malloc(size);
 }
 
commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -105,13 +105,13 @@
-_PyMem_RawCalloc(void *ctx, size_t nelem, size_t elsize)
+_PyMem_RawCalloc(void *Py_UNUSED(ctx), size_t nelem, size_t elsize)
 {
     /* PyMem_RawCalloc(0, 0) means calloc(1, 1). Some systems would return NULL
        for calloc(0, 0), which would be treated as an error. Some platforms
        would return a pointer with no memory behind it, which would break
        pymalloc.  To solve these problems, allocate an extra byte. */
     if (nelem == 0 || elsize == 0) {
         nelem = 1;
         elsize = 1;
     }
     return calloc(nelem, elsize);
 }
 
commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -119,7 +119,7 @@
-_PyMem_RawRealloc(void *ctx, void *ptr, size_t size)
+_PyMem_RawRealloc(void *Py_UNUSED(ctx), void *ptr, size_t size)
 {
     if (size == 0)
         size = 1;
     return realloc(ptr, size);
 }
 
commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -93,11 +93,11 @@
-_PyMem_RawMalloc(void *ctx, size_t size)
+_PyMem_RawMalloc(void *Py_UNUSED(ctx), size_t size)
 {
     /* PyMem_RawMalloc(0) means malloc(1). Some systems would return NULL
        for malloc(0), which would be treated as an error. Some platforms would
        return a pointer with no memory behind it, which would break pymalloc.
        To solve these problems, allocate an extra byte. */
     if (size == 0)
         size = 1;
     return malloc(size);
 }
 
commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -105,13 +105,13 @@
-_PyMem_RawCalloc(void *ctx, size_t nelem, size_t elsize)
+_PyMem_RawCalloc(void *Py_UNUSED(ctx), size_t nelem, size_t elsize)
 {
     /* PyMem_RawCalloc(0, 0) means calloc(1, 1). Some systems would return NULL
        for calloc(0, 0), which would be treated as an error. Some platforms
        would return a pointer with no memory behind it, which would break
        pymalloc.  To solve these problems, allocate an extra byte. */
     if (nelem == 0 || elsize == 0) {
         nelem = 1;
         elsize = 1;
     }
     return calloc(nelem, elsize);
 }
 
commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -119,7 +119,7 @@
-_PyMem_RawRealloc(void *ctx, void *ptr, size_t size)
+_PyMem_RawRealloc(void *Py_UNUSED(ctx), void *ptr, size_t size)
 {
     if (size == 0)
         size = 1;
     return realloc(ptr, size);
 }
 
[FUNC] **new** commit 836b17c9c3ea313e400e58a75f52b63f96e498bb
Date:   Tue May 3 16:40:24 2022 -0600

    Add more stats for freelist use and allocations. (GH-92211)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -614,8 +614,12 @@
 PyMem_Malloc(size_t size)
 {
     /* see PyMem_RawMalloc() */
     if (size > (size_t)PY_SSIZE_T_MAX)
         return NULL;
+    OBJECT_STAT_INC_COND(allocations512, size < 512);
+    OBJECT_STAT_INC_COND(allocations4k, size >= 512 && size < 4094);
+    OBJECT_STAT_INC_COND(allocations_big, size >= 4094);
+    OBJECT_STAT_INC(allocations);
     return _PyMem.malloc(_PyMem.ctx, size);
 }
 
commit 836b17c9c3ea313e400e58a75f52b63f96e498bb
Date:   Tue May 3 16:40:24 2022 -0600

    Add more stats for freelist use and allocations. (GH-92211)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -623,8 +627,12 @@
 PyMem_Calloc(size_t nelem, size_t elsize)
 {
     /* see PyMem_RawMalloc() */
     if (elsize != 0 && nelem > (size_t)PY_SSIZE_T_MAX / elsize)
         return NULL;
+    OBJECT_STAT_INC_COND(allocations512, elsize < 512);
+    OBJECT_STAT_INC_COND(allocations4k, elsize >= 512 && elsize < 4094);
+    OBJECT_STAT_INC_COND(allocations_big, elsize >= 4094);
+    OBJECT_STAT_INC(allocations);
     return _PyMem.calloc(_PyMem.ctx, nelem, elsize);
 }
 
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +82,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyObject_Malloc(void *ctx, size_t size);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +83,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyObject_Calloc(void *ctx, size_t nelem, size_t elsize);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +85,13 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyObject_Realloc(void *ctx, void *ptr, size_t size);
+#  define PYMALLOC_ALLOC {NULL, _PyObject_Malloc, _PyObject_Calloc, _PyObject_Realloc, _PyObject_Free}
+#  define PYOBJ_ALLOC PYMALLOC_ALLOC
+#else
+#  define PYOBJ_ALLOC MALLOC_ALLOC
+#endif  // WITH_PYMALLOC
+
+#define PYMEM_ALLOC PYOBJ_ALLOC
+
+/* the default debug allocators */
+
+// The actual implementation is further down.
+

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +82,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyObject_Malloc(void *ctx, size_t size);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +83,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyObject_Calloc(void *ctx, size_t nelem, size_t elsize);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +85,13 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyObject_Realloc(void *ctx, void *ptr, size_t size);
+#  define PYMALLOC_ALLOC {NULL, _PyObject_Malloc, _PyObject_Calloc, _PyObject_Realloc, _PyObject_Free}
+#  define PYOBJ_ALLOC PYMALLOC_ALLOC
+#else
+#  define PYOBJ_ALLOC MALLOC_ALLOC
+#endif  // WITH_PYMALLOC
+
+#define PYMEM_ALLOC PYOBJ_ALLOC
+
+/* the default debug allocators */
+
+// The actual implementation is further down.
+

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +98,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyMem_DebugRawMalloc(void *ctx, size_t size);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +99,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyMem_DebugRawCalloc(void *ctx, size_t nelem, size_t elsize);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +100,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyMem_DebugRawRealloc(void *ctx, void *ptr, size_t size);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +103,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyMem_DebugMalloc(void *ctx, size_t size);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +104,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyMem_DebugCalloc(void *ctx, size_t nelem, size_t elsize);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +105,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void* _PyMem_DebugRealloc(void *ctx, void *ptr, size_t size);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
[INCR] **new** commit 713bb19356bce9b8f2b95461834fe1dae505f889
Date:   Wed Oct 13 17:22:14 2021 +0200

    bpo-45434: Mark the PyTokenizer C API as private (GH-28924)
    
    Rename PyTokenize functions to mark them as private:
    
    * PyTokenizer_FindEncodingFilename() => _PyTokenizer_FindEncodingFilename()
    * PyTokenizer_FromString() => _PyTokenizer_FromString()
    * PyTokenizer_FromFile() => _PyTokenizer_FromFile()
    * PyTokenizer_FromUTF8() => _PyTokenizer_FromUTF8()
    * PyTokenizer_Free() => _PyTokenizer_Free()
    * PyTokenizer_Get() => _PyTokenizer_Get()
    
    Remove the unused PyTokenizer_FindEncoding() function.
    
    import.c: remove unused #include "errcode.h".

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -705,20 +705,20 @@
-PyTokenizer_FromString(const char *str, int exec_input)
+_PyTokenizer_FromString(const char *str, int exec_input)
 {
     struct tok_state *tok = tok_new();
     char *decoded;
 
     if (tok == NULL)
         return NULL;
     decoded = decode_str(str, exec_input, tok);
     if (decoded == NULL) {
-        PyTokenizer_Free(tok);
+        _PyTokenizer_Free(tok);
         return NULL;
     }
 
     tok->buf = tok->cur = tok->inp = decoded;
     tok->end = decoded;
     return tok;
 }
 
 /* Set up tokenizer for UTF-8 string */
 

[FUNC] **new** commit 261a452a1300eeeae1428ffd6e6623329c085e2c
Date:   Sun Mar 28 23:48:05 2021 +0100

    bpo-25643: Refactor the C tokenizer into smaller, logical units (GH-25050)

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -762,18 +699,20 @@
 PyTokenizer_FromString(const char *str, int exec_input)
 {
     struct tok_state *tok = tok_new();
     char *decoded;
 
     if (tok == NULL)
         return NULL;
     decoded = decode_str(str, exec_input, tok);
     if (decoded == NULL) {
         PyTokenizer_Free(tok);
         return NULL;
     }
 
     tok->buf = tok->cur = tok->inp = decoded;
     tok->end = decoded;
     return tok;
 }
 
+/* Set up tokenizer for UTF-8 string */
+
commit 713bb19356bce9b8f2b95461834fe1dae505f889
Date:   Wed Oct 13 17:22:14 2021 +0200

    bpo-45434: Mark the PyTokenizer C API as private (GH-28924)
    
    Rename PyTokenize functions to mark them as private:
    
    * PyTokenizer_FindEncodingFilename() => _PyTokenizer_FindEncodingFilename()
    * PyTokenizer_FromString() => _PyTokenizer_FromString()
    * PyTokenizer_FromFile() => _PyTokenizer_FromFile()
    * PyTokenizer_FromUTF8() => _PyTokenizer_FromUTF8()
    * PyTokenizer_Free() => _PyTokenizer_Free()
    * PyTokenizer_Get() => _PyTokenizer_Get()
    
    Remove the unused PyTokenizer_FindEncoding() function.
    
    import.c: remove unused #include "errcode.h".

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -726,27 +726,27 @@
-PyTokenizer_FromUTF8(const char *str, int exec_input)
+_PyTokenizer_FromUTF8(const char *str, int exec_input)
 {
     struct tok_state *tok = tok_new();
     char *translated;
     if (tok == NULL)
         return NULL;
     tok->input = translated = translate_newlines(str, exec_input, tok);
     if (translated == NULL) {
-        PyTokenizer_Free(tok);
+        _PyTokenizer_Free(tok);
         return NULL;
     }
     tok->decoding_state = STATE_NORMAL;
     tok->enc = NULL;
     tok->str = translated;
     tok->encoding = new_string("utf-8", 5, tok);
     if (!tok->encoding) {
-        PyTokenizer_Free(tok);
+        _PyTokenizer_Free(tok);
         return NULL;
     }
 
     tok->buf = tok->cur = tok->inp = translated;
     tok->end = translated;
     return tok;
 }
 
 /* Set up tokenizer for file */
 

commit 261a452a1300eeeae1428ffd6e6623329c085e2c
Date:   Sun Mar 28 23:48:05 2021 +0100

    bpo-25643: Refactor the C tokenizer into smaller, logical units (GH-25050)

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -781,29 +720,27 @@
 PyTokenizer_FromUTF8(const char *str, int exec_input)
 {
     struct tok_state *tok = tok_new();
     char *translated;
     if (tok == NULL)
         return NULL;
     tok->input = translated = translate_newlines(str, exec_input, tok);
     if (translated == NULL) {
         PyTokenizer_Free(tok);
         return NULL;
     }
-    tok->decoding_state = STATE_RAW;
-    tok->read_coding_spec = 1;
+    tok->decoding_state = STATE_NORMAL;
     tok->enc = NULL;
     tok->str = translated;
-    tok->encoding = (char *)PyMem_Malloc(6);
+    tok->encoding = new_string("utf-8", 5, tok);
     if (!tok->encoding) {
         PyTokenizer_Free(tok);
         return NULL;
     }
-    strcpy(tok->encoding, "utf-8");
 
     tok->buf = tok->cur = tok->inp = translated;
     tok->end = translated;
     return tok;
 }
 
 /* Set up tokenizer for file */
 
commit 713bb19356bce9b8f2b95461834fe1dae505f889
Date:   Wed Oct 13 17:22:14 2021 +0200

    bpo-45434: Mark the PyTokenizer C API as private (GH-28924)
    
    Rename PyTokenize functions to mark them as private:
    
    * PyTokenizer_FindEncodingFilename() => _PyTokenizer_FindEncodingFilename()
    * PyTokenizer_FromString() => _PyTokenizer_FromString()
    * PyTokenizer_FromFile() => _PyTokenizer_FromFile()
    * PyTokenizer_FromUTF8() => _PyTokenizer_FromUTF8()
    * PyTokenizer_Free() => _PyTokenizer_Free()
    * PyTokenizer_Get() => _PyTokenizer_Get()
    
    Remove the unused PyTokenizer_FindEncoding() function.
    
    import.c: remove unused #include "errcode.h".

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -754,30 +754,30 @@
-PyTokenizer_FromFile(FILE *fp, const char* enc,
-                     const char *ps1, const char *ps2)
+_PyTokenizer_FromFile(FILE *fp, const char* enc,
+                      const char *ps1, const char *ps2)
 {
     struct tok_state *tok = tok_new();
     if (tok == NULL)
         return NULL;
     if ((tok->buf = (char *)PyMem_Malloc(BUFSIZ)) == NULL) {
-        PyTokenizer_Free(tok);
+        _PyTokenizer_Free(tok);
         return NULL;
     }
     tok->cur = tok->inp = tok->buf;
     tok->end = tok->buf + BUFSIZ;
     tok->fp = fp;
     tok->prompt = ps1;
     tok->nextprompt = ps2;
     if (enc != NULL) {
         /* Must copy encoding declaration since it
            gets copied into the parse tree. */
         tok->encoding = new_string(enc, strlen(enc), tok);
         if (!tok->encoding) {
-            PyTokenizer_Free(tok);
+            _PyTokenizer_Free(tok);
             return NULL;
         }
         tok->decoding_state = STATE_NORMAL;
     }
     return tok;
 }
 
 /* Free a tok_state structure */
 

commit 261a452a1300eeeae1428ffd6e6623329c085e2c
Date:   Sun Mar 28 23:48:05 2021 +0100

    bpo-25643: Refactor the C tokenizer into smaller, logical units (GH-25050)

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -811,32 +748,30 @@
 PyTokenizer_FromFile(FILE *fp, const char* enc,
                      const char *ps1, const char *ps2)
 {
     struct tok_state *tok = tok_new();
     if (tok == NULL)
         return NULL;
     if ((tok->buf = (char *)PyMem_Malloc(BUFSIZ)) == NULL) {
         PyTokenizer_Free(tok);
         return NULL;
     }
     tok->cur = tok->inp = tok->buf;
     tok->end = tok->buf + BUFSIZ;
     tok->fp = fp;
     tok->prompt = ps1;
     tok->nextprompt = ps2;
     if (enc != NULL) {
         /* Must copy encoding declaration since it
            gets copied into the parse tree. */
-        tok->encoding = PyMem_Malloc(strlen(enc)+1);
+        tok->encoding = new_string(enc, strlen(enc), tok);
         if (!tok->encoding) {
             PyTokenizer_Free(tok);
             return NULL;
         }
-        strcpy(tok->encoding, enc);
         tok->decoding_state = STATE_NORMAL;
     }
     return tok;
 }
 
-
 /* Free a tok_state structure */
 
commit 836b17c9c3ea313e400e58a75f52b63f96e498bb
Date:   Tue May 3 16:40:24 2022 -0600

    Add more stats for freelist use and allocations. (GH-92211)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -715,36 +717,37 @@
 new_dict(PyDictKeysObject *keys, PyDictValues *values, Py_ssize_t used, int free_values_on_failure)
 {
     PyDictObject *mp;
     assert(keys != NULL);
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree) {
         mp = state->free_list[--state->numfree];
         assert (mp != NULL);
         assert (Py_IS_TYPE(mp, &PyDict_Type));
+        OBJECT_STAT_INC(from_freelist);
         _Py_NewReference((PyObject *)mp);
     }
     else
 #endif
     {
         mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (mp == NULL) {
             dictkeys_decref(keys);
             if (free_values_on_failure) {
                 free_values(values);
             }
             return NULL;
         }
     }
     mp->ma_keys = keys;
     mp->ma_values = values;
     mp->ma_used = used;
     mp->ma_version_tag = DICT_NEXT_VERSION();
     ASSERT_CONSISTENT(mp);
     return (PyObject *)mp;
 }
 

[FUNC] **new** commit 9942f42a93ccda047fd3558c47b822e99afe10c0
Date:   Thu Oct 21 16:12:20 2021 +0300

    bpo-45522: Allow to disable freelists on build time (GH-29056)
    
    
    
    Freelists for object structs can now be disabled. A new ``configure``
    option ``--without-freelists`` can be used to disable all freelists
    except empty tuple singleton. Internal Py*_MAXFREELIST macros can now
    be defined as 0 without causing compiler warnings and segfaults.
    
    Signed-off-by: Christian Heimes <christian@python.org>

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -637,33 +647,36 @@
 new_dict(PyDictKeysObject *keys, PyDictValues *values, Py_ssize_t used, int free_values_on_failure)
 {
     PyDictObject *mp;
     assert(keys != NULL);
+#if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree) {
         mp = state->free_list[--state->numfree];
         assert (mp != NULL);
         assert (Py_IS_TYPE(mp, &PyDict_Type));
         _Py_NewReference((PyObject *)mp);
     }
-    else {
+    else
+#endif
+    {
         mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (mp == NULL) {
             dictkeys_decref(keys);
             if (free_values_on_failure) {
                 free_values(values);
             }
             return NULL;
         }
     }
     mp->ma_keys = keys;
     mp->ma_values = values;
     mp->ma_used = used;
     mp->ma_version_tag = DICT_NEXT_VERSION();
     ASSERT_CONSISTENT(mp);
     return (PyObject *)mp;
 }
 

[PERF] **new** commit a8b9350964f43cb648c98c179c8037fbf3ff8a7d
Date:   Wed Oct 13 14:19:34 2021 +0100

    bpo-45340: Don't create object dictionaries unless actually needed (GH-28802)
    
    * Never change types' cached keys. It could invalidate inline attribute objects.
    
    * Lazily create object dictionaries.
    
    * Update specialization of LOAD/STORE_ATTR.
    
    * Don't update shared keys version for deletion of value.
    
    * Update gdb support to handle instance values.
    
    * Rename SPLIT_KEYS opcodes to INSTANCE_VALUE.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -637,33 +637,33 @@
-new_dict(PyDictKeysObject *keys, PyDictValues *values)
+new_dict(PyDictKeysObject *keys, PyDictValues *values, Py_ssize_t used, int free_values_on_failure)
 {
     PyDictObject *mp;
     assert(keys != NULL);
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree) {
         mp = state->free_list[--state->numfree];
         assert (mp != NULL);
         assert (Py_IS_TYPE(mp, &PyDict_Type));
         _Py_NewReference((PyObject *)mp);
     }
     else {
         mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (mp == NULL) {
             dictkeys_decref(keys);
-            if (values != empty_values) {
+            if (free_values_on_failure) {
                 free_values(values);
             }
             return NULL;
         }
     }
     mp->ma_keys = keys;
     mp->ma_values = values;
-    mp->ma_used = 0;
+    mp->ma_used = used;
     mp->ma_version_tag = DICT_NEXT_VERSION();
     ASSERT_CONSISTENT(mp);
     return (PyObject *)mp;
 }
 

[FUNC] **new** commit a7252f88d3fa33036bdd6036b8c97bc785ed6f17
Date:   Wed Oct 6 13:19:53 2021 +0100

    bpo-40116: Add insertion order bit-vector to dict values to allow dicts to share keys more freely. (GH-28520)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -614,33 +636,33 @@
-new_dict(PyDictKeysObject *keys, PyObject **values)
+new_dict(PyDictKeysObject *keys, PyDictValues *values)
 {
     PyDictObject *mp;
     assert(keys != NULL);
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree) {
         mp = state->free_list[--state->numfree];
         assert (mp != NULL);
         assert (Py_IS_TYPE(mp, &PyDict_Type));
         _Py_NewReference((PyObject *)mp);
     }
     else {
         mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (mp == NULL) {
             dictkeys_decref(keys);
             if (values != empty_values) {
                 free_values(values);
             }
             return NULL;
         }
     }
     mp->ma_keys = keys;
     mp->ma_values = values;
     mp->ma_used = 0;
     mp->ma_version_tag = DICT_NEXT_VERSION();
     ASSERT_CONSISTENT(mp);
     return (PyObject *)mp;
 }
 
[FUNC] **new** commit 4246fe977d850f8b78505c982f055d33d52ff339
Date:   Tue Nov 29 12:12:17 2022 +0100

    gh-99845: Change _PyDict_KeysSize() return type to size_t (#99848)
    
    * Change _PyDict_KeysSize() and shared_keys_usable_size() return type
      from signed (Py_ssize_t) to unsigned (size_t) type.
    * new_values() argument type is now unsigned (size_t).
    * init_inline_values() now uses size_t rather than int for the 'i'
      iterator variable.
    * type.__sizeof__() implementation now uses unsigned (size_t) type.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -757,19 +757,16 @@
 new_dict_with_shared_keys(PyDictKeysObject *keys)
 {
-    PyDictValues *values;
-    Py_ssize_t i, size;
-
-    size = shared_keys_usable_size(keys);
-    values = new_values(size);
+    size_t size = shared_keys_usable_size(keys);
+    PyDictValues *values = new_values(size);
     if (values == NULL) {
         dictkeys_decref(keys);
         return PyErr_NoMemory();
     }
     ((char *)values)[-2] = 0;
-    for (i = 0; i < size; i++) {
+    for (size_t i = 0; i < size; i++) {
         values->values[i] = NULL;
     }
     return new_dict(keys, values, 0, 1);
 }
 
 

[FUNC] **new** commit 25db2b361beb865192a3424830ddcb0ae4b17318
Date:   Tue Feb 8 11:50:38 2022 +0000

    bpo-46675: Allow object value arrays and split key dictionaries larger than 16 (GH-31191)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -691,19 +711,19 @@
 new_dict_with_shared_keys(PyDictKeysObject *keys)
 {
     PyDictValues *values;
     Py_ssize_t i, size;
 
     size = shared_keys_usable_size(keys);
     values = new_values(size);
     if (values == NULL) {
         dictkeys_decref(keys);
         return PyErr_NoMemory();
     }
-    values->mv_order = 0;
+    ((char *)values)[-2] = 0;
     for (i = 0; i < size; i++) {
         values->values[i] = NULL;
     }
     return new_dict(keys, values, 0, 1);
 }
 
 

commit a8b9350964f43cb648c98c179c8037fbf3ff8a7d
Date:   Wed Oct 13 14:19:34 2021 +0100

    bpo-45340: Don't create object dictionaries unless actually needed (GH-28802)
    
    * Never change types' cached keys. It could invalidate inline attribute objects.
    
    * Lazily create object dictionaries.
    
    * Update specialization of LOAD/STORE_ATTR.
    
    * Don't update shared keys version for deletion of value.
    
    * Update gdb support to handle instance values.
    
    * Rename SPLIT_KEYS opcodes to INSTANCE_VALUE.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -672,19 +678,19 @@
 new_dict_with_shared_keys(PyDictKeysObject *keys)
 {
     PyDictValues *values;
     Py_ssize_t i, size;
 
-    size = USABLE_FRACTION(DK_SIZE(keys));
+    size = shared_keys_usable_size(keys);
     values = new_values(size);
     if (values == NULL) {
         dictkeys_decref(keys);
         return PyErr_NoMemory();
     }
     values->mv_order = 0;
     for (i = 0; i < size; i++) {
         values->values[i] = NULL;
     }
-    return new_dict(keys, values);
+    return new_dict(keys, values, 0, 1);
 }
 
 

commit a7252f88d3fa33036bdd6036b8c97bc785ed6f17
Date:   Wed Oct 6 13:19:53 2021 +0100

    bpo-40116: Add insertion order bit-vector to dict values to allow dicts to share keys more freely. (GH-28520)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -649,18 +671,19 @@
 new_dict_with_shared_keys(PyDictKeysObject *keys)
 {
-    PyObject **values;
+    PyDictValues *values;
     Py_ssize_t i, size;
 
     size = USABLE_FRACTION(DK_SIZE(keys));
     values = new_values(size);
     if (values == NULL) {
         dictkeys_decref(keys);
         return PyErr_NoMemory();
     }
+    values->mv_order = 0;
     for (i = 0; i < size; i++) {
-        values[i] = NULL;
+        values->values[i] = NULL;
     }
     return new_dict(keys, values);
 }
 
 
[FUNC] **new** commit 03642df1a1cfddcd740b62e78bddfa3ea6863da4
Date:   Wed Mar 2 19:05:12 2022 +0900

    dict: Internal cleanup (GH-31641)
    
    * Make empty_key from split table to combined table.
    * Use unicode_get_hash() when possible.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -845,7 +835,7 @@
 PyDict_New(void)
 {
     dictkeys_incref(Py_EMPTY_KEYS);
-    return new_dict(Py_EMPTY_KEYS, empty_values, 0, 0);
+    return new_dict(Py_EMPTY_KEYS, NULL, 0, 0);
 }
 
 /* Search index of hash table from offset of entry table */

commit a8b9350964f43cb648c98c179c8037fbf3ff8a7d
Date:   Wed Oct 13 14:19:34 2021 +0100

    bpo-45340: Don't create object dictionaries unless actually needed (GH-28802)
    
    * Never change types' cached keys. It could invalidate inline attribute objects.
    
    * Lazily create object dictionaries.
    
    * Update specialization of LOAD/STORE_ATTR.
    
    * Don't update shared keys version for deletion of value.
    
    * Update gdb support to handle instance values.
    
    * Rename SPLIT_KEYS opcodes to INSTANCE_VALUE.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -733,7 +739,7 @@
 PyDict_New(void)
 {
     dictkeys_incref(Py_EMPTY_KEYS);
-    return new_dict(Py_EMPTY_KEYS, empty_values);
+    return new_dict(Py_EMPTY_KEYS, empty_values, 0, 0);
 }
 
 /* Search index of hash table from offset of entry table */
[FUNC] **new** commit 9833bb91e4d5c2606421d9ec2085f5c2dfb6f72c
Date:   Wed Mar 2 08:09:28 2022 +0900

    bpo-46845: Reduce dict size when all keys are Unicode (GH-31564)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -1350,0 +1595,5 @@
+_PyDict_NewPresized(Py_ssize_t minused)
+{
+    return dict_new_presized(minused, false);
+}
+
commit 4246fe977d850f8b78505c982f055d33d52ff339
Date:   Tue Nov 29 12:12:17 2022 +0100

    gh-99845: Change _PyDict_KeysSize() return type to size_t (#99848)
    
    * Change _PyDict_KeysSize() and shared_keys_usable_size() return type
      from signed (Py_ssize_t) to unsigned (size_t) type.
    * new_values() argument type is now unsigned (size_t).
    * init_inline_values() now uses size_t rather than int for the 'i'
      iterator variable.
    * type.__sizeof__() implementation now uses unsigned (size_t) type.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2958,93 +2955,91 @@
 PyDict_Copy(PyObject *o)
 {
     PyObject *copy;
     PyDictObject *mp;
-    Py_ssize_t i, n;
 
     if (o == NULL || !PyDict_Check(o)) {
         PyErr_BadInternalCall();
         return NULL;
     }
 
     mp = (PyDictObject *)o;
     if (mp->ma_used == 0) {
         /* The dict is empty; just return a new dict. */
         return PyDict_New();
     }
 
     if (_PyDict_HasSplitTable(mp)) {
         PyDictObject *split_copy;
-        Py_ssize_t size = shared_keys_usable_size(mp->ma_keys);
-        PyDictValues *newvalues;
-        newvalues = new_values(size);
+        size_t size = shared_keys_usable_size(mp->ma_keys);
+        PyDictValues *newvalues = new_values(size);
         if (newvalues == NULL)
             return PyErr_NoMemory();
         split_copy = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (split_copy == NULL) {
             free_values(newvalues);
             return NULL;
         }
         size_t prefix_size = ((uint8_t *)newvalues)[-1];
         memcpy(((char *)newvalues)-prefix_size, ((char *)mp->ma_values)-prefix_size, prefix_size-1);
         split_copy->ma_values = newvalues;
         split_copy->ma_keys = mp->ma_keys;
         split_copy->ma_used = mp->ma_used;
         split_copy->ma_version_tag = DICT_NEXT_VERSION();
         dictkeys_incref(mp->ma_keys);
-        for (i = 0, n = size; i < n; i++) {
+        for (size_t i = 0; i < size; i++) {
             PyObject *value = mp->ma_values->values[i];
             split_copy->ma_values->values[i] = Py_XNewRef(value);
         }
         if (_PyObject_GC_IS_TRACKED(mp))
             _PyObject_GC_TRACK(split_copy);
         return (PyObject *)split_copy;
     }
 
     if (Py_TYPE(mp)->tp_iter == (getiterfunc)dict_iter &&
             mp->ma_values == NULL &&
             (mp->ma_used >= (mp->ma_keys->dk_nentries * 2) / 3))
     {
         /* Use fast-copy if:
 
            (1) type(mp) doesn't override tp_iter; and
 
            (2) 'mp' is not a split-dict; and
 
            (3) if 'mp' is non-compact ('del' operation does not resize dicts),
                do fast-copy only if it has at most 1/3 non-used keys.
 
            The last condition (3) is important to guard against a pathological
            case when a large dict is almost emptied with multiple del/pop
            operations and copied after that.  In cases like this, we defer to
            PyDict_Merge, which produces a compacted copy.
         */
         PyDictKeysObject *keys = clone_combined_dict_keys(mp);
         if (keys == NULL) {
             return NULL;
         }
         PyDictObject *new = (PyDictObject *)new_dict(keys, NULL, 0, 0);
         if (new == NULL) {
             /* In case of an error, `new_dict()` takes care of
                cleaning up `keys`. */
             return NULL;
         }
 
         new->ma_used = mp->ma_used;
         ASSERT_CONSISTENT(new);
         if (_PyObject_GC_IS_TRACKED(mp)) {
             /* Maintain tracking. */
             _PyObject_GC_TRACK(new);
         }
 
         return (PyObject *)new;
     }
 
     copy = PyDict_New();
     if (copy == NULL)
         return NULL;
     if (dict_merge(copy, o, 1) == 0)
         return copy;
     Py_DECREF(copy);
     return NULL;
 }
 

[FUNC] **new** commit 6dedf42527fddbed8ef61ef8d3f025bf3a373359
Date:   Thu Nov 10 16:27:53 2022 +0100

    gh-99300: Use Py_NewRef() in Objects/dictobject.c (#99333)
    
    Replace Py_INCREF() and Py_XINCREF() with Py_NewRef() and
    Py_XNewRef() in Objects/dictobject.c.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2986,94 +2966,93 @@
 PyDict_Copy(PyObject *o)
 {
     PyObject *copy;
     PyDictObject *mp;
     Py_ssize_t i, n;
 
     if (o == NULL || !PyDict_Check(o)) {
         PyErr_BadInternalCall();
         return NULL;
     }
 
     mp = (PyDictObject *)o;
     if (mp->ma_used == 0) {
         /* The dict is empty; just return a new dict. */
         return PyDict_New();
     }
 
     if (_PyDict_HasSplitTable(mp)) {
         PyDictObject *split_copy;
         Py_ssize_t size = shared_keys_usable_size(mp->ma_keys);
         PyDictValues *newvalues;
         newvalues = new_values(size);
         if (newvalues == NULL)
             return PyErr_NoMemory();
         split_copy = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (split_copy == NULL) {
             free_values(newvalues);
             return NULL;
         }
         size_t prefix_size = ((uint8_t *)newvalues)[-1];
         memcpy(((char *)newvalues)-prefix_size, ((char *)mp->ma_values)-prefix_size, prefix_size-1);
         split_copy->ma_values = newvalues;
         split_copy->ma_keys = mp->ma_keys;
         split_copy->ma_used = mp->ma_used;
         split_copy->ma_version_tag = DICT_NEXT_VERSION();
         dictkeys_incref(mp->ma_keys);
         for (i = 0, n = size; i < n; i++) {
             PyObject *value = mp->ma_values->values[i];
-            Py_XINCREF(value);
-            split_copy->ma_values->values[i] = value;
+            split_copy->ma_values->values[i] = Py_XNewRef(value);
         }
         if (_PyObject_GC_IS_TRACKED(mp))
             _PyObject_GC_TRACK(split_copy);
         return (PyObject *)split_copy;
     }
 
     if (Py_TYPE(mp)->tp_iter == (getiterfunc)dict_iter &&
             mp->ma_values == NULL &&
             (mp->ma_used >= (mp->ma_keys->dk_nentries * 2) / 3))
     {
         /* Use fast-copy if:
 
            (1) type(mp) doesn't override tp_iter; and
 
            (2) 'mp' is not a split-dict; and
 
            (3) if 'mp' is non-compact ('del' operation does not resize dicts),
                do fast-copy only if it has at most 1/3 non-used keys.
 
            The last condition (3) is important to guard against a pathological
            case when a large dict is almost emptied with multiple del/pop
            operations and copied after that.  In cases like this, we defer to
            PyDict_Merge, which produces a compacted copy.
         */
         PyDictKeysObject *keys = clone_combined_dict_keys(mp);
         if (keys == NULL) {
             return NULL;
         }
         PyDictObject *new = (PyDictObject *)new_dict(keys, NULL, 0, 0);
         if (new == NULL) {
             /* In case of an error, `new_dict()` takes care of
                cleaning up `keys`. */
             return NULL;
         }
 
         new->ma_used = mp->ma_used;
         ASSERT_CONSISTENT(new);
         if (_PyObject_GC_IS_TRACKED(mp)) {
             /* Maintain tracking. */
             _PyObject_GC_TRACK(new);
         }
 
         return (PyObject *)new;
     }
 
     copy = PyDict_New();
     if (copy == NULL)
         return NULL;
     if (dict_merge(copy, o, 1) == 0)
         return copy;
     Py_DECREF(copy);
     return NULL;
 }
 

commit 25db2b361beb865192a3424830ddcb0ae4b17318
Date:   Tue Feb 8 11:50:38 2022 +0000

    bpo-46675: Allow object value arrays and split key dictionaries larger than 16 (GH-31191)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2703,93 +2721,94 @@
 PyDict_Copy(PyObject *o)
 {
     PyObject *copy;
     PyDictObject *mp;
     Py_ssize_t i, n;
 
     if (o == NULL || !PyDict_Check(o)) {
         PyErr_BadInternalCall();
         return NULL;
     }
 
     mp = (PyDictObject *)o;
     if (mp->ma_used == 0) {
         /* The dict is empty; just return a new dict. */
         return PyDict_New();
     }
 
     if (_PyDict_HasSplitTable(mp)) {
         PyDictObject *split_copy;
         Py_ssize_t size = shared_keys_usable_size(mp->ma_keys);
         PyDictValues *newvalues;
         newvalues = new_values(size);
         if (newvalues == NULL)
             return PyErr_NoMemory();
         split_copy = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (split_copy == NULL) {
             free_values(newvalues);
             return NULL;
         }
-        newvalues->mv_order = mp->ma_values->mv_order;
+        size_t prefix_size = ((uint8_t *)newvalues)[-1];
+        memcpy(((char *)newvalues)-prefix_size, ((char *)mp->ma_values)-prefix_size, prefix_size-1);
         split_copy->ma_values = newvalues;
         split_copy->ma_keys = mp->ma_keys;
         split_copy->ma_used = mp->ma_used;
         split_copy->ma_version_tag = DICT_NEXT_VERSION();
         dictkeys_incref(mp->ma_keys);
         for (i = 0, n = size; i < n; i++) {
             PyObject *value = mp->ma_values->values[i];
             Py_XINCREF(value);
             split_copy->ma_values->values[i] = value;
         }
         if (_PyObject_GC_IS_TRACKED(mp))
             _PyObject_GC_TRACK(split_copy);
         return (PyObject *)split_copy;
     }
 
     if (Py_TYPE(mp)->tp_iter == (getiterfunc)dict_iter &&
             mp->ma_values == NULL &&
             (mp->ma_used >= (mp->ma_keys->dk_nentries * 2) / 3))
     {
         /* Use fast-copy if:
 
            (1) type(mp) doesn't override tp_iter; and
 
            (2) 'mp' is not a split-dict; and
 
            (3) if 'mp' is non-compact ('del' operation does not resize dicts),
                do fast-copy only if it has at most 1/3 non-used keys.
 
            The last condition (3) is important to guard against a pathological
            case when a large dict is almost emptied with multiple del/pop
            operations and copied after that.  In cases like this, we defer to
            PyDict_Merge, which produces a compacted copy.
         */
         PyDictKeysObject *keys = clone_combined_dict_keys(mp);
         if (keys == NULL) {
             return NULL;
         }
         PyDictObject *new = (PyDictObject *)new_dict(keys, NULL, 0, 0);
         if (new == NULL) {
             /* In case of an error, `new_dict()` takes care of
                cleaning up `keys`. */
             return NULL;
         }
 
         new->ma_used = mp->ma_used;
         ASSERT_CONSISTENT(new);
         if (_PyObject_GC_IS_TRACKED(mp)) {
             /* Maintain tracking. */
             _PyObject_GC_TRACK(new);
         }
 
         return (PyObject *)new;
     }
 
     copy = PyDict_New();
     if (copy == NULL)
         return NULL;
     if (dict_merge(copy, o, 1) == 0)
         return copy;
     Py_DECREF(copy);
     return NULL;
 }
 

commit a8b9350964f43cb648c98c179c8037fbf3ff8a7d
Date:   Wed Oct 13 14:19:34 2021 +0100

    bpo-45340: Don't create object dictionaries unless actually needed (GH-28802)
    
    * Never change types' cached keys. It could invalidate inline attribute objects.
    
    * Lazily create object dictionaries.
    
    * Update specialization of LOAD/STORE_ATTR.
    
    * Don't update shared keys version for deletion of value.
    
    * Update gdb support to handle instance values.
    
    * Rename SPLIT_KEYS opcodes to INSTANCE_VALUE.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2676,93 +2661,93 @@
 PyDict_Copy(PyObject *o)
 {
     PyObject *copy;
     PyDictObject *mp;
     Py_ssize_t i, n;
 
     if (o == NULL || !PyDict_Check(o)) {
         PyErr_BadInternalCall();
         return NULL;
     }
 
     mp = (PyDictObject *)o;
     if (mp->ma_used == 0) {
         /* The dict is empty; just return a new dict. */
         return PyDict_New();
     }
 
     if (_PyDict_HasSplitTable(mp)) {
         PyDictObject *split_copy;
-        Py_ssize_t size = USABLE_FRACTION(DK_SIZE(mp->ma_keys));
+        Py_ssize_t size = shared_keys_usable_size(mp->ma_keys);
         PyDictValues *newvalues;
         newvalues = new_values(size);
         if (newvalues == NULL)
             return PyErr_NoMemory();
         split_copy = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (split_copy == NULL) {
             free_values(newvalues);
             return NULL;
         }
         newvalues->mv_order = mp->ma_values->mv_order;
         split_copy->ma_values = newvalues;
         split_copy->ma_keys = mp->ma_keys;
         split_copy->ma_used = mp->ma_used;
         split_copy->ma_version_tag = DICT_NEXT_VERSION();
         dictkeys_incref(mp->ma_keys);
         for (i = 0, n = size; i < n; i++) {
             PyObject *value = mp->ma_values->values[i];
             Py_XINCREF(value);
             split_copy->ma_values->values[i] = value;
         }
         if (_PyObject_GC_IS_TRACKED(mp))
             _PyObject_GC_TRACK(split_copy);
         return (PyObject *)split_copy;
     }
 
     if (Py_TYPE(mp)->tp_iter == (getiterfunc)dict_iter &&
             mp->ma_values == NULL &&
             (mp->ma_used >= (mp->ma_keys->dk_nentries * 2) / 3))
     {
         /* Use fast-copy if:
 
            (1) type(mp) doesn't override tp_iter; and
 
            (2) 'mp' is not a split-dict; and
 
            (3) if 'mp' is non-compact ('del' operation does not resize dicts),
                do fast-copy only if it has at most 1/3 non-used keys.
 
            The last condition (3) is important to guard against a pathological
            case when a large dict is almost emptied with multiple del/pop
            operations and copied after that.  In cases like this, we defer to
            PyDict_Merge, which produces a compacted copy.
         */
         PyDictKeysObject *keys = clone_combined_dict_keys(mp);
         if (keys == NULL) {
             return NULL;
         }
-        PyDictObject *new = (PyDictObject *)new_dict(keys, NULL);
+        PyDictObject *new = (PyDictObject *)new_dict(keys, NULL, 0, 0);
         if (new == NULL) {
             /* In case of an error, `new_dict()` takes care of
                cleaning up `keys`. */
             return NULL;
         }
 
         new->ma_used = mp->ma_used;
         ASSERT_CONSISTENT(new);
         if (_PyObject_GC_IS_TRACKED(mp)) {
             /* Maintain tracking. */
             _PyObject_GC_TRACK(new);
         }
 
         return (PyObject *)new;
     }
 
     copy = PyDict_New();
     if (copy == NULL)
         return NULL;
     if (dict_merge(copy, o, 1) == 0)
         return copy;
     Py_DECREF(copy);
     return NULL;
 }
 

commit a7252f88d3fa33036bdd6036b8c97bc785ed6f17
Date:   Wed Oct 6 13:19:53 2021 +0100

    bpo-40116: Add insertion order bit-vector to dict values to allow dicts to share keys more freely. (GH-28520)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2660,92 +2675,93 @@
 PyDict_Copy(PyObject *o)
 {
     PyObject *copy;
     PyDictObject *mp;
     Py_ssize_t i, n;
 
     if (o == NULL || !PyDict_Check(o)) {
         PyErr_BadInternalCall();
         return NULL;
     }
 
     mp = (PyDictObject *)o;
     if (mp->ma_used == 0) {
         /* The dict is empty; just return a new dict. */
         return PyDict_New();
     }
 
     if (_PyDict_HasSplitTable(mp)) {
         PyDictObject *split_copy;
         Py_ssize_t size = USABLE_FRACTION(DK_SIZE(mp->ma_keys));
-        PyObject **newvalues;
+        PyDictValues *newvalues;
         newvalues = new_values(size);
         if (newvalues == NULL)
             return PyErr_NoMemory();
         split_copy = PyObject_GC_New(PyDictObject, &PyDict_Type);
         if (split_copy == NULL) {
             free_values(newvalues);
             return NULL;
         }
+        newvalues->mv_order = mp->ma_values->mv_order;
         split_copy->ma_values = newvalues;
         split_copy->ma_keys = mp->ma_keys;
         split_copy->ma_used = mp->ma_used;
         split_copy->ma_version_tag = DICT_NEXT_VERSION();
         dictkeys_incref(mp->ma_keys);
         for (i = 0, n = size; i < n; i++) {
-            PyObject *value = mp->ma_values[i];
+            PyObject *value = mp->ma_values->values[i];
             Py_XINCREF(value);
-            split_copy->ma_values[i] = value;
+            split_copy->ma_values->values[i] = value;
         }
         if (_PyObject_GC_IS_TRACKED(mp))
             _PyObject_GC_TRACK(split_copy);
         return (PyObject *)split_copy;
     }
 
     if (Py_TYPE(mp)->tp_iter == (getiterfunc)dict_iter &&
             mp->ma_values == NULL &&
             (mp->ma_used >= (mp->ma_keys->dk_nentries * 2) / 3))
     {
         /* Use fast-copy if:
 
            (1) type(mp) doesn't override tp_iter; and
 
            (2) 'mp' is not a split-dict; and
 
            (3) if 'mp' is non-compact ('del' operation does not resize dicts),
                do fast-copy only if it has at most 1/3 non-used keys.
 
            The last condition (3) is important to guard against a pathological
            case when a large dict is almost emptied with multiple del/pop
            operations and copied after that.  In cases like this, we defer to
            PyDict_Merge, which produces a compacted copy.
         */
         PyDictKeysObject *keys = clone_combined_dict_keys(mp);
         if (keys == NULL) {
             return NULL;
         }
         PyDictObject *new = (PyDictObject *)new_dict(keys, NULL);
         if (new == NULL) {
             /* In case of an error, `new_dict()` takes care of
                cleaning up `keys`. */
             return NULL;
         }
 
         new->ma_used = mp->ma_used;
         ASSERT_CONSISTENT(new);
         if (_PyObject_GC_IS_TRACKED(mp)) {
             /* Maintain tracking. */
             _PyObject_GC_TRACK(new);
         }
 
         return (PyObject *)new;
     }
 
     copy = PyDict_New();
     if (copy == NULL)
         return NULL;
     if (dict_merge(copy, o, 1) == 0)
         return copy;
     Py_DECREF(copy);
     return NULL;
 }
 
commit 836b17c9c3ea313e400e58a75f52b63f96e498bb
Date:   Tue May 3 16:40:24 2022 -0600

    Add more stats for freelist use and allocations. (GH-92211)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -594,60 +594,61 @@
 new_keys_object(uint8_t log2_size, bool unicode)
 {
     PyDictKeysObject *dk;
     Py_ssize_t usable;
     int log2_bytes;
     size_t entry_size = unicode ? sizeof(PyDictUnicodeEntry) : sizeof(PyDictKeyEntry);
 
     assert(log2_size >= PyDict_LOG_MINSIZE);
 
     usable = USABLE_FRACTION(1<<log2_size);
     if (log2_size < 8) {
         log2_bytes = log2_size;
     }
     else if (log2_size < 16) {
         log2_bytes = log2_size + 1;
     }
 #if SIZEOF_VOID_P > 4
     else if (log2_size >= 32) {
         log2_bytes = log2_size + 3;
     }
 #endif
     else {
         log2_bytes = log2_size + 2;
     }
 
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
     if (log2_size == PyDict_LOG_MINSIZE && unicode && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
+        OBJECT_STAT_INC(from_freelist);
     }
     else
 #endif
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
                              + ((size_t)1 << log2_bytes)
                              + entry_size * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
     dk->dk_log2_size = log2_size;
     dk->dk_log2_index_bytes = log2_bytes;
     dk->dk_kind = unicode ? DICT_KEYS_UNICODE : DICT_KEYS_GENERAL;
     dk->dk_nentries = 0;
     dk->dk_usable = usable;
     dk->dk_version = 0;
     memset(&dk->dk_indices[0], 0xff, ((size_t)1 << log2_bytes));
     memset(&dk->dk_indices[(size_t)1 << log2_bytes], 0, entry_size * usable);
     return dk;
 }
 

commit 9833bb91e4d5c2606421d9ec2085f5c2dfb6f72c
Date:   Wed Mar 2 08:09:28 2022 +0900

    bpo-46845: Reduce dict size when all keys are Unicode (GH-31564)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -564,59 +605,60 @@
-new_keys_object(uint8_t log2_size)
+new_keys_object(uint8_t log2_size, bool unicode)
 {
     PyDictKeysObject *dk;
     Py_ssize_t usable;
     int log2_bytes;
+    size_t entry_size = unicode ? sizeof(PyDictUnicodeEntry) : sizeof(PyDictKeyEntry);
 
     assert(log2_size >= PyDict_LOG_MINSIZE);
 
     usable = USABLE_FRACTION(1<<log2_size);
     if (log2_size < 8) {
         log2_bytes = log2_size;
     }
     else if (log2_size < 16) {
         log2_bytes = log2_size + 1;
     }
 #if SIZEOF_VOID_P > 4
     else if (log2_size >= 32) {
         log2_bytes = log2_size + 3;
     }
 #endif
     else {
         log2_bytes = log2_size + 2;
     }
 
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
-    if (log2_size == PyDict_LOG_MINSIZE && state->keys_numfree > 0) {
+    if (log2_size == PyDict_LOG_MINSIZE && unicode && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
     }
     else
 #endif
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
                              + ((size_t)1 << log2_bytes)
-                             + sizeof(PyDictKeyEntry) * usable);
+                             + entry_size * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
     dk->dk_log2_size = log2_size;
     dk->dk_log2_index_bytes = log2_bytes;
-    dk->dk_kind = DICT_KEYS_UNICODE;
+    dk->dk_kind = unicode ? DICT_KEYS_UNICODE : DICT_KEYS_GENERAL;
     dk->dk_nentries = 0;
     dk->dk_usable = usable;
     dk->dk_version = 0;
     memset(&dk->dk_indices[0], 0xff, ((size_t)1 << log2_bytes));
-    memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);
+    memset(&dk->dk_indices[(size_t)1 << log2_bytes], 0, entry_size * usable);
     return dk;
 }
 

[FUNC] **new** commit 1e344684d8d42206858c4eca8ec7950e644f4220
Date:   Tue Feb 22 20:03:15 2022 +0900

    dict: Add dk_log2_index_bytes (GH-31439)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -562,57 +564,59 @@
 new_keys_object(uint8_t log2_size)
 {
     PyDictKeysObject *dk;
-    Py_ssize_t es, usable;
+    Py_ssize_t usable;
+    int log2_bytes;
 
     assert(log2_size >= PyDict_LOG_MINSIZE);
 
     usable = USABLE_FRACTION(1<<log2_size);
-    if (log2_size <= 7) {
-        es = 1;
+    if (log2_size < 8) {
+        log2_bytes = log2_size;
     }
-    else if (log2_size <= 15) {
-        es = 2;
+    else if (log2_size < 16) {
+        log2_bytes = log2_size + 1;
     }
 #if SIZEOF_VOID_P > 4
-    else if (log2_size <= 31) {
-        es = 4;
+    else if (log2_size >= 32) {
+        log2_bytes = log2_size + 3;
     }
 #endif
     else {
-        es = sizeof(Py_ssize_t);
+        log2_bytes = log2_size + 2;
     }
 
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
     if (log2_size == PyDict_LOG_MINSIZE && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
     }
     else
 #endif
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
-                             + (es<<log2_size)
+                             + ((size_t)1 << log2_bytes)
                              + sizeof(PyDictKeyEntry) * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
     dk->dk_log2_size = log2_size;
+    dk->dk_log2_index_bytes = log2_bytes;
     dk->dk_kind = DICT_KEYS_UNICODE;
     dk->dk_nentries = 0;
     dk->dk_usable = usable;
     dk->dk_version = 0;
-    memset(&dk->dk_indices[0], 0xff, es<<log2_size);
+    memset(&dk->dk_indices[0], 0xff, ((size_t)1 << log2_bytes));
     memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);
     return dk;
 }
 

commit 9942f42a93ccda047fd3558c47b822e99afe10c0
Date:   Thu Oct 21 16:12:20 2021 +0300

    bpo-45522: Allow to disable freelists on build time (GH-29056)
    
    
    
    Freelists for object structs can now be disabled. A new ``configure``
    option ``--without-freelists`` can be used to disable all freelists
    except empty tuple singleton. Internal Py*_MAXFREELIST macros can now
    be defined as 0 without causing compiler warnings and segfaults.
    
    Signed-off-by: Christian Heimes <christian@python.org>

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -550,55 +556,57 @@
 new_keys_object(uint8_t log2_size)
 {
     PyDictKeysObject *dk;
     Py_ssize_t es, usable;
 
     assert(log2_size >= PyDict_LOG_MINSIZE);
 
     usable = USABLE_FRACTION(1<<log2_size);
     if (log2_size <= 7) {
         es = 1;
     }
     else if (log2_size <= 15) {
         es = 2;
     }
 #if SIZEOF_VOID_P > 4
     else if (log2_size <= 31) {
         es = 4;
     }
 #endif
     else {
         es = sizeof(Py_ssize_t);
     }
 
+#if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
     if (log2_size == PyDict_LOG_MINSIZE && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
     }
     else
+#endif
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
                              + (es<<log2_size)
                              + sizeof(PyDictKeyEntry) * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
     dk->dk_log2_size = log2_size;
     dk->dk_kind = DICT_KEYS_UNICODE;
     dk->dk_nentries = 0;
     dk->dk_usable = usable;
     dk->dk_version = 0;
     memset(&dk->dk_indices[0], 0xff, es<<log2_size);
     memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);
     return dk;
 }
 

commit a7252f88d3fa33036bdd6036b8c97bc785ed6f17
Date:   Wed Oct 6 13:19:53 2021 +0100

    bpo-40116: Add insertion order bit-vector to dict values to allow dicts to share keys more freely. (GH-28520)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -533,55 +549,55 @@
 new_keys_object(uint8_t log2_size)
 {
     PyDictKeysObject *dk;
     Py_ssize_t es, usable;
 
     assert(log2_size >= PyDict_LOG_MINSIZE);
 
     usable = USABLE_FRACTION(1<<log2_size);
     if (log2_size <= 7) {
         es = 1;
     }
     else if (log2_size <= 15) {
         es = 2;
     }
 #if SIZEOF_VOID_P > 4
     else if (log2_size <= 31) {
         es = 4;
     }
 #endif
     else {
         es = sizeof(Py_ssize_t);
     }
 
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
     if (log2_size == PyDict_LOG_MINSIZE && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
     }
     else
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
                              + (es<<log2_size)
                              + sizeof(PyDictKeyEntry) * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
     dk->dk_log2_size = log2_size;
-    dk->dk_usable = usable;
     dk->dk_kind = DICT_KEYS_UNICODE;
     dk->dk_nentries = 0;
+    dk->dk_usable = usable;
     dk->dk_version = 0;
     memset(&dk->dk_indices[0], 0xff, es<<log2_size);
     memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);
     return dk;
 }
 

[CORR] **new** commit 21dd43c01d6b9cd50512c9ab6d83c97cde3bf115
Date:   Sat May 29 01:40:12 2021 +0100

    Fix MSVC compiler warnings in dictobject.c (GH-26432)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -553,55 +553,55 @@
 new_keys_object(uint8_t log2_size)
 {
     PyDictKeysObject *dk;
     Py_ssize_t es, usable;
 
     assert(log2_size >= PyDict_LOG_MINSIZE);
 
     usable = USABLE_FRACTION(1<<log2_size);
     if (log2_size <= 7) {
         es = 1;
     }
     else if (log2_size <= 15) {
         es = 2;
     }
 #if SIZEOF_VOID_P > 4
     else if (log2_size <= 31) {
         es = 4;
     }
 #endif
     else {
         es = sizeof(Py_ssize_t);
     }
 
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
     if (log2_size == PyDict_LOG_MINSIZE && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
     }
     else
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
                              + (es<<log2_size)
                              + sizeof(PyDictKeyEntry) * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
     dk->dk_log2_size = log2_size;
     dk->dk_usable = usable;
     dk->dk_kind = DICT_KEYS_UNICODE;
     dk->dk_nentries = 0;
     dk->dk_version = 0;
-    memset(&dk->dk_indices[0], 0xff, es * (1<<log2_size));
+    memset(&dk->dk_indices[0], 0xff, es<<log2_size);
     memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);
     return dk;
 }
 

[FUNC] **new** commit f8a95df84bcedebc0aa7132b3d1a4e8f000914bc
Date:   Fri May 28 09:54:10 2021 +0100

    bpo-44206: Add a version number to dictionary keys (GH-26333)
    
    * Store log2(size) instead of size in dict-keys.
    
    * Use enum instead of function pointer to record kind of keys.
    
    * Add version number to dict keys.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -566,55 +553,55 @@
-new_keys_object(Py_ssize_t size)
+new_keys_object(uint8_t log2_size)
 {
     PyDictKeysObject *dk;
     Py_ssize_t es, usable;
 
-    assert(size >= PyDict_MINSIZE);
-    assert(IS_POWER_OF_2(size));
+    assert(log2_size >= PyDict_LOG_MINSIZE);
 
-    usable = USABLE_FRACTION(size);
-    if (size <= 0xff) {
+    usable = USABLE_FRACTION(1<<log2_size);
+    if (log2_size <= 7) {
         es = 1;
     }
-    else if (size <= 0xffff) {
+    else if (log2_size <= 15) {
         es = 2;
     }
 #if SIZEOF_VOID_P > 4
-    else if (size <= 0xffffffff) {
+    else if (log2_size <= 31) {
         es = 4;
     }
 #endif
     else {
         es = sizeof(Py_ssize_t);
     }
 
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_keys_object() must not be called after _PyDict_Fini()
     assert(state->keys_numfree != -1);
 #endif
-    if (size == PyDict_MINSIZE && state->keys_numfree > 0) {
+    if (log2_size == PyDict_LOG_MINSIZE && state->keys_numfree > 0) {
         dk = state->keys_free_list[--state->keys_numfree];
     }
     else
     {
         dk = PyObject_Malloc(sizeof(PyDictKeysObject)
-                             + es * size
+                             + (es<<log2_size)
                              + sizeof(PyDictKeyEntry) * usable);
         if (dk == NULL) {
             PyErr_NoMemory();
             return NULL;
         }
     }
 #ifdef Py_REF_DEBUG
     _Py_RefTotal++;
 #endif
     dk->dk_refcnt = 1;
-    dk->dk_size = size;
+    dk->dk_log2_size = log2_size;
     dk->dk_usable = usable;
-    dk->dk_lookup = lookdict_unicode_nodummy;
+    dk->dk_kind = DICT_KEYS_UNICODE;
     dk->dk_nentries = 0;
-    memset(&dk->dk_indices[0], 0xff, es * size);
+    dk->dk_version = 0;
+    memset(&dk->dk_indices[0], 0xff, es * (1<<log2_size));
     memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable);
     return dk;
 }
 
commit 4246fe977d850f8b78505c982f055d33d52ff339
Date:   Tue Nov 29 12:12:17 2022 +0100

    gh-99845: Change _PyDict_KeysSize() return type to size_t (#99848)
    
    * Change _PyDict_KeysSize() and shared_keys_usable_size() return type
      from signed (Py_ssize_t) to unsigned (size_t) type.
    * new_values() argument type is now unsigned (size_t).
    * init_inline_values() now uses size_t rather than int for the 'i'
      iterator variable.
    * type.__sizeof__() implementation now uses unsigned (size_t) type.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -688,15 +688,15 @@
-new_values(Py_ssize_t size)
+new_values(size_t size)
 {
-    assert(size > 0);
+    assert(size >= 1);
     size_t prefix_size = _Py_SIZE_ROUND_UP(size+2, sizeof(PyObject *));
     assert(prefix_size < 256);
     size_t n = prefix_size + size * sizeof(PyObject *);
     uint8_t *mem = PyMem_Malloc(n);
     if (mem == NULL) {
         return NULL;
     }
     assert(prefix_size % sizeof(PyObject *) == 0);
     mem[prefix_size-1] = (uint8_t)prefix_size;
     return (PyDictValues*)(mem + prefix_size);
 }
 

commit 25db2b361beb865192a3424830ddcb0ae4b17318
Date:   Tue Feb 8 11:50:38 2022 +0000

    bpo-46675: Allow object value arrays and split key dictionaries larger than 16 (GH-31191)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -637,6 +643,15 @@
 new_values(Py_ssize_t size)
 {
-    Py_ssize_t n = sizeof(PyDictValues) + sizeof(PyObject *) * (size-1);
-    return (PyDictValues*)PyMem_Malloc(n);
+    assert(size > 0);
+    size_t prefix_size = _Py_SIZE_ROUND_UP(size+2, sizeof(PyObject *));
+    assert(prefix_size < 256);
+    size_t n = prefix_size + size * sizeof(PyObject *);
+    uint8_t *mem = PyMem_Malloc(n);
+    if (mem == NULL) {
+        return NULL;
+    }
+    assert(prefix_size % sizeof(PyObject *) == 0);
+    mem[prefix_size-1] = (uint8_t)prefix_size;
+    return (PyDictValues*)(mem + prefix_size);
 }
 

commit a7252f88d3fa33036bdd6036b8c97bc785ed6f17
Date:   Wed Oct 6 13:19:53 2021 +0100

    bpo-40116: Add insertion order bit-vector to dict values to allow dicts to share keys more freely. (GH-28520)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -609,1 +626,6 @@
-#define new_values(size) PyMem_NEW(PyObject *, size)
+new_values(Py_ssize_t size)
+{
+    Py_ssize_t n = sizeof(PyDictValues) + sizeof(PyObject *) * (size-1);
+    return (PyDictValues*)PyMem_Malloc(n);
+}
+
commit 6dedf42527fddbed8ef61ef8d3f025bf3a373359
Date:   Thu Nov 10 16:27:53 2022 +0100

    gh-99300: Use Py_NewRef() in Objects/dictobject.c (#99333)
    
    Replace Py_INCREF() and Py_XINCREF() with Py_NewRef() and
    Py_XNewRef() in Objects/dictobject.c.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -4552,23 +4513,22 @@
 _PyDictView_New(PyObject *dict, PyTypeObject *type)
 {
     _PyDictViewObject *dv;
     if (dict == NULL) {
         PyErr_BadInternalCall();
         return NULL;
     }
     if (!PyDict_Check(dict)) {
         /* XXX Get rid of this restriction later */
         PyErr_Format(PyExc_TypeError,
                      "%s() requires a dict argument, not '%s'",
                      type->tp_name, Py_TYPE(dict)->tp_name);
         return NULL;
     }
     dv = PyObject_GC_New(_PyDictViewObject, type);
     if (dv == NULL)
         return NULL;
-    Py_INCREF(dict);
-    dv->dv_dict = (PyDictObject *)dict;
+    dv->dv_dict = (PyDictObject *)Py_NewRef(dict);
     _PyObject_GC_TRACK(dv);
     return (PyObject *)dv;
 }
 
[CORR] **new** commit ab383eb6f03896b0ef6634ee3d776344fcb9e5b8
Date:   Thu May 13 08:54:17 2021 +0100

    bpo-44114: Fix dictkeys_reversed and dictvalues_reversed function signatures (GH-26062)
    
    These are passed and called as PyCFunction, however they are defined here without the (ignored) args parameter.
    
    This works fine in some C compilers, but fails in webassembly or anything else that has strict function pointer call type checking.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -4912,2 +4912,2 @@
-static PyObject* dictvalues_reversed(_PyDictViewObject *dv);
+static PyObject* dictvalues_reversed(_PyDictViewObject *dv, PyObject *Py_UNUSED(ignored));
 
commit ab383eb6f03896b0ef6634ee3d776344fcb9e5b8
Date:   Thu May 13 08:54:17 2021 +0100

    bpo-44114: Fix dictkeys_reversed and dictvalues_reversed function signatures (GH-26062)
    
    These are passed and called as PyCFunction, however they are defined here without the (ignored) args parameter.
    
    This works fine in some C compilers, but fails in webassembly or anything else that has strict function pointer call type checking.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -4829,2 +4829,2 @@
-static PyObject* dictitems_reversed(_PyDictViewObject *dv);
+static PyObject* dictitems_reversed(_PyDictViewObject *dv, PyObject *Py_UNUSED(ignored));
 
[INCR] **new** commit 9db1e17c80217d7b18a2f44297d72acd10ee73d6
Date:   Wed Nov 16 10:37:29 2022 -0700

    gh-81057: Move the global Dict-Related Versions to _PyRuntimeState (gh-99497)
    
    We also move the global func version.
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -237,11 +237,6 @@
 static PyObject* dict_iter(PyDictObject *dict);
 
-/*Global counter used to set ma_version_tag field of dictionary.
- * It is incremented each time that a dictionary is created and each
- * time that a dictionary is modified. */
-uint64_t _pydict_global_version = 0;
-
 #include "clinic/dictobject.c.h"
 
 
 #if PyDict_MAXFREELIST > 0

commit 9942f42a93ccda047fd3558c47b822e99afe10c0
Date:   Thu Oct 21 16:12:20 2021 +0300

    bpo-45522: Allow to disable freelists on build time (GH-29056)
    
    
    
    Freelists for object structs can now be disabled. A new ``configure``
    option ``--without-freelists`` can be used to disable all freelists
    except empty tuple singleton. Internal Py*_MAXFREELIST macros can now
    be defined as 0 without causing compiler warnings and segfaults.
    
    Signed-off-by: Christian Heimes <christian@python.org>

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -233,10 +233,11 @@
 static PyObject* dict_iter(PyDictObject *dict);
 
 /*Global counter used to set ma_version_tag field of dictionary.
  * It is incremented each time that a dictionary is created and each
  * time that a dictionary is modified. */
 uint64_t _pydict_global_version = 0;
 
 #include "clinic/dictobject.c.h"
 
 
+#if PyDict_MAXFREELIST > 0

[FUNC] **new** commit ac75f6bdd4748b3378dd321f862d13aa1898f77a
Date:   Mon Aug 9 10:40:21 2021 +0100

    bpo-44826: Specialize STORE_ATTR (GH-27590)
    
    * Generalize cache names for LOAD_ATTR to allow store and delete specializations.
    
    * Factor out specialization of attribute dictionary access.
    
    * Specialize STORE_ATTR.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -232,12 +232,10 @@
 static PyObject* dict_iter(PyDictObject *dict);
 
 /*Global counter used to set ma_version_tag field of dictionary.
  * It is incremented each time that a dictionary is created and each
  * time that a dictionary is modified. */
-static uint64_t pydict_global_version = 0;
-
-#define DICT_NEXT_VERSION() (++pydict_global_version)
+uint64_t _pydict_global_version = 0;
 
 #include "clinic/dictobject.c.h"
 
 
[FUNC] **new** commit c0feb99187f449f844621b378273776d70a50f57
Date:   Thu Nov 10 16:27:32 2022 +0100

    gh-99300: Use Py_NewRef() in Objects/ directory (#99332)
    
    Replace Py_INCREF() and Py_XINCREF() with Py_NewRef() and
    Py_XNewRef() in C files of the Objects/ directory.

diff --git a/Objects/bytesobject.c b/Objects/bytesobject.c
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -119,27 +118,26 @@
 PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
 {
     PyBytesObject *op;
     if (size < 0) {
         PyErr_SetString(PyExc_SystemError,
             "Negative size passed to PyBytes_FromStringAndSize");
         return NULL;
     }
     if (size == 1 && str != NULL) {
         op = CHARACTER(*str & 255);
-        Py_INCREF(op);
-        return (PyObject *)op;
+        return Py_NewRef(op);
     }
     if (size == 0) {
         return bytes_new_empty();
     }
 
     op = (PyBytesObject *)_PyBytes_FromSize(size, 0);
     if (op == NULL)
         return NULL;
     if (str == NULL)
         return (PyObject *) op;
 
     memcpy(op->ob_sval, str, size);
     return (PyObject *) op;
 }
 

[FUNC] **new** commit cf496d657a1a82eaf9ebfb47d721676fef6effa5
Date:   Tue Jan 11 09:37:24 2022 -0700

    bpo-45953: Statically allocate and initialize global bytes objects. (gh-30096)
    
    The empty bytes object (b'') and the 256 one-character bytes objects were allocated at runtime init.  Now we statically allocate and initialize them.
    
    https://bugs.python.org/issue45953

diff --git a/Objects/bytesobject.c b/Objects/bytesobject.c
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -142,36 +117,27 @@
 PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
 {
     PyBytesObject *op;
     if (size < 0) {
         PyErr_SetString(PyExc_SystemError,
             "Negative size passed to PyBytes_FromStringAndSize");
         return NULL;
     }
     if (size == 1 && str != NULL) {
-        struct _Py_bytes_state *state = get_bytes_state();
-        op = state->characters[*str & UCHAR_MAX];
-        if (op != NULL) {
-            Py_INCREF(op);
-            return (PyObject *)op;
-        }
+        op = CHARACTER(*str & 255);
+        Py_INCREF(op);
+        return (PyObject *)op;
     }
     if (size == 0) {
         return bytes_new_empty();
     }
 
     op = (PyBytesObject *)_PyBytes_FromSize(size, 0);
     if (op == NULL)
         return NULL;
     if (str == NULL)
         return (PyObject *) op;
 
     memcpy(op->ob_sval, str, size);
-    /* share short strings */
-    if (size == 1) {
-        struct _Py_bytes_state *state = get_bytes_state();
-        Py_INCREF(op);
-        state->characters[*str & UCHAR_MAX] = op;
-    }
     return (PyObject *) op;
 }
 
commit c0feb99187f449f844621b378273776d70a50f57
Date:   Thu Nov 10 16:27:32 2022 +0100

    gh-99300: Use Py_NewRef() in Objects/ directory (#99332)
    
    Replace Py_INCREF() and Py_XINCREF() with Py_NewRef() and
    Py_XNewRef() in C files of the Objects/ directory.

diff --git a/Objects/bytesobject.c b/Objects/bytesobject.c
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -119,27 +118,26 @@
 PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
 {
     PyBytesObject *op;
     if (size < 0) {
         PyErr_SetString(PyExc_SystemError,
             "Negative size passed to PyBytes_FromStringAndSize");
         return NULL;
     }
     if (size == 1 && str != NULL) {
         op = CHARACTER(*str & 255);
-        Py_INCREF(op);
-        return (PyObject *)op;
+        return Py_NewRef(op);
     }
     if (size == 0) {
         return bytes_new_empty();
     }
 
     op = (PyBytesObject *)_PyBytes_FromSize(size, 0);
     if (op == NULL)
         return NULL;
     if (str == NULL)
         return (PyObject *) op;
 
     memcpy(op->ob_sval, str, size);
     return (PyObject *) op;
 }
 

commit cf496d657a1a82eaf9ebfb47d721676fef6effa5
Date:   Tue Jan 11 09:37:24 2022 -0700

    bpo-45953: Statically allocate and initialize global bytes objects. (gh-30096)
    
    The empty bytes object (b'') and the 256 one-character bytes objects were allocated at runtime init.  Now we statically allocate and initialize them.
    
    https://bugs.python.org/issue45953

diff --git a/Objects/bytesobject.c b/Objects/bytesobject.c
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -142,36 +117,27 @@
 PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
 {
     PyBytesObject *op;
     if (size < 0) {
         PyErr_SetString(PyExc_SystemError,
             "Negative size passed to PyBytes_FromStringAndSize");
         return NULL;
     }
     if (size == 1 && str != NULL) {
-        struct _Py_bytes_state *state = get_bytes_state();
-        op = state->characters[*str & UCHAR_MAX];
-        if (op != NULL) {
-            Py_INCREF(op);
-            return (PyObject *)op;
-        }
+        op = CHARACTER(*str & 255);
+        Py_INCREF(op);
+        return (PyObject *)op;
     }
     if (size == 0) {
         return bytes_new_empty();
     }
 
     op = (PyBytesObject *)_PyBytes_FromSize(size, 0);
     if (op == NULL)
         return NULL;
     if (str == NULL)
         return (PyObject *) op;
 
     memcpy(op->ob_sval, str, size);
-    /* share short strings */
-    if (size == 1) {
-        struct _Py_bytes_state *state = get_bytes_state();
-        Py_INCREF(op);
-        state->characters[*str & UCHAR_MAX] = op;
-    }
     return (PyObject *) op;
 }
 
[FUNC] **new** commit 8370e07e1e5b626e78ddc7aadbfaf248976c4454
Date:   Wed Mar 24 02:23:01 2021 +0100

    bpo-43244: Remove the pyarena.h header (GH-25007)
    
    Remove the pyarena.h header file with functions:
    
    * PyArena_New()
    * PyArena_Free()
    * PyArena_Malloc()
    * PyArena_AddPyObject()
    
    These functions were undocumented, excluded from the limited C API,
    and were only used internally by the compiler.
    
    Add pycore_pyarena.h header. Rename functions:
    
    * PyArena_New() => _PyArena_New()
    * PyArena_Free() => _PyArena_Free()
    * PyArena_Malloc() => _PyArena_Malloc()
    * PyArena_AddPyObject() => _PyArena_AddPyObject()

diff --git a/Python/pyarena.c b/Python/pyarena.c
--- a/Python/pyarena.c
+++ b/Python/pyarena.c
@@ -180,22 +181,22 @@
-PyArena_Malloc(PyArena *arena, size_t size)
+_PyArena_Malloc(PyArena *arena, size_t size)
 {
     void *p = block_alloc(arena->a_cur, size);
     if (!p)
         return PyErr_NoMemory();
 #if defined(Py_DEBUG)
     arena->total_allocs++;
     arena->total_size += size;
 #endif
     /* Reset cur if we allocated a new block. */
     if (arena->a_cur->ab_next) {
         arena->a_cur = arena->a_cur->ab_next;
 #if defined(Py_DEBUG)
         arena->total_blocks++;
         arena->total_block_size += arena->a_cur->ab_size;
         if (arena->a_cur->ab_size > DEFAULT_BLOCK_SIZE)
             ++arena->total_big_blocks;
 #endif
     }
     return p;
 }
 
commit 8370e07e1e5b626e78ddc7aadbfaf248976c4454
Date:   Wed Mar 24 02:23:01 2021 +0100

    bpo-43244: Remove the pyarena.h header (GH-25007)
    
    Remove the pyarena.h header file with functions:
    
    * PyArena_New()
    * PyArena_Free()
    * PyArena_Malloc()
    * PyArena_AddPyObject()
    
    These functions were undocumented, excluded from the limited C API,
    and were only used internally by the compiler.
    
    Add pycore_pyarena.h header. Rename functions:
    
    * PyArena_New() => _PyArena_New()
    * PyArena_Free() => _PyArena_Free()
    * PyArena_Malloc() => _PyArena_Malloc()
    * PyArena_AddPyObject() => _PyArena_AddPyObject()

diff --git a/Python/pyarena.c b/Python/pyarena.c
--- a/Python/pyarena.c
+++ b/Python/pyarena.c
@@ -128,28 +129,28 @@
-PyArena_New()
+_PyArena_New(void)
 {
     PyArena* arena = (PyArena *)PyMem_Malloc(sizeof(PyArena));
     if (!arena)
         return (PyArena*)PyErr_NoMemory();
 
     arena->a_head = block_new(DEFAULT_BLOCK_SIZE);
     arena->a_cur = arena->a_head;
     if (!arena->a_head) {
         PyMem_Free((void *)arena);
         return (PyArena*)PyErr_NoMemory();
     }
     arena->a_objects = PyList_New(0);
     if (!arena->a_objects) {
         block_free(arena->a_head);
         PyMem_Free((void *)arena);
         return (PyArena*)PyErr_NoMemory();
     }
 #if defined(Py_DEBUG)
     arena->total_allocs = 0;
     arena->total_size = 0;
     arena->total_blocks = 1;
     arena->total_block_size = DEFAULT_BLOCK_SIZE;
     arena->total_big_blocks = 0;
 #endif
     return arena;
 }
 
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -2219,57 +1553,57 @@
 pymalloc_free(void *Py_UNUSED(ctx), void *p)
 {
     assert(p != NULL);
 
 #ifdef WITH_VALGRIND
     if (UNLIKELY(running_on_valgrind > 0)) {
         return 0;
     }
 #endif
 
     poolp pool = POOL_ADDR(p);
     if (UNLIKELY(!address_in_range(p, pool))) {
         return 0;
     }
     /* We allocated this address. */
 
     /* Link p to the start of the pool's freeblock list.  Since
      * the pool had at least the p block outstanding, the pool
      * wasn't empty (so it's already in a usedpools[] list, or
      * was full and is in no list -- it's not in the freeblocks
      * list in any case).
      */
     assert(pool->ref.count > 0);            /* else it was empty */
-    block *lastfree = pool->freeblock;
-    *(block **)p = lastfree;
-    pool->freeblock = (block *)p;
+    pymem_block *lastfree = pool->freeblock;
+    *(pymem_block **)p = lastfree;
+    pool->freeblock = (pymem_block *)p;
     pool->ref.count--;
 
     if (UNLIKELY(lastfree == NULL)) {
         /* Pool was full, so doesn't currently live in any list:
          * link it to the front of the appropriate usedpools[] list.
          * This mimics LRU pool usage for new allocations and
          * targets optimal filling when several pools contain
          * blocks of the same size class.
          */
         insert_to_usedpool(pool);
         return 1;
     }
 
     /* freeblock wasn't NULL, so the pool wasn't full,
      * and the pool is in a usedpools[] list.
      */
     if (LIKELY(pool->ref.count != 0)) {
         /* pool isn't empty:  leave it in usedpools */
         return 1;
     }
 
     /* Pool is now empty:  unlink from usedpools, and
      * link to the front of freepools.  This ensures that
      * previously freed pools will be allocated later
      * (being not referenced, they are perhaps paged out).
      */
     insert_to_freepool(pool);
     return 1;
 }
 
 

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -2218,57 +2219,57 @@
-pymalloc_free(void *ctx, void *p)
+pymalloc_free(void *Py_UNUSED(ctx), void *p)
 {
     assert(p != NULL);
 
 #ifdef WITH_VALGRIND
     if (UNLIKELY(running_on_valgrind > 0)) {
         return 0;
     }
 #endif
 
     poolp pool = POOL_ADDR(p);
     if (UNLIKELY(!address_in_range(p, pool))) {
         return 0;
     }
     /* We allocated this address. */
 
     /* Link p to the start of the pool's freeblock list.  Since
      * the pool had at least the p block outstanding, the pool
      * wasn't empty (so it's already in a usedpools[] list, or
      * was full and is in no list -- it's not in the freeblocks
      * list in any case).
      */
     assert(pool->ref.count > 0);            /* else it was empty */
     block *lastfree = pool->freeblock;
     *(block **)p = lastfree;
     pool->freeblock = (block *)p;
     pool->ref.count--;
 
     if (UNLIKELY(lastfree == NULL)) {
         /* Pool was full, so doesn't currently live in any list:
          * link it to the front of the appropriate usedpools[] list.
          * This mimics LRU pool usage for new allocations and
          * targets optimal filling when several pools contain
          * blocks of the same size class.
          */
         insert_to_usedpool(pool);
         return 1;
     }
 
     /* freeblock wasn't NULL, so the pool wasn't full,
      * and the pool is in a usedpools[] list.
      */
     if (LIKELY(pool->ref.count != 0)) {
         /* pool isn't empty:  leave it in usedpools */
         return 1;
     }
 
     /* Pool is now empty:  unlink from usedpools, and
      * link to the front of freepools.  This ensures that
      * previously freed pools will be allocated later
      * (being not referenced, they are perhaps paged out).
      */
     insert_to_freepool(pool);
     return 1;
 }
 
 
[FUNC] **new** commit f40bc7fa49f8d137f9b38f7a14569e9a9bdbed07
Date:   Wed Jul 27 16:03:38 2022 +0100

    gh-95324: Emit a warning if an object doesn't call PyObject_GC_UnTrack during deallocation in debug mode (#95325)

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2345,14 +2345,21 @@
 PyObject_GC_Del(void *op)
 {
     size_t presize = _PyType_PreHeaderSize(((PyObject *)op)->ob_type);
     PyGC_Head *g = AS_GC(op);
     if (_PyObject_GC_IS_TRACKED(op)) {
+#ifdef Py_DEBUG
+        if (PyErr_WarnExplicitFormat(PyExc_ResourceWarning, "gc", 0,
+                                     "gc", NULL, "Object of type %s is not untracked before destruction",
+                                     ((PyObject*)op)->ob_type->tp_name)) {
+            PyErr_WriteUnraisable(NULL);
+        }
+#endif
         gc_list_remove(g);
     }
     GCState *gcstate = get_gc_state();
     if (gcstate->generations[0].count > 0) {
         gcstate->generations[0].count--;
     }
     PyObject_Free(((char *)op)-presize);
 }
 

commit 8319114feedd2a5b77378bba24eb9fb2689c5033
Date:   Tue Dec 7 16:02:53 2021 +0000

    bpo-45947: Place dict and values pointer at fixed (negative) offset just before GC header. (GH-29879)
    
    * Place __dict__ immediately before GC header for plain Python objects.
    
    * Fix up lazy dict creation logic to use managed dict pointers.
    
    * Manage values pointer, placing them directly before managed dict pointers.
    
    * Convert hint-based load/store attr specialization target managed dict classes.
    
    * Specialize LOAD_METHOD for managed dict objects.
    
    * Remove unsafe _PyObject_GC_Calloc function.
    
    * Remove unsafe _PyObject_GC_Malloc() function.
    
    * Add comment explaning use of Py_TPFLAGS_MANAGED_DICT.

diff --git a/Modules/gcmodule.c b/Modules/gcmodule.c
--- a/Modules/gcmodule.c
+++ b/Modules/gcmodule.c
@@ -2334,13 +2327,14 @@
 PyObject_GC_Del(void *op)
 {
+    size_t presize = _PyType_PreHeaderSize(((PyObject *)op)->ob_type);
     PyGC_Head *g = AS_GC(op);
     if (_PyObject_GC_IS_TRACKED(op)) {
         gc_list_remove(g);
     }
     GCState *gcstate = get_gc_state();
     if (gcstate->generations[0].count > 0) {
         gcstate->generations[0].count--;
     }
-    PyObject_Free(g);
+    PyObject_Free(((char *)op)-presize);
 }
 
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -127,9 +69,13 @@
 _PyMem_RawFree(void *Py_UNUSED(ctx), void *ptr)
 {
     free(ptr);
 }
 
+#define MALLOC_ALLOC {NULL, _PyMem_RawMalloc, _PyMem_RawCalloc, _PyMem_RawRealloc, _PyMem_RawFree}
+#define PYRAW_ALLOC MALLOC_ALLOC
 
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+/* the default object allocator */
+
+// The actual implementation is further down.
+
+#ifdef WITH_PYMALLOC

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -127,9 +127,9 @@
-_PyMem_RawFree(void *ctx, void *ptr)
+_PyMem_RawFree(void *Py_UNUSED(ctx), void *ptr)
 {
     free(ptr);
 }
 
 
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -127,9 +69,13 @@
 _PyMem_RawFree(void *Py_UNUSED(ctx), void *ptr)
 {
     free(ptr);
 }
 
+#define MALLOC_ALLOC {NULL, _PyMem_RawMalloc, _PyMem_RawCalloc, _PyMem_RawRealloc, _PyMem_RawFree}
+#define PYRAW_ALLOC MALLOC_ALLOC
 
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+/* the default object allocator */
+
+// The actual implementation is further down.
+
+#ifdef WITH_PYMALLOC

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -127,9 +127,9 @@
-_PyMem_RawFree(void *ctx, void *ptr)
+_PyMem_RawFree(void *Py_UNUSED(ctx), void *ptr)
 {
     free(ptr);
 }
 
 
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 836b17c9c3ea313e400e58a75f52b63f96e498bb
Date:   Tue May 3 16:40:24 2022 -0600

    Add more stats for freelist use and allocations. (GH-92211)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -641,6 +649,7 @@
 PyMem_Free(void *ptr)
 {
+    OBJECT_STAT_INC(frees);
     _PyMem.free(_PyMem.ctx, ptr);
 }
 
 
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +84,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void _PyObject_Free(void *ctx, void *p);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +84,1 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void _PyObject_Free(void *ctx, void *p);

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +101,2 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void _PyMem_DebugRawFree(void *ctx, void *ptr);
+

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
commit 67807cfc87135fdce4992d38d2ffe3e44747e73b
Date:   Fri Nov 11 16:30:46 2022 -0700

    gh-81057: Move the Allocators to _PyRuntimeState (gh-99217)
    
    The global allocators were stored in 3 static global variables: _PyMem_Raw, _PyMem, and _PyObject.  State for the "small block" allocator was stored in another 13.  That makes a total of 16 global variables. We are moving all 16 to the _PyRuntimeState struct as part of the work for gh-81057.  (If PEP 684 is accepted then we will follow up by moving them all to PyInterpreterState.)
    
    https://github.com/python/cpython/issues/81057

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +106,22 @@
-#ifdef MS_WINDOWS
-static void *
-_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
+void _PyMem_DebugFree(void *ctx, void *p);
+
+#define PYDBGRAW_ALLOC \
+    {&_PyRuntime.allocators.debug.raw, _PyMem_DebugRawMalloc, _PyMem_DebugRawCalloc, _PyMem_DebugRawRealloc, _PyMem_DebugRawFree}
+#define PYDBGMEM_ALLOC \
+    {&_PyRuntime.allocators.debug.mem, _PyMem_DebugMalloc, _PyMem_DebugCalloc, _PyMem_DebugRealloc, _PyMem_DebugFree}
+#define PYDBGOBJ_ALLOC \
+    {&_PyRuntime.allocators.debug.obj, _PyMem_DebugMalloc, _PyMem_DebugCalloc, _PyMem_DebugRealloc, _PyMem_DebugFree}
+
+/* the low-level virtual memory allocator */
+
+#ifdef WITH_PYMALLOC
+#  ifdef MS_WINDOWS
+#    include <windows.h>
+#  elif defined(HAVE_MMAP)
+#    include <sys/mman.h>
+#    ifdef MAP_ANONYMOUS
+#      define ARENAS_USE_MMAP
+#    endif
+#  endif
+#endif
+

commit 9485a0dbddcee014821b41c960133632bb68b33c
Date:   Wed May 25 17:39:06 2022 +0700

    gh-93040 Wrap unused parameters in Objects/obmalloc.c with Py_UNUSED (#93175)

diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -133,3 +133,3 @@
 #ifdef MS_WINDOWS
 static void *
-_PyObject_ArenaVirtualAlloc(void *ctx, size_t size)
+_PyObject_ArenaVirtualAlloc(void *Py_UNUSED(ctx), size_t size)
[FUNC] **new** commit 3359cab038968935b40344fad7c30d211f9692e4
Date:   Fri Apr 2 15:45:37 2021 +0200

    bpo-43688: Support the limited C API in debug mode (GH-25131)
    
    The limited C API is now supported if Python is built in debug mode
    (if the Py_DEBUG macro is defined). In the limited C API, the
    Py_INCREF() and Py_DECREF() functions are now implemented as opaque
    function calls, rather than accessing directly the PyObject.ob_refcnt
    member, if Python is built in debug mode and the Py_LIMITED_API macro
    targets Python 3.10 or newer. It became possible to support the
    limited C API in debug mode because the PyObject structure is the
    same in release and debug mode since Python 3.8 (see bpo-36465).
    
    The limited C API is still not supported in the --with-trace-refs
    special build (Py_TRACE_REFS macro).

diff --git a/Objects/object.c b/Objects/object.c
--- a/Objects/object.c
+++ b/Objects/object.c
@@ -139,0 +151,5 @@
+_Py_DecRef(PyObject *o)
+{
+    Py_DECREF(o);
+}
+
[FUNC] **new** commit 364ed9409269fb321dc4eafdea677c09a4bc0d8d
Date:   Thu Apr 21 23:04:01 2022 +0200

    gh-89373: _Py_Dealloc() checks tp_dealloc exception (#32357)
    
    If Python is built in debug mode, _Py_Dealloc() now ensures that the
    tp_dealloc function leaves the current exception unchanged.

diff --git a/Objects/object.c b/Objects/object.c
--- a/Objects/object.c
+++ b/Objects/object.c
@@ -2355,10 +2355,44 @@
 _Py_Dealloc(PyObject *op)
 {
-    destructor dealloc = Py_TYPE(op)->tp_dealloc;
+    PyTypeObject *type = Py_TYPE(op);
+    destructor dealloc = type->tp_dealloc;
+#ifdef Py_DEBUG
+    PyThreadState *tstate = _PyThreadState_GET();
+    PyObject *old_exc_type = tstate->curexc_type;
+    // Keep the old exception type alive to prevent undefined behavior
+    // on (tstate->curexc_type != old_exc_type) below
+    Py_XINCREF(old_exc_type);
+    // Make sure that type->tp_name remains valid
+    Py_INCREF(type);
+#endif
+
 #ifdef Py_TRACE_REFS
     _Py_ForgetReference(op);
 #endif
     (*dealloc)(op);
+
+#ifdef Py_DEBUG
+    // gh-89373: The tp_dealloc function must leave the current exception
+    // unchanged.
+    if (tstate->curexc_type != old_exc_type) {
+        const char *err;
+        if (old_exc_type == NULL) {
+            err = "Deallocator of type '%s' raised an exception";
+        }
+        else if (tstate->curexc_type == NULL) {
+            err = "Deallocator of type '%s' cleared the current exception";
+        }
+        else {
+            // It can happen if dealloc() normalized the current exception.
+            // A deallocator function must not change the current exception,
+            // not even normalize it.
+            err = "Deallocator of type '%s' overrode the current exception";
+        }
+        _Py_FatalErrorFormat(__func__, err, type->tp_name);
+    }
+    Py_XDECREF(old_exc_type);
+    Py_DECREF(type);
+#endif
 }
 
 
[FUNC] **new** commit c45fa1a5d9b419cf13ad4b5a7cb453956495b83e
Date:   Tue Jul 6 21:04:33 2021 +0300

    bpo-44490: Add __parameters__ and __getitem__ to types.Union (GH-26980)
    
    Co-authored-by: Ken Jin <28750310+Fidget-Spinner@users.noreply.github.com>
    Co-authored-by: Guido van Rossum <gvanrossum@gmail.com>

diff --git a/Objects/unionobject.c b/Objects/unionobject.c
--- a/Objects/unionobject.c
+++ b/Objects/unionobject.c
@@ -14,10 +15,11 @@
 unionobject_dealloc(PyObject *self)
 {
     unionobject *alias = (unionobject *)self;
 
     _PyObject_GC_UNTRACK(self);
 
     Py_XDECREF(alias->args);
+    Py_XDECREF(alias->parameters);
     Py_TYPE(self)->tp_free(self);
 }
 

[FUNC] **new** commit 1097384ce964dd63686b1aac706cd0fa764c2dc9
Date:   Sat Jul 3 20:12:11 2021 +0800

    bpo-44553 : Implement GC methods for types.Union (GH-26993)

diff --git a/Objects/unionobject.c b/Objects/unionobject.c
--- a/Objects/unionobject.c
+++ b/Objects/unionobject.c
@@ -13,8 +14,10 @@
 unionobject_dealloc(PyObject *self)
 {
     unionobject *alias = (unionobject *)self;
 
+    _PyObject_GC_UNTRACK(self);
+
     Py_XDECREF(alias->args);
     Py_TYPE(self)->tp_free(self);
 }
 
commit 713bb19356bce9b8f2b95461834fe1dae505f889
Date:   Wed Oct 13 17:22:14 2021 +0200

    bpo-45434: Mark the PyTokenizer C API as private (GH-28924)
    
    Rename PyTokenize functions to mark them as private:
    
    * PyTokenizer_FindEncodingFilename() => _PyTokenizer_FindEncodingFilename()
    * PyTokenizer_FromString() => _PyTokenizer_FromString()
    * PyTokenizer_FromFile() => _PyTokenizer_FromFile()
    * PyTokenizer_FromUTF8() => _PyTokenizer_FromUTF8()
    * PyTokenizer_Free() => _PyTokenizer_Free()
    * PyTokenizer_Get() => _PyTokenizer_Get()
    
    Remove the unused PyTokenizer_FindEncoding() function.
    
    import.c: remove unused #include "errcode.h".

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -108,13 +108,13 @@
 error_ret(struct tok_state *tok) /* XXX */
 {
     tok->decoding_erred = 1;
-    if (tok->fp != NULL && tok->buf != NULL) /* see PyTokenizer_Free */
+    if (tok->fp != NULL && tok->buf != NULL) /* see _PyTokenizer_Free */
         PyMem_Free(tok->buf);
     tok->buf = tok->cur = tok->inp = NULL;
     tok->start = NULL;
     tok->end = NULL;
     tok->done = E_DECODE;
     return NULL;                /* as if it were EOF */
 }
 
 
commit 713bb19356bce9b8f2b95461834fe1dae505f889
Date:   Wed Oct 13 17:22:14 2021 +0200

    bpo-45434: Mark the PyTokenizer C API as private (GH-28924)
    
    Rename PyTokenize functions to mark them as private:
    
    * PyTokenizer_FindEncodingFilename() => _PyTokenizer_FindEncodingFilename()
    * PyTokenizer_FromString() => _PyTokenizer_FromString()
    * PyTokenizer_FromFile() => _PyTokenizer_FromFile()
    * PyTokenizer_FromUTF8() => _PyTokenizer_FromUTF8()
    * PyTokenizer_Free() => _PyTokenizer_Free()
    * PyTokenizer_Get() => _PyTokenizer_Get()
    
    Remove the unused PyTokenizer_FindEncoding() function.
    
    import.c: remove unused #include "errcode.h".

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -785,20 +785,20 @@
-PyTokenizer_Free(struct tok_state *tok)
+_PyTokenizer_Free(struct tok_state *tok)
 {
     if (tok->encoding != NULL) {
         PyMem_Free(tok->encoding);
     }
     Py_XDECREF(tok->decoding_readline);
     Py_XDECREF(tok->decoding_buffer);
     Py_XDECREF(tok->filename);
     if (tok->fp != NULL && tok->buf != NULL) {
         PyMem_Free(tok->buf);
     }
     if (tok->input) {
         PyMem_Free(tok->input);
     }
     if (tok->interactive_src_start != NULL) {
         PyMem_Free(tok->interactive_src_start);
     }
     PyMem_Free(tok);
 }
 

[CORR] **new** commit cd8dcbc851fcc312722cdb5544c2f25cf46b3f8a
Date:   Sun Mar 14 04:38:40 2021 +0100

    bpo-43410: Fix crash in the parser when producing syntax errors when reading from stdin (GH-24763)

diff --git a/Parser/tokenizer.c b/Parser/tokenizer.c
--- a/Parser/tokenizer.c
+++ b/Parser/tokenizer.c
@@ -808,16 +844,20 @@
 PyTokenizer_Free(struct tok_state *tok)
 {
-    if (tok->encoding != NULL)
+    if (tok->encoding != NULL) {
         PyMem_Free(tok->encoding);
+    }
     Py_XDECREF(tok->decoding_readline);
     Py_XDECREF(tok->decoding_buffer);
     Py_XDECREF(tok->filename);
-    if (tok->fp != NULL && tok->buf != NULL)
+    if (tok->fp != NULL && tok->buf != NULL) {
         PyMem_Free(tok->buf);
-    if (tok->input)
+    }
+    if (tok->input) {
         PyMem_Free(tok->input);
-    if (tok->stdin_content)
-        PyMem_Free(tok->stdin_content);
+    }
+    if (tok->interactive_src_start != NULL) {
+        PyMem_Free(tok->interactive_src_start);
+    }
     PyMem_Free(tok);
 }
 
commit 9942f42a93ccda047fd3558c47b822e99afe10c0
Date:   Thu Oct 21 16:12:20 2021 +0300

    bpo-45522: Allow to disable freelists on build time (GH-29056)
    
    
    
    Freelists for object structs can now be disabled. A new ``configure``
    option ``--without-freelists`` can be used to disable all freelists
    except empty tuple singleton. Internal Py*_MAXFREELIST macros can now
    be defined as 0 without causing compiler warnings and segfaults.
    
    Signed-off-by: Christian Heimes <christian@python.org>

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -252,14 +254,16 @@
 _PyDict_ClearFreeList(PyInterpreterState *interp)
 {
+#if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = &interp->dict_state;
     while (state->numfree) {
         PyDictObject *op = state->free_list[--state->numfree];
         assert(PyDict_CheckExact(op));
         PyObject_GC_Del(op);
     }
     while (state->keys_numfree) {
         PyObject_Free(state->keys_free_list[--state->keys_numfree]);
     }
+#endif
 }
 
 

[FUNC] **new** commit bcb094b41f7fe4dd1686c50891d85632fcf0d481
Date:   Fri Feb 19 15:10:45 2021 +0100

    bpo-43268: Pass interp rather than tstate to internal functions (GH-24580)
    
    Pass the current interpreter (interp) rather than the current Python
    thread state (tstate) to internal functions which only use the
    interpreter.
    
    Modified functions:
    
    * _PyXXX_Fini() and _PyXXX_ClearFreeList() functions
    * _PyEval_SignalAsyncExc(), make_pending_calls()
    * _PySys_GetObject(), sys_set_object(), sys_set_object_id(), sys_set_object_str()
    * should_audit(), set_flags_from_config(), make_flags()
    * _PyAtExit_Call()
    * init_stdio_encoding()
    * etc.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -263,14 +263,14 @@
-_PyDict_ClearFreeList(PyThreadState *tstate)
+_PyDict_ClearFreeList(PyInterpreterState *interp)
 {
-    struct _Py_dict_state *state = &tstate->interp->dict_state;
+    struct _Py_dict_state *state = &interp->dict_state;
     while (state->numfree) {
         PyDictObject *op = state->free_list[--state->numfree];
         assert(PyDict_CheckExact(op));
         PyObject_GC_Del(op);
     }
     while (state->keys_numfree) {
         PyObject_Free(state->keys_free_list[--state->keys_numfree]);
     }
 }
 
 
[FUNC] **new** commit a4b7794887929f82c532fcd055326954ff1197ce
Date:   Thu Oct 6 17:08:00 2022 -0700

    GH-91052: Add C API for watching dictionaries (GH-31787)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2322,39 +2331,40 @@
 dict_dealloc(PyDictObject *mp)
 {
+    _PyDict_NotifyEvent(PyDict_EVENT_DEALLOCATED, mp, NULL, NULL);
     PyDictValues *values = mp->ma_values;
     PyDictKeysObject *keys = mp->ma_keys;
     Py_ssize_t i, n;
 
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(mp);
     Py_TRASHCAN_BEGIN(mp, dict_dealloc)
     if (values != NULL) {
         for (i = 0, n = mp->ma_keys->dk_nentries; i < n; i++) {
             Py_XDECREF(values->values[i]);
         }
         free_values(values);
         dictkeys_decref(keys);
     }
     else if (keys != NULL) {
         assert(keys->dk_refcnt == 1 || keys == Py_EMPTY_KEYS);
         dictkeys_decref(keys);
     }
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree < PyDict_MAXFREELIST && Py_IS_TYPE(mp, &PyDict_Type)) {
         state->free_list[state->numfree++] = mp;
         OBJECT_STAT_INC(to_freelist);
     }
     else
 #endif
     {
         Py_TYPE(mp)->tp_free((PyObject *)mp);
     }
     Py_TRASHCAN_END
 }
 
 

commit 836b17c9c3ea313e400e58a75f52b63f96e498bb
Date:   Tue May 3 16:40:24 2022 -0600

    Add more stats for freelist use and allocations. (GH-92211)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2356,38 +2360,39 @@
 dict_dealloc(PyDictObject *mp)
 {
     PyDictValues *values = mp->ma_values;
     PyDictKeysObject *keys = mp->ma_keys;
     Py_ssize_t i, n;
 
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(mp);
     Py_TRASHCAN_BEGIN(mp, dict_dealloc)
     if (values != NULL) {
         for (i = 0, n = mp->ma_keys->dk_nentries; i < n; i++) {
             Py_XDECREF(values->values[i]);
         }
         free_values(values);
         dictkeys_decref(keys);
     }
     else if (keys != NULL) {
         assert(keys->dk_refcnt == 1 || keys == Py_EMPTY_KEYS);
         dictkeys_decref(keys);
     }
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree < PyDict_MAXFREELIST && Py_IS_TYPE(mp, &PyDict_Type)) {
         state->free_list[state->numfree++] = mp;
+        OBJECT_STAT_INC(to_freelist);
     }
     else
 #endif
     {
         Py_TYPE(mp)->tp_free((PyObject *)mp);
     }
     Py_TRASHCAN_END
 }
 
 

commit 03642df1a1cfddcd740b62e78bddfa3ea6863da4
Date:   Wed Mar 2 19:05:12 2022 +0900

    dict: Internal cleanup (GH-31641)
    
    * Make empty_key from split table to combined table.
    * Use unicode_get_hash() when possible.

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -2365,40 +2352,38 @@
 dict_dealloc(PyDictObject *mp)
 {
     PyDictValues *values = mp->ma_values;
     PyDictKeysObject *keys = mp->ma_keys;
     Py_ssize_t i, n;
 
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(mp);
     Py_TRASHCAN_BEGIN(mp, dict_dealloc)
     if (values != NULL) {
-        if (values != empty_values) {
-            for (i = 0, n = mp->ma_keys->dk_nentries; i < n; i++) {
-                Py_XDECREF(values->values[i]);
-            }
-            free_values(values);
+        for (i = 0, n = mp->ma_keys->dk_nentries; i < n; i++) {
+            Py_XDECREF(values->values[i]);
         }
+        free_values(values);
         dictkeys_decref(keys);
     }
     else if (keys != NULL) {
-        assert(keys->dk_refcnt == 1);
+        assert(keys->dk_refcnt == 1 || keys == Py_EMPTY_KEYS);
         dictkeys_decref(keys);
     }
 #if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree < PyDict_MAXFREELIST && Py_IS_TYPE(mp, &PyDict_Type)) {
         state->free_list[state->numfree++] = mp;
     }
     else
 #endif
     {
         Py_TYPE(mp)->tp_free((PyObject *)mp);
     }
     Py_TRASHCAN_END
 }
 
 

commit 9942f42a93ccda047fd3558c47b822e99afe10c0
Date:   Thu Oct 21 16:12:20 2021 +0300

    bpo-45522: Allow to disable freelists on build time (GH-29056)
    
    
    
    Freelists for object structs can now be disabled. A new ``configure``
    option ``--without-freelists`` can be used to disable all freelists
    except empty tuple singleton. Internal Py*_MAXFREELIST macros can now
    be defined as 0 without causing compiler warnings and segfaults.
    
    Signed-off-by: Christian Heimes <christian@python.org>

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -1968,37 +1984,40 @@
 dict_dealloc(PyDictObject *mp)
 {
     PyDictValues *values = mp->ma_values;
     PyDictKeysObject *keys = mp->ma_keys;
     Py_ssize_t i, n;
 
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(mp);
     Py_TRASHCAN_BEGIN(mp, dict_dealloc)
     if (values != NULL) {
         if (values != empty_values) {
             for (i = 0, n = mp->ma_keys->dk_nentries; i < n; i++) {
                 Py_XDECREF(values->values[i]);
             }
             free_values(values);
         }
         dictkeys_decref(keys);
     }
     else if (keys != NULL) {
         assert(keys->dk_refcnt == 1);
         dictkeys_decref(keys);
     }
+#if PyDict_MAXFREELIST > 0
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree < PyDict_MAXFREELIST && Py_IS_TYPE(mp, &PyDict_Type)) {
         state->free_list[state->numfree++] = mp;
     }
-    else {
+    else
+#endif
+    {
         Py_TYPE(mp)->tp_free((PyObject *)mp);
     }
     Py_TRASHCAN_END
 }
 
 

commit a7252f88d3fa33036bdd6036b8c97bc785ed6f17
Date:   Wed Oct 6 13:19:53 2021 +0100

    bpo-40116: Add insertion order bit-vector to dict values to allow dicts to share keys more freely. (GH-28520)

diff --git a/Objects/dictobject.c b/Objects/dictobject.c
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -1967,37 +1982,37 @@
 dict_dealloc(PyDictObject *mp)
 {
-    PyObject **values = mp->ma_values;
+    PyDictValues *values = mp->ma_values;
     PyDictKeysObject *keys = mp->ma_keys;
     Py_ssize_t i, n;
 
     /* bpo-31095: UnTrack is needed before calling any callbacks */
     PyObject_GC_UnTrack(mp);
     Py_TRASHCAN_BEGIN(mp, dict_dealloc)
     if (values != NULL) {
         if (values != empty_values) {
             for (i = 0, n = mp->ma_keys->dk_nentries; i < n; i++) {
-                Py_XDECREF(values[i]);
+                Py_XDECREF(values->values[i]);
             }
             free_values(values);
         }
         dictkeys_decref(keys);
     }
     else if (keys != NULL) {
         assert(keys->dk_refcnt == 1);
         dictkeys_decref(keys);
     }
     struct _Py_dict_state *state = get_dict_state();
 #ifdef Py_DEBUG
     // new_dict() must not be called after _PyDict_Fini()
     assert(state->numfree != -1);
 #endif
     if (state->numfree < PyDict_MAXFREELIST && Py_IS_TYPE(mp, &PyDict_Type)) {
         state->free_list[state->numfree++] = mp;
     }
     else {
         Py_TYPE(mp)->tp_free((PyObject *)mp);
     }
     Py_TRASHCAN_END
 }
 
 
[PERF] **new** commit 7108bdf27c7a460cf83c4a01dea54ae4591d8aea
Date:   Mon May 23 20:45:31 2022 -0500

    gh-93033: Use wmemchr in stringlib (GH-93034)
    
    Generally comparable perf for the "good" case where memchr doesn't
    return any collisions (false matches on lower byte) but clearly faster
    with collisions.

diff --git a/Objects/bytearrayobject.c b/Objects/bytearrayobject.c
--- a/Objects/bytearrayobject.c
+++ b/Objects/bytearrayobject.c
@@ -1071,40 +1071,41 @@
 bytearray_dealloc(PyByteArrayObject *self)
 {
     if (self->ob_exports > 0) {
         PyErr_SetString(PyExc_SystemError,
                         "deallocated bytearray object has exported buffers");
         PyErr_Print();
     }
     if (self->ob_bytes != 0) {
         PyObject_Free(self->ob_bytes);
     }
     Py_TYPE(self)->tp_free((PyObject *)self);
 }
 
 
 /* -------------------------------------------------------------------- */
 /* Methods */
 
 #define STRINGLIB_IS_UNICODE 0
 #define FASTSEARCH fastsearch
 #define STRINGLIB(F) stringlib_##F
 #define STRINGLIB_CHAR char
 #define STRINGLIB_SIZEOF_CHAR 1
 #define STRINGLIB_LEN PyByteArray_GET_SIZE
 #define STRINGLIB_STR PyByteArray_AS_STRING
 #define STRINGLIB_NEW PyByteArray_FromStringAndSize
 #define STRINGLIB_ISSPACE Py_ISSPACE
 #define STRINGLIB_ISLINEBREAK(x) ((x == '\n') || (x == '\r'))
 #define STRINGLIB_CHECK_EXACT PyByteArray_CheckExact
+#define STRINGLIB_FAST_MEMCHR memchr
 #define STRINGLIB_MUTABLE 1
 
 #include "stringlib/fastsearch.h"
 #include "stringlib/count.h"
 #include "stringlib/find.h"
 #include "stringlib/join.h"
 #include "stringlib/partition.h"
 #include "stringlib/split.h"
 #include "stringlib/ctype.h"
 #include "stringlib/transmogrify.h"
 
 

[FUNC] **new** commit 097f74a5a37e2a8a26d529cede456ede7011b66f
Date:   Mon Feb 7 01:26:58 2022 +0100

    bpo-46670: Define all macros for stringlib (GH-31176)
    
    bytesobject.c, bytearrayobject.c and unicodeobject.c now define all
    macros used by stringlib, to avoid using undefined macros.
    Fix "gcc -Wundef" warnings.

diff --git a/Objects/bytearrayobject.c b/Objects/bytearrayobject.c
--- a/Objects/bytearrayobject.c
+++ b/Objects/bytearrayobject.c
@@ -1060,39 +1060,40 @@
 bytearray_dealloc(PyByteArrayObject *self)
 {
     if (self->ob_exports > 0) {
         PyErr_SetString(PyExc_SystemError,
                         "deallocated bytearray object has exported buffers");
         PyErr_Print();
     }
     if (self->ob_bytes != 0) {
         PyObject_Free(self->ob_bytes);
     }
     Py_TYPE(self)->tp_free((PyObject *)self);
 }
 
 
 /* -------------------------------------------------------------------- */
 /* Methods */
 
+#define STRINGLIB_IS_UNICODE 0
 #define FASTSEARCH fastsearch
 #define STRINGLIB(F) stringlib_##F
 #define STRINGLIB_CHAR char
 #define STRINGLIB_SIZEOF_CHAR 1
 #define STRINGLIB_LEN PyByteArray_GET_SIZE
 #define STRINGLIB_STR PyByteArray_AS_STRING
 #define STRINGLIB_NEW PyByteArray_FromStringAndSize
 #define STRINGLIB_ISSPACE Py_ISSPACE
 #define STRINGLIB_ISLINEBREAK(x) ((x == '\n') || (x == '\r'))
 #define STRINGLIB_CHECK_EXACT PyByteArray_CheckExact
 #define STRINGLIB_MUTABLE 1
 
 #include "stringlib/fastsearch.h"
 #include "stringlib/count.h"
 #include "stringlib/find.h"
 #include "stringlib/join.h"
 #include "stringlib/partition.h"
 #include "stringlib/split.h"
 #include "stringlib/ctype.h"
 #include "stringlib/transmogrify.h"
 
 
commit 8370e07e1e5b626e78ddc7aadbfaf248976c4454
Date:   Wed Mar 24 02:23:01 2021 +0100

    bpo-43244: Remove the pyarena.h header (GH-25007)
    
    Remove the pyarena.h header file with functions:
    
    * PyArena_New()
    * PyArena_Free()
    * PyArena_Malloc()
    * PyArena_AddPyObject()
    
    These functions were undocumented, excluded from the limited C API,
    and were only used internally by the compiler.
    
    Add pycore_pyarena.h header. Rename functions:
    
    * PyArena_New() => _PyArena_New()
    * PyArena_Free() => _PyArena_Free()
    * PyArena_Malloc() => _PyArena_Malloc()
    * PyArena_AddPyObject() => _PyArena_AddPyObject()

diff --git a/Python/pyarena.c b/Python/pyarena.c
--- a/Python/pyarena.c
+++ b/Python/pyarena.c
@@ -157,22 +158,22 @@
-PyArena_Free(PyArena *arena)
+_PyArena_Free(PyArena *arena)
 {
     assert(arena);
 #if defined(Py_DEBUG)
     /*
     fprintf(stderr,
         "alloc=%zu size=%zu blocks=%zu block_size=%zu big=%zu objects=%zu\n",
         arena->total_allocs, arena->total_size, arena->total_blocks,
         arena->total_block_size, arena->total_big_blocks,
         PyList_Size(arena->a_objects));
     */
 #endif
     block_free(arena->a_head);
     /* This property normally holds, except when the code being compiled
        is sys.getobjects(0), in which case there will be two references.
     assert(arena->a_objects->ob_refcnt == 1);
     */
 
     Py_DECREF(arena->a_objects);
     PyMem_Free(arena);
 }
 
